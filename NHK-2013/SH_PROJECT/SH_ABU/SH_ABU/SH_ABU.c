/***********************************************************************/
/*                                                                     */
/*  FILE        :SH_ABU.c                                              */
/*  DATE        :Sun, Jan 06, 2013                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7125                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.18).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/

/****************************************
	グローバル変数
****************************************/
#define SHRS_SENDBUFFERSIZE1 1000
#define MD0AL PE.DRL.BIT.B0
#define MD1AL PE.DRL.BIT.B1
#define MD0BL PE.DRL.BIT.B2
#define MD1BL PE.DRL.BIT.B3
#define MD0BH PE.DRL.BIT.B4
#define MD1BH PE.DRL.BIT.B5
#define MD0AH PE.DRL.BIT.B6
#define MD1AH PE.DRL.BIT.B7
#define MD0ALT MTU20.TGRA
#define MD1ALT MTU20.TGRB
#define MD0BLT MTU20.TGRC
#define MD1BLT MTU20.TGRD
#define	MD0ALS PFC.PECRL1.BIT.PE0MD     //ノーマル2 1or6
#define	MD1ALS PFC.PECRL1.BIT.PE1MD     //
#define	MD0BLS PFC.PECRL1.BIT.PE2MD     //
#define	MD1BLS PFC.PECRL1.BIT.PE3MD     //


//signed int R,L;
signed int X,Y;
signed int D;
signed short sL,sR;
unsigned long int K;
char CMT0F;
/****************************************
	インクルードファイル
****************************************/
#include <math.h>
#include "iodefine.h"
#include "sh7125rslib.h"

/****************************************
		プロトタイプ宣言
****************************************/
void md0pwr(signed short);
void md1pwr(signed short);
void md0stop(short);
void md1stop(short);

/****************************************
		SH_INIT SH初期化
****************************************/
void SH_INIT(void){
	//	割り込み不許可
//	SetSRReg(0xf);
	set_imask(15);                // 割り込みマスククリア
	
	//	SCI1
 //   SCI_init();           // SCI初期化
 	SHRS_Open(1);
// 	SHRS_Open(0); 
	
	INTC.IPRL.BIT._SCI1 = 0x8;    // 割り込みレベル設定(SCI1)
//	INTC.IPRL.BIT._SCI0 = 0xF;    // 割り込みレベル設定(SCI1)


	//	IRQ0
	INTC.IRQCR.BIT.IRQ0S=3;
	INTC.IRQCR.BIT.IRQ3S=3;
	INTC.IPRA.BIT._IRQ0=15;
	INTC.IPRA.BIT._IRQ3=15;
	INTC.IRQSR.BIT.IRQ0F=0;
	INTC.IRQSR.BIT.IRQ3F=0;
	PFC.PACRL2.BIT.PA5MD=7;		//IRQ3
	PFC.PBCRL1.BIT.PB2MD=1;		//IRQ0
/*
	//	CMT0
	STB.CR4.BIT._CMT=0;
	CMT.CMSTR.BIT.STR0=0;
	CMT0.CMCSR.BIT.CMIE=1;
	CMT0.CMCSR.BIT.CKS=3;
	CMT0.CMCNT=1;
	CMT0.CMCOR=60000;
	INTC.IPRJ.BIT._CMT0 =10;
	CMT.CMSTR.BIT.STR0=1;
*/

	//	MTU2
	STB.CR4.BIT._MTU2=0;		//スタンバイ復帰
	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=0;		//カウント停止
	
	//	MTU2 0＆1
	MTU2.TSTR.BIT.CST1 = MTU2.TSTR.BIT.CST0 = 0;     //MTU21,20カウント停止
	MTU21.TCR.BIT.TPSC = 0;     //クロック周波数φ/1
	MTU20.TCR.BIT.TPSC = 0;     //クロック周波数φ/1
	MTU21.TCR.BIT.CCLR = 1;     //TGRAコンペアマッチでTCNTクリア
	MTU20.TCR.BIT.CCLR = 7;     //同期クリア
	MTU2.TSYR.BYTE = 3;         //チャネル0，1同期動作
//	MTU20.TIOR.BIT.IOA = 2;     //初期状態で0出力 コンペアマッチしたら1出力
//	MTU20.TIOR.BIT.IOB = 2;     //初期状態で0出力 コンペアマッチしたら1出力
//	MTU20.TIOR.BIT.IOC = 2;     //初期状態で0出力 コンペアマッチしたら1出力
//	MTU20.TIOR.BIT.IOD = 2;     //初期状態で0出力 コンペアマッチしたら1出力

	MTU20.TIOR.BIT.IOA = 5;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOB = 5;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOC = 5;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOD = 5;     //初期状態で0出力 コンペアマッチしたら1出力

	MTU21.TGRA = 2500;
	MTU20.TGRA = 0;
	MTU20.TGRB = 0;
	MTU20.TGRC = 0;
	MTU20.TGRD = 0;
	
	MTU20.TMDR.BIT.MD = 3;      //PWMモード2
	MTU21.TMDR.BIT.MD = 3;      //PWMモード2

	PFC.PEIORL.WORD=0x00FF;		//出力ポートに設定
	PE.DRL.WORD=0x0000;		//出力ポートに設定

	md0pwr(0);
	md1pwr(0);
	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=1;		//カウント開始

	
	


}

#define M_PI 3.1415926535897932
#define M_HPI 1.5707963267948966
#define M_2PI 6.2831853071795864

double nsin(double si){
	return si-si*si*si/6.0;
}
double ncos(double si){
	return 1.0-si*si/2.0;
}

int inductmm(int px,int py,int pd){

	double tx,ty,tsit,tsitt,txt,tyt,tsi,si;
	int dsi,r;
	int sV;
	short sf;

	tx=(double)(px-X/1000);
	ty=(double)(py-Y/1000);
	tx=-tx;
	ty=-ty;

	si=(double)pd*M_PI/180.0-M_HPI;
	if(si<=-M_HPI) si+=M_2PI;

	txt=tx*cos(si)+ty*sin(si);
	tyt=-tx*sin(si)+ty*cos(si);

	tsit=atan(tyt/txt*2.0);
	
	if(txt<0) tsit=tsit-M_HPI;
	else tsit=tsit+M_HPI;
	tsi=tsit+si;

	dsi=(int)((int)((tsi/M_PI)*180.0)-D/1000000);

	if(dsi>180) dsi-=360;
	else if(dsi<-180) dsi+=360;

	r=(int)sqrt(tx*tx+ty*ty);
	
	if(r<200)
		sV=10;
	else if(r<1000)
		sV=30;
	else
		sV=40;

	if(dsi>1){
		sL=0;
		sR=sV;
	}else if(dsi<-1){
		sR=0;
		sL=sV;
	}else{
		sL=sV;
		sR=sV;
	}

	md0pwr(sL);
	md1pwr(sR);
	K++;
	return (int)r;
}
void whit(int t){
	t*=300000;
	while(t--);	
}
void gomm(int px,int py,int pd){
	int r=1000000000,old_r;

	do{
		old_r=r;
		r=inductmm(px,py,pd);
	}while(r<=old_r);
	md0stop(30);
	md1stop(30);		
	whit(50);
	md0pwr(0);
	md1pwr(0);		

}
void turn(signed short pd){
	int td;
	int sV;
	while(1){
		td=pd-D/1000000;
		if(td>180) td-=360;
		if(td<-180) td+=360;
				
		if((td<2)&&(td>-2)) break;
		
		if(abs(td)<5)
			sV=5;
		else if(abs(td)<20)
			sV=10;
		else
			sV=40;
		
		if(td>0){
			md0pwr(-sV);	
			md1pwr(sV);	

		}else{
			md0pwr(sV);	
			md1pwr(-sV);	

		}
	}
	md0stop(30);
	md1stop(30);
	whit(50);
	md0pwr(0);
	md1pwr(0);

}


/****************************************
		メイン
****************************************/
void main(void){
	unsigned long i=50000;
	char t,q,s;
	while(--i);
	SH_INIT();
	
	set_imask(5);                // 割り込みマスククリア


//	L=0;
//	R=0;
	X=0;
	Y=0;
	D=0;
	K=0;
	q=1;
	
//	GO(895.25*1000,189.85*1000);
	SHRS_Printf(1,"aaaaaaaa1");		

//	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=1;		//カウント開始
	
	CMT0F=0;

while(1){	
	gomm(0,1200,0);
	turn(180);
	gomm(0,0,180);
	turn(0);
}

	i=0;
	s=0;
	while(1){
		if(SHRS_CheckRecv(1)){
			t=SHRS_Getc(1);
			if('0'<=t&&':'>=t){
				if(s==0){
					md0pwr((t-'0')*10*q);
					md1pwr((t-'0')*10*q);
				}else{
					md0stop((t-'0')*10*q);
					md1stop((t-'0')*10*q);
				}
			}
			if(t=='q')	q=-q;
			if(t=='s')	s=(s==1?0:1);
		}
/*		if(i++==40000){
			SHRS_Printf(1,"\n%6d,%6d,%d,%d",(int)(X/1000),(int)(Y/1000),D/1000000,K);		
			i=0;	
		}
*/
	}

}

/****************************************
		MD0
****************************************/
void md0pwr(signed short pwr){
	static char v=0;
	if(pwr>0){
		if(pwr>100) pwr=100;
		MD0ALS=0;
		MD0BH=0;
		if(pwr==100)
	 		MD0BLT=2501;		
		else
	 		MD0BLT=25*pwr;
		MD0BLS=1;
		MD0AH=1;
	}else if(pwr<0){
		if(pwr<-100) pwr=-100;
		MD0BLS=0;
		MD0AH=0;
		if(pwr==-100)
 			MD0ALT=2501;
		else
	 		MD0ALT=25*(-pwr);
		MD0ALS=1;
		MD0BH=1;
	}else{
		MD0ALS=0;
		MD0BLS=0;
		MD0AH=0;
		MD0BH=0;
		v=0;
	}
}
/****************************************
		MD1
****************************************/
void md1pwr(signed short pwr){
	pwr=-pwr;
	if(pwr>0){
		if(pwr>100) pwr=100;
		MD1ALS=0;
		MD1BH=0;
//		MD1BLT=25*(100-pwr);
		if(pwr==100)
	 		MD1BLT=2501;		
		else
	 		MD1BLT=25*pwr;
		MD1BLS=1;
		MD1AH=1;
	}else if(pwr<0){
		if(pwr<-100) pwr=-100;
		MD1BLS=0;
		MD1AH=0;
//		MD1ALT=25*(100+pwr);
		if(pwr==-100)
 			MD1ALT=2501;
		else
	 		MD1ALT=25*(-pwr);
		MD1ALS=1;
		MD1BH=1;
	}else{
		MD1ALS=0;
		MD1BLS=0;
		MD1AH=0;
		MD1BH=0;
	}
}
/****************************************
		MD0 stop
****************************************/
void md0stop(short pwr){
	MD0AH=0;
	MD0BH=0;
	if(pwr==0){
		MD0ALS=0;
		MD0BLS=0;	
	}else{
		if(pwr>=100) pwr=101;
	 	MD0ALT=25*(pwr);
	 	MD0BLT=25*(pwr);
		MD0ALS=1;
		MD0BLS=1;	
	}
}

/****************************************
		MD1 stop
****************************************/
void md1stop(short pwr){
	MD1AH=0;
	MD1BH=0;
	if(pwr==0){
		MD1ALS=0;
		MD1BLS=0;	
	}else{
		if(pwr>=100) pwr=101;
	 	MD1ALT=25*(pwr);
	 	MD1BLT=25*(pwr);
		MD1ALS=1;
		MD1BLS=1;	
	}
}

