/***********************************************************************/
/*                                                                     */
/*  FILE        :SH000.c                                               */
/*  DATE        :Mon, Oct 29, 2012                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7125                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.18).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/
/*  シリアルについて
http://www.geocities.jp/in_subaru/shrslib/index7125.html*/
#define SHRS_SENDBUFFERSIZE1 500
#define SHRS_BRR1 19
#define SHRS_USE_PRINTF


/****************************************
	マクロ設定
****************************************/
#define MD0AL PE.DRL.BIT.B0
#define MD1AL PE.DRL.BIT.B1
#define MD0BL PE.DRL.BIT.B2
#define MD1BL PE.DRL.BIT.B3
#define MD0BH PE.DRL.BIT.B4
#define MD1BH PE.DRL.BIT.B5
#define MD0AH PE.DRL.BIT.B6
#define MD1AH PE.DRL.BIT.B7
#define RE0A PB.PR.BIT.B3
#define RE0B PB.DR.BIT.B2
#define RE1A PB.DR.BIT.B5
#define RE1B PA.DRL.BIT.B5
/****************************************
	グローバル変数
****************************************/

signed int PRPM0,PRPM1,PRPS0,PRPS1;
signed int RPS0,RPS1,EN0,EO0,IP0,CMT0F;
double PID0,PID1;

signed int X02,X01,X00;
signed int X12,X11,X10;
double y0,P0,P1,X,Y,th;

/****************************************
	インクルードファイル
****************************************/
#include "iodefine.h"
#include <machine.h>
#include <stdarg.h>
//#include "sci_mod.h"
#include "sh7125rslib.h"
/******************************
		SH_INIT SH初期化
****************************************/
void SH_INIT(void){
	//	割り込み不許可
//	SetSRReg(0xf);
	set_imask(15);                // 割り込みマスククリア
	
	//	SCI1
 //   SCI_init();           // SCI初期化
 	SHRS_Open(1);
 
	
	INTC.IPRL.BIT._SCI1 = 0xF;    // 割り込みレベル設定(SCI1)

	//	IRQ0
	INTC.IRQCR.BIT.IRQ0S=3;
	INTC.IRQCR.BIT.IRQ3S=3;
	INTC.IPRA.BIT._IRQ0=11;
	INTC.IPRA.BIT._IRQ3=11;
	INTC.IRQSR.BIT.IRQ0F = 0;
	INTC.IRQSR.BIT.IRQ3F = 0;
	
	//	AD
	STB.CR4.BIT._AD0=0;//ADスタンバイ復帰
	AD0.ADCR.BIT.ADST=0;//ADストップ
	AD0.ADCSR.BIT.ADF=0;//エンドフラグクリア
	AD0.ADCSR.BIT.ADIE=0;//割り込み許可
	AD0.ADCSR.BIT.CKSL=3;//超高速
	AD0.ADCSR.BIT.ADM=3;//2chスキャンモード
	AD0.ADCSR.BIT.ADCS=0;//サイクルスキャン
	AD0.ADCSR.BIT.CH=1;//AN0&AN1
//	INTC.IPRK.BIT._AD01=0xc;

	//	CMT0
	STB.CR4.BIT._CMT=0;
	CMT.CMSTR.BIT.STR0=0;
	CMT.CMSTR.BIT.STR1=0;
	CMT0.CMCSR.BIT.CMIE=1;
	CMT0.CMCSR.BIT.CKS=3;
	CMT0.CMCNT=1;
	CMT0.CMCOR=10000;
	CMT1.CMCSR.BIT.CMIE=1;
	CMT1.CMCSR.BIT.CKS=2;
	CMT1.CMCNT=1;
	CMT1.CMCOR=24414;
	INTC.IPRJ.BIT._CMT0 =6;
	INTC.IPRJ.BIT._CMT1 =6;
	CMT.CMSTR.BIT.STR0=1;
	CMT.CMSTR.BIT.STR1=1;
	
	
		
	
	//	MTU2
	STB.CR4.BIT._MTU2=0;		//スタンバイ復帰
	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=0;		//カウント停止
	
	
	//	MTU2 0＆1
	
	MTU2.TSTR.BIT.CST1 = MTU2.TSTR.BIT.CST0 = 0;     //MTU21,20カウント停止
	MTU21.TCR.BIT.TPSC = 0;     //クロック周波数φ/4
	MTU20.TCR.BIT.TPSC = 0;     //クロック周波数φ/4
	MTU21.TCR.BIT.CCLR = 1;     //TGRAコンペアマッチでTCNTクリア
	MTU20.TCR.BIT.CCLR = 7;     //同期クリア
	MTU2.TSYR.BYTE = 3;         //チャネル0，1同期動作
	MTU20.TIOR.BIT.IOA = 2;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOB = 2;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOC = 2;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOD = 2;     //初期状態で0出力 コンペアマッチしたら1出力

	MTU21.TGRA = 2500;
	MTU20.TGRA = 2500;
	MTU20.TGRB = 2500;
	MTU20.TGRC = 2500;
	MTU20.TGRD = 2500;
	
	MTU20.TMDR.BIT.MD = 3;      //PWMモード2
	MTU21.TMDR.BIT.MD = 3;      //PWMモード2

	// MTU2 5  100ms  両エッジカウント
	MTU25.TSTR.BIT.CSTU = 0;	//ストップ
	MTU25.TSTR.BIT.CSTV = 0;
	MTU25.TSTR.BIT.CSTW = 0;
	MTU25.TSR.BIT.CMFW = 0;		//フラグクリア
	MTU25.TCRW.BIT.TPSC = 1;		//φ/4
//	MTU25.TIORU.BIT.IOC = 17;
//	MTU25.TIORV.BIT.IOC = 17;
	MTU25.TIER.BIT.TGIEW = 1;		//Wコンペアマッチインタラプト
	MTU25.TGRW = 12,500;			//2msでクリア
	MTU25.TCCR.BIT.CLRW = 1;	//Wマッチでタイマクリア
	MTU25.TSR.BIT.CMFW = 0;		//フラグクリア
	INTC.IPRF.BIT._MTU25 =7;

	// IO
	PFC.PECRL1.BIT.PE0MD=1;		//タイマーポートに設定
	PFC.PECRL1.BIT.PE1MD=1;		//タイマーポートに設定
	PFC.PECRL1.BIT.PE2MD=1;		//タイマーポートに設定
	PFC.PECRL1.BIT.PE3MD=1;		//タイマーポートに設定
	PFC.PECRL2.BIT.PE4MD=0;		//IOポートに設定
	PFC.PECRL2.BIT.PE5MD=0;		//IOポートに設定
	PFC.PECRL2.BIT.PE6MD=0;		//IOポートに設定
	PFC.PECRL2.BIT.PE7MD=0;		//IOポートに設定

//	PFC.PEIORL.BIT.B0 = 1;
//	PFC.PEIORL.BIT.B5 = 1;
	
	PFC.PEIORL.WORD=0x00FF;		//出力ポートに設定
	
	PFC.PACRL2.BIT.PA5MD=7;		//IRQ3
	PFC.PBCRL1.BIT.PB2MD=1;		//IRQ0
	PFC.PBCRL1.BIT.PB3MD=3;		//TIC5V
	PFC.PBCRL2.BIT.PB5MD=3;		//TIC5U

	

}


/****************************************
		メイン
****************************************/
void main(void){
	unsigned long i=500000;
	unsigned char L=0,R=0;
	double RR,LL;
	int n=0;
	int chr;
	while(--i);
	PRPM0=0;
	PRPM1=0;	
	PRPS0=0;
	PRPS1=0;
	PID0=0;
	PID1=0;
	X02=0;
	X01=0;
	X00=0;
	X12=0;
	X11=0;
	X10=0;
	
//	MD0BH=1;
//	MD0AH=1;
		


	SH_INIT();
	
	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=1;		//カウント開始
	MTU25.TSTR.BIT.CSTW = MTU25.TSTR.BIT.CSTV = 1;
	set_imask(5);
//	SHRS_Printf(1, "nakahara");
	
	AD0.ADCR.BIT.ADST=1;

//	LED01=1;

	chr=0;

	while(1){
		n+=PB.PR.BIT.B3;
		
//		if(chr!=-1)PRPS0=((chr-0x30)*10)*0.6;

//		if(PRPS0>100)PRPS0=100;
//		else if(PRPS0<0)PRPS0=0;
/*		chr=SHRS_Getc(1);
		if(chr!=-1){
			switch (chr&0x0f){
			case 0x03:
				R&=0x0f;
				R|=(chr&0xf0);
				RR=(double)(125-R)/125.0;	
				PRPS0=60*(RR*RR*RR*RR*RR);	
//				PRPS0=(signed int)R*60/125;
				break;
			case 0x0B:
				R&=0xf0;
				R|=((chr>>4)&0x0f);	
				RR=(double)(125-R)/125.0;
				PRPS0=60*(RR*RR*RR*RR*RR);	
//				PRPS0=(signed int)R*60/125;
				break;
			case 0x05:
				L&=0x0f;
				L|=(chr&0xf0);	
				LL=(double)(125-L)/125.0;
				PRPS1=60*(LL*LL*LL*LL*LL);	
//				PRPS1=(signed int)L*60/125;
				break;
			case 0x0D:
				L&=0xf0;
				L|=((chr>>4)&0x0f);	
				LL=(double)(125-L)/125.0;	
				PRPS1=60*(LL*LL*LL*LL*LL);	
//				PRPS1=(signed int)L*60/125;
				break;
			}
				
		}
*/

		if(CMT0F){
			CMT0F=0;

			SHRS_Printf(1,"\033[2J");
			SHRS_Printf(1,"入力値\nX=%3d\tY=%3d\nP0=%3d\tP1=%3d\n",(int)X,(int)Y,(int)P0,(int)P1);
			
			

			SHRS_Printf(1,"右輪\t");
			if("-PID0<0")
				SHRS_Printf(1,"正転\n");
			else
				SHRS_Printf(1,"逆転\n");
			SHRS_Printf(1,"目標値%3d\t制御量%3d\t出力%3d",(int)PRPS0,(int)RPS0,(int)PID0);
			SHRS_Printf(1,"\n左輪\t");
			if("-PID1<0")
				SHRS_Printf(1,"正転\n");
			else
				SHRS_Printf(1,"逆転\n");
			SHRS_Printf(1,"目標値%3d\t制御量%3d\t出力%3d",(int)PRPS1,(int)RPS1,(int)PID1);

			
//			chr=SCI_getc(0);
//			chr=SHRS_Getc(1);

//		LED01=~LED01;
		}

	}


}
