/***********************************************************************/
/*                                                                     */
/*  FILE        :SH000.c                                               */
/*  DATE        :Mon, Oct 29, 2012                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7125                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.18).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/***********************************************************************/
/*  シリアルについて
http://www.geocities.jp/in_subaru/shrslib/index7125.html*/
#define SHRS_SENDBUFFERSIZE1 500
#define SHRS_BRR1 80
#define SHRS_USE_PRINTF

/****************************************
	マクロ設定
****************************************/
#define MD0AL PE.DRL.BIT.B0
#define MD1AL PE.DRL.BIT.B1
#define MD0BL PE.DRL.BIT.B2
#define MD1BL PE.DRL.BIT.B3
#define MD0BH PE.DRL.BIT.B4
#define MD1BH PE.DRL.BIT.B5
#define MD0AH PE.DRL.BIT.B6
#define MD1AH PE.DRL.BIT.B7
#define RE0A PB.PR.BIT.B3
#define RE0B PB.DR.BIT.B2
#define RE1A PB.DRL.BIT.B5
#define RE1B PA.DRL.BIT.B5
/****************************************
	グローバル変数
****************************************/

signed int PRPM0,PRPM1,PRPS0,PRPS1;
signed int RPS0,RPS1,EN0,EO0,IP0,CMT0F;
double PID0;

signed int X02,X01,X00;

/****************************************
	インクルードファイル
****************************************/
#include "iodefine.h"
#include <machine.h>
#include <stdarg.h>
//#include "sci_mod.h"
#include "sh7125rslib.h"
/******************************
		SH_INIT SH初期化
****************************************/
void SH_INIT(void){
	//	割り込み不許可
//	SetSRReg(0xf);
	set_imask(15);                // 割り込みマスククリア
	
	//	SCI1
 //   SCI_init();           // SCI初期化
 	SHRS_Open(1);
 
	
	INTC.IPRL.BIT._SCI1 = 0xF;    // 割り込みレベル設定(SCI1)

	//	IRQ0
	INTC.IRQCR.BIT.IRQ0S=3;
	INTC.IRQCR.BIT.IRQ3S=3;
	INTC.IPRA.BIT._IRQ0=11;
	INTC.IPRA.BIT._IRQ3=11;
	INTC.IRQSR.BIT.IRQ0F = 0;
	INTC.IRQSR.BIT.IRQ3F = 0;
	
	//	AD
	STB.CR4.BIT._AD0=0;//ADスタンバイ復帰
	AD0.ADCR.BIT.ADST=0;//ADストップ
	AD0.ADCSR.BIT.ADF=0;//エンドフラグクリア
	AD0.ADCSR.BIT.ADIE=0;//割り込み許可
	AD0.ADCSR.BIT.CKSL=3;//超高速
	AD0.ADCSR.BIT.ADM=0;//シングルモード
	AD0.ADCSR.BIT.ADCS=0;//サイクルスキャン
	AD0.ADCSR.BIT.CH=0;//AN0のみ
//	INTC.IPRK.BIT._AD01=0xc;

	//	CMT0
	STB.CR4.BIT._CMT=0;
	CMT.CMSTR.BIT.STR0=0;
	CMT.CMSTR.BIT.STR1=0;
	CMT0.CMCSR.BIT.CMIE=1;
	CMT0.CMCSR.BIT.CKS=2;
	CMT0.CMCNT=1;
	CMT0.CMCOR=24414;
	CMT1.CMCSR.BIT.CMIE=1;
	CMT1.CMCSR.BIT.CKS=2;
	CMT1.CMCNT=1;
	CMT1.CMCOR=24414;
	INTC.IPRJ.BIT._CMT0 =6;
	INTC.IPRJ.BIT._CMT1 =6;
	CMT.CMSTR.BIT.STR0=1;
	CMT.CMSTR.BIT.STR1=1;
	
	
		
	
	//	MTU2
	STB.CR4.BIT._MTU2=0;		//スタンバイ復帰
	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=0;		//カウント停止
	
	
	//	MTU2 0＆1
	
	MTU2.TSTR.BIT.CST1 = MTU2.TSTR.BIT.CST0 = 0;     //MTU21,20カウント停止
	MTU21.TCR.BIT.TPSC = 0;     //クロック周波数φ/4
	MTU20.TCR.BIT.TPSC = 0;     //クロック周波数φ/4
	MTU21.TCR.BIT.CCLR = 1;     //TGRAコンペアマッチでTCNTクリア
	MTU20.TCR.BIT.CCLR = 7;     //同期クリア
	MTU2.TSYR.BYTE = 3;         //チャネル0，1同期動作
	MTU20.TIOR.BIT.IOA = 2;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOB = 2;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOC = 2;     //初期状態で0出力 コンペアマッチしたら1出力
	MTU20.TIOR.BIT.IOD = 2;     //初期状態で0出力 コンペアマッチしたら1出力

	MTU21.TGRA = 2500;
	MTU20.TGRA = 2500;
	MTU20.TGRB = 2500;
	MTU20.TGRC = 2500;
	MTU20.TGRD = 2500;
	
	MTU20.TMDR.BIT.MD = 3;      //PWMモード2
	MTU21.TMDR.BIT.MD = 3;      //PWMモード2

	// MTU2 5  100ms  両エッジカウント
	MTU25.TSTR.BIT.CSTU = 0;
	MTU25.TSTR.BIT.CSTV = 0;
	MTU25.TSTR.BIT.CSTW = 0;
	MTU25.TSR.BIT.CMFW = 0;		//フラグクリア
	MTU25.TCRW.BIT.TPSC = 3;		//φ/64
//	MTU25.TIORU.BIT.IOC = 17;
//	MTU25.TIORV.BIT.IOC = 17;
	MTU25.TIER.BIT.TGIEW = 1;		//Wコンペアマッチインタラプト
	MTU25.TGRW = 39062;
	MTU25.TCCR.BIT.CLRW = 1; //Wマッチでタイマクリア
	MTU25.TSR.BIT.CMFW = 0;		//フラグクリア
	INTC.IPRF.BIT._MTU25 =7;

	// IO
	PFC.PECRL1.BIT.PE0MD=1;		//タイマーポートに設定
	PFC.PECRL1.BIT.PE1MD=1;		//タイマーポートに設定
	PFC.PECRL1.BIT.PE2MD=1;		//タイマーポートに設定
	PFC.PECRL1.BIT.PE3MD=1;		//タイマーポートに設定
	PFC.PECRL2.BIT.PE4MD=0;		//IOポートに設定
	PFC.PECRL2.BIT.PE5MD=0;		//IOポートに設定
	PFC.PECRL2.BIT.PE6MD=0;		//IOポートに設定
	PFC.PECRL2.BIT.PE7MD=0;		//IOポートに設定

//	PFC.PEIORL.BIT.B0 = 1;
//	PFC.PEIORL.BIT.B5 = 1;
	
	PFC.PEIORL.WORD=0x00FF;		//出力ポートに設定
	
	PFC.PACRL2.BIT.PA5MD=7;		//IRQ3
	PFC.PBCRL1.BIT.PB2MD=1;		//IRQ0
	PFC.PBCRL1.BIT.PB3MD=3;		//TIC5V
	PFC.PBCRL2.BIT.PB5MD=3;		//TIC5U

	

}


/****************************************
		メイン
****************************************/
void main(void){
	unsigned long i=500000;
 int n=0;
	int chr;
	while(--i);
	PRPM0=0;
	PRPM1=0;	
	PRPS0=0;
	PRPS1=0;
	PID0=0;
	X02=0;
	X01=0;
	X00=0;
	
//	MD0BH=1;
//	MD0AH=1;
		


	SH_INIT();
	
	MTU2.TSTR.BIT.CST0=MTU2.TSTR.BIT.CST1=1;		//カウント開始
	MTU25.TSTR.BIT.CSTW = MTU25.TSTR.BIT.CSTV = 1;
	set_imask(5);
//	SHRS_Printf(1, "nakahara");
AD0.ADCR.BIT.ADST=1;

//	LED01=1;

	PRPM1=0;
	chr=0;

	while(1){
		n+=PB.PR.BIT.B3;
		
//		if(chr!=-1)PRPS0=((chr-0x30)*10)*0.6;

//		if(PRPS0>100)PRPS0=100;
//		else if(PRPS0<0)PRPS0=0;

		if(CMT0F){
			CMT0F=0;
//			SHRS_Printf(1,"\nP %d\O %d\S %d\t%d",PRPS0,RPS0,(unsigned)(2500-MTU20.TGRA),AD0.ADDR0>>6);
			SHRS_Printf(1,"\nP%2d O%2d T%d",PRPS0,RPS0,(int)(2500-MTU20.TGRA));
//			SHRS_Printf(1,"\nP%2d O%2d T%d",1,1,1);
			SHRS_Printf(1,"S%2d X%2d M%3d",(int)(PID0),X00,(int)(RPS0*3));
//			SHRS_Printf(1," PID0 %d\tIP0= %d\t dr/dt %d\tRPM %d\tRPS %d\n",(int)(PID0),IP0,(EN0-EO0),(int)(RPS0*3),(int)(RPS0*0.05));
			
//			chr=SCI_getc(0);
//			chr=SHRS_Getc(1);

//		LED01=~LED01;
		}
	}


}
