/***********************************************************************/
/*                                                                     */
/*  FILE        :Serial.c                                              */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7125                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.5).     */
/*                                                                     */
/***********************************************************************/
//シリアル通信割り込み版
//AKI-SH7125+ベースボード
//Eiji Kamiya
//Licence : New BSD

#include <string.h>
#include "typedefine.h"
#include "iodefine.h" 
#include "Serial.h"
#include "RingBuffer.h"

//定数定義

//構造体定義

//グローバル変数
RingBuffer g_send;		//送信用リングバッファ
RingBuffer g_recieve;	//受信用リングバッファ

//プロトタイプ宣言
//シリアル通信：1文字送信（同期処理）
void PutChar(char ch);
//シリアル通信：1文字受信（同期処理）
char GetChar();

//シリアル通信：初期化
void InitializeSerial(void)
{
	int i;
	//リングバッファ
	InitializeRingBuffer(&g_send);
	InitializeRingBuffer(&g_recieve);
	//スタンバイコントロールレジスタ（省電力モード）
    STB.CR3.BIT._SCI1=0;//SCI1起動
	//送受信割込禁止、送受信禁止
    SCI1.SCSCR.BYTE=0x00;
	//シリアルモードレジスタ：通信フォーマット、クロックソースを選択
    SCI1.SCSMR.BYTE=0x00;
	//ビットレートレジスタ
	//25MHz, 9600bpsのときBRR=(25000000/(32*9600)) - 1 = 80 
	//25Mhz,38400bpsのときBRR=(25000000/(32*38400))- 1 = 19
    SCI1.SCBRR=19;
	for(i=0;i<100000;i++){
	}
	//ピンファンクションコントローラ
	//RXD1(PA3) PACRL1(14-12):001
    PFC.PACRL1.BYTE.H=0x10;  
	//TXD1(PA4) PACRL2(2-0):001
    PFC.PACRL2.BYTE.L=0x01;  
	//シリアルコントロールレジスタ
    SCI1.SCSCR.BIT.TE=1;  //送信可
    SCI1.SCSCR.BIT.RE=1;  //受信可	
    SCI1.SCSCR.BIT.RIE=1; //受信割り込みON
    SCI1.SCSCR.BIT.TIE=0; //送信割り込みOFF
}

//シリアル通信：文字列送信
void SerialPuts(const char* str)
{
	int16 len=strlen(str);
	int16 capa=GetRingBufferCapacity(&g_send);
	char ch;
	if(len>capa){//送信バッファより長い文字列のとき
		len=capa;
	}
	WriteRingBuffer(&g_send,(const uint8*)str,0,len);
    SCI1.SCSCR.BIT.TIE=1; //送信割り込みON
}

//シリアル通信：1文字送信
void SerialPutc(char ch)
{
	int16 capa=GetRingBufferCapacity(&g_send);
	if(capa==0){//送信バッファがいっぱいのとき
		return;
	}
	WriteRingBufferByte(&g_send,ch);
    SCI1.SCSCR.BIT.TIE=1; //送信割り込みON
}

//バイト配列送信
void SerialWriteData(uint8* buf,int16 size)
{
	int len=GetRingBufferCapacity(&g_send);
	if(size>len){//送信バッファの空き領域よりデータが大きいとき
		size=len;
	}
	WriteRingBuffer(&g_send,buf,0,size);
    SCI1.SCSCR.BIT.TIE=1; //送信割り込みON
}

//受信バッファにあるデータサイズ
int16 GetRecieveBufferDataSize()
{
	return GetRingBufferSize(&g_recieve);
}

//1文字受信
int16 SerialGetc()
{
	if(IsRingBufferEmpty(&g_recieve)){//空のとき
		return -1;
	}
	return ReadRingBufferByte(&g_recieve);
}

//バイト配列受信
int16 SerialReadData(uint8* buf,int16 size)
{
	int len=GetRingBufferSize(&g_recieve);
	if(size>len){
		size=len;
	}
	ReadRingBuffer(&g_recieve,buf,0,size);
	return size;
}

//シリアル通信：1文字送信（同期処理）
void PutChar(char ch)
{
	while (SCI1.SCSSR.BIT.TDRE==0);
	SCI1.SCSSR.BIT.TDRE=0;//フラグをクリア
	SCI1.SCTDR=ch;
}

//シリアル通信：1文字受信（同期処理）
char GetChar()
{
	char ch;
    while ((SCI1.SCSSR.BYTE & 0x40)==0);
    ch = SCI1.SCRDR;
	SCI1.SCSSR.BYTE = SCI1.SCSSR.BYTE & 0xBF;
	return ch;
}

//シリアル通信：受信割り込み
//intprg.cのINT_SCI1_RXI1に記述を追加すること
void int_sci1_rxi()
{
	WriteRingBufferByte(&g_recieve,GetChar());
}

//シリアル通信：送信割り込み
//intprg.cのINT_SCI1_TXI1に記述を追加すること
void int_sci1_txi()
{
	char ch;
	if(IsRingBufferEmpty(&g_send)==false){//送信バッファにデータがあるとき
		ch=ReadRingBufferByte(&g_send);
		PutChar(ch);
		if(IsRingBufferEmpty(&g_send)){//送信バッファにデータがなくなったとき
		    SCI1.SCSCR.BIT.TIE=0; //送信割り込みOFF
		}
	}
}
