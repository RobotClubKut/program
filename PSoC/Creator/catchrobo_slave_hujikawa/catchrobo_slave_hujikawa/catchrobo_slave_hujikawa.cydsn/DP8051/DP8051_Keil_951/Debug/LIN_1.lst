C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE LIN_1
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\LIN_1.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\LIN_1.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_951\Debug\LIN_1.lst) CD DB NOIP OT
                    -(2,SIZE) DF(DEBUG) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_951\Debug\LIN_1.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: LIN_1.c
   3          * Version 1.30
   4          *
   5          * Description:
   6          *  This file contains implementation of LIN Slave component.
   7          *
   8          ********************************************************************************
   9          * Copyright 2011-2013, Cypress Semiconductor Corporation.  All rights reserved.
  10          * You may use this file only in accordance with the license, terms, conditions,
  11          * disclaimers, and limitations in the end user license agreement accompanying
  12          * the software package with which this file was provided.
  13          *******************************************************************************/
  14          
  15          #include "LIN_1.h"
  16          
  17          
  18          /*******************************************************************************
  19          *  Place your includes, defines and variable declarations here
  20          *******************************************************************************/
  21          /* `#START LIN_1_DECLARATIONS` */
  22          
  23          /* `#END` */
  24          
  25          /* Internal APIs */
  26          static l_u8    LIN_1_FindPidIndex(l_u8 pid);
  27          static void    LIN_1_EndFrame(l_u8 status);
  28          static void    LIN_1_SetAssociatedFlags(l_u8 pIndex);
  29          
  30          /* SAE J2602 is disabled */
  31          #if(0u == LIN_1_SAE_J2602)
  32          
  33              static l_bool  LIN_1_GetEtFlagValue(l_u8 pidIndex);
  34              static void    LIN_1_ClearEtFlagValue(l_u8 pidIndex);
  35          
  36          #endif /* (0u == LIN_1_SAE_J2602) */
  37          
  38          #if(1u == LIN_1_TL_ENABLED)
              
                  static void LIN_1_ProcessMrf(l_u8 frame[]);
              
                  #if(1u == LIN_1_CS_ENABLED)
                  
                      #if((0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB0_SEL)) || \
                          (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL)))
              
                          static l_bool LIN_1_LinProductId(volatile const l_u8 frameData[]);
                          
                      #endif /*((0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB0_SEL)) || \
                             * (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL)))
                             */
                             
                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB1_SEL))
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 2   

                          #if(1u == LIN_1_LIN_2_0)
              
                              static l_u8 LIN_1_MessageId(volatile const l_u8* frameData);
              
                          #endif /* (1u == LIN_1_LIN_2_0) */
                      #endif /* (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB1_SEL)) */
              
                  #endif /* (1u == LIN_1_CS_ENABLED) */
              
                  /* RAM copy of the slave NAD */
                  static volatile l_u8 LIN_1_nad;
              
              #endif /* (1u == LIN_1_TL_ENABLED) */
  67          
  68          #if(1u == LIN_1_TL_ENABLED)
              
                  #if(1u == LIN_1_LIN_2_0)
                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & (LIN_1_NCS_0xB2_SEL | \
                              LIN_1_NCS_0xB1_SEL)))
              
                      
              
                      #endif /* (0u != (LIN_1_CS_SEL_SERVICES01 & (LIN_1_NCS_0xB2_SEL |
                             * LIN_1_NCS_0xB1_SEL)))
                             */
              
                  #endif /* (1u == LIN_1_LIN_2_0) */
              
              #endif /* (1u == LIN_1_TL_ENABLED) */
  83          
  84          #if(1u == LIN_1_INACTIVITY_ENABLED)
  85          
  86              /* Free-running timer */
  87              static l_u8    LIN_1_periodCounter;
  88          
  89          #endif /* (1u == LIN_1_INACTIVITY_ENABLED) */
  90          
  91          static volatile l_u8  LIN_1_status;       /* Internal Status                  */
  92          static volatile l_u8  LIN_1_syncCounts;   /* Sync Field Timer Counts          */
  93          static volatile l_u8  LIN_1_auxStatus;    /* Internal AUX ISR shadow status   */
  94          static volatile l_u16 LIN_1_ioctlStatus;  /* Status used by l_ifc_ioctl()     */
  95          static volatile l_u16 LIN_1_ifcStatus;    /* Interface communication status   */
  96          static volatile l_u8  LIN_1_uartFsmState; /* Current state of the UART ISR    */
  97          static volatile l_u8  LIN_1_fsmFlags;
  98          
  99          #if(1u == LIN_1_AUTO_BAUD_RATE_SYNC)
 100          
 101              /* Initial clock divider */
 102              static l_u16   LIN_1_initialClockDivider;
 103          
 104          #endif  /* (1u == LIN_1_AUTO_BAUD_RATE_SYNC) */
 105          
 106          #if(1u == LIN_1_SAE_J2602)
              
                  /* J2602 status variable */
                  static l_u8 LIN_1_j2602Status;
              
              #endif  /* (1u == LIN_1_SAE_J2602) */
 112          
 113          /* Notification API statuses */
 114          static l_u8 LIN_1_statusFlagArray[LIN_1_SIG_FRAME_FLAGS_SIZE];
 115          
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 3   

 116          /* SAE J2602 is disabled */
 117          #if(0u == LIN_1_SAE_J2602)
 118          
 119              #if (0u != LIN_1_NUM_ET_FRAMES)
                      static l_u8 LIN_1_etFrameFlags[LIN_1_ET_FRAMES_FLAGS_SIZE];
                  #endif /* (0u != LIN_1_NUM_ET_FRAMES) */
 122          
 123          #endif /* (0u == LIN_1_SAE_J2602) */
 124          
 125          /* RAM copy of the slave configuration data */
 126          static volatile l_u8 LIN_1_volatileConfig[LIN_1_NUM_FRAMES];
 127          
 128          
 129          /****************************************************
 130          *   Transport Layer API
 131          *****************************************************/
 132          #if(1u == LIN_1_TL_ENABLED)
              
                  #if(1u == LIN_1_CS_ENABLED)
                      
                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & (LIN_1_NCS_0xB0_SEL | LIN_1_NCS_0xB1_SEL \
                                  | LIN_1_NCS_0xB2_SEL | LIN_1_NCS_0xB3_SEL)))
                      
                          /* LIN Slave Identification */
                          static const LIN_1_SLAVE_ID CYCODE LIN_1_slaveId =
                          {
                              LIN_1_CS_SUPPLIER_ID,
                              LIN_1_CS_FUNCTION_ID,
                              LIN_1_CS_VARIANT
                          };
                          
                      #endif /*(0u != (LIN_1_CS_SEL_SERVICES01 & (LIN_1_NCS_0xB0_SEL 
                             * | LIN_1_NCS_0xB1_SEL | LIN_1_NCS_0xB2_SEL | 
                             * LIN_1_NCS_0xB3_SEL))
                             */
              
              
                      /* Serial Number */
                      static l_u8* LIN_1_serialNumber;
              
                  #endif /* (1u == LIN_1_CS_ENABLED) */
              
                  /* SRF buffer */
                  static volatile l_u8 LIN_1_srfBuffer[LIN_1_FRAME_BUFF_LEN];
              
                  /* Transport Layer Rx and Tx Statuses */
                  static volatile l_u8   LIN_1_txTlStatus;
                  static volatile l_u8   LIN_1_rxTlStatus;
              
                  /* Flags that are used for Transport Layer */
                  static volatile l_u8   LIN_1_tlFlags;
              
                  #if(1u == LIN_1_TL_API_FORMAT)
              
                      /* Internal variable used to store the PCI of the previous frame */
                      static l_u8 LIN_1_prevPci;
                  
                      static const    l_u8*   LIN_1_txTlDataPointer     = NULL;
                      static volatile l_u16   LIN_1_txTlDataCount;
                      static volatile l_u8*   LIN_1_rxTlDataPointer     = NULL;
                      static volatile l_u8*   LIN_1_rxTlInitDataPointer = NULL;
                      static volatile l_u8*   LIN_1_tlNadPointer      = NULL;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 4   

                      static volatile l_u16*  LIN_1_tlLengthPointer   = NULL;
              
                      static volatile l_u16   LIN_1_txMessageLength = 0u;
                      static volatile l_u16   LIN_1_rxMessageLength = 0u;
              
                      static volatile l_u8 LIN_1_txFrameCounter = 0u;
                      static l_u8 LIN_1_rxFrameCounter = 0u;
                      static volatile l_u8 LIN_1_tlTimeoutCnt   = 0u;
              
                  #else
              
                      /* Internal variables for buffer indexing */
                      static l_u8 LIN_1_txBufDepth;
                      static l_u8 LIN_1_rxBufDepth;
              
                      /* The Master Request Frame (MRF) buffer */
                      static volatile l_u8 LIN_1_rawRxQueue[LIN_1_TL_RX_QUEUE_LEN];
              
                      /* The Slave Response Frame (SRF) buffer */
                      static volatile l_u8 LIN_1_rawTxQueue[LIN_1_TL_TX_QUEUE_LEN];
              
                      /* TX buffer indexes */
                      static volatile l_u16 LIN_1_txWrIndex;
                      static volatile l_u16 LIN_1_txRdIndex;
              
                      /* RX buffer indexes */
                      static volatile l_u16 LIN_1_rxWrIndex;
                      static volatile l_u16 LIN_1_rxRdIndex;
              
                  #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
              #endif /* (1u == LIN_1_TL_ENABLED) */
 210          
 211          
 212          /* LIN slave configuration data */
 213          static LIN_1_SLAVE_CONFIG const CYCODE LIN_1_LinSlaveConfig = {
 214              /* Frame PID Table */
 215              {0xC1u, 0x85u}
 216          };
 217          
 218          
 219          /* Frames declaration with initial signals values */
 220          static volatile l_u8  LIN_1_Buffer_Frame1[1u] = {0xFBu};
 221          static volatile l_u8  LIN_1_Buffer_seesaw_motor[1u] = {0x00u};
 222          
 223          
 224          
 225          /*******************************************************************************
 226          *  Place your code here
 227          *******************************************************************************/
 228          /* `#START LIN_1_CODE` */
 229          
 230          /* `#END` */
 231          
 232          
 233          /*******************************************************************************
 234          * Function Name: LIN_1_Start
 235          ********************************************************************************
 236          *
 237          * Summary:
 238          *  Starts the component operation. This function is not required to be used.
 239          *
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 5   

 240          * Parameters:
 241          *  None
 242          *
 243          * Return:
 244          *  Zero     - if the initialization succeeded.
 245          *  Non-zero - if the initialization failed.
 246          *
 247          * Reentrant:
 248          *  No
 249          *
 250          *******************************************************************************/
 251          l_bool LIN_1_Start(void) 
 252          {
 253   1          l_bool returnValue;
 254   1      
 255   1          /* Call initialization function */
 256   1          returnValue = l_sys_init();
 257   1      
 258   1          /* Start LIN components. Ignore the return value. */
 259   1          (void) l_ifc_init_LIN_1();
 260   1      
 261   1          return (returnValue);
 262   1      }
 263          
 264          
 265          /*******************************************************************************
 266          * Function Name: LIN_1_Stop
 267          ********************************************************************************
 268          *
 269          * Summary:
 270          *  Starts the component operation. This function is not required to be used.
 271          *
 272          * Parameters:
 273          *  None
 274          *
 275          * Return:
 276          *  None
 277          *
 278          *******************************************************************************/
 279          l_u8 LIN_1_Stop(void) 
 280          {
 281   1          /* Stop UART */
 282   1          LIN_1_UART_Stop();
 283   1      
 284   1          /* Disable hardware blocks operation */
 285   1          LIN_1_CONTROL_REG &= (l_u8) ~LIN_1_CONTROL_ENABLE;
 286   1      
 287   1          /* Disable interrupts */
 288   1          return(l_sys_irq_disable());
 289   1      }
 290          
 291          
 292          /*******************************************************************************
 293          * Function Name: l_sys_init
 294          ********************************************************************************
 295          *
 296          * Summary:
 297          *  Performs the initialization of the LIN core. This function does nothing and
 298          *  and always returns zero.
 299          *
 300          * Parameters:
 301          *  None
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 6   

 302          *
 303          * Return:
 304          *  Zero     - if the initialization succeeded.
 305          *  Non-zero - if the initialization failed.
 306          *
 307          *******************************************************************************/
 308          l_bool l_sys_init(void)  
 309          {
 310   1          return (LIN_1_FALSE);
 311   1      }
 312          
 313          
 314          /* Signal interaction and notification API */
 315          
 316          
 317          /*******************************************************************************
 318          * Function Name: l_u8_rd
 319          ********************************************************************************
 320          *
 321          * Summary:
 322          *  Reads and returns the current value of the signal for signals of the size
 323          *  2 - 8 bits. If an invalid signal handle is passed into the function, no
 324          *  action is done.
 325          *
 326          * Parameters:
 327          *  sss - signal handle of the signal to read.
 328          *
 329          * Return:
 330          *  Returns current value of signal.
 331          *
 332          *******************************************************************************/
 333          l_u8 l_u8_rd(l_signal_handle sss) 
 334          {
 335   1          l_u8 returnValue;
 336   1      
 337   1          switch(sss)
 338   1          {
 339   2              case seesaw_motor_status_SIGNAL_HANDLE:
 340   2                  returnValue = l_u8_rd_seesaw_motor_status();
 341   2              break;
 342   2      
 343   2              default:
 344   2                  returnValue = (l_u8) 0xFFu;
 345   2              break;
 346   2          }
 347   1      
 348   1          return(returnValue);
 349   1      }
 350          
 351          
 352          /*******************************************************************************
 353          * Function Name: l_u8_rd_seesaw_motor_status
 354          ********************************************************************************
 355          *
 356          * Summary:
 357          *  Reads and returns the current value of the signal for signals of the size
 358          *  2 - 8 bits.
 359          *
 360          * Parameters:
 361          *  None
 362          *
 363          * Return:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 7   

 364          *  Returns current value of signal.
 365          *
 366          *******************************************************************************/
 367          l_u8 l_u8_rd_seesaw_motor_status(void) 
 368          {
 369   1          /* Get one complete byte signal from frame */
 370   1          return(LIN_1_Buffer_seesaw_motor[LIN_1_seesaw_motor_status_seesaw_motor_SIG_BYTE_OFFSET]);
 371   1      }
 372          
 373          
 374          
 375          
 376          
 377          
 378          
 379          
 380          
 381          
 382          /*******************************************************************************
 383          * Function Name: l_bool_wr
 384          ********************************************************************************
 385          *
 386          * Summary:
 387          *  Sets the current value of the signal for one bit signals to "v".
 388          *  If an invalid signal handle is passed into the function, no action is done. 
 389          *
 390          * Parameters:
 391          *  sss - signal handle of the signal to be set.
 392          *  v - value of the signal to be set.
 393          *
 394          * Return:
 395          *  None
 396          *
 397          * Reentrant:
 398          *  No
 399          *
 400          *******************************************************************************/
 401          void l_bool_wr(l_signal_handle sss, l_bool v)
 402          {
 403   1          switch(sss)
 404   1          {
 405   2              case Response_Error_SIGNAL_HANDLE:
 406   2                  l_bool_wr_Response_Error(v);
 407   2              break;
 408   2      
 409   2              default:
 410   2              break;
 411   2          }
 412   1      }
 413          
 414          
 415          /*******************************************************************************
 416          * Function Name: l_bool_wr_Response_Error
 417          ********************************************************************************
 418          *
 419          * Summary:
 420          *  Sets the current value of the signal for one bit signals to v.
 421          *
 422          * Parameters:
 423          *  v - value of the signal to be set.
 424          *
 425          * Return:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 8   

 426          *  None
 427          *
 428          * Reentrant:
 429          *  No
 430          *
 431          *******************************************************************************/
 432          void l_bool_wr_Response_Error(l_bool v)
 433          {
 434   1          uint8 interruptState;
 435   1      
 436   1          /* Save current global interrupt enable and disable it */
 437   1          interruptState = CyEnterCriticalSection();
 438   1      
 439   1          if(0u != v)
 440   1          {
 441   2              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
 442   2                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
 443   2          }
 444   1          else
 445   1          {
 446   2              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] &= 
 447   2                                  (l_u8) ~LIN_1_Response_Error_Frame1_SIG_MASK_0;
 448   2          }
 449   1      
 450   1          /* Restore global interrupt enable state */
 451   1          CyExitCriticalSection(interruptState);
 452   1      }
 453          
 454          
 455          
 456          
 457          
 458          
 459          
 460          
 461          
 462          
 463          
 464          /*******************************************************************************
 465          * Function Name: l_flg_tst
 466          ********************************************************************************
 467          *
 468          * Summary:
 469          *  Returns a C boolean indicating the current state of the flag specified by
 470          *  the name fff, i.e. returns zero if the flag is cleared, non-zero otherwise.
 471          *
 472          * Parameters:
 473          *  fff - is the name of the flag handle.
 474          *
 475          * Return:
 476          *  Returns a C boolean indicating the current state of the flag specified by
 477          *  the name fff:
 478          *  False - if the flag is cleared;
 479          *  True - if the flag is not cleared.
 480          *
 481          *******************************************************************************/
 482          l_bool l_flg_tst(l_flag_handle fff)
 483          {
 484   1          l_bool returnValue;
 485   1      
 486   1          switch(fff)
 487   1          {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 9   

 488   2              case seesaw_motor_status_FLAG_HANDLE:
 489   2                  returnValue = l_flg_tst_seesaw_motor_status();
 490   2              break;
 491   2      
 492   2              case Frame1_FLAG_HANDLE:
 493   2                  returnValue = l_flg_tst_Frame1();
 494   2              break;
 495   2      
 496   2              case seesaw_motor_FLAG_HANDLE:
 497   2                  returnValue = l_flg_tst_seesaw_motor();
 498   2              break;
 499   2      
 500   2              default:
 501   2                  returnValue = LIN_1_TRUE;
 502   2              break;
 503   2          }
 504   1      
 505   1          return(returnValue);
 506   1      }
 507          
 508          
 509          /*******************************************************************************
 510          * Function Name: l_flg_tst_seesaw_motor_status
 511          ********************************************************************************
 512          *
 513          * Summary:
 514          *  Returns a C boolean indicating the current state of the flag specified by
 515          *  the name fff, i.e. returns zero if the flag is cleared, non-zero otherwise.
 516          *
 517          * Parameters:
 518          *  None
 519          *
 520          * Return:
 521          *  Returns a C boolean indicating the current state of the flag specified by
 522          *  the name fff:
 523          *  False - if the flag is cleared;
 524          *  True - if the flag is not cleared.
 525          *
 526          *******************************************************************************/
 527          l_bool l_flg_tst_seesaw_motor_status(void)
 528          {
 529   1          l_bool result = LIN_1_FALSE;
 530   1      
 531   1          if(0u != (LIN_1_statusFlagArray[LIN_1_seesaw_motor_status_FRAME_FLAG_BYTE_OFFSET_0] &
 532   1          LIN_1_seesaw_motor_status_FRAME_FLAG_MASK_0))
 533   1          {
 534   2              result = LIN_1_TRUE;
 535   2          }
 536   1      
 537   1          return(result);
 538   1      }
 539          
 540          /*******************************************************************************
 541          * Function Name: l_flg_tst_Frame1
 542          ********************************************************************************
 543          *
 544          * Summary:
 545          *  Returns a C boolean indicating the current state of the flag specified by
 546          *  the name fff, i.e. returns zero if the flag is cleared, non-zero otherwise.
 547          *
 548          * Parameters:
 549          *  None
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 10  

 550          *
 551          * Return:
 552          *  Returns a C boolean indicating the current state of the flag specified by
 553          *  the name fff:
 554          *  False - if the flag is cleared;
 555          *  True - if the flag is not cleared.
 556          *
 557          *******************************************************************************/
 558          l_bool l_flg_tst_Frame1(void)
 559          {
 560   1          l_bool result = LIN_1_FALSE;
 561   1      
 562   1          if(0u != (LIN_1_statusFlagArray[LIN_1_Frame1_FRAME_FLAG_BYTE_OFFSET_0] &
 563   1          LIN_1_Frame1_FRAME_FLAG_MASK_0))
 564   1          {
 565   2              result = LIN_1_TRUE;
 566   2          }
 567   1      
 568   1          return(result);
 569   1      }
 570          
 571          /*******************************************************************************
 572          * Function Name: l_flg_tst_seesaw_motor
 573          ********************************************************************************
 574          *
 575          * Summary:
 576          *  Returns a C boolean indicating the current state of the flag specified by
 577          *  the name fff, i.e. returns zero if the flag is cleared, non-zero otherwise.
 578          *
 579          * Parameters:
 580          *  None
 581          *
 582          * Return:
 583          *  Returns a C boolean indicating the current state of the flag specified by
 584          *  the name fff:
 585          *  False - if the flag is cleared;
 586          *  True - if the flag is not cleared.
 587          *
 588          *******************************************************************************/
 589          l_bool l_flg_tst_seesaw_motor(void)
 590          {
 591   1          l_bool result = LIN_1_FALSE;
 592   1      
 593   1          if(0u != (LIN_1_statusFlagArray[LIN_1_seesaw_motor_FRAME_FLAG_BYTE_OFFSET_0] &
 594   1          LIN_1_seesaw_motor_FRAME_FLAG_MASK_0))
 595   1          {
 596   2              result = LIN_1_TRUE;
 597   2          }
 598   1      
 599   1          return(result);
 600   1      }
 601          
 602          
 603          
 604          
 605          
 606          
 607          /*******************************************************************************
 608          * Function Name: l_flg_clr
 609          ********************************************************************************
 610          *
 611          * Summary:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 11  

 612          *  Sets the current value of the flag specified by the name fff to zero.
 613          *
 614          * Parameters:
 615          *  fff - is the name of the flag handle.
 616          *
 617          * Return:
 618          *  None
 619          *
 620          * Reentrant:
 621          *  No
 622          *
 623          *******************************************************************************/
 624          void l_flg_clr(l_flag_handle fff)
 625          {
 626   1          switch(fff)
 627   1          {
 628   2              case seesaw_motor_status_FLAG_HANDLE:
 629   2                  l_flg_clr_seesaw_motor_status();
 630   2              break;
 631   2      
 632   2              case Frame1_FLAG_HANDLE:
 633   2                  l_flg_clr_Frame1();
 634   2              break;
 635   2      
 636   2              case seesaw_motor_FLAG_HANDLE:
 637   2                  l_flg_clr_seesaw_motor();
 638   2              break;
 639   2      
 640   2              default:
 641   2              break;
 642   2          }
 643   1      }
 644          
 645          
 646          /*******************************************************************************
 647          * Function Name: l_flg_clr_seesaw_motor_status
 648          ********************************************************************************
 649          *
 650          * Summary:
 651          *  Sets the current value of the flag specified by the name fff to zero.
 652          *
 653          * Parameters:
 654          *  None
 655          *
 656          * Return:
 657          *  None
 658          *
 659          * Reentrant:
 660          *  No
 661          *
 662          *******************************************************************************/
 663          void l_flg_clr_seesaw_motor_status(void)
 664          {
 665   1          LIN_1_statusFlagArray[LIN_1_seesaw_motor_status_FRAME_FLAG_BYTE_OFFSET_0] &=
 666   1             ((l_u8) ~LIN_1_seesaw_motor_status_FRAME_FLAG_MASK_0);
 667   1      }
 668          
 669          /*******************************************************************************
 670          * Function Name: l_flg_clr_Frame1
 671          ********************************************************************************
 672          *
 673          * Summary:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 12  

 674          *  Sets the current value of the flag specified by the name fff to zero.
 675          *
 676          * Parameters:
 677          *  None
 678          *
 679          * Return:
 680          *  None
 681          *
 682          * Reentrant:
 683          *  No
 684          *
 685          *******************************************************************************/
 686          void l_flg_clr_Frame1(void)
 687          {
 688   1          LIN_1_statusFlagArray[LIN_1_Frame1_FRAME_FLAG_BYTE_OFFSET_0] &=
 689   1             ((l_u8) ~LIN_1_Frame1_FRAME_FLAG_MASK_0);
 690   1      }
 691          
 692          /*******************************************************************************
 693          * Function Name: l_flg_clr_seesaw_motor
 694          ********************************************************************************
 695          *
 696          * Summary:
 697          *  Sets the current value of the flag specified by the name fff to zero.
 698          *
 699          * Parameters:
 700          *  None
 701          *
 702          * Return:
 703          *  None
 704          *
 705          * Reentrant:
 706          *  No
 707          *
 708          *******************************************************************************/
 709          void l_flg_clr_seesaw_motor(void)
 710          {
 711   1          LIN_1_statusFlagArray[LIN_1_seesaw_motor_FRAME_FLAG_BYTE_OFFSET_0] &=
 712   1             ((l_u8) ~LIN_1_seesaw_motor_FRAME_FLAG_MASK_0);
 713   1      }
 714          
 715          
 716          
 717          
 718          
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: l_ifc_init_LIN_1
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  The function initializes the LIN Slave component instance that is specified
 727          *  by the name iii. It sets up internal functions such as the baud rate and
 728          *  starts up digital blocks that are used by the LIN Slave component. This is
 729          *  the first call that must be performed, before using any other interface-
 730          *  related LIN Slave API functions.
 731          *
 732          * Parameters:
 733          *  None
 734          *
 735          * Return:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 13  

 736          *  The 0 is returned if operation succeeded and 1 if an invalid operation
 737          *  parameter was passed to the function.
 738          *
 739          * Reentrant:
 740          *  No
 741          *
 742          *******************************************************************************/
 743          l_bool l_ifc_init_LIN_1(void) 
 744          {
 745   1          l_u8 interruptState;
 746   1          l_u8 i;
 747   1      
 748   1          /* Set bLIN interrupt priority */
 749   1          CyIntSetPriority(LIN_1_BLIN_ISR_NUMBER, LIN_1_BLIN_ISR_PRIORITY);
 750   1      
 751   1          /* Set bLIN interrupt vector */
 752   1          (void) CyIntSetVector(LIN_1_BLIN_ISR_NUMBER, &LIN_1_BLIN_ISR);
 753   1      
 754   1          /* Clear any pending bLIN interrupt */
 755   1          CyIntClearPending(LIN_1_BLIN_ISR_NUMBER);
 756   1      
 757   1          /* Clear any pending bLIN interrupt */
 758   1          CyIntClearPending(LIN_1_BLIN_ISR_NUMBER);
 759   1      
 760   1          /* Set UART interrupt priority */
 761   1          CyIntSetPriority(LIN_1_UART_ISR_NUMBER, LIN_1_UART_ISR_PRIORITY);
 762   1      
 763   1          /* Set UART interrupt vector */
 764   1          (void) CyIntSetVector(LIN_1_UART_ISR_NUMBER, &LIN_1_UART_ISR);
 765   1      
 766   1          /* Start UART */
 767   1          LIN_1_UART_Start();
 768   1      
 769   1          /* Set Break Detection Threshold in counts */
 770   1          LIN_1_BREAK_THRESHOLD_REG = (l_u8) LIN_1_BREAK_THRESHOLD_VALUE;
 771   1      
 772   1          /* Allow interrupts on break, sync and inactivity (optional) events */
 773   1          LIN_1_INT_MASK_REG |= (LIN_1_INT_MASK_BREAK     |
 774   1                                            LIN_1_INT_MASK_SYNC      |
 775   1                                            LIN_1_INT_MASK_INACTIVITY);
 776   1      
 777   1          interruptState = CyEnterCriticalSection();
 778   1      
 779   1          LIN_1_STATUS_AUX_CONTROL_REG |= LIN_1_STATUS_AUX_CONTROL_INT_EN;
 780   1      
 781   1          CyExitCriticalSection(interruptState);
 782   1      
 783   1          /* Bus inactivity block configuration */
 784   1          #if(1u == LIN_1_INACTIVITY_ENABLED)
 785   1      
 786   1              /* Bus inactivity block configuration to issue interrupt every 100 ms */
 787   1              LIN_1_INACTIVITY_DIV0_REG = LIN_1_INACT_DIV0;
 788   1              LIN_1_INACTIVITY_DIV1_REG = LIN_1_INACT_DIV1;
 789   1      
 790   1          #endif  /* (1u == LIN_1_INACTIVITY_ENABLED) */
 791   1      
 792   1      
 793   1          /* Save clock divider */
 794   1           #if(1u == LIN_1_AUTO_BAUD_RATE_SYNC)
 795   1      
 796   1              /* Save default clock divider */
 797   1              LIN_1_initialClockDivider = LIN_1_IntClk_GetDividerRegister();
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 14  

 798   1      
 799   1          #endif  /* (1u == LIN_1_AUTO_BAUD_RATE_SYNC) */
 800   1      
 801   1          /* Enable hardware blocks operation */
 802   1          LIN_1_CONTROL_REG |= LIN_1_CONTROL_ENABLE;
 803   1      
 804   1          /* Copy PIDs from NVRAM to VRAM */
 805   1          for(i = 0u; i < LIN_1_NUM_FRAMES; i++)
 806   1          {
 807   2              LIN_1_volatileConfig[i] = LIN_1_LinSlaveConfig.pidTable[i];
 808   2          }
 809   1      
 810   1          #if(1u == LIN_1_TL_ENABLED)
              
                      LIN_1_nad = LIN_1_LinSlaveConfig.initialNad;
              
                  #endif /* (1u == LIN_1_TL_ENABLED) */
 815   1      
 816   1          /*  Clear interface status */
 817   1          LIN_1_ifcStatus &= (l_u16) ~LIN_1_IFC_STS_MASK;
 818   1      
 819   1          /* Enable bLIN interrupt */
 820   1          CyIntEnable(LIN_1_BLIN_ISR_NUMBER);
 821   1      
 822   1          /* Initialization is always expected to succeeded */
 823   1          return (LIN_1_FALSE);
 824   1      }
 825          
 826          
 827          /*******************************************************************************
 828          * Function Name: l_ifc_init
 829          ********************************************************************************
 830          *
 831          * Summary:
 832          *  The function initializes the LIN Slave component instance that is specified
 833          *  by the name iii. It sets up internal functions such as the baud rate and
 834          *  starts up digital blocks that are used by the LIN Slave component. This is
 835          *  the first call that must be performed, before using any other interface-
 836          *  related LIN Slave API functions.
 837          *
 838          * Parameters:
 839          *  iii - is the name of the interface handle.
 840          *
 841          * Return:
 842          *  The 0 is returned if operation succeeded and 1 if an invalid operation
 843          *  parameter was passed to the function.
 844          *
 845          * Reentrant:
 846          *  No
 847          *
 848          *******************************************************************************/
 849          l_bool l_ifc_init(l_ifc_handle iii) 
 850          {
 851   1          l_bool returnValue;
 852   1      
 853   1          switch(iii)
 854   1          {
 855   2              case LIN_1_IFC_HANDLE:
 856   2                  returnValue = l_ifc_init_LIN_1();
 857   2              break;
 858   2      
 859   2              default:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 15  

 860   2                  /* Unknown interface handle */
 861   2                  returnValue = LIN_1_TRUE;
 862   2              break;
 863   2          }
 864   1      
 865   1          return (returnValue);
 866   1      }
 867          
 868          
 869          /*******************************************************************************
 870          * Function Name: l_ifc_wake_up
 871          ********************************************************************************
 872          *
 873          * Summary:
 874          *  This function transmits one wakeup signal. The wakeup signal is transmitted
 875          *  directly when this function is called. When you call this API function, the
 876          *  application is blocked until a wakeup signal is transmitted on the LIN bus.
 877          *  The CyDelayUs() function is used as the timing source. The delay is
 878          *  calculated based on the clock configuration entered in PSoC Creator.
 879          *
 880          * Parameters:
 881          *  None
 882          *
 883          * Return:
 884          *  None
 885          *
 886          *******************************************************************************/
 887          void l_ifc_wake_up_LIN_1(void) 
 888          {
 889   1          /* Force TXD low */
 890   1          LIN_1_CONTROL_REG |= LIN_1_CONTROL_TX_DIS;
 891   1      
 892   1          /* Wait */
 893   1          CyDelayUs(LIN_1_WAKE_UP_SIGNAL_LENGTH);
 894   1      
 895   1          /* Connect TXD from UART to LIN bus line */
 896   1          LIN_1_CONTROL_REG &=  ((l_u8) ~LIN_1_CONTROL_TX_DIS);
 897   1      }
 898          
 899          
 900          /*******************************************************************************
 901          * Function Name: l_ifc_wake_up
 902          ********************************************************************************
 903          *
 904          * Summary:
 905          *  This function transmits one wakeup signal. The wakeup signal is transmitted
 906          *  directly when this function is called. When you call this API function, the
 907          *  application is blocked until a wakeup signal is transmitted on the LIN bus.
 908          *  The CyDelayUs() function is used as the timing source. The delay is
 909          *  calculated based on the clock configuration entered in PSoC Creator.
 910          *
 911          * Parameters:
 912          *  iii - is the name of the interface handle.
 913          *
 914          * Return:
 915          *  None
 916          *
 917          *******************************************************************************/
 918          void l_ifc_wake_up(l_ifc_handle iii) 
 919          {
 920   1          switch(iii)
 921   1          {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 16  

 922   2              case LIN_1_IFC_HANDLE:
 923   2                  l_ifc_wake_up_LIN_1();
 924   2              break;
 925   2      
 926   2              default:
 927   2                  /* Unknown interface handle - do nothing. */
 928   2              break;
 929   2          }
 930   1      }
 931          
 932          
 933          /*******************************************************************************
 934          * Function Name: l_ifc_ioctl
 935          ********************************************************************************
 936          *
 937          * Summary:
 938          *  This function controls functionality that is not covered by the other API
 939          *  calls. It is used for protocol specific parameters or hardware specific
 940          *  functionality.
 941          *
 942          * Parameters:
 943          *  op - is the operation that should be applied.
 944          *  pv - is the pointer to the optional parameter.
 945          *
 946          * Return:
 947          *  There is no error code value returned for operation selected. This means that
 948          *  you must ensure that the values passed into the function are correct.
 949          *
 950          *  L_IOCTL_READ_STATUS operation:
 951          *  The first bit in this byte is the flag that indicates that there has been no
 952          *  signaling on the bus for a certain elapsed time (available when
 953          *  Bus Inactivity Timeout Detection option is enabled). If the elapsed time
 954          *  passes a certain threshold, then this flag is set. Calling this API clears
 955          *  all status bits after they are returned. The second bit is the flag that
 956          *  indicates that a Targeted Reset service request (0xB5) was received
 957          *  (when J2602-1 Compliance is enabled).
 958          *
 959          *  Symbolic Name : LIN_1_IOCTL_STS_BUS_INACTIVITY
 960          *  Value         : 0x0001u
 961          *  Description   : No signal was detected on the bus for a certain elapsed time
 962          *
 963          *  Symbolic Name : LIN_1_IOCTL_STS_TARGET_RESET
 964          *  Value         : 0x0002u
 965          *  Description   : Targeted Reset service request (0xB5) was received.
 966          *
 967          *  L_IOCTL_SET_BAUD_RATE operation:
 968          *  The 0 is returned if operation succeeded and 1 if an invalid operation
 969          *  parameter was passed to the function.
 970          *
 971          *  L_IOCTL_SLEEP operation:
 972          *  The CYRET_SUCCESS is returned if operation succeeded and CYRET_BAD_PARAM if
 973          *  an invalid operation parameter was passed to the function.
 974          *
 975          *  L_IOCTL_WAKEUP operation:
 976          *  The CYRET_SUCCESS is returned if operation succeeded and CYRET_BAD_PARAM if
 977          *  an invalid operation parameter was passed to the function.
 978          *
 979          *  L_IOCTL_SYNC_COUNTS operation:
 980          *  The CYRET_SUCCESS is returned if operation succeeded and CYRET_BAD_PARAM if
 981          *  an invalid operation parameter was passed to the function.
 982          *
 983          *  L_IOCTL_SET_SERIAL_NUMBER operation:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 17  

 984          *  The CYRET_SUCCESS is returned if operation succeeded and CYRET_BAD_PARAM if
 985          *  an invalid operation parameter was passed to the function.
 986          *
 987          * Reentrant:
 988          *  No
 989          *
 990          *******************************************************************************/
 991          l_u16 l_ifc_ioctl_LIN_1(l_ioctl_op op, void* pv) 
 992          {
 993   1          /* Retention registers are stored here */
 994   1          static LIN_1_BACKUP_STRUCT  LIN_1_backup = {0u, };
 995   1      
 996   1          l_u16 returnValue = (l_u16) CYRET_SUCCESS;
 997   1          l_u8 interruptState;
 998   1      
 999   1          switch (op)
1000   1          {
1001   2              /***********************************************************************
1002   2              *                           Read Status
1003   2              ***********************************************************************/
1004   2              case L_IOCTL_READ_STATUS:
1005   2      
1006   2                  /* Return status */
1007   2                  returnValue = LIN_1_ioctlStatus;
1008   2      
1009   2                  /* Clear status */
1010   2                  LIN_1_ioctlStatus = 0x0000u;
1011   2      
1012   2              break;
1013   2      
1014   2              /***********************************************************************
1015   2              *                           Set Baud Rate
1016   2              ***********************************************************************/
1017   2              case L_IOCTL_SET_BAUD_RATE:
1018   2      
1019   2                  interruptState = CyEnterCriticalSection();
1020   2      
1021   2                  /* Set new internal clock divider with effect on end of cycle */
1022   2                  LIN_1_IntClk_SetDividerRegister(((*((l_u16*)pv)) - 1u), 0u);
1023   2      
1024   2                  /* Bus inactivity block reconfiguration */
1025   2                  #if(1u == LIN_1_INACTIVITY_ENABLED)
1026   2      
1027   2                      /* Divider 1 for specified interrupt rate */
1028   2                      LIN_1_INACTIVITY_DIV0_REG =
1029   2                          (((l_u8)(((LIN_1_INACT_OVERSAMPLE_RATE) *
1030   2                          ((*(l_u16*)pv) / LIN_1_INACT_100MS_IN_S)) /
1031   2                          LIN_1_INACT_DIVIDE_FACTOR) - 1u));
1032   2      
1033   2                      /* Divider 1 for specified interrupt rate */
1034   2                      LIN_1_INACTIVITY_DIV1_REG =
1035   2                          ((l_u8)(((LIN_1_INACT_OVERSAMPLE_RATE) *
1036   2                          ((*(l_u16*)pv) / LIN_1_INACT_100MS_IN_S)) -
1037   2                          (LIN_1_INACT_DIVIDE_FACTOR *
1038   2                          LIN_1_INACTIVITY_DIV0_REG)));
1039   2      
1040   2                  #endif  /* (1u == LIN_1_INACTIVITY_ENABLED) */
1041   2      
1042   2                  CyExitCriticalSection(interruptState);
1043   2      
1044   2              break;
1045   2      
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 18  

1046   2      
1047   2              /***********************************************************************
1048   2              *                   Prepare for the low power modes
1049   2              ***********************************************************************/
1050   2              case L_IOCTL_SLEEP:
1051   2      
1052   2                  LIN_1_backup.control = LIN_1_CONTROL_REG;
1053   2      
1054   2                  if(0u != (LIN_1_CONTROL_REG  & LIN_1_CONTROL_ENABLE))
1055   2                  {
1056   3                     LIN_1_backup.enableState = LIN_1_TRUE;
1057   3                  }
1058   2                  else
1059   2                  {
1060   3                      LIN_1_backup.enableState = LIN_1_FALSE;
1061   3                  }
1062   2      
1063   2                  /* Disable interrupts */
1064   2                  (void) l_sys_irq_disable();
1065   2      
1066   2                  /* Prepare UART for low power mode */
1067   2                  LIN_1_UART_Sleep();
1068   2      
1069   2                  /* Disable hardware blocks operation */
1070   2                  LIN_1_CONTROL_REG &= ((l_u8) ~LIN_1_CONTROL_ENABLE);
1071   2      
1072   2                  LIN_1_backup.statusMask = LIN_1_INT_MASK_REG;
1073   2      
1074   2                  #if(1u == LIN_1_INACTIVITY_ENABLED)
1075   2      
1076   2                      LIN_1_backup.inactivityDiv0 = LIN_1_INACTIVITY_DIV0_REG;
1077   2                      LIN_1_backup.inactivityDiv1 = LIN_1_INACTIVITY_DIV1_REG;
1078   2      
1079   2                  #endif  /* (1u == LIN_1_INACTIVITY_ENABLED) */
1080   2      
1081   2              break;
1082   2      
1083   2      
1084   2              /***********************************************************************
1085   2              *             Restore after wakeup from low power modes
1086   2              ***********************************************************************/
1087   2              case L_IOCTL_WAKEUP:
1088   2      
1089   2                  LIN_1_INT_MASK_REG = LIN_1_backup.statusMask;
1090   2      
1091   2                  #if(1u == LIN_1_INACTIVITY_ENABLED)
1092   2      
1093   2                      LIN_1_INACTIVITY_DIV0_REG = LIN_1_backup.inactivityDiv0;
1094   2                      LIN_1_INACTIVITY_DIV1_REG = LIN_1_backup.inactivityDiv1;
1095   2      
1096   2                  #endif  /* (1u == LIN_1_INACTIVITY_ENABLED) */
1097   2      
1098   2                  LIN_1_CONTROL_REG = LIN_1_backup.control;
1099   2      
1100   2                  /* Restore UART state*/
1101   2                  LIN_1_UART_Wakeup();
1102   2      
1103   2                  if(0u != LIN_1_backup.enableState)
1104   2                  {
1105   3                     l_sys_irq_restore(LIN_1_ALL_IRQ_ENABLE);
1106   3                  }
1107   2      
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 19  

1108   2              break;
1109   2      
1110   2              #if(1u == LIN_1_AUTO_BAUD_RATE_SYNC)
1111   2      
1112   2                  case L_IOCTL_SYNC_COUNTS:
1113   2      
1114   2                      /* Returns current number of sync field timer counts */
1115   2                      returnValue = (l_u16) LIN_1_syncCounts;
1116   2      
1117   2                  break;
1118   2      
1119   2              #endif  /* (1u == LIN_1_AUTO_BAUD_RATE_SYNC) */
1120   2      
1121   2      
1122   2              #if(1u == LIN_1_TL_ENABLED)
                          #if(1u == LIN_1_CS_ENABLED)
              
                              case L_IOCTL_SET_SERIAL_NUMBER:
                                  LIN_1_serialNumber = (l_u8*) pv;
                              break;
              
                          #endif /* (1u == LIN_1_CS_ENABLED) */
                      #endif /* (1u == LIN_1_TL_ENABLED) */
1131   2      
1132   2      
1133   2              default:
1134   2                  /* Unknown operation */
1135   2                  returnValue = (l_u16) CYRET_BAD_PARAM;
1136   2              break;
1137   2          }
1138   1      
1139   1          return (returnValue);
1140   1      }
1141          
1142          
1143          /*******************************************************************************
1144          * Function Name: l_ifc_ioctl
1145          ********************************************************************************
1146          *
1147          * Summary:
1148          *  This function controls functionality that is not covered by the other API
1149          *  calls. It is used for protocol specific parameters or hardware specific
1150          *  functionality. Example of such functionality can be to switch on/off the
1151          *  wake up signal detection.
1152          *
1153          * Parameters:
1154          *  iii - is the name of the interface handle.
1155          *  op - is the operation that should be applied.
1156          *  pv - is the pointer to the optional parameter.
1157          *
1158          * Return:
1159          *  There is no error code value returned for operation selected. This means that
1160          *  you must ensure that the values passed into the function are correct.
1161          *
1162          *  L_IOCTL_READ_STATUS operation
1163          *  The first bit in this byte is the flag that indicates that there has been no
1164          *  signaling on the bus for a certain elapsed time (available when
1165          *  Bus Inactivity Timeout Detection option is enabled). If the elapsed time
1166          *  passes a certain threshold, then this flag is set. Calling this API clears
1167          *  all status bits after they are returned. The second bit is the flag that
1168          *  indicates that a Targeted Reset service request (0xB5) was received
1169          *  (when J2602-1 Compliance is enabled).
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 20  

1170          *
1171          *  Symbolic Name : LIN_1_IOCTL_STS_BUS_INACTIVITY
1172          *  Value         : 0x0001u
1173          *  Description   : No signal was detected on the bus for a certain elapsed time
1174          *
1175          *  Symbolic Name : LIN_1_IOCTL_STS_TARGET_RESET
1176          *  Value         : 0x0002u
1177          *  Description   : Targeted Reset service request (0xB5) was received.
1178          *
1179          *  L_IOCTL_SET_BAUD_RATE operation
1180          *  The 0 is returned if operation succeeded and 1 if an invalid operation
1181          *  parameter was passed to the function.
1182          *
1183          *  L_IOCTL_SLEEP operation
1184          *  The 0 is returned if operation succeeded and 1 if an invalid operation
1185          *  parameter was passed to the function.
1186          *
1187          *  L_IOCTL_WAKEUP operation
1188          *  The 0 is returned if operation succeeded and 1 if an invalid operation
1189          *  parameter was passed to the function.
1190          *
1191          *  L_IOCTL_SYNC_COUNTS operation
1192          *  The 0 is returned if operation succeeded and 1 if an invalid operation
1193          *  parameter was passed to the function.
1194          *
1195          *  L_IOCTL_SET_SERIAL_NUMBER operation
1196          *  The 0 is returned if operation succeeded and 1 if an invalid operation
1197          *  parameter was passed to the function.
1198          *
1199          * Reentrant:
1200          *  No
1201          *
1202          *******************************************************************************/
1203          l_u16 l_ifc_ioctl(l_ifc_handle iii, l_ioctl_op op, void* pv) 
1204          {
1205   1          l_u16 returnValue;
1206   1      
1207   1          switch(iii)
1208   1          {
1209   2              case LIN_1_IFC_HANDLE:
1210   2                  returnValue = l_ifc_ioctl_LIN_1(op, pv);
1211   2              break;
1212   2      
1213   2              default:
1214   2                  /* Unknown operation */
1215   2                  returnValue = (l_u16) CYRET_BAD_PARAM;
1216   2              break;
1217   2          }
1218   1      
1219   1          return (returnValue);
1220   1      }
1221          
1222          
1223          /*******************************************************************************
1224          * Function Name: l_ifc_rx
1225          ********************************************************************************
1226          *
1227          * Summary:
1228          *  The LIN Slave component takes care of calling this API routine automatically.
1229          *  Therefore, this API routine must not be called by the application code.
1230          *
1231          * Parameters:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 21  

1232          *  None
1233          *
1234          * Return:
1235          *  None
1236          *
1237          * Reentrant:
1238          *  No
1239          *
1240          *******************************************************************************/
1241          void l_ifc_rx_LIN_1(void) 
1242          {
1243   1          l_u8 i;
1244   1          l_u8 interruptState;
1245   1      
1246   1          static l_u16 LIN_1_interimChecksum;   /* Holds interim checksum value     */
1247   1          static l_u8 LIN_1_framePid;           /* PID of the current frame         */
1248   1          static l_u8 LIN_1_frameSize;          /* Size of frame being processed    */
1249   1          static l_u8 LIN_1_bytesTransferred;   /* Number of transferred bytes       */
1250   1          static l_u8 LIN_1_tmpData;            /* Used to store transmitted byte   */
1251   1          static l_u8 LIN_1_pidIndex;           /* Index in pidInfoTable            */
1252   1          static l_u8 LIN_1_tmpRxFrameData[8u]; /* RXed data before checksum checked */
1253   1          static volatile l_u8* LIN_1_frameData = NULL;  /* Pointer to frame data. Points to the byte to be sent
             -.*/
1254   1      
1255   1          #if(1u == LIN_1_TL_ENABLED)
              
                      #if(1u == LIN_1_TL_API_FORMAT)
                          l_u8 tmpPci;
                      #endif /* 1u == LIN_1_TL_API_FORMAT */
              
                      static l_u8 LIN_1_mrfBuffer[LIN_1_FRAME_BUFF_LEN];
                  #endif /* (1u == LIN_1_TL_ENABLED) */
1263   1      
1264   1          /*******************************************************************************
1265   1          * Parity lookup table.  Given a six bit identifier as an index, the indexed
1266   1          * value will provide the correct value with the parity bit set.
1267   1          *******************************************************************************/
1268   1          static const l_u8 CYCODE LIN_1_parityTable[] =
1269   1          {
1270   1              0x80u, 0xC1u, 0x42u, 0x03u, 0xC4u, 0x85u, 0x06u, 0x47u, 0x08u, 0x49u, 0xCAu,
1271   1              0x8Bu, 0x4Cu, 0x0Du, 0x8Eu, 0xCFu, 0x50u, 0x11u, 0x92u, 0xD3u, 0x14u, 0x55u,
1272   1              0xD6u, 0x97u, 0xD8u, 0x99u, 0x1Au, 0x5Bu, 0x9Cu, 0xDDu, 0x5Eu, 0x1Fu, 0x20u,
1273   1              0x61u, 0xE2u, 0xA3u, 0x64u, 0x25u, 0xA6u, 0xE7u, 0xA8u, 0xE9u, 0x6Au, 0x2Bu,
1274   1              0xECu, 0xADu, 0x2Eu, 0x6Fu, 0xF0u, 0xB1u, 0x32u, 0x73u, 0xB4u, 0xF5u, 0x76u,
1275   1              0x37u, 0x78u, 0x39u, 0xBAu, 0xFBu, 0x3Cu, 0x7Du, 0xFEu, 0xBFu
1276   1          };
1277   1      
1278   1          /* PID information table */
1279   1          static LIN_1_PID_INFO_TABLE const CYCODE LIN_1_pidInfoTable[LIN_1_NUM_FRAMES] =
1280   1      {
1281   1          {(LIN_1_FRAME_DIR_PUBLISH | LIN_1_FRAME_DATA_SIZE_1 | LIN_1_FRAME_TYPE_UNCOND),
1282   1           LIN_1_Buffer_Frame1}, 
1283   1      
1284   1          {(LIN_1_FRAME_DIR_SUBSCRIBE | LIN_1_FRAME_DATA_SIZE_1 | LIN_1_FRAME_TYPE_UNCOND),
1285   1           LIN_1_Buffer_seesaw_motor}
1286   1      };
1287   1      
1288   1      
1289   1          /* Check for correctness data for UART */
1290   1          if(0u == (LIN_1_FSM_UART_ENABLE_FLAG & LIN_1_fsmFlags))
1291   1          {
1292   2              /* Reset UART state machine */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 22  

1293   2              LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
1294   2          }
1295   1      
1296   1          /* Check for UART framing error */
1297   1          if(0u != (LIN_1_UART_ReadRxStatus() & LIN_1_UART_RX_STS_STOP_ERROR))
1298   1          {
1299   2              #if(1u == LIN_1_SAE_J2602)
              
                          /* Set framing error bits */
                          LIN_1_j2602Status |= LIN_1_J2602_STS_FRAMING_ERR;
              
                      #endif /* (1u == LIN_1_SAE_J2602) */
1305   2      
1306   2              /* Set framing error  */
1307   2              LIN_1_fsmFlags |= LIN_1_FSM_FRAMING_ERROR_FLAG;
1308   2      
1309   2              
1310   2          /* Save current global interrupt enable and disable it */
1311   2          interruptState = CyEnterCriticalSection();
1312   2      
1313   2              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
1314   2                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
1315   2      
1316   2          /* Restore global interrupt enable state */
1317   2          CyExitCriticalSection(interruptState);
1318   2      
1319   2      
1320   2              /* Finish frame processing */
1321   2              LIN_1_EndFrame(LIN_1_HANDLING_DONT_SAVE_PID);
1322   2          }
1323   1      
1324   1          switch(LIN_1_uartFsmState)
1325   1          {
1326   2      
1327   2              /***********************************************************************
1328   2              *                       Sync Field Byte Receive
1329   2              * State description:
1330   2              *  - Available if Automatic Baud Rate Synchronization is disabled
1331   2              *  - Receives sync byte and verifies its correctness
1332   2              *  - Next state is PID Field Byte Receive (state 1)
1333   2              ***********************************************************************/
1334   2              #if(0u == LIN_1_AUTO_BAUD_RATE_SYNC)
              
                          case LIN_1_UART_ISR_STATE_0_SNC:
              
                              /* Handle Sync field correctness */
                              if(LIN_1_FRAME_SYNC_BYTE != LIN_1_UART_ReadRxData())
                              {
                                  /* Set response error */
                                  LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
              
                                  #if(1u == LIN_1_SAE_J2602)
              
                                      /* Set data error bit */
                                      LIN_1_j2602Status |= LIN_1_J2602_STS_DATA_ERR;
              
                                  #endif /* (1u == LIN_1_SAE_J2602) */
              
                                  
                  /* Save current global interrupt enable and disable it */
                  interruptState = CyEnterCriticalSection();
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 23  

                      LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
                                          LIN_1_Response_Error_Frame1_SIG_MASK_0;
              
                  /* Restore global interrupt enable state */
                  CyExitCriticalSection(interruptState);
              
              
                                  /* Reset UART State Machine */
                                  LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                              }
                              else
                              {
                                  /* Next step is reception of the frame PID field */
                                  LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_1_PID;
                              }
                          break;
              
                      #endif  /* (0u == LIN_1_AUTO_BAUD_RATE_SYNC) */
1373   2      
1374   2      
1375   2              /***********************************************************************
1376   2              *                       PID Field Byte Receive
1377   2              * State description:
1378   2              *  - Receives protected identifier (PID)
1379   2              *  - Checks PID parity
1380   2              *  - Set flags
1381   2              *  - Determine next state (RX or TX)
1382   2              ***********************************************************************/
1383   2              case LIN_1_UART_ISR_STATE_1_PID:
1384   2      
1385   2                  /* Save PID */
1386   2                  LIN_1_framePid = LIN_1_UART_ReadRxData();
1387   2      
1388   2                  /* Reset number of transferred bytes */
1389   2                  LIN_1_bytesTransferred = 0u;
1390   2      
1391   2                  /* Verify PID parity */
1392   2                  if(LIN_1_parityTable[LIN_1_framePid & LIN_1_PID_PARITY_MASK] !=
1393   2                      LIN_1_framePid)
1394   2                  {
1395   3                      /* Set response error */
1396   3                      LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
1397   3      
1398   3                      #if(1u == LIN_1_SAE_J2602)
              
                                  /* Set ERR2, ERR1 and ERR0 bits */
                                  LIN_1_j2602Status |= LIN_1_J2602_STS_PARITY_ERR;
              
                              #endif /* (1u == LIN_1_SAE_J2602) */
1404   3      
1405   3                      
1406   3          /* Save current global interrupt enable and disable it */
1407   3          interruptState = CyEnterCriticalSection();
1408   3      
1409   3              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
1410   3                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
1411   3      
1412   3          /* Restore global interrupt enable state */
1413   3          CyExitCriticalSection(interruptState);
1414   3      
1415   3      
1416   3                      /* Reset UART State Machine */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 24  

1417   3                      LIN_1_EndFrame(LIN_1_HANDLING_DONT_SAVE_PID);
1418   3                  }
1419   2                  else    /* PID parity is correct */
1420   2                  {
1421   3                      /* Check if MRF or SRF frame */
1422   3                      if((LIN_1_FRAME_PID_MRF == LIN_1_framePid) ||
1423   3                      (LIN_1_FRAME_PID_SRF == LIN_1_framePid))
1424   3                      {
1425   4                          /*  Transport Layer section. MRF and SRF detection */
1426   4                          #if(1u == LIN_1_TL_ENABLED)
              
                                      #if(1u == LIN_1_SAE_J2602)
              
                                          if(LIN_1_FRAME_PID_MRF_J2602 == LIN_1_framePid)
                                          {
                                              /* Process Master Request */
              
                                              /* Nothing need to be done for Transport Layer */
              
                                              /* Set response error */
                                              LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
              
                                              /* Set ERR2, ERR1 and ERR0 bits */
                                              LIN_1_j2602Status |= LIN_1_J2602_STS_PARITY_ERR;
              
                                              
                  /* Save current global interrupt enable and disable it */
                  interruptState = CyEnterCriticalSection();
              
                      LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
                                          LIN_1_Response_Error_Frame1_SIG_MASK_0;
              
                  /* Restore global interrupt enable state */
                  CyExitCriticalSection(interruptState);
              
              
                                              /* Check for framing error */
                                              if(0u == (LIN_1_fsmFlags & LIN_1_FSM_FRAMING_ERROR_FLAG))
                                              {
                                                  /* Save the last processed PID on the bus to the status variable */
                                                  LIN_1_ifcStatus &= ((l_u16) ~LIN_1_IFC_STS_PID_MASK);
                                                  LIN_1_ifcStatus |= ((l_u16) (((l_u16)LIN_1_framePid) << 8u));
                                              }
              
                                              /* Reset UART State Machine */
                                              LIN_1_EndFrame(LIN_1_HANDLING_DONT_SAVE_PID);
                                          }
              
                                      #endif  /* (1u == LIN_1_SAE_J2602) */
              
                                      if(LIN_1_FRAME_PID_MRF == LIN_1_framePid)
                                      {
                                          /* Indicate that slave is required to receive the data */
                                          LIN_1_tlFlags |= LIN_1_TL_RX_DIRECTION;
              
                                          /*******************************************************
                                          *               Cooked & RAW API
                                          *******************************************************/
              
                                          /* If the MRF PID is detected then pass a pointer to a start of a
                                          * Frame Buffer and size of data to RX state to handle data receiving.
                                          */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 25  

              
                                          /* Frame equals 8 bytes */
                                          LIN_1_frameSize = LIN_1_FRAME_DATA_SIZE_8;
              
                                          /* Set frame data pointer to a start of a frame buffer */
                                          LIN_1_frameData = LIN_1_mrfBuffer;
              
                                          /* Switch to the subscribe data state. */
                                          LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_3_RX;
                                      }
              
                                      if(LIN_1_FRAME_PID_SRF == LIN_1_framePid)
                                      {
                                          /* Indicate that slave is required to transmit the data */
                                          LIN_1_tlFlags |= LIN_1_TL_TX_DIRECTION;
              
                                          if(0u != (LIN_1_status & LIN_1_STATUS_SRVC_RSP_RDY))
                                          {
                                              /* Clear Service Response ready status bit */
                                              LIN_1_status &= ((l_u8) ~LIN_1_STATUS_SRVC_RSP_RDY);
              
                                              /* Frame always equal to 8 bytes for TL */
                                              LIN_1_frameSize = LIN_1_FRAME_DATA_SIZE_8;
              
                                              /* Set frame data pointer to a start of a frame buffer */
                                              LIN_1_frameData = LIN_1_srfBuffer;
              
                                              /* Send first byte to the LIN master */
                                              LIN_1_tmpData = *LIN_1_frameData;
                                              LIN_1_frameData++;
                                              LIN_1_UART_WriteTxData(LIN_1_tmpData);
                                              LIN_1_bytesTransferred = 1u;
              
                                              /* Switch to the publish data state. */
                                              LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_2_TX;
                                          }
                                          else
                                          {
                                              #if(1u == LIN_1_TL_API_FORMAT)
              
                                                  /***************************************************
                                                  *                    Cooked API
                                                  ***************************************************/
              
                                                  /* Send one frame of a message if there is a message pending */
                                                  if(LIN_1_txTlStatus == LD_IN_PROGRESS)
                                                  {
                                                      /* This part of code will handle PDU packing for Cooked API */
                                                      /* Check length it shows if the message already sent */
                                                      if(LIN_1_txMessageLength == 0u)
                                                      {
                                                          /* Reset UART State Machine */
                                                          LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                                      }
                                                      /* Process the message sending */
                                                      else
                                                      {
                                                          /* Fill Frame NAD field */
                                                          LIN_1_srfBuffer[0u] = LIN_1_nad;
              
                                                          /* Analyze length to find the type of frame the message should
             - be sent */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 26  

                                                          if(LIN_1_txMessageLength > LIN_1_FRAME_DATA_SIZE_6)
                                                          {
                                                              /* Process the FF Frame */
                                                              if(LIN_1_prevPci == LIN_1_PDU_PCI_TYPE_UNKNOWN)
                                                              {
                                                                  /* Fill Frame PCI field */
                                                                  LIN_1_srfBuffer[1u] = (LIN_1_PDU_PCI_TYPE_FF |
                                                                      (HI8(LIN_1_txMessageLength)));
              
                                                                  /* Fill Frame LEN field */
                                                                  LIN_1_srfBuffer[2u] =
                                                                      LO8(LIN_1_txMessageLength);
              
                                                                  /* Fill Frame Data fields */
                                                                  for(i = 3u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                                                  {
                                                                      LIN_1_srfBuffer[i] =
                                                                          LIN_1_txTlDataPointer[(i +
                                                                              LIN_1_txTlDataCount) - 3u];
                                                                  }
              
                                                                  /* Update the user buffer pointer */
                                                                  LIN_1_txTlDataCount +=
                                                                      LIN_1_FRAME_DATA_SIZE_5;
              
                                                                  /* Save the previous PCI */
                                                                  LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_FF;
              
                                                                  LIN_1_txMessageLength -=
                                                                      LIN_1_FRAME_DATA_SIZE_5;
                                                              }
                                                              /* Process the CF Frame */
                                                              else
                                                              {
                                                                   /* Fill Frame PCI field */
                                                                  LIN_1_srfBuffer[1u] =
                                                                      (LIN_1_PDU_PCI_TYPE_CF |
                                                                          LIN_1_txFrameCounter);
              
                                                                  /* Fill Frame Data fields */
                                                                  for(i = 2u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                                                  {
                                                                      LIN_1_srfBuffer[i] =
                                                                          LIN_1_txTlDataPointer[(i +
                                                                              LIN_1_txTlDataCount) - 2u];
                                                                  }
              
                                                                  /* Update the user buffer pointer */
                                                                  LIN_1_txTlDataCount +=
                                                                          LIN_1_FRAME_DATA_SIZE_6;
              
                                                                  /* Save the previous PCI */
                                                                  LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_CF;
              
                                                                  /* Update length pointer properly */
                                                                  LIN_1_txMessageLength -=
                                                                      LIN_1_FRAME_DATA_SIZE_6;
                                                              }
                                                          }
                                                          /* Process the SF Frame or last CF Frame */
                                                          else
                                                          {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 27  

                                                              /* Check if the Previous frame is unknown which indicates 
             -that current
                                                              * frame is SF, otherwise it is last CF frame. Fill Frame P
             -CI field
                                                              * properly.
                                                              */
                                                              if(LIN_1_PDU_PCI_TYPE_UNKNOWN == LIN_1_prevPci)
                                                              {
                                                                  LIN_1_srfBuffer[1u] = (l_u8)
                                                                      LIN_1_txMessageLength;
              
                                                                  /* Save the previous PCI */
                                                                  LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_SF;
                                                              }
                                                              else
                                                              {
                                                                  LIN_1_srfBuffer[1u] =
                                                                      (LIN_1_PDU_PCI_TYPE_CF |
                                                                          LIN_1_txFrameCounter);
              
                                                                  /* Save the previous PCI */
                                                                  LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_CF;
                                                              }
              
                                                              /* Fill Frame Data fields */
                                                              for(i = 2u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                                              {
                                                                  if(LIN_1_txMessageLength >= ((l_u8) (i - 1u)))
                                                                  {
                                                                      LIN_1_srfBuffer[i] =
                                                                          LIN_1_txTlDataPointer[(i +
                                                                              LIN_1_txTlDataCount) - 2u];
                                                                  }
                                                                  else
                                                                  {
                                                                      /* Fill unused data bytes with FFs */
                                                                      LIN_1_srfBuffer[i] = 0xFFu;
                                                                  }
                                                              }
              
                                                              /* Update the user buffer pointer */
                                                              LIN_1_txTlDataCount +=
                                                                          LIN_1_FRAME_DATA_SIZE_6;
              
                                                              /* Update length pointer properly */
                                                              if(LIN_1_txMessageLength >=
                                                                      LIN_1_FRAME_DATA_SIZE_6)
                                                              {
                                                                  LIN_1_txMessageLength -=
                                                                      LIN_1_FRAME_DATA_SIZE_6;
                                                              }
                                                              else
                                                              {
                                                                  LIN_1_txMessageLength = 0u;
                                                              }
                                                          }
              
                                                          /* Update the frame counter */
                                                          if(LIN_1_txFrameCounter != 15u)
                                                          {
                                                              LIN_1_txFrameCounter++;
                                                          }
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 28  

                                                          else
                                                          {
                                                              /* If frame counter is larger then 15 then reset it */
                                                              LIN_1_txFrameCounter = 0u;
                                                          }
                                                      }
              
                                                      /* Frame equals 8 bytes */
                                                      LIN_1_frameSize = LIN_1_FRAME_DATA_SIZE_8;
              
                                                      /* Set frame data pointer to a start of a frame buffer */
                                                      LIN_1_frameData = LIN_1_srfBuffer;
              
                                                      /* Send first byte to the LIN master */
                                                      LIN_1_tmpData = *LIN_1_frameData;
                                                      LIN_1_frameData++;
                                                      LIN_1_UART_WriteTxData(LIN_1_tmpData);
                                                      LIN_1_bytesTransferred = 1u;
              
                                                      /* Switch to the publish data state. */
                                                      LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_2_TX;
                                                  }
                                                  else
                                                  {
                                                      /* Reset UART State Machine */
                                                      LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                                  }
              
                                              #else
              
                                                  /***************************************************
                                                  *                     Raw API
                                                  ***************************************************/
              
                                                  if(0u != LIN_1_txBufDepth)
                                                  {
                                                      /* Fill the frame buffer from SRF*/
                                                      for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                                      {
                                                          LIN_1_srfBuffer[i] =
                                                              LIN_1_rawTxQueue[LIN_1_txRdIndex];
              
                                                          /* Update the index to TX queue */
                                                          LIN_1_txRdIndex++;
                                                      }
              
                                                      /* Read index should point to the next byte in MRF */
                                                      if(LIN_1_TL_TX_QUEUE_LEN == LIN_1_txRdIndex)
                                                      {
                                                          LIN_1_txRdIndex = 0u;
                                                      }
              
                                                      /* 8 bytes were read from the SRF so decrement the buffer depth */
                                                      LIN_1_txBufDepth--;
              
                                                      /* Update status properly */
                                                      if(0u == LIN_1_txBufDepth)
                                                      {
                                                          LIN_1_txTlStatus = LD_QUEUE_EMPTY;
                                                      }
                                                      else
                                                      {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 29  

                                                          LIN_1_txTlStatus = LD_QUEUE_AVAILABLE;
                                                      }
              
                                                      /* Frame equals 8 bytes */
                                                      LIN_1_frameSize = LIN_1_FRAME_DATA_SIZE_8;
              
                                                      /* Set frame data pointer to a start of a frame buffer */
                                                      LIN_1_frameData = LIN_1_srfBuffer;
              
                                                      /* Send first byte to the LIN master */
                                                      LIN_1_tmpData = *LIN_1_frameData;
                                                      LIN_1_frameData++;
                                                      LIN_1_UART_WriteTxData(LIN_1_tmpData);
                                                      LIN_1_bytesTransferred = 1u;
              
                                                      /* Switch to the publish data state. */
                                                      LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_2_TX;
                                                  }
                                                  else
                                                  {
                                                      /* Reset UART State Machine */
                                                      LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                                  }
              
                                              #endif /* (1u == LIN_1_TL_API_FORMAT) */
                                          }
              
              
                                      }
              
                                  #else
1755   4      
1756   4                              /* These are invalid PIDs when TL is disabled - reset UART state machine */
1757   4      
1758   4                              /* Set response error */
1759   4                              LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
1760   4      
1761   4                              #if(1u == LIN_1_SAE_J2602)
              
                                          /* Set ERR2, ERR1 and ERR0 bits */
                                          LIN_1_j2602Status |= LIN_1_J2602_STS_PARITY_ERR;
              
                                      #endif /* (1u == LIN_1_SAE_J2602) */
1767   4      
1768   4                              
1769   4          /* Save current global interrupt enable and disable it */
1770   4          interruptState = CyEnterCriticalSection();
1771   4      
1772   4              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
1773   4                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
1774   4      
1775   4          /* Restore global interrupt enable state */
1776   4          CyExitCriticalSection(interruptState);
1777   4      
1778   4      
1779   4                              /* Reset UART State Machine */
1780   4                              LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
1781   4      
1782   4                          #endif /* (1u == LIN_1_TL_ENABLED) */
1783   4                      }
1784   3                      else    /* Not MRF and SRF */
1785   3                      {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 30  

1786   4                          /* Get PID index in LIN_1_pidInfoTable */
1787   4                          LIN_1_pidIndex = LIN_1_FindPidIndex(LIN_1_framePid);
1788   4      
1789   4                          if(LIN_1_INVALID_FRAME_PID != LIN_1_pidIndex)
1790   4                          {
1791   5                              /* Valid ID */
1792   5      
1793   5                              /* Start enhanced checksum calculation  */
1794   5                              LIN_1_interimChecksum = LIN_1_framePid;
1795   5      
1796   5                              /* Get size of frame */
1797   5                              LIN_1_frameSize = LIN_1_pidInfoTable[LIN_1_pidIndex].param &
1798   5                                                              LIN_1_FRAME_DATA_SIZE_MASK;
1799   5      
1800   5                              /* TX response (publish action) was requested by Master */
1801   5                              if(0u != (LIN_1_FRAME_DIR_PUBLISH &
1802   5                                       LIN_1_pidInfoTable[LIN_1_pidIndex].param))
1803   5                              {
1804   6                                  /* SAE J2602 is disabled */
1805   6                                  #if(0u == LIN_1_SAE_J2602)
1806   6      
1807   6                                      /* This frame is event-triggered */
1808   6                                      if(0u  != (LIN_1_FRAME_TYPE_EVENT &
1809   6                                                 LIN_1_pidInfoTable[LIN_1_pidIndex].param))
1810   6                                      {
1811   7                                          /* Check do we need to process event-triggered frame */
1812   7                                          if(0u == LIN_1_GetEtFlagValue(LIN_1_pidIndex))
1813   7                                          {
1814   8                                              /* Reset UART State Machine */
1815   8                                              LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
1816   8                                          }
1817   7                                      }
1818   6      
1819   6                                  #endif /* (0u == LIN_1_SAE_J2602) */
1820   6      
1821   6                                  /* Get pointer to the frame data */
1822   6                                  LIN_1_frameData =
1823   6                                      LIN_1_pidInfoTable[LIN_1_pidIndex].dataPtr;
1824   6      
1825   6                                  /* Send first byte to the LIN master */
1826   6                                  LIN_1_tmpData = *LIN_1_frameData;
1827   6                                  LIN_1_frameData++;
1828   6                                  LIN_1_UART_WriteTxData(LIN_1_tmpData);
1829   6                                  LIN_1_bytesTransferred = 1u;
1830   6      
1831   6                                  /* Switch to the publish data state. */
1832   6                                  LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_2_TX;
1833   6      
1834   6                              }
1835   5                              else    /* RX response (subscribe action) was requested by Master */
1836   5                              {
1837   6                                  /* Get pointer to the temp RX frame data buffer */
1838   6                                  LIN_1_frameData = LIN_1_tmpRxFrameData;
1839   6      
1840   6                                  /* Switch to the subscribe data state. */
1841   6                                  LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_3_RX;
1842   6                              }
1843   5                          }
1844   4                          else    /* Invalid ID */
1845   4                          {
1846   5                              /* Set response error */
1847   5                              LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 31  

1848   5      
1849   5                              #if(1u == LIN_1_SAE_J2602)
              
                                          /* Set data error bit */
                                          LIN_1_j2602Status |= LIN_1_J2602_STS_DATA_ERR;
              
                                      #endif /* (1u == LIN_1_SAE_J2602) */
1855   5      
1856   5                              
1857   5          /* Save current global interrupt enable and disable it */
1858   5          interruptState = CyEnterCriticalSection();
1859   5      
1860   5              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
1861   5                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
1862   5      
1863   5          /* Restore global interrupt enable state */
1864   5          CyExitCriticalSection(interruptState);
1865   5      
1866   5      
1867   5                              /* Reset UART State Machine */
1868   5                              LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
1869   5                          }
1870   4                      }
1871   3                  }
1872   2      
1873   2              break;
1874   2      
1875   2      
1876   2              /***********************************************************************
1877   2              *                       TX response (Publish)
1878   2              * State description:
1879   2              *  - Transmits data to LIN Master
1880   2              *  - Transmits next data byte if there were no any errors
1881   2              *  - Transmits checksum when data was send correctly
1882   2              ***********************************************************************/
1883   2              case LIN_1_UART_ISR_STATE_2_TX:
1884   2      
1885   2                  /* Set the response active flag */
1886   2                  LIN_1_status |= LIN_1_STATUS_RESPONSE_ACTIVE;
1887   2      
1888   2                  /* Previously transmitted and read back bytes are not equal */
1889   2                  if(LIN_1_tmpData != LIN_1_UART_ReadRxData())
1890   2                  {
1891   3                      /* Mismatch Error */
1892   3      
1893   3                      #if(1u == LIN_1_SAE_J2602)
              
                                  /* Set ERR2 bit */
                                  LIN_1_j2602Status |= LIN_1_J2602_STS_DATA_ERR;
              
                                  /* Readback error - set response error flag */
                                  LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
              
                              #else
1902   3      
1903   3                          /* Skip event-triggered frame */
1904   3                          if(0u  == (LIN_1_FRAME_TYPE_EVENT &
1905   3                                     LIN_1_pidInfoTable[LIN_1_pidIndex].param))
1906   3                          {
1907   4                              /* Readback error - set response error flag */
1908   4                              LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
1909   4                          }
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 32  

1910   3      
1911   3                      #endif  /* (1u == LIN_1_SAE_J2602) */
1912   3      
1913   3                      
1914   3          /* Save current global interrupt enable and disable it */
1915   3          interruptState = CyEnterCriticalSection();
1916   3      
1917   3              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
1918   3                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
1919   3      
1920   3          /* Restore global interrupt enable state */
1921   3          CyExitCriticalSection(interruptState);
1922   3      
1923   3      
1924   3                      /* Check for framing error */
1925   3                      if(0u == (LIN_1_fsmFlags & LIN_1_FSM_FRAMING_ERROR_FLAG))
1926   3                      {
1927   4                          /* Save the last processed PID on the bus to the status variable */
1928   4                          LIN_1_ifcStatus &= ((l_u16) ~LIN_1_IFC_STS_PID_MASK);
1929   4                          LIN_1_ifcStatus |= ((l_u16) (((l_u16)LIN_1_framePid) << 8u));
1930   4                      }
1931   3      
1932   3                      /* End frame with response error */
1933   3                      LIN_1_EndFrame(LIN_1_HANDLING_DONT_SAVE_PID);
1934   3                  }
1935   2                  else    /* If readback was successful than continue transmitting */
1936   2                  {
1937   3                      /* Add transmitted byte to the interim checksum */
1938   3                      LIN_1_interimChecksum += LIN_1_tmpData;
1939   3                      if(LIN_1_interimChecksum >= 256u)
1940   3                      {
1941   4                          LIN_1_interimChecksum -= 255u;
1942   4                      }
1943   3      
1944   3                      /* Check to see if all data bytes were sent */
1945   3                      if(LIN_1_frameSize > LIN_1_bytesTransferred)
1946   3                      {
1947   4                          /* Send out the next byte of the buffer */
1948   4                          LIN_1_tmpData = *LIN_1_frameData;
1949   4                          LIN_1_frameData++;
1950   4                          LIN_1_UART_WriteTxData(LIN_1_tmpData);
1951   4                          LIN_1_bytesTransferred++;
1952   4                      }
1953   3                      else    /* All data bytes were sent - compute and transmit checksum */
1954   3                      {
1955   4                          /* Compute and send out the checksum byte */
1956   4                          LIN_1_UART_WriteTxData((((l_u8) LIN_1_interimChecksum) ^ 0xFFu));
1957   4      
1958   4                          LIN_1_bytesTransferred = 0u;
1959   4      
1960   4                          /* Switch to the checksum state */
1961   4                          LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_4_CHS;
1962   4                      }
1963   3                  }
1964   2              break;
1965   2      
1966   2      
1967   2              /***********************************************************************
1968   2              *                       RX response (Subscribe)
1969   2              * State description:
1970   2              *  - Receives data from LIN Master
1971   2              *  - Received data are saved to the temporary buffer
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 33  

1972   2              ***********************************************************************/
1973   2              case LIN_1_UART_ISR_STATE_3_RX:
1974   2      
1975   2                  /* Save received byte */
1976   2                  LIN_1_tmpData = LIN_1_UART_ReadRxData();
1977   2                  *LIN_1_frameData = LIN_1_tmpData;
1978   2                  LIN_1_frameData++;
1979   2                  LIN_1_bytesTransferred++;
1980   2      
1981   2                  /* Set response active flag */
1982   2                  LIN_1_status |= LIN_1_STATUS_RESPONSE_ACTIVE;
1983   2      
1984   2                  /* One or more data bytes have been received */
1985   2                  LIN_1_fsmFlags |= LIN_1_FSM_DATA_RECEIVE;
1986   2      
1987   2                  /* Add received byte to the interim checksum */
1988   2                  LIN_1_interimChecksum += LIN_1_tmpData;
1989   2                  if(LIN_1_interimChecksum >= 256u)
1990   2                  {
1991   3                      LIN_1_interimChecksum -= 255u;
1992   3                  }
1993   2      
1994   2                  /* Check to see if the data section has not finished */
1995   2                  if(LIN_1_frameSize > LIN_1_bytesTransferred)
1996   2                  {
1997   3                      /* There is data to be sent */
1998   3                  }
1999   2                  else
2000   2                  {
2001   3                      /* There is no data to be sent */
2002   3      
2003   3                      LIN_1_bytesTransferred = 0u;
2004   3      
2005   3                      /* Switch to the checksum state */
2006   3                      LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_4_CHS;
2007   3                  }
2008   2      
2009   2              break;
2010   2      
2011   2      
2012   2      
2013   2              /***********************************************************************
2014   2              *                              Checksum
2015   2              ***********************************************************************/
2016   2              case LIN_1_UART_ISR_STATE_4_CHS:
2017   2      
2018   2                  /* Previously transmitted and read back bytes are not equal */
2019   2                  if((((l_u8) LIN_1_interimChecksum) ^ 0xFFu) != LIN_1_UART_ReadRxData())
2020   2                  {
2021   3                      /* Mismatch or Ckechsum Error */
2022   3      
2023   3                      /* Set response error */
2024   3                      LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
2025   3      
2026   3                      #if(1u == LIN_1_SAE_J2602)
              
                                  /* Set ERR2 and ERR0 bits */
                                  LIN_1_j2602Status |= LIN_1_J2602_STS_CHECKSUM_ERR;
              
                              #endif /* (1u == LIN_1_SAE_J2602) */
2032   3      
2033   3                      
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 34  

2034   3          /* Save current global interrupt enable and disable it */
2035   3          interruptState = CyEnterCriticalSection();
2036   3      
2037   3              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
2038   3                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
2039   3      
2040   3          /* Restore global interrupt enable state */
2041   3          CyExitCriticalSection(interruptState);
2042   3      
2043   3      
2044   3                      /* Check for framing error */
2045   3                      if(0u == (LIN_1_fsmFlags & LIN_1_FSM_FRAMING_ERROR_FLAG))
2046   3                      {
2047   4                          /* Save the last processed PID on the bus to the status variable */
2048   4                          LIN_1_ifcStatus &= ((l_u16) ~LIN_1_IFC_STS_PID_MASK);
2049   4                          LIN_1_ifcStatus |= ((l_u16) (((l_u16)LIN_1_framePid) << 8u));
2050   4                      }
2051   3      
2052   3                      /* Reset UART state machine with checksum or mismatch error */
2053   3                      LIN_1_EndFrame(LIN_1_HANDLING_DONT_SAVE_PID);
2054   3                  }
2055   2                  else
2056   2                  {
2057   3                      /*  Clear all error bits in interface status */
2058   3                      #if(1u == LIN_1_SAE_J2602)
              
                                  LIN_1_j2602Status &= LIN_1_J2602_CLEAR_ERR_BITS_MASK;
              
                              #endif  /* (1u == LIN_1_SAE_J2602) */
2063   3      
2064   3      
2065   3                      /* Clear framing error and data receive flags */
2066   3                      LIN_1_fsmFlags &=
2067   3                         ((l_u8) ~(LIN_1_FSM_FRAMING_ERROR_FLAG | LIN_1_FSM_DATA_RECEIVE));
2068   3      
2069   3                      /* Set successful transfer interface flag */
2070   3                      LIN_1_ifcStatus |= LIN_1_IFC_STS_SUCCESSFUL_TRANSFER;
2071   3      
2072   3                      /* Save the last processed PID on the bus to the status variable */
2073   3                      LIN_1_ifcStatus &= ((l_u16) ~LIN_1_IFC_STS_PID_MASK);
2074   3                      LIN_1_ifcStatus |= ((l_u16) (((l_u16)LIN_1_framePid) << 8u));
2075   3      
2076   3                      /* Set overrun interface flag */
2077   3                      if(0u != (LIN_1_FSM_OVERRUN & LIN_1_fsmFlags))
2078   3                      {
2079   4                          LIN_1_ifcStatus |= LIN_1_IFC_STS_OVERRUN;
2080   4                      }
2081   3      
2082   3                      /* Set Overrun flag */
2083   3                      LIN_1_fsmFlags |= LIN_1_FSM_OVERRUN;
2084   3      
2085   3                      /* Clear response error signal if frame contains RESPONSE ERROR signal */
2086   3                      #if(1u == LIN_1_RESPONSE_ERROR_SIGNAL)
2087   3      
2088   3                          if(LIN_1_RESPONSE_ERROR_FRAME_INDEX == LIN_1_pidIndex)
2089   3                          {
2090   4                              
2091   4          /* Save current global interrupt enable and disable it */
2092   4          interruptState = CyEnterCriticalSection();
2093   4      
2094   4              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] &= 
2095   4                                  (l_u8) ~LIN_1_Response_Error_Frame1_SIG_MASK_0;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 35  

2096   4      
2097   4          /* Restore global interrupt enable state */
2098   4          CyExitCriticalSection(interruptState);
2099   4      
2100   4                          }
2101   3      
2102   3                      #endif /* (1u == LIN_1_RESPONSE_ERROR_SIGNAL) */
2103   3      
2104   3      
2105   3                      #if(1u == LIN_1_TL_ENABLED)
              
                                  if(!((LIN_1_FRAME_PID_MRF == LIN_1_framePid) ||
                                       (LIN_1_FRAME_PID_SRF == LIN_1_framePid)))
                                  {
                                      /* SAE J2602 is disabled */
                                      #if(0u == LIN_1_SAE_J2602)
              
                                          /* This frame is event-triggered */
                                          if(0u  != (LIN_1_FRAME_TYPE_EVENT &
                                                     LIN_1_pidInfoTable[LIN_1_pidIndex].param))
                                          {
                                              /* Clear event-triggered flags */
                                              LIN_1_ClearEtFlagValue(LIN_1_pidIndex);
              
                                              /* Reset UART State Machine */
                                             LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                          }
              
                                      #endif /* (0u == LIN_1_SAE_J2602) */
              
                                      /* Set associated with current frame flags */
                                      LIN_1_SetAssociatedFlags(LIN_1_pidIndex);
                                  }
              
                              #else
2131   3      
2132   3                          /* SAE J2602 is disabled */
2133   3                          #if(0u == LIN_1_SAE_J2602)
2134   3      
2135   3                              /* This frame is event-triggered */
2136   3                              if(0u  != (LIN_1_FRAME_TYPE_EVENT &
2137   3                                         LIN_1_pidInfoTable[LIN_1_pidIndex].param))
2138   3                              {
2139   4                                  /* Clear event-triggered flags */
2140   4                                  LIN_1_ClearEtFlagValue(LIN_1_pidIndex);
2141   4      
2142   4                                  /* Reset UART State Machine */
2143   4                                 LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
2144   4                              }
2145   3      
2146   3                          #endif /* (0u == LIN_1_SAE_J2602) */
2147   3      
2148   3                          /* Set associated with current frame flags */
2149   3                          LIN_1_SetAssociatedFlags(LIN_1_pidIndex);
2150   3      
2151   3                      #endif  /* (1u == LIN_1_TL_ENABLED) */
2152   3      
2153   3                      #if(1u == LIN_1_TL_ENABLED)
              
                                  /* Check to see if received data was a "master request frame" */
                                  if(LIN_1_FRAME_PID_MRF == LIN_1_framePid)
                                  {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 36  

                                      /* Process master request frame data here */
                                      LIN_1_ProcessMrf(LIN_1_mrfBuffer);
              
                                      #if(1u == LIN_1_TL_API_FORMAT)
              
                                          /* Store previous PCI to avoid MISRA warning */
                                          tmpPci = LIN_1_prevPci;
              
                                          if((LIN_1_PDU_PCI_TYPE_FF == tmpPci) ||
                                              (LIN_1_PDU_PCI_TYPE_CF == tmpPci))
                                          {
                                              LIN_1_tlFlags |= LIN_1_TL_N_CR_TIMEOUT_ON;
                                              LIN_1_tlTimeoutCnt = 0u;
                                          }
              
                                          if((0u == LIN_1_rxMessageLength) &&
                                              ( 0u != (LIN_1_tlFlags & LIN_1_TL_RX_REQUESTED)))
                                          {
                                              /* Indicate that message is received */
                                              LIN_1_rxTlStatus = LD_COMPLETED;
              
                                              /* Reset the frame counter */
                                              LIN_1_rxFrameCounter = 0u;
              
                                              /* Previous PCI is required to be unknown at the beginning of a new messag
             -e */
                                              LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_UNKNOWN;
              
                                              /* Clear TX requested flag as the message was transferred */
                                              LIN_1_tlFlags &= ((l_u8) ~LIN_1_TL_RX_REQUESTED);
              
                                              LIN_1_tlFlags &= ((l_u8) ~LIN_1_TL_N_CR_TIMEOUT_ON);
                                          }
              
                                      #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
                                      /* Clear the TL RX direction flag */
                                      LIN_1_tlFlags &= ((l_u8) ~LIN_1_TL_RX_DIRECTION);
              
                                      /* Reset UART state machine */
                                      LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                  }
                                  else if(LIN_1_FRAME_PID_SRF == LIN_1_framePid)
                                  {
                                      #if(1u == LIN_1_TL_API_FORMAT)
              
                                          /* Store previous PCI to avoid MISRA warning */
                                          tmpPci = LIN_1_prevPci;
              
                                          if((LIN_1_PDU_PCI_TYPE_FF == tmpPci) ||
                                              (LIN_1_PDU_PCI_TYPE_CF == tmpPci))
                                          {
                                              LIN_1_tlFlags |= LIN_1_TL_N_AS_TIMEOUT_ON;
                                              LIN_1_tlTimeoutCnt = 0u;
                                          }
              
                                          if((0u == LIN_1_txMessageLength) &&
                                              ( 0u != (LIN_1_tlFlags & LIN_1_TL_TX_REQUESTED)))
                                          {
                                              /* Indicate that message is sent */
                                              LIN_1_txTlStatus = LD_COMPLETED;
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 37  

                                              /* Reset the frame counter */
                                              LIN_1_txFrameCounter = 0u;
              
                                              /* Previous PCI is required to be unknown at the beginning of a new messag
             -e */
                                              LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_UNKNOWN;
              
                                              /* Clear TX requested flag as the message was transferred */
                                              LIN_1_tlFlags &= (l_u8) ~LIN_1_TL_TX_REQUESTED;
              
                                              LIN_1_tlFlags &= (l_u8) ~LIN_1_TL_N_AS_TIMEOUT_ON;
                                          }
              
                                      #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
                                      /* Clear the TL TX direction flag */
                                      LIN_1_tlFlags &= ((l_u8) ~LIN_1_TL_TX_DIRECTION);
              
                                      /* Reset UART state machine */
                                      LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                  }
                                  else
                                  {
                                      /* RX response (subscribe action) was requested by Master */
                                      if(0u == (LIN_1_FRAME_DIR_PUBLISH &
                                               LIN_1_pidInfoTable[LIN_1_pidIndex].param))
                                      {
                                          interruptState = CyEnterCriticalSection();
              
                                          /* Copy received data from tempororary buffer to the frame one */
                                          for(i = 0u; i < LIN_1_frameSize; i++)
                                          {
                                              *(LIN_1_pidInfoTable[LIN_1_pidIndex].dataPtr + i) =
                                                  LIN_1_tmpRxFrameData[i];
                                          }
              
                                          CyExitCriticalSection(interruptState);
                                      }
              
                                      /* Reset UART state machine */
                                      LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
                                  }
              
                              #else
2262   3      
2263   3                          /* RX response (subscribe action) was requested by Master */
2264   3                          if(0u == (LIN_1_FRAME_DIR_PUBLISH &
2265   3                                   LIN_1_pidInfoTable[LIN_1_pidIndex].param))
2266   3                          {
2267   4                              interruptState = CyEnterCriticalSection();
2268   4      
2269   4                              /* Copy received data from tempororary buffer to the frame one */
2270   4                              for(i = 0u; i < LIN_1_frameSize; i++)
2271   4                              {
2272   5                                  *(LIN_1_pidInfoTable[LIN_1_pidIndex].dataPtr + i) =
2273   5                                      LIN_1_tmpRxFrameData[i];
2274   5                              }
2275   4      
2276   4                              CyExitCriticalSection(interruptState);
2277   4                          }
2278   3      
2279   3                          /* Reset UART state machine */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 38  

2280   3                          LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
2281   3      
2282   3                      #endif  /* (1u == LIN_1_TL_ENABLED) */
2283   3      
2284   3                  }
2285   2      
2286   2                  LIN_1_interimChecksum = 0u;
2287   2      
2288   2              break;
2289   2      
2290   2      
2291   2              default:
2292   2                  /* Reset UART state machine */
2293   2                  LIN_1_EndFrame(LIN_1_HANDLING_RESET_FSM_ERR);
2294   2              break;
2295   2          }
2296   1      
2297   1      
2298   1          /***************************************************************************
2299   1          *  Place your UART ISR code here
2300   1          ***************************************************************************/
2301   1          /* `#START LIN_1_UART_ISR_CODE` */
2302   1      
2303   1          /* `#END` */
2304   1      }
2305          
2306          
2307          /*******************************************************************************
2308          * Function Name: l_ifc_rx
2309          ********************************************************************************
2310          *
2311          * Summary:
2312          *  The LIN Slave component takes care of calling this API routine automatically.
2313          *  Therefore, this API routine must not be called by the application code.
2314          *
2315          * Parameters:
2316          *  iii - is the name of the interface handle.
2317          *
2318          * Return:
2319          *  None
2320          *
2321          * Reentrant:
2322          *  No
2323          *
2324          *******************************************************************************/
2325          void l_ifc_rx(l_ifc_handle iii) 
2326          {
2327   1          switch(iii)
2328   1          {
2329   2              case LIN_1_IFC_HANDLE:
2330   2                  l_ifc_rx_LIN_1();
2331   2              break;
2332   2      
2333   2              default:
2334   2              break;
2335   2          }
2336   1      }
2337          
2338          
2339          /*******************************************************************************
2340          * Function Name: l_ifc_rx
2341          ********************************************************************************
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 39  

2342          *
2343          * Summary:
2344          *  The LIN Slave component takes care of calling this API routine automatically.
2345          *  Therefore, this API routine must not be called by the application code.
2346          *
2347          * Parameters:
2348          *  None
2349          *
2350          * Return:
2351          *  None
2352          *
2353          * Reentrant:
2354          *  No
2355          *
2356          *******************************************************************************/
2357          void l_ifc_tx_LIN_1(void) 
2358          {
2359   1          l_ifc_rx_LIN_1();
2360   1      }
2361          
2362          
2363          /*******************************************************************************
2364          * Function Name: l_ifc_tx
2365          ********************************************************************************
2366          *
2367          * Summary:
2368          *  The LIN Slave component takes care of calling this API routine automatically.
2369          *  Therefore, this API routine must not be called by the application code.
2370          *
2371          * Parameters:
2372          *  iii - is the name of the interface handle.
2373          *
2374          * Return:
2375          *  None
2376          *
2377          * Reentrant:
2378          *  No
2379          *
2380          *******************************************************************************/
2381          void l_ifc_tx(l_ifc_handle iii) 
2382          {
2383   1          switch(iii)
2384   1          {
2385   2              case LIN_1_IFC_HANDLE:
2386   2                  l_ifc_tx_LIN_1();
2387   2              break;
2388   2      
2389   2              default:
2390   2              break;
2391   2          }
2392   1      }
2393          
2394          
2395          /*******************************************************************************
2396          * Function Name: l_ifc_aux
2397          ********************************************************************************
2398          *
2399          * Summary:
2400          *  The LIN Slave component takes care of calling this API routine automatically.
2401          *  Therefore, this API routine must not be called by the application code.
2402          *
2403          * Parameters:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 40  

2404          *  None
2405          *
2406          * Return:
2407          *  None
2408          *
2409          * Reentrant:
2410          *  No
2411          *
2412          *******************************************************************************/
2413          void l_ifc_aux_LIN_1(void) 
2414          {
2415   1          l_u8 interruptState;
2416   1      
2417   1          /* Update shadow status register with the hardware status */
2418   1          LIN_1_auxStatus |= LIN_1_STATUS_REG;
2419   1      
2420   1          /***************************************************************************
2421   1          *                             Edge Detected                                *
2422   1          ***************************************************************************/
2423   1          if(0u != (LIN_1_auxStatus & LIN_1_STATUS_EDGE_DETECTED))
2424   1          {
2425   2              /* Set bus activity interface status bit */
2426   2              LIN_1_ifcStatus |= LIN_1_IFC_STS_BUS_ACTIVITY;
2427   2      
2428   2              #if(1u == LIN_1_INACTIVITY_ENABLED)
2429   2      
2430   2                  /* Clear period timer counter */
2431   2                  LIN_1_periodCounter = 0x00u;
2432   2      
2433   2              #endif /* (1u == LIN_1_INACTIVITY_ENABLED) */
2434   2          }
2435   1      
2436   1      
2437   1          /***************************************************************************
2438   1          *                       Bus Inactivity Interrupt Detected
2439   1          ***************************************************************************/
2440   1          #if(1u == LIN_1_INACTIVITY_ENABLED)
2441   1      
2442   1              if(0u != (LIN_1_auxStatus & LIN_1_STATUS_INACTIVITY_INT))
2443   1              {
2444   2                  #if(1u == LIN_1_TL_ENABLED)              /* TL enabled */
                              #if(1u == LIN_1_TL_API_FORMAT)       /* Cooked API */
              
                                  /* if the timeout is enabled then proceed timeout manage */
                                  if(0u !=(LIN_1_tlFlags & LIN_1_TL_N_AS_TIMEOUT_ON))
                                  {
                                      /* Increment timeout */
                                      LIN_1_tlTimeoutCnt++;
              
                                      if(LIN_1_TL_N_AS_TIMEOUT_VALUE <= LIN_1_tlTimeoutCnt)
                                      {
                                          /* Set error status as the timeout occurred */
                                          LIN_1_txTlStatus = LD_N_AS_TIMEOUT;
                                      }
                                  }
                                  else if(0u !=(LIN_1_tlFlags & LIN_1_TL_N_CR_TIMEOUT_ON))
                                  {
                                      /* Increment timeout */
                                      LIN_1_tlTimeoutCnt++;
              
                                      if(LIN_1_TL_N_CR_TIMEOUT_VALUE <= LIN_1_tlTimeoutCnt)
                                      {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 41  

                                          /* Set error status as the timeout occurred */
                                          LIN_1_rxTlStatus = LD_N_CR_TIMEOUT;
                                      }
                                  }
                                  else
                                  {
                                      /* Reset timeout counter */
                                      LIN_1_tlTimeoutCnt = 0u;
                                  }
              
                              #endif /* (1u == LIN_1_TL_API_FORMAT) */
                          #endif /* (1u == LIN_1_TL_ENABLED) */
2478   2      
2479   2                  if(LIN_1_INACTIVITY_THRESHOLD_IN_100_MS == LIN_1_periodCounter)
2480   2                  {
2481   3                      /* Inactivity threshold achieved */
2482   3      
2483   3                      /* Set bus inactivity ioctl status bit */
2484   3                      LIN_1_ioctlStatus |= LIN_1_IOCTL_STS_BUS_INACTIVITY;
2485   3                  }
2486   2                  else
2487   2                  {
2488   3                      LIN_1_periodCounter++;
2489   3                  }
2490   2              }
2491   1      
2492   1          #endif  /* (1u == LIN_1_INACTIVITY_ENABLED) */
2493   1      
2494   1      
2495   1          /***************************************************************************
2496   1          *                       Break Field Detected
2497   1          ***************************************************************************/
2498   1          if(0u != (LIN_1_auxStatus & LIN_1_STATUS_BREAK_DETECTED))
2499   1          {
2500   2              /* Framing error or data transfer was aborted */
2501   2              if(0u  != ((LIN_1_FSM_FRAMING_ERROR_FLAG | LIN_1_FSM_DATA_RECEIVE) &
2502   2                          LIN_1_fsmFlags))
2503   2              {
2504   3                  /* Set response error */
2505   3                  LIN_1_ifcStatus |= LIN_1_IFC_STS_ERROR_IN_RESPONSE;
2506   3      
2507   3                  /* Clear framing error */
2508   3                  LIN_1_fsmFlags &= ((l_u8) ~LIN_1_FSM_FRAMING_ERROR_FLAG);
2509   3      
2510   3                  #if(1u == LIN_1_SAE_J2602)
              
                              /* Set ERR2 bit */
                              LIN_1_j2602Status |= LIN_1_J2602_STS_DATA_ERR;
              
                          #endif  /* (1u == LIN_1_SAE_J2602) */
2516   3      
2517   3                  
2518   3          /* Save current global interrupt enable and disable it */
2519   3          interruptState = CyEnterCriticalSection();
2520   3      
2521   3              LIN_1_Buffer_Frame1[LIN_1_Response_Error_Frame1_SIG_BYTE_OFFSET] |= 
2522   3                                  LIN_1_Response_Error_Frame1_SIG_MASK_0;
2523   3      
2524   3          /* Restore global interrupt enable state */
2525   3          CyExitCriticalSection(interruptState);
2526   3      
2527   3      
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 42  

2528   3              }   /* No response error, continue */
2529   2      
2530   2              /* Set break detected flag */
2531   2              LIN_1_fsmFlags |= LIN_1_FSM_BREAK_FLAG;
2532   2      
2533   2              /***********************************************************************
2534   2              *  This will make bus RXD signal to be automatically routed to the
2535   2              *  UART's input when rising edge of the break field occurs (in case
2536   2              *  when Auto Baud Rate Sync is disabled; that will make UART to be
2537   2              *  able to receive sync byte) or when sync field is already processed
2538   2              *  by hardware (in case when Auto Baud Rate Sync is enabled; that will
2539   2              *  make UART to be able to receive frame's PID).
2540   2              ***********************************************************************/
2541   2              LIN_1_CONTROL_REG &= ((l_u8) ~LIN_1_CONTROL_RX_DIS);
2542   2      
2543   2              /* Auto Baud Rate Sync Enabled */
2544   2              #if(1u == LIN_1_AUTO_BAUD_RATE_SYNC)
2545   2      
2546   2                  /* Restore initial clock divider */
2547   2                  LIN_1_IntClk_SetDividerRegister(LIN_1_initialClockDivider, 0u);
2548   2      
2549   2              #else   /* Auto Baud Rate Sync Disabled */
              
                          /* Clear one or more data bytes have been received internal flag */
                          LIN_1_fsmFlags &= ((l_u8) ~LIN_1_FSM_DATA_RECEIVE);
              
                          /* Set UART ISR FSM to sync byte receive state */
                          LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_0_SNC;
              
                          /* Set UART enable flag */
                          LIN_1_fsmFlags |= LIN_1_FSM_UART_ENABLE_FLAG;
              
                          /* Clear any pending UART interrupt */
                          CyIntClearPending(LIN_1_UART_ISR_NUMBER);
              
                          /* Enable UART ISR interrupt */
                          CyIntEnable(LIN_1_UART_ISR_NUMBER);
              
                      #endif  /* (1u == LIN_1_AUTO_BAUD_RATE_SYNC) */
2567   2          }
2568   1      
2569   1      
2570   1          /* Auto Baud Rate Sync Enabled */
2571   1          #if(1u == LIN_1_AUTO_BAUD_RATE_SYNC)
2572   1      
2573   1              /***********************************************************************
2574   1              *                       Sync Field Complete                            *
2575   1              ***********************************************************************/
2576   1              if(0u != (LIN_1_auxStatus & LIN_1_STATUS_SYNC_COMPLETED))
2577   1              {
2578   2                  /* Save actual sync field timer counts */
2579   2                  LIN_1_syncCounts = LIN_1_LOW_BIT_LENGTH_SUM_REG;
2580   2                  LIN_1_syncCounts = LIN_1_LOW_BIT_LENGTH_SUM_REG;
2581   2                  LIN_1_syncCounts = LIN_1_LOW_BIT_LENGTH_SUM_REG;
2582   2                  LIN_1_syncCounts = LIN_1_LOW_BIT_LENGTH_SUM_REG +
2583   2                                                LIN_1_HIGH_BITS_LENGTH_SUM_REG;
2584   2      
2585   2                  /* Set new clock divider */
2586   2                  if(LIN_1_syncCounts != LIN_1_EXPECTED_TIME_COUNTS)
2587   2                  {
2588   3                      LIN_1_IntClk_SetDividerRegister((uint16)(((uint32)LIN_1_initialClockDivider *
2589   3                          (uint32) LIN_1_syncCounts) / LIN_1_EXPECTED_TIME_COUNTS), 0u);
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 43  

2590   3                  }
2591   2      
2592   2                  /* Clear one or more data bytes have been received internal flag */
2593   2                  LIN_1_fsmFlags &= ((l_u8) ~LIN_1_FSM_DATA_RECEIVE);
2594   2      
2595   2                  /* This will reset the UART ISR FSM to state 1 */
2596   2                  LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_1_PID;
2597   2      
2598   2                  /* Set UART enabled flag */
2599   2                  LIN_1_fsmFlags |= LIN_1_FSM_UART_ENABLE_FLAG;
2600   2      
2601   2                  /* Clear any pending UART interrupt */
2602   2                  CyIntClearPending(LIN_1_UART_ISR_NUMBER);
2603   2      
2604   2                  /* Enable UART ISR interrupt */
2605   2                  CyIntEnable(LIN_1_UART_ISR_NUMBER);
2606   2              }
2607   1      
2608   1          #endif /* (1u == LIN_1_AUTO_BAUD_RATE_SYNC) */
2609   1      
2610   1      
2611   1          /***************************************************************************
2612   1          *  Place your BASE ISR code here
2613   1          ***************************************************************************/
2614   1          /* `#START LIN_1_BASE_ISR_CODE` */
2615   1      
2616   1          /* `#END` */
2617   1      
2618   1      
2619   1          /* Clear software shadow register file  */
2620   1          LIN_1_auxStatus = 0x00u;
2621   1      }
2622          
2623          
2624          /*******************************************************************************
2625          * Function Name: l_ifc_aux
2626          ********************************************************************************
2627          *
2628          * Summary:
2629          *  The LIN Slave component takes care of calling this API routine automatically.
2630          *  Therefore, this API routine must not be called by the application code.
2631          *
2632          * Parameters:
2633          *  iii - is the name of the interface handle.
2634          *
2635          * Return:
2636          *  None
2637          *
2638          * Reentrant:
2639          *  No
2640          *
2641          *******************************************************************************/
2642          void l_ifc_aux(l_ifc_handle iii) 
2643          {
2644   1          switch(iii)
2645   1          {
2646   2              case LIN_1_IFC_HANDLE:
2647   2                  l_ifc_aux_LIN_1();
2648   2              break;
2649   2      
2650   2              default:
2651   2              break;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 44  

2652   2          }
2653   1      }
2654          
2655          
2656          /*******************************************************************************
2657          * Function Name: l_ifc_read_status_LIN_1
2658          ********************************************************************************
2659          *
2660          * Summary:
2661          *  This function is defined by the LIN specification. This returns the status of
2662          *  the specified LIN interface and then clears all status bits for that
2663          *  interface. See Section 7.2.5.8 of the LIN 2.1 specification.
2664          *
2665          * Parameters:
2666          *  None
2667          *
2668          * Return:
2669          *  The status bits of the specified LIN interface are returned. These bits have
2670          *  the following meanings:
2671          *    [15:8]    Last Received PID
2672          *    [7]        0
2673          *    [6]        Save Configuration flag
2674          *    [5]        0
2675          *    [4]        Bus Activity flag
2676          *    [3]        Go To Sleep flag
2677          *    [2]        Overrun flag
2678          *    [1]        Successful Transfer flag
2679          *    [0]        Error in Response flag
2680          *
2681          * Reentrant:
2682          *  No
2683          *
2684          *******************************************************************************/
2685          l_u16 l_ifc_read_status_LIN_1(void) 
2686          {
2687   1          l_u16 returnValue;
2688   1          l_u8 interruptState;
2689   1      
2690   1          interruptState = CyEnterCriticalSection();
2691   1      
2692   1          /***************************************************************************
2693   1          * Update software shadow status register with the value of the hardware
2694   1          * status register to obtain current value of the edge detected bit. The
2695   1          * edge detected status bit is cleared immediately and the rest of the
2696   1          * software shadow status register bits are expected to be cleared in ISR.
2697   1          ***************************************************************************/
2698   1          LIN_1_auxStatus |= LIN_1_STATUS_REG;
2699   1      
2700   1          /* Optionally update interface status variable */
2701   1          if(0u != (LIN_1_auxStatus & LIN_1_STATUS_EDGE_DETECTED))
2702   1          {
2703   2              /* Set bus activity bit in IFC status */
2704   2              LIN_1_ifcStatus |= LIN_1_IFC_STS_BUS_ACTIVITY;
2705   2      
2706   2              /* Clear edge detected bit in shadow register variable */
2707   2              LIN_1_auxStatus &= ((l_u8) ~LIN_1_STATUS_EDGE_DETECTED);
2708   2      
2709   2              #if(1u == LIN_1_INACTIVITY_ENABLED)
2710   2      
2711   2                  /* Clear period timer counter */
2712   2                  LIN_1_periodCounter = 0x00u;
2713   2      
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 45  

2714   2              #endif /* (1u == LIN_1_INACTIVITY_ENABLED) */
2715   2          }
2716   1      
2717   1          /* Copy the global status variable to the local temp variable */
2718   1          returnValue = LIN_1_ifcStatus;
2719   1      
2720   1          /* Clear status variable */
2721   1          LIN_1_ifcStatus &= (l_u16) ~LIN_1_IFC_STS_MASK;
2722   1      
2723   1          CyExitCriticalSection(interruptState);
2724   1      
2725   1          /* Clear the "stats not checked" flag, since the status is now being checked by the user */
2726   1          LIN_1_status &= ((l_u8) ~LIN_1_STATUS_NOT_CHECKED);
2727   1      
2728   1          /* Return the status in the temp variable */
2729   1          return (returnValue);
2730   1      }
2731          
2732          
2733          /*******************************************************************************
2734          * Function Name: l_ifc_read_status
2735          ********************************************************************************
2736          *
2737          * Summary:
2738          *  This function is defined by the LIN specification. This returns the status of
2739          *  the specified LIN interface and then clears all status bits for that
2740          *  interface. See Section 7.2.5.8 of the LIN 2.1 specification.
2741          *
2742          *
2743          * Parameters:
2744          *  iii - is the name of the interface handle.
2745          *
2746          * Return:
2747          *  The status bits of the specified LIN interface are returned. These bits have
2748          *  the following meanings:
2749          *    [15:8]    Last Received PID
2750          *    [7]        0
2751          *    [6]        Save Configuration flag
2752          *    [5]        0
2753          *    [4]        Bus Activity flag
2754          *    [3]        Go To Sleep flag
2755          *    [2]        Overrun flag
2756          *    [1]        Successful Transfer flag
2757          *    [0]        Error in Response flag
2758          *
2759          * Reentrant:
2760          *  No
2761          *
2762          *******************************************************************************/
2763          l_u16 l_ifc_read_status(l_ifc_handle iii) 
2764          {
2765   1          l_u16 returnValue;
2766   1      
2767   1          /* Determine which interface is specified */
2768   1          switch(iii)
2769   1          {
2770   2              /* Go here is interface 0 is specified */
2771   2              case LIN_1_IFC_HANDLE:
2772   2                  returnValue = l_ifc_read_status_LIN_1();
2773   2              break;
2774   2      
2775   2              default:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 46  

2776   2                  returnValue = (l_u16) CYRET_BAD_PARAM;
2777   2              break;
2778   2          }
2779   1      
2780   1          return (returnValue);
2781   1      }
2782          
2783          
2784          /*******************************************************************************
2785          * Function Name: l_sys_irq_disable
2786          ********************************************************************************
2787          *
2788          * Summary:
2789          *  This function disables all interrupts for the component. It returns a mask of
2790          *  the state that the interruptmask bits were in. This function is essentially
2791          *  equivalent to the DisableInt API of most components.
2792          *
2793          *  However, the returned value must be saved and later used with the
2794          *  l_sys_irq_restore function to restore the interrupt state properly. It is
2795          *  highly recommended that great care be taken when using this API routine. It
2796          *  is likely that LIN communication failures will occur if the interrupts for
2797          *  this component are disabled for too long.
2798          *
2799          *  This routine is supposed to be provided by the application. However, the LIN
2800          *  Slave component implements this routine automatically. You can modify the
2801          *  code in the routine if necessary.
2802          *
2803          * Parameters:
2804          *  None
2805          *
2806          * Return:
2807          *  Returns an interrupt register mask that defines the digital blocks for which
2808          *  interrupts were disabled.
2809          *
2810          *******************************************************************************/
2811          l_irqmask l_sys_irq_disable(void)
2812          {
2813   1          l_irqmask irqMask = 0u;
2814   1      
2815   1          if(1u == CyIntGetState(LIN_1_UART_ISR_NUMBER))
2816   1          {
2817   2              irqMask = 0x01u;
2818   2              CyIntDisable(LIN_1_UART_ISR_NUMBER);
2819   2          }
2820   1      
2821   1          if(1u == CyIntGetState(LIN_1_BLIN_ISR_NUMBER))
2822   1          {
2823   2              irqMask |= ((l_u8) (0x01u << 1u));
2824   2              CyIntDisable(LIN_1_BLIN_ISR_NUMBER);
2825   2          }
2826   1      
2827   1          return (irqMask);
2828   1      }
2829          
2830          
2831          /*******************************************************************************
2832          * Function Name: l_sys_irq_restore
2833          ********************************************************************************
2834          *
2835          * Summary:
2836          *  This function restores interrupts for the component. It should be used in
2837          *  conjunction with l_sys_irq_disable. This function is essentially equivalent
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 47  

2838          *  to the EnableInt API of most components. However, it should not be called
2839          *  when the component is being started.
2840          *
2841          *  This routine is supposed to be provided by the application. However, the LIN
2842          *  Slave component implements this routine automatically. You can modify the
2843          *  code in the routine if necessary.
2844          *
2845          * Parameters:
2846          *  previous - interrupt mask that defines the digital blocks for which
2847          *  interrupts will be enabled.
2848          *
2849          * Return:
2850          *  None
2851          *
2852          *******************************************************************************/
2853          void l_sys_irq_restore(l_irqmask previous)
2854          {
2855   1          if(0u != (previous & 0x01u))
2856   1          {
2857   2              CyIntEnable(LIN_1_UART_ISR_NUMBER);
2858   2          }
2859   1      
2860   1          if(0u != (previous & ((l_u8) (0x01u << 1u))))
2861   1          {
2862   2              CyIntEnable(LIN_1_BLIN_ISR_NUMBER);
2863   2          }
2864   1      }
2865          
2866          
2867          /*******************************************************************************
2868          * Function Name: LIN_1_FindPidIndex
2869          ********************************************************************************
2870          *
2871          * Summary:
2872          *  Returns index of the PID in LIN_1_volatileConfig.
2873          *
2874          * Parameters:
2875          *  l_u8 pid - PID of the frame which index required.
2876          *
2877          * Return:
2878          *  Index if the PID in LIN_1_volatileConfig,
2879          *  0xFFu - if PID is not found
2880          *
2881          *******************************************************************************/
2882          static l_u8 LIN_1_FindPidIndex(l_u8 pid)
2883          {
2884   1          l_u8 i;
2885   1          l_u8 returnValue = LIN_1_INVALID_FRAME_PID;
2886   1      
2887   1          for(i = 0u; i < LIN_1_NUM_FRAMES; i++)
2888   1          {
2889   2              if(pid == LIN_1_volatileConfig[i])
2890   2              {
2891   3                  returnValue = i;
2892   3      
2893   3                  /* Break the for loop */
2894   3                  break;
2895   3              }
2896   2          }
2897   1      
2898   1          return (returnValue);
2899   1      }
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 48  

2900          
2901          
2902          /*******************************************************************************
2903          * Function Name: LIN_1_EndFrame
2904          ********************************************************************************
2905          *
2906          * Summary:
2907          *  Finishes the frame transmission.
2908          *
2909          * Parameters:
2910          *  None
2911          *
2912          * Return:
2913          *  None
2914          *
2915          * Reentrant:
2916          *  No
2917          *
2918          *******************************************************************************/
2919          static void LIN_1_EndFrame(l_u8 status) 
2920          {
2921   1          l_u8 interruptState;
2922   1      
2923   1          if(status == LIN_1_HANDLING_DONT_SAVE_PID)
2924   1          {
2925   2              /* Clear data received flag */
2926   2              LIN_1_fsmFlags &= ((l_u8) ~LIN_1_FSM_DATA_RECEIVE);
2927   2      
2928   2              if(0u != (LIN_1_fsmFlags & LIN_1_FSM_OVERRUN))
2929   2              {
2930   3                  /* Set overrun */
2931   3                  LIN_1_ifcStatus |= LIN_1_IFC_STS_OVERRUN;
2932   3              }
2933   2          }
2934   1          else if(status ==LIN_1_HANDLING_SKIP_OVERRUN)
2935   1          {
2936   2              /* Set Overrun flag */
2937   2              LIN_1_fsmFlags |= LIN_1_FSM_OVERRUN;
2938   2      
2939   2              #if(1u == LIN_1_TL_ENABLED)
              
                          if(0u != (LIN_1_tlFlags & LIN_1_TL_TX_DIRECTION))
                          {
                              /* Transport Layer Functions: Cooked Transport Layer API */
                              #if(1u == LIN_1_TL_API_FORMAT)
              
                                  /* Set TL TX error status */
                                  LIN_1_txTlStatus = LD_FAILED;
              
                              #else   /* Transport Layer Functions: Raw Transport Layer API */
              
                                  /* Set TL TX error status */
                                  LIN_1_txTlStatus = LD_TRANSMIT_ERROR;
              
                              #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
                              /* Clear TL flags register */
                              LIN_1_tlFlags = 0u;
                          }
              
                          if(0u != (LIN_1_tlFlags & LIN_1_TL_RX_DIRECTION))
                          {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 49  

                              /* Transport Layer Functions: Cooked Transport Layer API */
                              #if(1u == LIN_1_TL_API_FORMAT)
              
                                  /* Set TL RX error status */
                                  LIN_1_rxTlStatus = LD_FAILED;
              
                              #else   /* Transport Layer Functions: Raw Transport Layer API */
              
                                  /* Set TL RX error status */
                                  LIN_1_rxTlStatus = LD_RECEIVE_ERROR;
              
                              #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
                              /* Clear TL flags register */
                              LIN_1_tlFlags = 0u;
                          }
              
                      #endif /* (1u == LIN_1_TL_ENABLED) */
2980   2          }
2981   1          else if(status == LIN_1_HANDLING_RESET_FSM_ERR)
2982   1          {
2983   2              /* Clear UART enable flag */
2984   2              LIN_1_fsmFlags &= ((l_u8) ~LIN_1_FSM_UART_ENABLE_FLAG);
2985   2      
2986   2              /* Shutdown and disconnect UART, clear pending interrupts */
2987   2              CyIntDisable(LIN_1_UART_ISR_NUMBER);
2988   2      
2989   2              /* Disconnect bus RX from UART */
2990   2              LIN_1_CONTROL_REG |=  LIN_1_CONTROL_RX_DIS;
2991   2      
2992   2              /*******************************************************************
2993   2              * Clear UART Rx FIFO.
2994   2              * This should be done by calling UART_ClearRxBuffer() function, but
2995   2              * its current implementation clears only memory buffer, but not FIFO
2996   2              * one.
2997   2              *******************************************************************/
2998   2              interruptState = CyEnterCriticalSection();
2999   2      
3000   2              LIN_1_UART_RX_FIFO_REG |= LIN_1_UART_RX_FIFO_CLEAR;
3001   2              LIN_1_UART_RX_FIFO_REG &= ((l_u8) ~LIN_1_UART_RX_FIFO_CLEAR);
3002   2      
3003   2              CyExitCriticalSection(interruptState);
3004   2      
3005   2              /* Clear any pending UART interrupt */
3006   2              CyIntClearPending(LIN_1_UART_ISR_NUMBER);
3007   2      
3008   2              /* Update UART ISR FSM state */
3009   2               #if(1u == LIN_1_AUTO_BAUD_RATE_SYNC)
3010   2      
3011   2                  /* Auto Baud Rate Sync Enabled */
3012   2                  LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_1_PID;
3013   2      
3014   2              #else
              
                          /* Auto Baud Rate Sync disabled */
                          LIN_1_uartFsmState = LIN_1_UART_ISR_STATE_0_SNC;
              
                      #endif  /* (1u == LIN_1_AUTO_BAUD_RATE_SYNC) */
3020   2          }
3021   1          else
3022   1          {
3023   2              /* Do nothing */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 50  

3024   2          }
3025   1      }
3026          
3027          
3028          /*******************************************************************************
3029          * Function Name: LIN_1_SetAssociatedFlags
3030          ********************************************************************************
3031          *
3032          * Summary:
3033          *  This function sets appropriate flags. Used by ISR.
3034          *
3035          * Parameters:
3036          *  Index of the PID in LIN_1_LinSlaveConfig.
3037          *
3038          * Return:
3039          *  None
3040          *
3041          * Reentrant:
3042          *  No
3043          *
3044          *******************************************************************************/
3045          static void LIN_1_SetAssociatedFlags(l_u8 pIndex)
3046          {
3047   1          switch(pIndex)
3048   1          {
3049   2              case 0u:
3050   2                  /* Mark frame "Frame1" (Type:Unconditional,Associated With:None) and associated signals proces
             -sed. */ 
3051   2                  LIN_1_statusFlagArray[LIN_1_ISR_AUX_SET_FLAGS_Frame1_FLAG_BYTE_OFFSET_0] |=
3052   2                      LIN_1_ISR_AUX_SET_FLAGS_Frame1_FLAG_MASK_0;
3053   2              break;
3054   2      
3055   2              case 1u:
3056   2                  /* Mark frame "seesaw_motor" (Type:Unconditional,Associated With:None) and associated signals 
             -processed. */ 
3057   2                  LIN_1_statusFlagArray[LIN_1_ISR_AUX_SET_FLAGS_seesaw_motor_FLAG_BYTE_OFFSET_0] |=
3058   2                      LIN_1_ISR_AUX_SET_FLAGS_seesaw_motor_FLAG_MASK_0;
3059   2              break;
3060   2      
3061   2      
3062   2              default:
3063   2              break;    
3064   2          }
3065   1      }
3066          
3067          
3068          
3069          /* SAE J2602 is disabled */
3070          #if(0u == LIN_1_SAE_J2602)
3071          
3072          
3073              /*******************************************************************************
3074              * Function Name: LIN_1_GetEtFlagValue
3075              ********************************************************************************
3076              *
3077              * Summary:
3078              *  This function gets value of appropriate event-triggered frame flag.
3079              *
3080              * Parameters:
3081              *  Index of the PID in LIN_1_LinSlaveConfig.
3082              *
3083              * Return:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 51  

3084              *  Current flag value.
3085              *
3086              *******************************************************************************/
3087              static l_bool LIN_1_GetEtFlagValue(l_u8 pidIndex)
3088          {
3089   1          l_bool returnValue;
3090   1      
3091   1          switch(pidIndex)
3092   1          {
3093   2              default:
3094   2                   returnValue = LIN_1_FALSE;
3095   2              break;    
3096   2          }
3097   1      
3098   1          return (returnValue);
3099   1      }
3100          
3101          
3102          
3103              /*******************************************************************************
3104              * Function Name: LIN_1_ClearEtFlagValue
3105              ********************************************************************************
3106              *
3107              * Summary:
3108              *  This function clears value of appropriate event-triggered frame flag.
3109              *
3110              * Parameters:
3111              *  Index of the PID in LIN_1_LinSlaveConfig.
3112              *
3113              * Return:
3114              *  None
3115              *
3116              * Reentrant:
3117              *  No
3118              *
3119              *******************************************************************************/
3120              static void LIN_1_ClearEtFlagValue(l_u8 pidIndex)
3121          {
3122   1          switch(pidIndex)
3123   1          {
3124   2              default:
3125   2              break;    
3126   2          }
3127   1      }
3128          
3129          
3130          
3131          #endif /* (0u == LIN_1_SAE_J2602) */
3132          
3133          
3134          #if(1u == LIN_1_TL_ENABLED)
              
                  /*******************************************************************************
                  * Function Name: ld_init
                  ********************************************************************************
                  *
                  * Summary:
                  *  This call will (re)initialize the raw and the cooked layers on the interface
                  *  iii.
                  *
                  *  All transport layer buffers will be initialized.
                  *
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 52  

                  *  If there is an ongoing diagnostic frame transporting a cooked or raw message
                  *  on the bus, it will not be aborted.
                  *
                  * Parameters:
                  *  iii - Interface.
                  *
                  * Return:
                  *  None
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  void ld_init(l_ifc_handle iii) 
                  {
                      l_u8 interruptState;
              
                      /* To remove unreferenced local variable warning */
                      iii = iii;
              
                      #if(1u == LIN_1_TL_API_FORMAT)
              
                          while(LIN_1_rxTlStatus == LD_IN_PROGRESS)
                          {
                              /* Wait until current message will be processed */
                          }
              
                          while(LIN_1_txTlStatus == LD_IN_PROGRESS)
                          {
                              /* Wait until current message will be processed */
                          }
              
                          /* Save interrupt state and disable interrupts */
                          interruptState = CyEnterCriticalSection();
              
                          /* Initialize Tx and Rx status variables correctly */
                          LIN_1_txTlStatus = LD_COMPLETED;
                          LIN_1_rxTlStatus = LD_COMPLETED;
              
                          LIN_1_tlLengthPointer = NULL;
              
                          /* Reset the frame counters */
                          LIN_1_rxMessageLength = 0u;
                          LIN_1_txMessageLength = 0u;
              
                          /* Reset the frame counters */
                          LIN_1_txFrameCounter = 0u;
                          LIN_1_rxFrameCounter = 0u;
              
                          LIN_1_rxTlDataPointer = NULL;
                          LIN_1_rxTlInitDataPointer = NULL;
                          
                          /* Previous PCI requires to be unknown after the initialization */
                          LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_UNKNOWN;
              
                      #else
              
                          /* Save interrupt state and disable interupts */
                          interruptState = CyEnterCriticalSection();
              
                          /* Reset buffers depth to 0, it will indicate the buffers are empty */
                          LIN_1_txBufDepth = 0u;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 53  

                          LIN_1_rxBufDepth = 0u;
              
                          /* Raw API buffers initialization */
              
                          LIN_1_txWrIndex = 0u;
                          LIN_1_txRdIndex = 0u;
              
                          LIN_1_rxWrIndex = 0u;
                          LIN_1_rxRdIndex = 0u;
              
                          LIN_1_txTlStatus = LD_QUEUE_EMPTY;
                          LIN_1_rxTlStatus = LD_NO_DATA;
              
                      #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
                      /* Set initial NAD as a current active NAD before initializing TL */
                      LIN_1_nad = LIN_1_LinSlaveConfig.initialNad;
              
                      LIN_1_tlFlags = 0u;
              
                      /* Enable interrupts */
                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: ld_read_configuration
                  ********************************************************************************
                  *
                  * Summary:
                  *  This function is used to read the NAD and PID values from volatile memory.
                  *  This function can be used to read the current configuration data, and then
                  *  save this data into non-volatile (flash) memory. The application should save
                  *  the configuration data to flash when the "Save Configuration" bit is set in
                  *  the LIN status register (returned by l_ifc_read_status_LIN_1).
                  *  The configuration data that is read is a series of bytes. The first byte is
                  *  the current NAD of the slave. The next bytes are the current PID values for
                  *  the frames that the slave responds to. The PID values are in the order in
                  *  which the frames appear in the LDF or NCF file.
                  *
                  * Parameters:
                  *  iii - Interface.
                  *
                  * Return:
                  *  LD_READ_OK - If the service was successful.
                  *
                  *  LD_LENGTH_TOO_SHORT - If the configuration size is greater than the length.
                  *                        It means that the data area does not contain a valid
                  *                        configuration.
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  l_u8 ld_read_configuration(l_ifc_handle iii, l_u8* const pData, l_u8* const length) 
                                                              
                  {
                      l_u8 i;
                      l_u8 result = LIN_1_LD_READ_OK;
              
                      if(*length < (LIN_1_NUM_FRAMES + 1u))
                      {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 54  

                          /* Return with no action when the requested length is smaller
                          *  than the configuration data length.
                          */
                          result = LIN_1_LD_LENGTH_TOO_SHORT;
                      }
                      else
                      {
                          /* Copy over the configured NAD */
                          pData[0u] = LIN_1_nad;
              
                          /* Copy the data from the PID array to the data array */
                          for (i = 0u; i < LIN_1_NUM_FRAMES; i++)
                          {
                              pData[i + 1u] = LIN_1_volatileConfig[i];
                          }
              
                          /* Set the length parameter to the actual length of the configuration data */
                          *length = LIN_1_NUM_FRAMES + 1u;
                      }
              
                      /* To remove unreferenced local variable warning */
                      iii = iii;
              
                      /* Return status */
                      return (result);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: ld_set_configuration
                  ********************************************************************************
                  *
                  * Summary:
                  *  This call will not transport anything on the bus.
                  *
                  *  The function will configure the NAD and the PIDs according to the
                  *  configuration given by data. The intended usage is to restore a saved
                  *  configuration or set an initial configuration (e.g. coded by I/O pins).
                  *
                  *  The function shall be called after calling l_ifc_init.
                  *
                  *  The caller shall set the size of the data area before calling the function.
                  *
                  *  The data contains the NAD and the PIDs and occupies one byte each.
                  *  The structure of the data is: NAD and then all PIDs for the frames.
                  *  The order of the PIDs are the same as the frame list in the LDF,
                  *  Section 9.2.2.2, and NCF, Section 8.2.5.
                  *
                  * Parameters:
                  *  iii - Interface.
                  *
                  * Return:
                  *  LD_SET_OK - If the service was successful.
                  *
                  *  LD_LENGTH_NOT_CORRECT - If the required size of the configuration is not
                  *                          equal to the given length.
                  *
                  *  LD_DATA_ERROR - The set of configuration could not be set. A an error
                  *                  occurred while setting the configuration and the read back
                  *                  configuration settings doesn't match required settings.
                  *
                  *  LIN_1_volatileConfig - new frame PIDs are copied.
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 55  

                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  l_u8 ld_set_configuration(l_ifc_handle iii, const l_u8* const pData, l_u16 length) 
                                                                   
                  {
                      l_u8 i;
                      l_u8 result = LIN_1_LD_SET_OK;
              
                      if(length != (LIN_1_NUM_FRAMES + 1u))
                      {
                          /* Return error if the length isn't correct */
                          result = LIN_1_LD_LENGTH_NOT_CORRECT;
                      }
                      else
                      {
                          /* Copy NAD to a volatile memory */
                          LIN_1_nad = pData[0u];
              
                          /* Data read back */
                          if(LIN_1_nad != pData[0u])
                          {
                              /* Indicate data error if NAD is not set correctly */
                              result = LIN_1_LD_DATA_ERROR;
                          }
              
                          /* Copy Frame PIDs to a volatile memory */
                          for(i = 0u; i < LIN_1_NUM_FRAMES; i++)
                          {
                              LIN_1_volatileConfig[i] = pData[i + 1u];
              
                              /* Data read back */
                              if(LIN_1_volatileConfig[i] != pData[i + 1u])
                              {
                                  /* Indicate data error if NAD is not set correctly */
                                  result = LIN_1_LD_DATA_ERROR;
                              }
                          }
                      }
              
                      /* To remove unreferenced local variable warning */
                      iii = iii;
              
                      /* Return success code if the copy has completed */
                      return(result);
                  }
              
                  #if(1u == LIN_1_CS_ENABLED)
              
                      #if((0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB0_SEL)) || \
                          (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL)))
                          
                          /*******************************************************************************
                          * Function Name: LIN_1_LinProductId
                          ********************************************************************************
                          *
                          * Summary:
                          *  Verify that received LIN product identification matches.
                          *
                          * Parameters:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 56  

                          *  frameData - pointer to a 4 bytes that holds LIN product ID.
                          *
                          * Return:
                          *  0 - in case when LIN product IDs don't match.
                          *  1 - in case when LIN product IDs do match.
                          *
                          * Reentrant:
                          *  No
                          *
                          *******************************************************************************/
                          static l_bool LIN_1_LinProductId(volatile const l_u8 frameData[])
                          {
                              l_u8 i = 1u;
              
                              if((frameData[0u] != LO8(LIN_1_slaveId.supplierId)) &&
                                  (frameData[0u] != LO8(LIN_1_CS_SUPPLIER_ID_WILDCARD)))
                              {
                                  i = 0u;        /* Zero out 'i' if the data isn't for this slave */
                              }
              
                              if((frameData[1u] != HI8(LIN_1_slaveId.supplierId)) &&
                                  (frameData[1u] != HI8(LIN_1_CS_SUPPLIER_ID_WILDCARD)))
                              {
                                  i = 0u;        /* Zero out 'i' if the data isn't for this slave */
                              }
              
                              if((frameData[2u] != LO8(LIN_1_slaveId.functionId)) &&
                                  (frameData[2u] != LO8(LIN_1_CS_FUNCTION_ID_WILDCARD)))
                              {
                                  i = 0u;        /* Zero out 'i' if the data isn't for this slave */
                              }
              
                              if((frameData[3u] != HI8(LIN_1_slaveId.functionId)) &&
                                  (frameData[3u] != HI8(LIN_1_CS_FUNCTION_ID_WILDCARD)))
                              {
                                  i = 0u;        /* Zero out 'i' if the data isn't for this slave */
                              }
              
                              return(i);
                          }
                          
                      #endif /*((0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB0_SEL)) ||
                             * (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL)))
                             */
                              
                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB1_SEL))
              
                          #if(1u == LIN_1_LIN_2_0)
              
                              /*******************************************************************************
                              * Function Name: LIN_1_MessageId
                              ********************************************************************************
                              *
                              * Summary:
                              *  Search for message ID in the LIN message ID table in case of success returns
                              *  message ID index in the table.
                              *
                              * Parameters:
                              *  frameData - The data pointer points to a data area with 2 bytes.
                              *
                              * Return:
                              *  message ID index - in case of successful operation;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 57  

                              *  LD_INVALID_MESSAGE_INDEX - in case when message ID wasn't found.
                              *
                              * Reentrant:
                              *  No
                              *
                              *******************************************************************************/
                              static l_u8 LIN_1_MessageId(volatile const l_u8* frameData)
                              {
                                  l_u8 i = 0u;
                                  l_u8 result = LD_INVALID_MESSAGE_INDEX;
              
                                  while((i < LIN_1_NUM_FRAMES) && (result == LD_INVALID_MESSAGE_INDEX))
                                  {
                                      /* If LSB of the message ID from the table is equal to received one then
                                      * Compare the MSB and in case of success set result to message index.
                                      */
                                      if(frameData[0u] == LO8(messageIdTable[i]))
                                      {
                                          if(frameData[1u] == HI8(messageIdTable[i]))
                                          {
                                              result = i;
                                          }
                                      }
              
                                      i++;
                                  }
              
                                  return(result);
                              }
              
                          #endif /* (1u == LIN_1_LIN_2_0) */
              
                      #endif /*(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB1_SEL)) */
              
                      #if((0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL)) || \
                          (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB3_SEL)))
              
                          /*******************************************************************************
                          * Function Name: ld_read_by_id_callout
                          ********************************************************************************
                          *
                          * Summary:
                          *  This callout is used when the master node transmits a read by identifier
                          *  request with an identifier in the user defined area. The slave node
                          *  application will be called from the driver when such request is received.
                          *
                          * Parameters:
                          *  iii - Interface.
                          *  id - The id parameter is the identifier in the user defined area (32 to 63),
                          *  from the read by identifier configuration request.
                          *  frameData - The data pointer points to a data area with 5 bytes. This area
                          *  will be used by the application to set up the positive response.
                          *
                          * Return:
                          *  LD_NEGATIVE_RESPONSE - The slave node will respond with a negative response.
                          *  In this case the data area is not considered
                          *
                          *  LD_POSTIVE_RESPONSE - The slave node will setup a positive response using
                          *  the data provided by the application.
                          *
                          *  LD_NO_RESPONSE - The slave node will not answer.
                          *
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 58  

                          * Reentrant:
                          *  No
                          *
                          *******************************************************************************/
                          l_u8 ld_read_by_id_callout(l_ifc_handle iii, l_u8 id, l_u8* frameData)
                                                                      
                          {
                              l_u8 result = LD_NEGATIVE_RESPONSE;
              
                              /* User code required to handle user defined identification (Optional) */
                              /* `#START LD_READ_BY_ID_CALLOUT_USER_SECTION` */
              
                              /* `#END` */
              
                              /* To remove unreferenced local variable warning */
                              iii = iii;
                              id = id;
                              frameData = frameData;
              
                              return(result);
                          }
              
                      #endif /* ((0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL))
                             * ||
                             * (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB3_SEL)))
                             */
              
                  #endif /* (1u == LIN_1_CS_ENABLED) */
              
              
                  /*******************************************************************************
                  * Function Name: LIN_1_ProcessMrf
                  ********************************************************************************
                  *
                  * Summary:
                  *  This API is called from the ISR. It is responsible to parse the RX frames
                  *  that come from a LIN Master. This API handles Automatic Configuration
                  *  requests and receiving both Raw and Cooked API frames.
                  *
                  * Parameters:
                  *  frame - Pointer to an array that contains a last received frame.
                  *
                  * Return:
                  *  None
                  *
                  * Reentrant:
                  *  No
                  *
                  *******************************************************************************/
                  static void LIN_1_ProcessMrf(l_u8 frame[])
                  {
                      l_u8 i;
                      l_u8 tempStatus = 0u;
              
                      #if(1u == LIN_1_TL_API_FORMAT) /* Cooked API */
                          l_u8 tmpPci;
                          l_u16 tmpWord;
                          l_u8 tmpByte;
                      #endif /* 1u == LIN_1_TL_API_FORMAT */
              
                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB3_SEL))
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 59  

                          l_u8 idByte;
                          l_u8 idMask;
                          l_u8 idInvert;
              
                      #endif /* (0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB3_SEL)) */
              
              
                      if(LIN_1_NAD_GO_TO_SLEEP == frame[LIN_1_PDU_NAD_IDX])
                      {
                          LIN_1_ifcStatus |= LIN_1_IFC_STS_GO_TO_SLEEP;
                      }
                      else if((LIN_1_nad == frame[LIN_1_PDU_NAD_IDX]) ||
                                  (LIN_1_NAD_BROADCAST == frame[LIN_1_PDU_NAD_IDX]) ||
                                      (LIN_1_NAD_FUNCTIONAL == frame[LIN_1_PDU_NAD_IDX]))
                      {
                          /* Single Frame detected */
                          if(0u == (frame[LIN_1_PDU_PCI_IDX] & LIN_1_PDU_PCI_TYPE_MASK))
                          {
                              /* SID used for node configuration */
                              switch(frame[LIN_1_PDU_SID_IDX])
                              {
                                  #if(1u == LIN_1_CS_ENABLED)
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB0_SEL))
              
                                          case LIN_1_NCS_ASSIGN_NAD:
              
                                              if(1u == LIN_1_LinProductId(&frame[3u]))  /* Check LIN Product ID */
                                              {
                                                  /* Save received NAD */
                                                  LIN_1_nad = frame[LIN_1_PDU_D5_NEW_NAD_IDX];
              
                                                  /* Fill the SRF Buffer with response for a service */
                                                  /* Nad field should contain initial NAD */
                                                  LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                      LIN_1_LinSlaveConfig.initialNad;
              
                                                  /* PCI is 0 so only length required */
                                                  LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                                  /* The RSID for a positive response is always SID + 0x40 */
                                                  LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                      LIN_1_NCS_POS_RESP_ASSIGN_NAD;
              
                                                  /* Fill unused data bytes with 0xFFs */
                                                  for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                  {
                                                      LIN_1_srfBuffer[i] = 0xFFu;
                                                  }
              
                                                  /* Set the service response bit that indicates that the response is
                                                  * ready to be sent to master node.
                                                  */
                                                  LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                              }
                                              else
                                              {
                                                  /* No response as the Supplier ID and the Function ID is invalid */
                                              }
              
                                          break;
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 60  

                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB0_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB1_SEL))
              
                                          case LIN_1_NCS_ASSIGN_FRAME_ID:  /* Obsolete, not implemented for LIN lin 2.1 
             -*/
                                                                                      /* LIN 2.0 specification Only */
                                              #if(1u == LIN_1_LIN_2_0)
              
                                                  /* tempStatus is used in Supplier ID verification */
                                                  tempStatus = 1u;
              
                                                  if((frame[LIN_1_PDU_D1_IDX] !=
                                                      LO8(LIN_1_slaveId.supplierId)) &&
                                                          (frame[LIN_1_PDU_D1_IDX] !=
                                                              LO8(LIN_1_CS_SUPPLIER_ID_WILDCARD)))
                                                  {
                                                      tempStatus = 0u;  /* Zero out tempStatus if the data isn't for thi
             -s slave */
                                                  }
              
                                                  if((frame[LIN_1_PDU_D2_IDX] !=
                                                      HI8(LIN_1_slaveId.supplierId)) &&
                                                          (frame[LIN_1_PDU_D2_IDX] !=
                                                              HI8(LIN_1_CS_SUPPLIER_ID_WILDCARD)))
                                                  {
                                                      tempStatus = 0u;   /* Zero out tempStatus if the data isn't for th
             -is slave */
                                                  }
              
                                                  /* If tempStatus is not 0 then verification passed successfully */
                                                  if(tempStatus != 0u)
                                                  {
                                                      /* Now tempStatus is used to hold Message ID Index */
                                                      tempStatus = LIN_1_MessageId(frame + 5u);
              
                                                      /* If Message ID index is valid then process the request and
                                                      * prepare positive answer
                                                      */
                                                      if(tempStatus != LD_INVALID_MESSAGE_INDEX)
                                                      {
                                                          /* Set the PID in the position where the valid index points */
                                                          LIN_1_volatileConfig[tempStatus] =
                                                              frame[LIN_1_PDU_D5_IDX];
              
                                                          /* Fill the SRF Buffer with response for a service */
                                                          /* Nad field should contain current NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* PCI is 0 so only length required */
                                                          LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                                          /* The RSID for a positive response is always SID + 0x40 */
                                                          LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                              LIN_1_NCS_POS_RESP_ASSIGN_FRAME_ID;
              
                                                          /* Fill unused data bytes with 0xFFs */
                                                          for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                          {
                                                              LIN_1_srfBuffer[i] = 0xFFu;
                                                          }
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 61  

              
                                                          /* Set the service response bit that indicates that the respon
             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
                                                  }
              
                                              #else
              
                                                  /* Do nothing ignore obsolete request */
              
                                              #endif /* (1u == LIN_1_LIN_2_0) */
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB1_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL))
              
                                          case LIN_1_NCS_READ_BY_ID:
              
                                              /* tempStatus is used to hold a status of LIN_1_LinProductId() */
                                              tempStatus = LIN_1_LinProductId(&frame[4u]);
              
                                              /* LIN Product Identification (the only identifier is supported) */
                                              if(LIN_1_NCS_READ_BY_ID_ID == frame[LIN_1_PDU_D1_IDX])
                                              {
                                                  if(1u == tempStatus)
                                                  {
                                                      /* Fill the SRF Buffer with response for a service */
                                                      /* Nad field should contain current NAD */
                                                      LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                          LIN_1_nad;
              
                                                      /* PCI is 0 so only length required */
                                                      LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 6u;
              
                                                      /* The RSID for a positive response is always SID + 0x40 */
                                                      LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                          LIN_1_NCS_POS_RESP_READ_BY_ID;
              
                                                      /* Fill data fields with Supplier and function IDs */
                                                      LIN_1_srfBuffer[LIN_1_PDU_D1_IDX] =
                                                         LO8(LIN_1_slaveId.supplierId);
                                                      LIN_1_srfBuffer[LIN_1_PDU_D2_IDX] =
                                                          HI8(LIN_1_slaveId.supplierId);
                                                      LIN_1_srfBuffer[LIN_1_PDU_D3_IDX] =
                                                          LO8(LIN_1_slaveId.functionId);
                                                      LIN_1_srfBuffer[LIN_1_PDU_D4_IDX] =
                                                          HI8(LIN_1_slaveId.functionId);
                                                      LIN_1_srfBuffer[LIN_1_PDU_D5_IDX] =
                                                          LIN_1_slaveId.variant;
              
                                                      /* Set the service response bit that indicates that the response i
             -s
                                                      * ready to be sent to master node.
                                                      */
                                                      LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                  }
                                                  else
                                                  {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 62  

                                                      /* No action */
                                                  }
                                              }
                                              else if(LIN_1_NCS_READ_BY_ID_SERIAL == frame[LIN_1_PDU_D1_IDX])
                                              {
                                                  /* Serial number identification*/
              
                                                  /* If the slave serial number matches received one
                                                  * then prepare positive response.
                                                  */
                                                  if(1u == tempStatus)
                                                  {
                                                      /* Fill the SRF Buffer with response for a service */
                                                      /* Nad field should contain current NAD */
                                                      LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                          LIN_1_nad;
              
                                                      /* PCI is 0 so only length required */
                                                      LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 5u;
              
                                                      /* The RSID for a positive response is always SID + 0x40 */
                                                      LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                          LIN_1_NCS_POS_RESP_READ_BY_ID;
              
                                                      /* Fill unused data bytes with serial number ID */
                                                      for(i = 3u; i < (LIN_1_FRAME_LEN - 1u); i++)
                                                      {
                                                          LIN_1_srfBuffer[i] = LIN_1_serialNumber[i - 3u];
                                                      }
              
                                                      /* The serial number is 4 byte length so set to 0xFF last unusued 
             -byte */
                                                      LIN_1_srfBuffer[LIN_1_PDU_D5_IDX] = 0xFFu;
              
                                                      /* Set the service response bit that indicates that the response i
             -s
                                                      * ready to be sent to master node.
                                                      */
                                                      LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                  }
                                                  else
                                                  {
                                                       /* Do nothing serial number is invalid */
                                                  }
              
                                              }
                                              else if((frame[LIN_1_PDU_D1_IDX] >= 32u) &&
                                              (frame[LIN_1_PDU_D1_IDX] <= 63u))     /* User defined identification */
                                              {
              
                                                  if(1u == tempStatus)
                                                  {
                                                      /* Copy five bytes of data from volatile location into non-volatil
             -e memory
                                                      *  location. This is done to suppress MISRA violation of rule 11.5
             -.
                                                      */
               /*                                       for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_5; i++)
                                                      {
                                                          tmpFrameBuff[i] = frame[i + LIN_1_FRAME_DATA_SIZE_3];
                                                      }*/
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 63  

                                                      /* If user didn't reassign the status of ld_read_by_id_callout() t
             -hen
                                                      * LD_NEGATIVE_RESPONSE will always be returned by ld_read_by_id_ca
             -llout().
                                                      * This will indicate to master that the service by user defined id
             -entification
                                                      * is not supported. tempStatus will be used to hold status of
                                                      * ld_read_by_id_callout().
                                                      */
                                                      tempStatus = ld_read_by_id_callout(LIN_1_IFC_HANDLE,
                                                          frame[LIN_1_PDU_D1_IDX],
                                                              frame + LIN_1_FRAME_DATA_SIZE_3);
              
                                                      if(tempStatus == LD_NEGATIVE_RESPONSE)
                                                      {
                                                          /* Fill the SRF Buffer with negative response for the service 
             -*/
                                                          /* Nad field should contain current NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* PCI is 0 so only length required */
                                                          LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 3u;
              
                                                          /* The RSID for a positive response is always SID + 0x40 */
                                                          LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                              LIN_1_NCS_RSID_NEG_REPLY;
              
                                                          /* D1 will hold the service ID */
                                                          LIN_1_srfBuffer[LIN_1_PDU_D1_ID_IDX] =
                                                              LIN_1_NCS_READ_BY_ID;
              
                                                          /* D2 contains error code */
                                                          LIN_1_srfBuffer[LIN_1_PDU_D2_IDX] = 0x12u;
              
                                                          /* Fill unused data bytes with 0xFFs */
                                                          for(i = 5u; i < LIN_1_FRAME_LEN; i++)
                                                          {
                                                              LIN_1_srfBuffer[i] = 0xFFu;
                                                          }
              
                                                          /* Set the service response bit that indicates that the respon
             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
                                                      else if(tempStatus == LD_POSITIVE_RESPONSE)
                                                      {
                                                          /* Fill the SRF Buffer with response for a service */
                                                          /* Nad field should contain current NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* PCI is 0 so only length required */
                                                          LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 6u;
              
                                                          /* The RSID for a positive response is always SID + 0x40 */
                                                          LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                              LIN_1_NCS_POS_RESP_READ_BY_ID;
              
                                                          /* Fill unused data bytes with user defined information */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 64  

                                                          for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                          {
                                                              LIN_1_srfBuffer[i] = frame[i];
                                                          }
              
                                                          /* Set the service response bit that indicates that the respon
             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
                                                      else
                                                      {
                                                          /* Do nothing as there no response from user */
                                                      }
                                                  }
                                                  else
                                                  {
                                                       /* Do nothing serial number is invalid */
                                                  }
                                              }
                                              else if((frame[LIN_1_PDU_D1_IDX] >= 16u) &&
                                                  (frame[LIN_1_PDU_D1_IDX] <= 31u))     /* Message ID identification*/
                                              {
                                                  /* LIN 2.0 specification Only */
                                                  #if(1u == LIN_1_LIN_2_0)
              
                                                      /* If the slave serial number matchs received one
                                                      * then prepare positive response.
                                                      */
                                                      if(1u == tempStatus)
                                                      {
                                                          /* Fill the SRF Buffer with response for a service */
                                                          /* Nad field should contain current NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* tempStatus now used to store calculated Message ID index */
                                                          tempStatus = frame[LIN_1_PDU_D1_IDX] - LD_MESSAGE_ID_BASE;
              
                                                          if(LIN_1_NUM_FRAMES > tempStatus)
                                                          {
                                                              /* PCI is 0 so only length required */
                                                              LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 4u;
              
                                                              /* The RSID for a positive response is always SID + 0x40 *
             -/
                                                              LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                                  LIN_1_NCS_POS_RESP_READ_BY_ID;
              
                                                              /* D1 = Message ID LSB */
                                                              LIN_1_srfBuffer[LIN_1_PDU_D1_IDX] =
                                                                  HI8(messageIdTable[tempStatus]);
              
                                                              /* D2 = Message ID MSB */
                                                              LIN_1_srfBuffer[LIN_1_PDU_D2_IDX] =
                                                                  LO8(messageIdTable[tempStatus]);
              
                                                              /* D3 = PID */
                                                              LIN_1_srfBuffer[LIN_1_PDU_D3_IDX] =
                                                                  LIN_1_volatileConfig[tempStatus];
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 65  

                                                              /* The Message ID response is 3 byte length so set last tw
             -o bytes
                                                              * to 0xFF.
                                                              */
                                                              LIN_1_srfBuffer[LIN_1_PDU_D4_IDX] = 0xFFu;
                                                              LIN_1_srfBuffer[LIN_1_PDU_D5_IDX] = 0xFFu;
                                                          }
                                                          else
                                                          {
                                                              /* PCI is 0 so only length required */
                                                              LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 3u;
              
                                                              /* The RSID for a positive response is always SID + 0x40 *
             -/
                                                              LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                                  LIN_1_NCS_RSID_NEG_REPLY;
              
                                                              /* D1 will hold the service ID */
                                                              LIN_1_srfBuffer[LIN_1_PDU_D1_ID_IDX] =
                                                                  LIN_1_NCS_READ_BY_ID;
              
                                                              /* D2 contains error code */
                                                              LIN_1_srfBuffer[LIN_1_PDU_D2_IDX] = 0x12u;
              
                                                              /* Fill unused data bytes with 0xFFs */
                                                              for(i = 5u; i < LIN_1_FRAME_LEN; i++)
                                                              {
                                                                  LIN_1_srfBuffer[i] = 0xFFu;
                                                              }
                                                          }
              
                                                          /* Set the service response bit that indicates that the respon
             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
              
                                                  #else
              
                                                      /* Do nothing ignore errorneous request */
              
                                                  #endif /* (1u == LIN_1_LIN_2_0) */
                                              }
                                              else
                                              {
                                                  /* Do nothing */
                                              }
              
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB2_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB3_SEL))
              
                                          case LIN_1_NCS_COND_CHANGE_NAD:
              
                                              if(LIN_1_NCS_READ_BY_ID_ID == frame[LIN_1_PDU_D1_ID_IDX])
                                              {
                                                  /* LIN Product Identification */
                                                  if((6u > frame[LIN_1_PDU_D2_BYTE_IDX]) &&
                                                      (0u != frame[LIN_1_PDU_D2_BYTE_IDX]))
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 66  

                                                  {
                                                      switch (frame[LIN_1_PDU_D2_BYTE_IDX])
                                                      {
                                                          /* tempStatus will be used as a teporary variable to store ID 
             -byte */
              
                                                          case LIN_1_CS_BYTE_SUPPLIER_ID1:
              
                                                              tempStatus = LO8(LIN_1_slaveId.supplierId);
              
                                                          break;
              
                                                          case LIN_1_CS_BYTE_SUPPLIER_ID2:
              
                                                              tempStatus = HI8(LIN_1_slaveId.supplierId);
              
                                                          break;
              
                                                          case LIN_1_CS_BYTE_FUNCTION_ID1:
              
                                                              tempStatus = LO8(LIN_1_slaveId.functionId);
              
                                                          break;
              
                                                          case LIN_1_CS_BYTE_FUNCTION_ID2:
              
                                                              tempStatus = HI8(LIN_1_slaveId.functionId);
              
                                                          break;
              
                                                          case LIN_1_CS_BYTE_VARIANT:
              
                                                              tempStatus = LIN_1_slaveId.variant;
              
                                                          break;
              
                                                          default:
              
                                                              /* This state should never be used */
              
                                                          break;
                                                      }
              
                                                      if(0u == ((tempStatus ^ frame[LIN_1_PDU_D4_INVERT_IDX]) &
                                                          frame[LIN_1_PDU_D3_MASK_IDX]))
                                                      {
                                                          /* Change NAD to new NAD */
                                                          LIN_1_nad = frame[LIN_1_PDU_D5_NEW_NAD_IDX];
              
                                                          /* Fill the SRF Buffer with response for a service */
                                                          /* Nad field should contain current NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* PCI is 0 so only length required */
                                                          LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                                          /* The RSID for a positive response is always SID + 0x40 */
                                                          LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                              LIN_1_NCS_POS_RESP_COND_CHANGE_NAD;
              
                                                          /* Fill unused bytes with 0xFF */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 67  

                                                          for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                          {
                                                              LIN_1_srfBuffer[i] = 0xFFu;
                                                          }
              
                                                          /* Set the service response bit that indicates that the respon
             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
                                                      else
                                                      {
                                                          /* Do nothing ignore errorneous request */
                                                      }
                                                  }
                                                  else
                                                  {
                                                      /* Do nothing ignore errorneous request */
                                                  }
                                              }
                                              else if(LIN_1_NCS_READ_BY_ID_SERIAL == frame[LIN_1_PDU_D1_ID_IDX])
                                              {
                                                  if((5u < frame[LIN_1_PDU_D2_BYTE_IDX]) &&
                                                      (0u != frame[LIN_1_PDU_D2_BYTE_IDX]))
                                                  {
                                                      /* Byte = 1 corresponds to the first byte (LIN_1_serialNumber[0]) 
             -*/
                                                      if(0u == ((
                                                      LIN_1_serialNumber[frame[LIN_1_PDU_D2_BYTE_IDX] - 1u] ^
                                                          frame[LIN_1_PDU_D4_INVERT_IDX]) &
                                                              frame[LIN_1_PDU_D3_MASK_IDX]))
                                                      {
                                                          /* Change NAD to new NAD */
                                                          LIN_1_nad = frame[LIN_1_PDU_D5_NEW_NAD_IDX];
              
                                                          /* Fill the SRF Buffer with response for a service */
                                                          /* Nad field should contain current NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* PCI is 0 so only length required */
                                                          LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                                          /* The RSID for a positive response is always SID + 0x40 */
                                                          LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                              LIN_1_NCS_POS_RESP_COND_CHANGE_NAD;
              
                                                          /* Fill unused bytes with 0xFF */
                                                          for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                          {
                                                              LIN_1_srfBuffer[i] = 0xFFu;
                                                          }
              
                                                          /* Set the service response bit that indicates that the respon
             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
                                                      else
                                                      {
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 68  

                                                          /* Do nothing ignore errorneous request */
                                                      }
                                                  }
                                                  else
                                                  {
                                                      /* Do nothing ignore errorneous request */
                                                  }
                                              }
                                              else if((frame[LIN_1_PDU_D1_IDX] >= 32u) &&
                                                  (frame[LIN_1_PDU_D1_IDX] <= 63u))     /* User defined identification*/
                                              {
                                                  /* Need to store Byte, Invert and Mask in a variables for user defined
                                                  * identification as frame[] should contain user data after execution o
             -f
                                                  * ld_read_by_id_callout();
                                                  */
                                                  idByte = frame[LIN_1_PDU_D2_BYTE_IDX] - 1u;
                                                  idInvert = frame[LIN_1_PDU_D4_INVERT_IDX];
                                                  idMask = frame[LIN_1_PDU_D3_MASK_IDX];
              
                                                  /* If user didn't reassign the status of ld_read_by_id_callout() then
                                                  * LD_NEGATIVE_RESPONSE will alwas be returned by ld_read_by_id_callout
             -(). This will
                                                  * indicate to master that the service by user defined identification i
             -s not
                                                  * supported. tempStatus will be used to hold status of ld_read_by_id_c
             -allout().
                                                  */
                                                  tempStatus = ld_read_by_id_callout(LIN_1_IFC_HANDLE,
                                                      frame[LIN_1_PDU_D1_IDX], frame + LIN_1_PDU_D1_IDX);
              
                                                  if((tempStatus == LD_NEGATIVE_RESPONSE) || (tempStatus == LD_NO_RESPON
             -SE))
                                                  {
                                                      /* Do nothing as there no response from user */
                                                  }
                                                  else
                                                  {
                                                      if(0u == ((frame[idByte + LIN_1_PDU_D1_IDX] ^ idInvert) & idMask))
                                                      {
                                                          /* Change NAD to new NAD */
                                                          LIN_1_nad = frame[LIN_1_PDU_D5_NEW_NAD_IDX];
              
                                                          /* Fill the SRF Buffer with response for a service */
                                                          /* Nad field should contain changed NAD */
                                                          LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                              LIN_1_nad;
              
                                                          /* PCI is 0 so only length required */
                                                          LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                                          /* The RSID for a positive response is always SID + 0x40 */
                                                          LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                              LIN_1_NCS_POS_RESP_COND_CHANGE_NAD;
              
                                                          /* Fill unused bytes with 0xFF */
                                                          for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                          {
                                                              LIN_1_srfBuffer[i] = 0xFFu;
                                                          }
              
                                                          /* Set the service response bit that indicates that the respon
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 69  

             -se is
                                                          * ready to be sent to master node.
                                                          */
                                                          LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                                      }
                                                      else
                                                      {
                                                          /* Do nothing ignore errorneous request */
                                                      }
                                                  }
                                              }
                                              else
                                              {
                                                  /* Do nothing ignore errorneous request */
                                              }
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB3_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB4_SEL))
              
                                          case LIN_1_NCS_DATA_DUMP:
              
                                              /* Not Supported */
              
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB4_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB5_SEL))
              
                                          /* LIN Slave Node Position Detection */
                                          case LIN_1_NCS_ASSIGN_NAD_SNPD:
              
                                              #if(1u == LIN_1_SAE_J2602)
              
                                                  LIN_1_ioctlStatus = LIN_1_IOCTL_STS_TARGET_RESET;
              
                                              #endif /* (1u == LIN_1_SAE_J2602) */
              
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB5_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB6_SEL))
              
                                          case LIN_1_NCS_SAVE_CONFIG:
              
                                              /* Set save configuration bit in the status register */
                                              LIN_1_ifcStatus |= LIN_1_IFC_STS_SAVE_CONFIG;
              
                                              /* Fill the SRF Buffer with response for a service */
                                              /* Nad field should contain current NAD */
                                              LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                  LIN_1_nad;
              
                                              /* PCI is 0 so only length required */
                                              LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                              /* The RSID for a positive response is always SID + 0x40 */
                                              LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                  LIN_1_NCS_POS_RESP_SAVE_CONFIG;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 70  

              
                                              /* Fill unused data bytes with 0xFFs */
                                              for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                              {
                                                  LIN_1_srfBuffer[i] = 0xFFu;
                                              }
              
                                              /* Set the service response bit that indicates that the response is
                                              * ready to be sent to master node.
                                              */
                                              LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
              
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB6_SEL) */
              
                                      #if(0u != (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB7_SEL))
              
                                          case LIN_1_NCS_ASSIGN_FRAME_ID_RANGE:
              
                                              /* Zero out the temp satus. It will be used as error counter. */
                                              tempStatus = 0u;
              
                                              for(i = 0u; i < LIN_1_NCS_MAX_FRAME_ID_RANGE; i++)
                                              {
                                                  if((i + frame[LIN_1_PDU_D1_START_IDX]) < LIN_1_NUM_FRAMES)
                                                  {
                                                      if((frame[i + LIN_1_PDU_D2_PID_IDX] !=
                                                          LIN_1_INVALID_FRAME_PID) &&
                                                              ((frame[i + LIN_1_PDU_D2_PID_IDX] &
                                                                  LIN_1_PID_PARITY_MASK) < LIN_1_FRAME_PID_MRF))
                                                      {
                                                          /* The unassigned value "0" is used to invalidate
                                                          *  this frame for transportation on the bus.
                                                          */
                                                          /* Set the new received PID value */
                                                          LIN_1_volatileConfig[i +
                                                              frame[LIN_1_PDU_D1_START_IDX]] =
                                                                  frame[i + LIN_1_PDU_D2_PID_IDX];
                                                      }
                                                      else if(frame[i + LIN_1_PDU_D2_PID_IDX] == 0xFFu)
                                                      {
                                                          /* Do nothing. */
                                                      }
                                                      else
                                                      {
                                                          /* Indicate an error by changing the status other then 0
                                                          * if the Frame ID is reserved.
                                                          */
                                                          tempStatus++;
                                                      }
                                                  }
                                                  else
                                                  {
                                                      if(frame[i + LIN_1_PDU_D2_PID_IDX] != 0xFFu)
                                                      {
                                                          tempStatus++;  /* Indicate an error by changing the status oth
             -er then 0 */
                                                      }
                                                  }
                                              }
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 71  

                                              if(tempStatus == 0u) /* No errors condition check */
                                              {
                                                  /* Fill the SRF Buffer with response for a service */
                                                  /* Nad field should contain current NAD */
                                                  LIN_1_srfBuffer[LIN_1_PDU_NAD_IDX] =
                                                      LIN_1_nad;
              
                                                  /* PCI is 0 so only length required */
                                                  LIN_1_srfBuffer[LIN_1_PDU_PCI_IDX] = 1u;
              
                                                  /* The RSID for a positive response is always SID + 0x40 */
                                                  LIN_1_srfBuffer[LIN_1_PDU_SID_IDX] =
                                                      LIN_1_NCS_POS_RESP_ASSIGN_FRAME_ID_RANGE;
              
                                                  /* Fill unused data bytes with 0xFFs */
                                                  for(i = 3u; i < LIN_1_FRAME_LEN; i++)
                                                  {
                                                      LIN_1_srfBuffer[i] = 0xFFu;
                                                  }
              
                                                  /* Set the service response bit that indicates that the response is
                                                  * ready to be sent to master node.
                                                  */
                                                  LIN_1_status |= LIN_1_STATUS_SRVC_RSP_RDY;
                                              }
                                              else
                                              {
                                                  /* Do nothing ignore errorneous request */
                                              }
              
                                          break;
              
                                      #endif /* (LIN_1_CS_SEL_SERVICES01 & LIN_1_NCS_0xB7_SEL) */
              
                                  #endif /* (1u == LIN_1_CS_ENABLED) */
              
                                  default:
              
                                     /* This will indicate that requested service is disabled and the Frame
                                     * will be "passed" to TL. This means user should process this Frame
                                     * properly using TL API.
                                     */
                                     LIN_1_tlFlags |= LIN_1_TL_CS_SERVICE_DISABLED;
              
                                     /* Indicates that detected SID is a diagnostic SID and it should be
                                     * passed to Transport Layer.
                                     */
                                    LIN_1_tlFlags |= LIN_1_TL_DIAG_FRAME_DETECTED;
              
                                  break;
                              }
              
                              if((0u != (LIN_1_tlFlags & LIN_1_TL_CS_SERVICE_DISABLED)) ||
                                  (0u != (LIN_1_tlFlags & LIN_1_TL_DIAG_FRAME_DETECTED)))
                              {
                                  /* SID used for diagnostics */
                                  if(frame[LIN_1_PDU_PCI_IDX] <= LIN_1_PDU_SF_DATA_LEN)
                                  {
                                      #if(1u == LIN_1_TL_API_FORMAT) /* Cooked API */
              
                                          /* Get one frame of a message if there is a message pending */
                                          if(LIN_1_rxTlStatus == LD_IN_PROGRESS)
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 72  

                                          {
                                              /* Make sure the pointer is points to the beginning of
                                              * receive buffer.
                                              */
                                              if(0u != (LIN_1_tlFlags & LIN_1_TL_CS_SERVICE_DISABLED))
                                              {
                                                  LIN_1_rxTlDataPointer = LIN_1_rxTlInitDataPointer;
                                              }
                                              else
                                              {
                                                  /* Do nothing */
                                              }
              
                                              /* Copy data to user buffer */
                                              for(i = 0u; i < frame[LIN_1_PDU_PCI_IDX]; i++)
                                              {
                                                  *LIN_1_rxTlDataPointer = frame[i + 2u];
                                                  LIN_1_rxTlDataPointer++;
                                              }
              
                                              /* Store the NAD */
                                              *LIN_1_tlNadPointer = frame[LIN_1_PDU_NAD_IDX];
              
                                              /* Get length of the data bytes */
                                              *LIN_1_tlLengthPointer = (l_u16) frame[LIN_1_PDU_PCI_IDX];
              
                                              /* Update length pointer properly */
                                              LIN_1_rxMessageLength = 0u;
              
                                              /* The SF message is received, so set the proper status */
                                              LIN_1_rxTlStatus = LD_COMPLETED;
                                          }
              
                                      #else /* Raw API */
              
                                          if(LIN_1_rxBufDepth < (LIN_1_TL_RX_QUEUE_LEN / 8u))
                                          {
                                              /* Fill the RX queue from a MRF buffer */
                                              for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                              {
                                                  LIN_1_rawRxQueue[LIN_1_rxWrIndex] = frame[i];
                                                  LIN_1_rxWrIndex++;
                                              }
              
                                              /* Read index should point to the next byte in MRF */
                                              if(LIN_1_rxWrIndex == LIN_1_TL_RX_QUEUE_LEN)
                                              {
                                                  LIN_1_rxWrIndex = 0u;
                                              }
              
                                              /* 8 Bytes copied to MRF - increment buffer depth */
                                              LIN_1_rxBufDepth++;
              
                                              /* Specification doesn't require status of queue full
                                              * so unconditionally set the status to data available
                                              */
                                              LIN_1_rxTlStatus = LD_DATA_AVAILABLE;
                                          }
              
                                      #endif /* (1u == LIN_1_TL_API_FORMAT) */
                                  }
                                  else
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 73  

                                  {
                                      /* Do nothing. Length is not valid the data should not be trusted. */
                                  }
              
                                  /* Clear Service Disabled and Diagnostic Frame detected bits
                                  * and process diagnostic frame receiving into a user buffer or MRF.
                                  */
                                  LIN_1_tlFlags &=
                                      ((l_u8) ~(LIN_1_TL_CS_SERVICE_DISABLED | LIN_1_TL_DIAG_FRAME_DETECTED));
                              }
                              else
                              {
                                  /* Do nothing. Length is not valid the data should not be trusted. */
                              }
                          }
                          else if((frame[LIN_1_PDU_PCI_IDX] & LIN_1_PDU_PCI_TYPE_MASK) ==
                              LIN_1_PDU_PCI_TYPE_FF)                                 /* First Frame detected */
                          {
                              if(frame[LIN_1_PDU_LEN_IDX] > LIN_1_FRAME_DATA_SIZE_7)
                              {
                                  #if(1u == LIN_1_TL_API_FORMAT)    /* Cooked API */
              
                                      /* Get one frame of a message if there is a message pending
                                      * and the PCI is valid
                                      */
                                      if((LIN_1_rxTlStatus == LD_IN_PROGRESS) &&
                                          (LIN_1_prevPci == LIN_1_PDU_PCI_TYPE_UNKNOWN ))
                                      {
                                          /* Store the result of condition check operand in temporary
                                          * variable. This will improve code readability and will remove
                                          * MISRA warning of uneven typecast.
                                          */
                                          tmpByte = (frame[LIN_1_PDU_PCI_IDX] &
                                              ((l_u8) ~LIN_1_PDU_PCI_TYPE_MASK));
              
                                          /* Following line allows to avoid violation of MISRA Rule 10.3:
                                          * "A composite expression of 'essentially unsigned' type (unsigned char)
                                          * is being cast to a wider unsigned type, 'unsigned int'."
                                          */
                                          tmpWord = (l_u16) tmpByte;
              
                                          tmpWord = ((l_u16) (tmpWord << 8u)) | ((l_u16) frame[LIN_1_PDU_LEN_IDX]);
              
                                          if(LIN_1_TL_BUF_LEN_MAX >= tmpWord)
                                          {
                                              /* Get First Frame Length with following two operations */
                                              *LIN_1_tlLengthPointer = (((l_u16)
                                                  frame[LIN_1_PDU_PCI_IDX]) &
                                                      ((l_u16) ((l_u8) ~LIN_1_PDU_PCI_TYPE_MASK)));
              
                                              *LIN_1_tlLengthPointer =
                                                  ((l_u16) (*LIN_1_tlLengthPointer << 8u)) |
                                                      ((l_u16) frame[LIN_1_PDU_LEN_IDX]);
              
                                              /* Copy Length to current length variable */
                                              LIN_1_rxMessageLength = *LIN_1_tlLengthPointer;
              
                                              for(i = 3u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                              {
                                                  *LIN_1_rxTlDataPointer = frame[i];   /* Get Frame Data */
                                                  LIN_1_rxTlDataPointer++;
                                              }
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 74  

              
                                              /* Update length pointer properly */
                                              LIN_1_rxMessageLength -= LIN_1_FRAME_DATA_SIZE_5;
              
                                              /* Save the state of the Frame Counter for monitor future possible errors 
             -*/
                                              LIN_1_rxFrameCounter = 0u;
              
                                              /* Save the PCI type */
                                              LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_FF;
                                          }
                                          else
                                          {
                                              /* Do nothing Length is invalid. */
                                          }
                                      }
              
                                  #else /* Raw API */
              
                                      if(LIN_1_rxBufDepth < (LIN_1_TL_RX_QUEUE_LEN / 8u))
                                      {
                                          /* Fill the MRF from a frame buffer */
                                          for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                          {
                                              LIN_1_rawRxQueue[LIN_1_rxWrIndex] = frame[i];
                                              LIN_1_rxWrIndex++;
                                          }
              
                                          /* Read index should point to the next byte in MRF */
                                          if(LIN_1_rxWrIndex == LIN_1_TL_RX_QUEUE_LEN)
                                          {
                                              LIN_1_rxWrIndex = 0u;
                                          }
              
                                          /* 8 Bytes copied to MRF - increment buffer depth */
                                          LIN_1_rxBufDepth++;
              
                                          /* Specification doesn't require status of queue full
                                          * so unconditionally set the status to data available
                                          */
                                          LIN_1_rxTlStatus = LD_DATA_AVAILABLE;
                                      }
              
                                  #endif /* (1u == LIN_1_TL_API_FORMAT) */
                              }
                              else
                              {
                                  /* Do nothing. Length is not valid the data should not be trusted. */
                              }
                          }
                          else if((frame[LIN_1_PDU_PCI_IDX] & LIN_1_PDU_PCI_TYPE_MASK) ==
                              LIN_1_PDU_PCI_TYPE_CF)                                 /* Consecutive Frames detected */
                          {
                              #if(1u == LIN_1_TL_API_FORMAT) /* Cooked API */
              
                                  /* Store previous PCI to avoid MISRA warning */
                                  tmpPci = LIN_1_prevPci;
              
                                  /* Get one frame of a message if there is a message pending and the
                                  * PCI is valid.
                                  */
                                  if((LIN_1_rxTlStatus == LD_IN_PROGRESS) &&
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 75  

                                      ((tmpPci == LIN_1_PDU_PCI_TYPE_FF) ||
                                          (tmpPci == LIN_1_PDU_PCI_TYPE_CF)))
                                  {
                                      /* Store the result of condition check operand in temporary
                                      * variable. This will improve code readability and will remove
                                      * MISRA warning of uneven typecast.
                                      */
                                      tmpByte = frame[LIN_1_PDU_PCI_IDX] & ((l_u8) ~LIN_1_PDU_PCI_TYPE_MASK);
              
                                      /* Check if frame counter is valid */
                                      if(((LIN_1_rxFrameCounter + 1u) == tmpByte) ||
                                              (((LIN_1_rxFrameCounter + 1u) == 16u) && (tmpByte == 0u)))
                                      {
                                          for(i = 2u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                          {
                                              *LIN_1_rxTlDataPointer = frame[i];    /* Get Frame Data */
                                              LIN_1_rxTlDataPointer++;
                                          }
              
                                          /* Save current Frame Counter */
                                          LIN_1_rxFrameCounter =
                                              frame[LIN_1_PDU_PCI_IDX] & ((l_u8) ~LIN_1_PDU_PCI_TYPE_MASK);
              
                                          /* Save the PCI type */
                                          LIN_1_prevPci = LIN_1_PDU_PCI_TYPE_CF;
              
                                          /* Update length pointer properly */
                                          if(LIN_1_rxMessageLength >= LIN_1_FRAME_DATA_SIZE_6)
                                          {
                                              LIN_1_rxMessageLength -= LIN_1_FRAME_DATA_SIZE_6;
                                          }
                                          else
                                          {
                                              LIN_1_rxMessageLength = 0u;
                                          }
                                      }
                                      else
                                      {
                                          /* Indicate an error if Frame Counter is invalid. */
                                          LIN_1_rxTlStatus = LD_WRONG_SN;
                                      }
                                  }
              
                              #else /* Raw API */
              
                                  if(LIN_1_rxBufDepth < (LIN_1_TL_RX_QUEUE_LEN / 8u))
                                  {
                                      /* Fill the MRF from a frame buffer */
                                      for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                                      {
                                          LIN_1_rawRxQueue[LIN_1_rxWrIndex] = frame[i];
                                          LIN_1_rxWrIndex++;
                                      }
              
                                      /* Read index should point to the next byte in MRF */
                                      if(LIN_1_rxWrIndex == LIN_1_TL_RX_QUEUE_LEN)
                                      {
                                          LIN_1_rxWrIndex = 0u;
                                      }
              
                                      /* 8 Bytes copied to MRF - increment buffer depth */
                                      LIN_1_rxBufDepth++;
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 76  

              
                                      /* Specification doesn't require status of queue full
                                      * so unconditionally set the status to data available
                                      */
                                      LIN_1_rxTlStatus = LD_DATA_AVAILABLE;
                                  }
              
                              #endif /* (1u == LIN_1_TL_API_FORMAT) */
                          }
                          else
                          {
                              /* Do nothing SID is invalid. */
                          }
                      }
                      else  /* Indicate an error */
                      {
                          #if(1u == LIN_1_TL_API_FORMAT) /* Cooked API */
              
                              /* Reception failed */
                              if((0u != (LIN_1_tlFlags & LIN_1_TL_RX_DIRECTION)) &&
                                  (0u != (LIN_1_tlFlags & LIN_1_TL_RX_REQUESTED)))
                              {
                                  LIN_1_rxTlStatus = LD_FAILED;
                              }
              
                          #endif /* (1u == LIN_1_TL_API_FORMAT) */
                      }
                  }
              
                  #if(1u == LIN_1_TL_API_FORMAT)
              
                      /*******************************************************************************
                      * Function Name: ld_send_message
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call packs the information specified by data and length into one or
                      *  multiple diagnostic frames. If the call is made in a master node application
                      *  the frames are transmitted to the slave node with the address NAD. If the
                      *  call is made in a slave node application the frames are transmitted to the
                      *  master node with the address NAD. The parameter NAD is not used in slave
                      *  nodes.
                      *
                      *  The value of the SID (or RSID) shall be the first byte in the data area.
                      *
                      *  Length must be in the range of 1 to 4095 bytes. The length shall also include
                      *  the SID (or RSID) value, i.e. message length plus one.
                      *
                      *  The call is asynchronous, i.e. not suspended until the message has been sent,
                      *  and the buffer may not be changed by the application as long as calls to
                      *  ld_tx_status returns LD_IN_PROGRESS.
                      *
                      *  The data is transmitted in suitable frames (master request frame for master
                      *  nodes and slave response frame for slave nodes).
                      *
                      *  If there is a message in progress, the call will return with no action.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *  length - Size of data to be sent in bytes.
                      *  nad - Address of the slave node to which data is sent.
                      *  data - Array of data to be sent. The value of the RSID is the first byte in
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 77  

                      *  the data area.
                      *
                      * Return:
                      *  None
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      void ld_send_message(l_ifc_handle iii, l_u16 length, l_u8 nad, const l_u8* const ld_data)
                                                                      
                      { volatile
                          l_u8 interruptState;
              
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          /* NAD isn't used in the slave node */
                          nad = nad;
              
                          if(LIN_1_txTlStatus != LD_IN_PROGRESS)
                          {
                              /* Interrupts can be disabled as the global variables used by LIN ISR
                              * is used below.
                              */
                              interruptState = CyEnterCriticalSection();
              
                              LIN_1_txTlDataPointer = ld_data;
              
                              /* Reset the data count */
                              LIN_1_txTlDataCount = 0u;
              
                              /* Set up the length pointer, Length shouldn't be greater then
                              * LIN_1_TL_BUF_LEN_MAX.
                              */
                              LIN_1_txMessageLength = length;
              
                              /* Indicates that there is a message in progress */
                              LIN_1_txTlStatus = LD_IN_PROGRESS;
              
                              /* Indicates that Cooked API requested transmit data */
                              LIN_1_tlFlags |= LIN_1_TL_TX_REQUESTED;
              
                              /* Restore the interrupt state */
                              CyExitCriticalSection(interruptState);
                          }
                      }
              
              
                      /*******************************************************************************
                      * Function Name: ld_receive_message
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call prepares the LIN diagnostic module to receive one message and store
                      *  it in the buffer pointed to by data. At the call, length shall specify the
                      *  maximum length allowed. When the reception has completed, length is changed
                      *  to the actual length and NAD to the NAD in the message.
                      *
                      *  SID (or RSID) will be the first byte in the data area.
                      *
                      *  Length will be in the range of 1 to 4095 bytes, but never more than the value
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 78  

                      *  originally set in the call. SID (or RSID) is included in the length.
                      *
                      *  The parameter NAD is not used in slave nodes.
                      *
                      *  The call is asynchronous, i.e. not suspended until the message has been
                      *  received, and the buffer may not be changed by the application as long as
                      *  calls to ld_rx_status returns LD_IN_PROGRESS. If the call is made after the
                      *  message transmission has commenced on the bus (i.e. the SF or FF is already
                      *  transmitted), this message will not be received. Instead the function will
                      *  wait until next message commence.
                      *
                      *  The data is received from the succeeding suitable frames (master request
                      *  frame for slave nodes and slave response frame for master nodes).
                      *
                      *  The application shall monitor the ld_rx_status and shall not call this
                      *  function until the status is LD_COMPLETED. Otherwise this function may
                      *  return inconsistent data in the parameters.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *  length: Size of data to be received in bytes.
                      *  nad: Address of the slave node from which data is received.
                      *  data: Array of data to be received. The value of the SID is the first byte
                      *  in the data area.
                      *
                      * Return:
                      *  None
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      void ld_receive_message(l_ifc_handle iii, l_u16* const length, l_u8* const nad, l_u8* const ld_dat
             -a)
                                                                      
                      {
                          l_u8 interruptState;
              
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          if(LIN_1_rxTlStatus != LD_IN_PROGRESS)
                          {
                              /* Interrupts can be disabled as the global variables used by LIN ISR
                              * is used below.
                              */
                              interruptState = CyEnterCriticalSection();
              
                              /* Set the user status bits */
                              LIN_1_rxTlStatus = LD_IN_PROGRESS;
              
                              /* Set up the data pointer */
                              LIN_1_rxTlDataPointer = ld_data;
              
                              /* Set up the initial data pointer that should
                              * always point to the beginning of a user buffer.
                              */
                              LIN_1_rxTlInitDataPointer = ld_data;
              
                              /* Set up the NAD pointer */
                              LIN_1_tlNadPointer = nad;
              
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 79  

                              /* Set up the length pointer */
                              LIN_1_tlLengthPointer = length;
              
                              LIN_1_rxMessageLength = *length;
              
                              /* Indicates that Cooked API requested receive data */
                              LIN_1_tlFlags |= LIN_1_TL_RX_REQUESTED;
              
                              /* Restore the interrupt state */
                              CyExitCriticalSection(interruptState);
                          }
                      }
              
              
                      /*******************************************************************************
                      * Function Name: ld_tx_status
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call returns the status of the last made call to ld_send_message.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *
                      * Return:
                      *  LD_IN_PROGRESS - The transmission is not yet completed.
                      *
                      *  LD_COMPLETED - The transmission has completed successfully (and you can
                      *                 issue a new ld_send_message call). This value is also
                      *                 returned after initialization of the Transport Layer.
                      *
                      *  LD_FAILED - The transmission ended in an error. The data was only partially
                      *              sent. The transport layer shall be reinitialized before
                      *              processing further messages. To find out why a transmission has
                      *              failed, check the status management function l_read_status.
                      *
                      *  LD_N_AS_TIMEOUT - The transmission failed because of a N_As timeout,
                      *
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      l_u8 ld_tx_status(l_ifc_handle iii) 
                      {
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          return(LIN_1_txTlStatus);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: ld_rx_status
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call returns the status of the last made call to ld_receive_message.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 80  

                      * Return:
                      *  LD_IN_PROGRESS - The reception is not yet completed.
                      *
                      *  LD_COMPLETED - The reception has completed successfully and all information
                      *                 (length, NAD, data) is available. (You can also issue a new
                      *                 ld_receive_message call). This value is also returned after
                      *                 initialization of the Tansport Layer.
                      *
                      *  LD_FAILED - The reception ended in an error. The data was only partially
                      *              received and should not be trusted. Initialize before processing
                      *              further transport layer messages. To find out why a reception
                      *              has failed, check the status management function l_read_status.
                      *
                      *  LD_N_CR_TIMEOUT - The reception failed because of a N_Cr timeout,
                      *
                      *  LD_WRONG_SN - The reception failed because of an unexpected sequence
                      *                number.
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      l_u8 ld_rx_status(l_ifc_handle iii) 
                      {
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          return(LIN_1_rxTlStatus);
                      }
              
              
                  #else
              
              
                      /*******************************************************************************
                      * Function Name: ld_put_raw
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call queues the transmission of 8 bytes of data in one frame. The data
                      *  is sent in the next suitable frame (slave response frame). The data area
                      *  will be copied in the call, the pointer will not be memorized. If no more
                      *  queue resources are available, the data may be jettisoned and the
                      *  appropriate error status will be set.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *  data - Array of data to be sent.
                      *
                      * Return:
                      *  None
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      void ld_put_raw(l_ifc_handle iii, const l_u8* const ld_data) 
                      {
                          l_u8 interruptState;
                          l_u8 i;
              
                          /* To remove unreferenced local variable warning */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 81  

                          iii = iii;
              
                          /* Interrupts can be disabled as the global variables used by LIN ISR
                          * is used below.
                          */
                          interruptState = CyEnterCriticalSection();
              
                          /* Copy data only when the buffer is not full */
                          if(LIN_1_txBufDepth < (LIN_1_TL_TX_QUEUE_LEN / 8u))
                          {
                              /* Copy 8 bytes of data to Raw TX queue buffer */
                              for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                              {
                                  /* Copy one byte of data to SRF buffer */
                                  LIN_1_rawTxQueue[LIN_1_txWrIndex] = *(ld_data + i);
                                  LIN_1_txWrIndex++;
                              }
              
                              /* If the end of the buffer is reached then reset the write index */
                              if(LIN_1_txWrIndex == LIN_1_TL_TX_QUEUE_LEN)
                              {
                                  LIN_1_txWrIndex = 0u;
                              }
              
                              /* 8 bytes of data were copied so increment a buffer depth */
                              LIN_1_txBufDepth++;
              
                              /* Update the status properly */
                              if(LIN_1_txBufDepth == (LIN_1_TL_TX_QUEUE_LEN / 8u))
                              {
                                  LIN_1_txTlStatus = LD_QUEUE_FULL;
                              }
                              else
                              {
                                  LIN_1_txTlStatus = LD_QUEUE_AVAILABLE;
                              }
                          }
              
                          /* Restore the interrupt state */
                          CyExitCriticalSection(interruptState);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: ld_get_raw
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call copies the oldest received diagnostic frame data to the memory
                      *  specified by data. The data returned is received from master request frame
                      *  If the receive queue is empty no data will be copied.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *  data - Array to which the oldest received diagnostic frame data will be
                      *  copied.
                      *
                      * Return:
                      *  None
                      *
                      * Reentrant:
                      *  No
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 82  

                      *
                      *******************************************************************************/
                      void ld_get_raw(l_ifc_handle iii, l_u8* const ld_data) 
                      {
                          l_u8 interruptState;
                          l_u8 i;
              
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          /* Interrupts can be disabled as the global variables used by LIN ISR
                          * is used below.
                          */
                          interruptState = CyEnterCriticalSection();
              
                          /* If queue is empty then do not copy anything */
                          if(LIN_1_rxBufDepth != 0u)
                          {
                              /* Copy 8 bytes of data from Raw RX queue buffer */
                              for(i = 0u; i < LIN_1_FRAME_DATA_SIZE_8; i++)
                              {
                                  *(ld_data + i) = LIN_1_rawRxQueue[LIN_1_rxRdIndex];
                                  LIN_1_rxRdIndex++;
                              }
              
                              /* 8 bytes of data were copied so decrement a buffer depth */
                              LIN_1_rxBufDepth--;
              
                              /* If the end of the buffer is reached then go to the start */
                              if(LIN_1_rxRdIndex == LIN_1_TL_RX_QUEUE_LEN)
                              {
                                  LIN_1_rxRdIndex = 0u;
                              }
              
                              /* Update the status properly */
                              if(LIN_1_rxBufDepth == 0u)
                              {
                                  LIN_1_rxTlStatus = LD_NO_DATA;
                              }
                              else
                              {
                                  LIN_1_rxTlStatus = LD_DATA_AVAILABLE;
                              }
                          }
              
                          /* Restore the interrupt state */
                          CyExitCriticalSection(interruptState);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: ld_raw_tx_status
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call returns the status of the raw frame transmission function.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *
                      * Return:
                      *  Status:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 83  

                      *   LD_QUEUE_EMPTY - The transmit queue is empty. In case previous calls to
                      *   ld_put_raw, all frames in the queue have been transmitted.
                      *
                      *   LD_QUEUE_AVAILABLE - The transmit queue contains entries, but is not full.
                      *
                      *   LD_QUEUE_FULL - The transmit queue is full and can not accept further
                      *   frames.
                      *
                      *   LD_TRANSMIT_ERROR - LIN protocol errors occurred during the transfer;
                      *   initialize and redo the transfer.
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      l_u8 ld_raw_tx_status(l_ifc_handle iii) 
                      {
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          return(LIN_1_txTlStatus);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: LIN_1_ld_raw_rx_status
                      ********************************************************************************
                      *
                      * Summary:
                      *  The call returns the status of the raw frame receive function.
                      *
                      * Parameters:
                      *  iii - Interface.
                      *
                      * Return:
                      *  Status:
                      *   LD_NO_DATA - The receive queue is empty.
                      *
                      *   LD_DATA_AVAILABLE - The receive queue contains data that can be read.
                      *
                      *   LD_RECEIVE_ERROR - LIN protocol errors occurred during the transfer;
                      *
                      *   initialize and redo the transfer.
                      *
                      * Reentrant:
                      *  No
                      *
                      *******************************************************************************/
                      l_u8 ld_raw_rx_status(l_ifc_handle iii) 
                      {
                          /* To remove unreferenced local variable warning */
                          iii = iii;
              
                          return(LIN_1_rxTlStatus);
                      }
              
                  #endif /* (1u == LIN_1_TL_API_FORMAT) */
              
              #endif /* (1u == LIN_1_TL_ENABLED) */
5095          
5096          
5097          /* [] END OF FILE */
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 84  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION LIN_1_Start (BEGIN)
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 256
0000 120000      R     LCALL   l_sys_init
0003 900000      R     MOV     DPTR,#returnValue
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
0008 120000      R     LCALL   l_ifc_init_LIN_1
                                           ; SOURCE LINE # 261
000B 900000      R     MOV     DPTR,#returnValue
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
                                           ; SOURCE LINE # 262
0010         ?C0001:
0010 22                RET     
             ; FUNCTION LIN_1_Start (END)

             ; FUNCTION LIN_1_Stop (BEGIN)
                                           ; SOURCE LINE # 279
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 282
0000 120000      E     LCALL   LIN_1_UART_Stop
                                           ; SOURCE LINE # 285
0003 90647C            MOV     DPTR,#0647CH
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 EF                MOV     A,R7
0009 54FE              ANL     A,#0FEH
000B FF                MOV     R7,A
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 288
000E 120000      R     LCALL   l_sys_irq_disable
                                           ; SOURCE LINE # 289
0011         ?C0002:
0011 22                RET     
             ; FUNCTION LIN_1_Stop (END)

             ; FUNCTION l_sys_init (BEGIN)
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 310
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 311
0002         ?C0003:
0002 22                RET     
             ; FUNCTION l_sys_init (END)

             ; FUNCTION _l_u8_rd (BEGIN)
                                           ; SOURCE LINE # 333
0000 900000      R     MOV     DPTR,#sss
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 337
0005 900000      R     MOV     DPTR,#sss
0008 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 85  

0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0005
0010 01                DB      01H
0011 0000              DW      00H
0013 0000        R     DW      ?C0006
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
0015         ?C0005:
                                           ; SOURCE LINE # 340
0015 120000      R     LCALL   l_u8_rd_seesaw_motor_status
0018 900000      R     MOV     DPTR,#returnValue
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 341
001D 8006              SJMP    ?C0004
                                           ; SOURCE LINE # 343
001F         ?C0006:
                                           ; SOURCE LINE # 344
001F 900000      R     MOV     DPTR,#returnValue
0022 74FF              MOV     A,#0FFH
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
0025         ?C0004:
                                           ; SOURCE LINE # 348
0025 900000      R     MOV     DPTR,#returnValue
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
                                           ; SOURCE LINE # 349
002A         ?C0007:
002A 22                RET     
             ; FUNCTION _l_u8_rd (END)

             ; FUNCTION l_u8_rd_seesaw_motor_status (BEGIN)
                                           ; SOURCE LINE # 367
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 370
0000 900000      R     MOV     DPTR,#LIN_1_Buffer_seesaw_motor
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 371
0005         ?C0008:
0005 22                RET     
             ; FUNCTION l_u8_rd_seesaw_motor_status (END)

             ; FUNCTION _l_bool_wr (BEGIN)
                                           ; SOURCE LINE # 401
0000 900000      R     MOV     DPTR,#sss
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#v
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 402
                                           ; SOURCE LINE # 403
000A 900000      R     MOV     DPTR,#sss
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 120000      E     LCALL   ?C?CCASE
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 86  

0013 0000        R     DW      ?C0010
0015 00                DB      00H
0016 0000              DW      00H
0018 0000        R     DW      ?C0012
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
001A         ?C0010:
                                           ; SOURCE LINE # 406
001A 900000      R     MOV     DPTR,#v
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F 120000      R     LCALL   _l_bool_wr_Response_Error
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 410
                                           ; SOURCE LINE # 411
                                           ; SOURCE LINE # 412
0022         ?C0012:
0022 22                RET     
             ; FUNCTION _l_bool_wr (END)

             ; FUNCTION _l_bool_wr_Response_Error (BEGIN)
                                           ; SOURCE LINE # 432
0000 900000      R     MOV     DPTR,#v
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 433
                                           ; SOURCE LINE # 437
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#interruptState
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
000D 900000      R     MOV     DPTR,#v
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 6010              JZ      ?C0013
                                           ; SOURCE LINE # 440
                                           ; SOURCE LINE # 441
0015 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B 4404              ORL     A,#04H
001D FF                MOV     R7,A
001E 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 443
0023 800E              SJMP    ?C0014
0025         ?C0013:
                                           ; SOURCE LINE # 445
                                           ; SOURCE LINE # 447
0025 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
002A EF                MOV     A,R7
002B 54FB              ANL     A,#0FBH
002D FF                MOV     R7,A
002E 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0031 EF                MOV     A,R7
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 87  

0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 448
0033         ?C0014:
                                           ; SOURCE LINE # 451
0033 900000      R     MOV     DPTR,#interruptState
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 452
003B 22                RET     
             ; FUNCTION _l_bool_wr_Response_Error (END)

             ; FUNCTION _l_flg_tst (BEGIN)
                                           ; SOURCE LINE # 482
0000 900000      R     MOV     DPTR,#fff
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 483
                                           ; SOURCE LINE # 486
0005 900000      R     MOV     DPTR,#fff
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0017
0010 00                DB      00H
0011 0000        R     DW      ?C0018
0013 01                DB      01H
0014 0000        R     DW      ?C0019
0016 02                DB      02H
0017 0000              DW      00H
0019 0000        R     DW      ?C0020
                                           ; SOURCE LINE # 487
                                           ; SOURCE LINE # 488
001B         ?C0017:
                                           ; SOURCE LINE # 489
001B 120000      R     LCALL   l_flg_tst_seesaw_motor_status
001E 900000      R     MOV     DPTR,#returnValue
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 490
0023 801A              SJMP    ?C0016
                                           ; SOURCE LINE # 492
0025         ?C0018:
                                           ; SOURCE LINE # 493
0025 120000      R     LCALL   l_flg_tst_Frame1
0028 900000      R     MOV     DPTR,#returnValue
002B EF                MOV     A,R7
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 494
002D 8010              SJMP    ?C0016
                                           ; SOURCE LINE # 496
002F         ?C0019:
                                           ; SOURCE LINE # 497
002F 120000      R     LCALL   l_flg_tst_seesaw_motor
0032 900000      R     MOV     DPTR,#returnValue
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 498
0037 8006              SJMP    ?C0016
                                           ; SOURCE LINE # 500
0039         ?C0020:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 88  

                                           ; SOURCE LINE # 501
0039 900000      R     MOV     DPTR,#returnValue
003C 7401              MOV     A,#01H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 502
                                           ; SOURCE LINE # 503
003F         ?C0016:
                                           ; SOURCE LINE # 505
003F 900000      R     MOV     DPTR,#returnValue
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
                                           ; SOURCE LINE # 506
0044         ?C0021:
0044 22                RET     
             ; FUNCTION _l_flg_tst (END)

             ; FUNCTION l_flg_tst_seesaw_motor_status (BEGIN)
                                           ; SOURCE LINE # 527
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 529
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 531
0005 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5401              ANL     A,#01H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0022
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 535
001A         ?C0022:
                                           ; SOURCE LINE # 537
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 538
001F         ?C0023:
001F 22                RET     
             ; FUNCTION l_flg_tst_seesaw_motor_status (END)

             ; FUNCTION l_flg_tst_Frame1 (BEGIN)
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 559
                                           ; SOURCE LINE # 560
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 562
0005 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 89  

000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0024
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 565
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 566
001A         ?C0024:
                                           ; SOURCE LINE # 568
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 569
001F         ?C0025:
001F 22                RET     
             ; FUNCTION l_flg_tst_Frame1 (END)

             ; FUNCTION l_flg_tst_seesaw_motor (BEGIN)
                                           ; SOURCE LINE # 589
                                           ; SOURCE LINE # 590
                                           ; SOURCE LINE # 591
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 593
0005 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5404              ANL     A,#04H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0026
                                           ; SOURCE LINE # 595
                                           ; SOURCE LINE # 596
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 597
001A         ?C0026:
                                           ; SOURCE LINE # 599
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 600
001F         ?C0027:
001F 22                RET     
             ; FUNCTION l_flg_tst_seesaw_motor (END)

             ; FUNCTION _l_flg_clr (BEGIN)
                                           ; SOURCE LINE # 624
0000 900000      R     MOV     DPTR,#fff
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 625
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 90  

                                           ; SOURCE LINE # 626
0005 900000      R     MOV     DPTR,#fff
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0029
0010 00                DB      00H
0011 0000        R     DW      ?C0030
0013 01                DB      01H
0014 0000        R     DW      ?C0031
0016 02                DB      02H
0017 0000              DW      00H
0019 0000        R     DW      ?C0033
                                           ; SOURCE LINE # 627
                                           ; SOURCE LINE # 628
001B         ?C0029:
                                           ; SOURCE LINE # 629
001B 120000      R     LCALL   l_flg_clr_seesaw_motor_status
                                           ; SOURCE LINE # 630
001E 22                RET     
                                           ; SOURCE LINE # 632
001F         ?C0030:
                                           ; SOURCE LINE # 633
001F 120000      R     LCALL   l_flg_clr_Frame1
                                           ; SOURCE LINE # 634
0022 22                RET     
                                           ; SOURCE LINE # 636
0023         ?C0031:
                                           ; SOURCE LINE # 637
0023 120000      R     LCALL   l_flg_clr_seesaw_motor
                                           ; SOURCE LINE # 638
                                           ; SOURCE LINE # 640
                                           ; SOURCE LINE # 641
                                           ; SOURCE LINE # 642
                                           ; SOURCE LINE # 643
0026         ?C0033:
0026 22                RET     
             ; FUNCTION _l_flg_clr (END)

             ; FUNCTION l_flg_clr_seesaw_motor_status (BEGIN)
                                           ; SOURCE LINE # 663
                                           ; SOURCE LINE # 664
                                           ; SOURCE LINE # 666
0000 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 54FE              ANL     A,#0FEH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 667
000E 22                RET     
             ; FUNCTION l_flg_clr_seesaw_motor_status (END)

             ; FUNCTION l_flg_clr_Frame1 (BEGIN)
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 687
                                           ; SOURCE LINE # 689
0000 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 91  

0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 54FD              ANL     A,#0FDH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
000E 22                RET     
             ; FUNCTION l_flg_clr_Frame1 (END)

             ; FUNCTION l_flg_clr_seesaw_motor (BEGIN)
                                           ; SOURCE LINE # 709
                                           ; SOURCE LINE # 710
                                           ; SOURCE LINE # 712
0000 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 54FB              ANL     A,#0FBH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 713
000E 22                RET     
             ; FUNCTION l_flg_clr_seesaw_motor (END)

             ; FUNCTION l_ifc_init_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 743
                                           ; SOURCE LINE # 744
                                           ; SOURCE LINE # 749
0000 7D07              MOV     R5,#07H
0002 7F00              MOV     R7,#00H
0004 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 752
0007 7C00        E     MOV     R4,#HIGH LIN_1_BLIN_ISR
0009 7D00        E     MOV     R5,#LOW LIN_1_BLIN_ISR
000B 7F00              MOV     R7,#00H
000D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 755
0010 9044D8            MOV     DPTR,#044D8H
0013 7401              MOV     A,#01H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 758
0016 9044D8            MOV     DPTR,#044D8H
0019 7401              MOV     A,#01H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
001C 7D07              MOV     R5,#07H
001E 7F01              MOV     R7,#01H
0020 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 764
0023 7C00        E     MOV     R4,#HIGH LIN_1_UART_ISR
0025 7D00        E     MOV     R5,#LOW LIN_1_UART_ISR
0027 7F01              MOV     R7,#01H
0029 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 767
002C 120000      E     LCALL   LIN_1_UART_Start
                                           ; SOURCE LINE # 770
002F 906428            MOV     DPTR,#06428H
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 92  

0032 74B0              MOV     A,#0B0H
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 773
0035 906488            MOV     DPTR,#06488H
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A EF                MOV     A,R7
003B 440D              ORL     A,#0DH
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 777
0040 120000      E     LCALL   CyEnterCriticalSection
0043 900000      R     MOV     DPTR,#interruptState
0046 EF                MOV     A,R7
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0048 906498            MOV     DPTR,#06498H
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
004D EF                MOV     A,R7
004E 4410              ORL     A,#010H
0050 FF                MOV     R7,A
0051 EF                MOV     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
0053 900000      R     MOV     DPTR,#interruptState
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 787
005B 906528            MOV     DPTR,#06528H
005E E4                CLR     A
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
0060 906538            MOV     DPTR,#06538H
0063 7478              MOV     A,#078H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 797
0066 120000      E     LCALL   LIN_1_IntClk_GetDividerRegister
0069 900000      R     MOV     DPTR,#LIN_1_initialClockDivider
006C EE                MOV     A,R6
006D F0                MOVX    @DPTR,A
006E A3                INC     DPTR
006F EF                MOV     A,R7
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 802
0071 90647C            MOV     DPTR,#0647CH
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 EF                MOV     A,R7
0077 4401              ORL     A,#01H
0079 FF                MOV     R7,A
007A EF                MOV     A,R7
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 805
007C 900000      R     MOV     DPTR,#i
007F E4                CLR     A
0080 F0                MOVX    @DPTR,A
0081         ?C0037:
0081 900000      R     MOV     DPTR,#i
0084 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 93  

0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 C3                CLR     C
0088 9402              SUBB    A,#02H
008A 5024              JNC     ?C0038
                                           ; SOURCE LINE # 806
                                           ; SOURCE LINE # 807
008C 900000      R     MOV     DPTR,#i
008F E0                MOVX    A,@DPTR
0090 FF                MOV     R7,A
0091 EF                MOV     A,R7
0092 900000      R     MOV     DPTR,#LIN_1_LinSlaveConfig
0095 93                MOVC    A,@A+DPTR
0096 FF                MOV     R7,A
0097 900000      R     MOV     DPTR,#i
009A E0                MOVX    A,@DPTR
009B FE                MOV     R6,A
009C 7400        R     MOV     A,#LOW LIN_1_volatileConfig
009E 2E                ADD     A,R6
009F F582              MOV     DPL,A
00A1 E4                CLR     A
00A2 3400        R     ADDC    A,#HIGH LIN_1_volatileConfig
00A4 F583              MOV     DPH,A
00A6 EF                MOV     A,R7
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 808
00A8 900000      R     MOV     DPTR,#i
00AB E0                MOVX    A,@DPTR
00AC 04                INC     A
00AD F0                MOVX    @DPTR,A
00AE 80D1              SJMP    ?C0037
00B0         ?C0038:
                                           ; SOURCE LINE # 817
00B0 900000      R     MOV     DPTR,#LIN_1_ifcStatus
00B3 E0                MOVX    A,@DPTR
00B4 FE                MOV     R6,A
00B5 A3                INC     DPTR
00B6 E0                MOVX    A,@DPTR
00B7 FF                MOV     R7,A
00B8 7E00              MOV     R6,#00H
00BA 7F00              MOV     R7,#00H
00BC 900000      R     MOV     DPTR,#LIN_1_ifcStatus
00BF EE                MOV     A,R6
00C0 F0                MOVX    @DPTR,A
00C1 A3                INC     DPTR
00C2 EF                MOV     A,R7
00C3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 820
00C4 9044C0            MOV     DPTR,#044C0H
00C7 7401              MOV     A,#01H
00C9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 823
00CA 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 824
00CC         ?C0040:
00CC 22                RET     
             ; FUNCTION l_ifc_init_LIN_1 (END)

             ; FUNCTION _l_ifc_init (BEGIN)
                                           ; SOURCE LINE # 849
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 94  

0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 850
                                           ; SOURCE LINE # 853
0005 900000      R     MOV     DPTR,#iii
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0042
0010 00                DB      00H
0011 0000              DW      00H
0013 0000        R     DW      ?C0043
                                           ; SOURCE LINE # 854
                                           ; SOURCE LINE # 855
0015         ?C0042:
                                           ; SOURCE LINE # 856
0015 120000      R     LCALL   l_ifc_init_LIN_1
0018 900000      R     MOV     DPTR,#returnValue
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 857
001D 8006              SJMP    ?C0041
                                           ; SOURCE LINE # 859
001F         ?C0043:
                                           ; SOURCE LINE # 861
001F 900000      R     MOV     DPTR,#returnValue
0022 7401              MOV     A,#01H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 862
                                           ; SOURCE LINE # 863
0025         ?C0041:
                                           ; SOURCE LINE # 865
0025 900000      R     MOV     DPTR,#returnValue
0028 E0                MOVX    A,@DPTR
0029 FF                MOV     R7,A
                                           ; SOURCE LINE # 866
002A         ?C0044:
002A 22                RET     
             ; FUNCTION _l_ifc_init (END)

             ; FUNCTION l_ifc_wake_up_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 887
                                           ; SOURCE LINE # 888
                                           ; SOURCE LINE # 890
0000 90647C            MOV     DPTR,#0647CH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 4402              ORL     A,#02H
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 893
000B 7F2C              MOV     R7,#02CH
000D 7E01              MOV     R6,#01H
000F 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 896
0012 90647C            MOV     DPTR,#0647CH
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 EF                MOV     A,R7
0018 54FD              ANL     A,#0FDH
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 95  

001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 897
001D 22                RET     
             ; FUNCTION l_ifc_wake_up_LIN_1 (END)

             ; FUNCTION _l_ifc_wake_up (BEGIN)
                                           ; SOURCE LINE # 918
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 919
                                           ; SOURCE LINE # 920
0005 900000      R     MOV     DPTR,#iii
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0047
0010 00                DB      00H
0011 0000              DW      00H
0013 0000        R     DW      ?C0049
                                           ; SOURCE LINE # 921
                                           ; SOURCE LINE # 922
0015         ?C0047:
                                           ; SOURCE LINE # 923
0015 120000      R     LCALL   l_ifc_wake_up_LIN_1
                                           ; SOURCE LINE # 924
                                           ; SOURCE LINE # 926
                                           ; SOURCE LINE # 928
                                           ; SOURCE LINE # 929
                                           ; SOURCE LINE # 930
0018         ?C0049:
0018 22                RET     
             ; FUNCTION _l_ifc_wake_up (END)

             ; FUNCTION _l_ifc_ioctl_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 991
0000 900000      R     MOV     DPTR,#op
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#pv
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 992
                                           ; SOURCE LINE # 996
000B 900000      R     MOV     DPTR,#returnValue
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
0010 A3                INC     DPTR
0011 E4                CLR     A
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 999
0013 900000      R     MOV     DPTR,#op
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 120000      E     LCALL   ?C?CCASE
001C 0000        R     DW      ?C0051
001E 00                DB      00H
001F 0000        R     DW      ?C0052
0021 01                DB      01H
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 96  

0022 0000        R     DW      ?C0053
0024 02                DB      02H
0025 0000        R     DW      ?C0056
0027 03                DB      03H
0028 0000        R     DW      ?C0058
002A 04                DB      04H
002B 0000              DW      00H
002D 0000        R     DW      ?C0059
                                           ; SOURCE LINE # 1000
                                           ; SOURCE LINE # 1004
002F         ?C0051:
                                           ; SOURCE LINE # 1007
002F 900000      R     MOV     DPTR,#LIN_1_ioctlStatus
0032 E0                MOVX    A,@DPTR
0033 FE                MOV     R6,A
0034 A3                INC     DPTR
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 900000      R     MOV     DPTR,#returnValue
003A EE                MOV     A,R6
003B F0                MOVX    @DPTR,A
003C A3                INC     DPTR
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1010
003F 900000      R     MOV     DPTR,#LIN_1_ioctlStatus
0042 E4                CLR     A
0043 F0                MOVX    @DPTR,A
0044 A3                INC     DPTR
0045 E4                CLR     A
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1012
0047 020000      R     LJMP    ?C0050
                                           ; SOURCE LINE # 1017
004A         ?C0052:
                                           ; SOURCE LINE # 1019
004A 120000      E     LCALL   CyEnterCriticalSection
004D 900000      R     MOV     DPTR,#interruptState
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1022
0052 900000      R     MOV     DPTR,#pv
0055 120000      E     LCALL   ?C?PLDXDATA
0058 120000      E     LCALL   ?C?ILDPTR
005B FF                MOV     R7,A
005C AEF0              MOV     R6,B
005E EF                MOV     A,R7
005F 24FF              ADD     A,#0FFH
0061 FF                MOV     R7,A
0062 EE                MOV     A,R6
0063 34FF              ADDC    A,#0FFH
0065 FE                MOV     R6,A
0066 7D00              MOV     R5,#00H
0068 120000      E     LCALL   _LIN_1_IntClk_SetDividerRegister
                                           ; SOURCE LINE # 1030
006B 900000      R     MOV     DPTR,#pv
006E 120000      E     LCALL   ?C?PLDXDATA
0071 120000      E     LCALL   ?C?ILDPTR
0074 FF                MOV     R7,A
0075 AEF0              MOV     R6,B
0077 7C00              MOV     R4,#00H
0079 7D0A              MOV     R5,#0AH
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 97  

007B 120000      E     LCALL   ?C?UIDIV
007E EF                MOV     A,R7
007F C4                SWAP    A
0080 F8                MOV     R0,A
0081 540F              ANL     A,#0FH
0083 C8                XCH     A,R0
0084 68                XRL     A,R0
0085 FF                MOV     R7,A
0086 EE                MOV     A,R6
0087 C4                SWAP    A
0088 54F0              ANL     A,#0F0H
008A 48                ORL     A,R0
008B FE                MOV     R6,A
008C EE                MOV     A,R6
008D FF                MOV     R7,A
008E 7E00              MOV     R6,#00H
0090 EF                MOV     A,R7
0091 14                DEC     A
0092 FF                MOV     R7,A
0093 906528            MOV     DPTR,#06528H
0096 EF                MOV     A,R7
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1038
0098 900000      R     MOV     DPTR,#pv
009B 120000      E     LCALL   ?C?PLDXDATA
009E 120000      E     LCALL   ?C?ILDPTR
00A1 FF                MOV     R7,A
00A2 AEF0              MOV     R6,B
00A4 7C00              MOV     R4,#00H
00A6 7D0A              MOV     R5,#0AH
00A8 120000      E     LCALL   ?C?UIDIV
00AB EF                MOV     A,R7
00AC C4                SWAP    A
00AD 54F0              ANL     A,#0F0H
00AF FF                MOV     R7,A
00B0 906538            MOV     DPTR,#06538H
00B3 EF                MOV     A,R7
00B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1042
00B5 900000      R     MOV     DPTR,#interruptState
00B8 E0                MOVX    A,@DPTR
00B9 FF                MOV     R7,A
00BA 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1044
00BD 020000      R     LJMP    ?C0050
                                           ; SOURCE LINE # 1050
00C0         ?C0053:
                                           ; SOURCE LINE # 1052
00C0 90647C            MOV     DPTR,#0647CH
00C3 E0                MOVX    A,@DPTR
00C4 FF                MOV     R7,A
00C5 900000      R     MOV     DPTR,#LIN_1_backup+01H
00C8 EF                MOV     A,R7
00C9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1054
00CA 90647C            MOV     DPTR,#0647CH
00CD E0                MOVX    A,@DPTR
00CE FF                MOV     R7,A
00CF EF                MOV     A,R7
00D0 30E008            JNB     ACC.0,?C0054
                                           ; SOURCE LINE # 1055
                                           ; SOURCE LINE # 1056
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 98  

00D3 900000      R     MOV     DPTR,#LIN_1_backup
00D6 7401              MOV     A,#01H
00D8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1057
00D9 8005              SJMP    ?C0055
00DB         ?C0054:
                                           ; SOURCE LINE # 1059
                                           ; SOURCE LINE # 1060
00DB 900000      R     MOV     DPTR,#LIN_1_backup
00DE E4                CLR     A
00DF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1061
00E0         ?C0055:
                                           ; SOURCE LINE # 1064
00E0 120000      R     LCALL   l_sys_irq_disable
                                           ; SOURCE LINE # 1067
00E3 120000      E     LCALL   LIN_1_UART_Sleep
                                           ; SOURCE LINE # 1070
00E6 90647C            MOV     DPTR,#0647CH
00E9 E0                MOVX    A,@DPTR
00EA FF                MOV     R7,A
00EB EF                MOV     A,R7
00EC 54FE              ANL     A,#0FEH
00EE FF                MOV     R7,A
00EF EF                MOV     A,R7
00F0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1072
00F1 906488            MOV     DPTR,#06488H
00F4 E0                MOVX    A,@DPTR
00F5 FF                MOV     R7,A
00F6 900000      R     MOV     DPTR,#LIN_1_backup+02H
00F9 EF                MOV     A,R7
00FA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1076
00FB 906528            MOV     DPTR,#06528H
00FE E0                MOVX    A,@DPTR
00FF FF                MOV     R7,A
0100 900000      R     MOV     DPTR,#LIN_1_backup+03H
0103 EF                MOV     A,R7
0104 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1077
0105 906538            MOV     DPTR,#06538H
0108 E0                MOVX    A,@DPTR
0109 FF                MOV     R7,A
010A 900000      R     MOV     DPTR,#LIN_1_backup+04H
010D EF                MOV     A,R7
010E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1081
010F 8054              SJMP    ?C0050
                                           ; SOURCE LINE # 1087
0111         ?C0056:
                                           ; SOURCE LINE # 1089
0111 900000      R     MOV     DPTR,#LIN_1_backup+02H
0114 E0                MOVX    A,@DPTR
0115 FF                MOV     R7,A
0116 906488            MOV     DPTR,#06488H
0119 EF                MOV     A,R7
011A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1093
011B 900000      R     MOV     DPTR,#LIN_1_backup+03H
011E E0                MOVX    A,@DPTR
011F FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 99  

0120 906528            MOV     DPTR,#06528H
0123 EF                MOV     A,R7
0124 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1094
0125 900000      R     MOV     DPTR,#LIN_1_backup+04H
0128 E0                MOVX    A,@DPTR
0129 FF                MOV     R7,A
012A 906538            MOV     DPTR,#06538H
012D EF                MOV     A,R7
012E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
012F 900000      R     MOV     DPTR,#LIN_1_backup+01H
0132 E0                MOVX    A,@DPTR
0133 FF                MOV     R7,A
0134 90647C            MOV     DPTR,#0647CH
0137 EF                MOV     A,R7
0138 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1101
0139 120000      E     LCALL   LIN_1_UART_Wakeup
                                           ; SOURCE LINE # 1103
013C 900000      R     MOV     DPTR,#LIN_1_backup
013F E0                MOVX    A,@DPTR
0140 FF                MOV     R7,A
0141 EF                MOV     A,R7
0142 6021              JZ      ?C0050
                                           ; SOURCE LINE # 1104
                                           ; SOURCE LINE # 1105
0144 7F03              MOV     R7,#03H
0146 120000      R     LCALL   _l_sys_irq_restore
                                           ; SOURCE LINE # 1106
                                           ; SOURCE LINE # 1108
0149 801A              SJMP    ?C0050
                                           ; SOURCE LINE # 1112
014B         ?C0058:
                                           ; SOURCE LINE # 1115
014B 900000      R     MOV     DPTR,#LIN_1_syncCounts
014E E0                MOVX    A,@DPTR
014F FF                MOV     R7,A
0150 7E00              MOV     R6,#00H
0152 900000      R     MOV     DPTR,#returnValue
0155 EE                MOV     A,R6
0156 F0                MOVX    @DPTR,A
0157 A3                INC     DPTR
0158 EF                MOV     A,R7
0159 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1117
015A 8009              SJMP    ?C0050
                                           ; SOURCE LINE # 1133
015C         ?C0059:
                                           ; SOURCE LINE # 1135
015C 900000      R     MOV     DPTR,#returnValue
015F E4                CLR     A
0160 F0                MOVX    @DPTR,A
0161 A3                INC     DPTR
0162 7401              MOV     A,#01H
0164 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1136
                                           ; SOURCE LINE # 1137
0165         ?C0050:
                                           ; SOURCE LINE # 1139
0165 900000      R     MOV     DPTR,#returnValue
0168 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 100 

0169 FE                MOV     R6,A
016A A3                INC     DPTR
016B E0                MOVX    A,@DPTR
016C FF                MOV     R7,A
                                           ; SOURCE LINE # 1140
016D         ?C0060:
016D 22                RET     
             ; FUNCTION _l_ifc_ioctl_LIN_1 (END)

             ; FUNCTION _l_ifc_ioctl (BEGIN)
                                           ; SOURCE LINE # 1203
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#op
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
000A 900000      R     MOV     DPTR,#pv
000D 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1204
                                           ; SOURCE LINE # 1207
0010 900000      R     MOV     DPTR,#iii
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 120000      E     LCALL   ?C?CCASE
0019 0000        R     DW      ?C0062
001B 00                DB      00H
001C 0000              DW      00H
001E 0000        R     DW      ?C0063
                                           ; SOURCE LINE # 1208
                                           ; SOURCE LINE # 1209
0020         ?C0062:
                                           ; SOURCE LINE # 1210
0020 900000      R     MOV     DPTR,#op
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 900000      R     MOV     DPTR,#pv
0028 120000      E     LCALL   ?C?PLDXDATA
002B 120000      R     LCALL   _l_ifc_ioctl_LIN_1
002E 900000      R     MOV     DPTR,#returnValue
0031 EE                MOV     A,R6
0032 F0                MOVX    @DPTR,A
0033 A3                INC     DPTR
0034 EF                MOV     A,R7
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1211
0036 8009              SJMP    ?C0061
                                           ; SOURCE LINE # 1213
0038         ?C0063:
                                           ; SOURCE LINE # 1215
0038 900000      R     MOV     DPTR,#returnValue
003B E4                CLR     A
003C F0                MOVX    @DPTR,A
003D A3                INC     DPTR
003E 7401              MOV     A,#01H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1216
                                           ; SOURCE LINE # 1217
0041         ?C0061:
                                           ; SOURCE LINE # 1219
0041 900000      R     MOV     DPTR,#returnValue
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 101 

0044 E0                MOVX    A,@DPTR
0045 FE                MOV     R6,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
                                           ; SOURCE LINE # 1220
0049         ?C0064:
0049 22                RET     
             ; FUNCTION _l_ifc_ioctl (END)

             ; FUNCTION l_ifc_rx_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 1241
                                           ; SOURCE LINE # 1242
                                           ; SOURCE LINE # 1290
0000 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5408              ANL     A,#08H
0008 FF                MOV     R7,A
0009 7E00              MOV     R6,#00H
000B EF                MOV     A,R7
000C 4E                ORL     A,R6
000D 7005              JNZ     ?C0065
                                           ; SOURCE LINE # 1291
                                           ; SOURCE LINE # 1293
000F 7F01              MOV     R7,#01H
0011 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1294
0014         ?C0065:
                                           ; SOURCE LINE # 1297
0014 120000      E     LCALL   LIN_1_UART_ReadRxStatus
0017 EF                MOV     A,R7
0018 30E331            JNB     ACC.3,?C0066
                                           ; SOURCE LINE # 1298
                                           ; SOURCE LINE # 1307
001B 900000      R     MOV     DPTR,#LIN_1_fsmFlags
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 4480              ORL     A,#080H
0023 FF                MOV     R7,A
0024 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1311
0029 120000      E     LCALL   CyEnterCriticalSection
002C 900000      R     MOV     DPTR,#interruptState
002F EF                MOV     A,R7
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1313
0031 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 4404              ORL     A,#04H
0039 FF                MOV     R7,A
003A 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1317
003F 900000      R     MOV     DPTR,#interruptState
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 102 

0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1321
0047 7F10              MOV     R7,#010H
0049 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1322
004C         ?C0066:
                                           ; SOURCE LINE # 1324
004C 900000      R     MOV     DPTR,#LIN_1_uartFsmState
004F E0                MOVX    A,@DPTR
0050 FF                MOV     R7,A
0051 EF                MOV     A,R7
0052 120000      E     LCALL   ?C?CCASE
0055 0000        R     DW      ?C0068
0057 01                DB      01H
0058 0000        R     DW      ?C0080
005A 02                DB      02H
005B 0000        R     DW      ?C0088
005D 03                DB      03H
005E 0000        R     DW      ?C0092
0060 04                DB      04H
0061 0000              DW      00H
0063 0000        R     DW      ?C0103
                                           ; SOURCE LINE # 1325
                                           ; SOURCE LINE # 1383
0065         ?C0068:
                                           ; SOURCE LINE # 1386
0065 120000      E     LCALL   LIN_1_UART_ReadRxData
0068 900000      R     MOV     DPTR,#LIN_1_framePid
006B EF                MOV     A,R7
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1389
006D 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
0070 E4                CLR     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1392
0072 900000      R     MOV     DPTR,#LIN_1_framePid
0075 E0                MOVX    A,@DPTR
0076 FF                MOV     R7,A
0077 EF                MOV     A,R7
0078 543F              ANL     A,#03FH
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 900000      R     MOV     DPTR,#LIN_1_parityTable
007F 93                MOVC    A,@A+DPTR
0080 FF                MOV     R7,A
0081 900000      R     MOV     DPTR,#LIN_1_framePid
0084 E0                MOVX    A,@DPTR
0085 FE                MOV     R6,A
0086 EF                MOV     A,R7
0087 6E                XRL     A,R6
0088 6032              JZ      ?C0069
                                           ; SOURCE LINE # 1394
                                           ; SOURCE LINE # 1396
008A 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
008D E0                MOVX    A,@DPTR
008E FF                MOV     R7,A
008F EF                MOV     A,R7
0090 4401              ORL     A,#01H
0092 FF                MOV     R7,A
0093 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 103 

0096 EF                MOV     A,R7
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1407
0098 120000      E     LCALL   CyEnterCriticalSection
009B 900000      R     MOV     DPTR,#interruptState
009E EF                MOV     A,R7
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1409
00A0 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
00A3 E0                MOVX    A,@DPTR
00A4 FF                MOV     R7,A
00A5 EF                MOV     A,R7
00A6 4404              ORL     A,#04H
00A8 FF                MOV     R7,A
00A9 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
00AC EF                MOV     A,R7
00AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1413
00AE 900000      R     MOV     DPTR,#interruptState
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
00B3 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1417
00B6 7F10              MOV     R7,#010H
00B8 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1418
00BB 22                RET     
00BC         ?C0069:
                                           ; SOURCE LINE # 1420
                                           ; SOURCE LINE # 1422
00BC 900000      R     MOV     DPTR,#LIN_1_framePid
00BF E0                MOVX    A,@DPTR
00C0 FF                MOV     R7,A
00C1 EF                MOV     A,R7
00C2 643C              XRL     A,#03CH
00C4 600A              JZ      ?C0072
00C6 900000      R     MOV     DPTR,#LIN_1_framePid
00C9 E0                MOVX    A,@DPTR
00CA FF                MOV     R7,A
00CB EF                MOV     A,R7
00CC 647D              XRL     A,#07DH
00CE 7032              JNZ     ?C0071
00D0         ?C0072:
                                           ; SOURCE LINE # 1424
                                           ; SOURCE LINE # 1759
00D0 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
00D3 E0                MOVX    A,@DPTR
00D4 FF                MOV     R7,A
00D5 EF                MOV     A,R7
00D6 4401              ORL     A,#01H
00D8 FF                MOV     R7,A
00D9 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
00DC EF                MOV     A,R7
00DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1770
00DE 120000      E     LCALL   CyEnterCriticalSection
00E1 900000      R     MOV     DPTR,#interruptState
00E4 EF                MOV     A,R7
00E5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1772
00E6 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
00E9 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 104 

00EA FF                MOV     R7,A
00EB EF                MOV     A,R7
00EC 4404              ORL     A,#04H
00EE FF                MOV     R7,A
00EF 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
00F2 EF                MOV     A,R7
00F3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1776
00F4 900000      R     MOV     DPTR,#interruptState
00F7 E0                MOVX    A,@DPTR
00F8 FF                MOV     R7,A
00F9 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1780
00FC 7F01              MOV     R7,#01H
00FE 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1783
0101 22                RET     
0102         ?C0071:
                                           ; SOURCE LINE # 1785
                                           ; SOURCE LINE # 1787
0102 900000      R     MOV     DPTR,#LIN_1_framePid
0105 E0                MOVX    A,@DPTR
0106 FF                MOV     R7,A
0107 120000      R     LCALL   _LIN_1_FindPidIndex
010A 900000      R     MOV     DPTR,#LIN_1_pidIndex
010D EF                MOV     A,R7
010E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1789
010F 900000      R     MOV     DPTR,#LIN_1_pidIndex
0112 E0                MOVX    A,@DPTR
0113 FF                MOV     R7,A
0114 EF                MOV     A,R7
0115 64FF              XRL     A,#0FFH
0117 7003              JNZ     $ + 5H
0119 020000      R     LJMP    ?C0074
                                           ; SOURCE LINE # 1790
                                           ; SOURCE LINE # 1794
011C 900000      R     MOV     DPTR,#LIN_1_framePid
011F E0                MOVX    A,@DPTR
0120 FF                MOV     R7,A
0121 7E00              MOV     R6,#00H
0123 900000      R     MOV     DPTR,#LIN_1_interimChecksum
0126 EE                MOV     A,R6
0127 F0                MOVX    @DPTR,A
0128 A3                INC     DPTR
0129 EF                MOV     A,R7
012A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1797
012B 900000      R     MOV     DPTR,#LIN_1_pidIndex
012E E0                MOVX    A,@DPTR
012F FF                MOV     R7,A
0130 EF                MOV     A,R7
0131 25E0              ADD     A,ACC
0133 25E0              ADD     A,ACC
0135 2400        R     ADD     A,#LOW LIN_1_pidInfoTable
0137 F582              MOV     DPL,A
0139 E4                CLR     A
013A 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable
013C F583              MOV     DPH,A
013E E4                CLR     A
013F 93                MOVC    A,@A+DPTR
0140 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 105 

0141 EF                MOV     A,R7
0142 540F              ANL     A,#0FH
0144 FF                MOV     R7,A
0145 900000      R     MOV     DPTR,#LIN_1_frameSize
0148 EF                MOV     A,R7
0149 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1801
014A 900000      R     MOV     DPTR,#LIN_1_pidIndex
014D E0                MOVX    A,@DPTR
014E FF                MOV     R7,A
014F EF                MOV     A,R7
0150 25E0              ADD     A,ACC
0152 25E0              ADD     A,ACC
0154 2400        R     ADD     A,#LOW LIN_1_pidInfoTable
0156 F582              MOV     DPL,A
0158 E4                CLR     A
0159 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable
015B F583              MOV     DPH,A
015D E4                CLR     A
015E 93                MOVC    A,@A+DPTR
015F FF                MOV     R7,A
0160 EF                MOV     A,R7
0161 5410              ANL     A,#010H
0163 FF                MOV     R7,A
0164 7E00              MOV     R6,#00H
0166 EF                MOV     A,R7
0167 4E                ORL     A,R6
0168 607A              JZ      ?C0075
                                           ; SOURCE LINE # 1803
                                           ; SOURCE LINE # 1808
016A 900000      R     MOV     DPTR,#LIN_1_pidIndex
016D E0                MOVX    A,@DPTR
016E FF                MOV     R7,A
016F EF                MOV     A,R7
0170 25E0              ADD     A,ACC
0172 25E0              ADD     A,ACC
0174 2400        R     ADD     A,#LOW LIN_1_pidInfoTable
0176 F582              MOV     DPL,A
0178 E4                CLR     A
0179 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable
017B F583              MOV     DPH,A
017D E4                CLR     A
017E 93                MOVC    A,@A+DPTR
017F FF                MOV     R7,A
0180 EF                MOV     A,R7
0181 5420              ANL     A,#020H
0183 FF                MOV     R7,A
0184 7E00              MOV     R6,#00H
0186 EF                MOV     A,R7
0187 4E                ORL     A,R6
0188 6010              JZ      ?C0076
                                           ; SOURCE LINE # 1810
                                           ; SOURCE LINE # 1812
018A 900000      R     MOV     DPTR,#LIN_1_pidIndex
018D E0                MOVX    A,@DPTR
018E FF                MOV     R7,A
018F 120000      R     LCALL   _LIN_1_GetEtFlagValue
0192 EF                MOV     A,R7
0193 7005              JNZ     ?C0076
                                           ; SOURCE LINE # 1813
                                           ; SOURCE LINE # 1815
0195 7F01              MOV     R7,#01H
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 106 

0197 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1816
                                           ; SOURCE LINE # 1817
019A         ?C0076:
                                           ; SOURCE LINE # 1822
019A 900000      R     MOV     DPTR,#LIN_1_pidIndex
019D E0                MOVX    A,@DPTR
019E FF                MOV     R7,A
019F EF                MOV     A,R7
01A0 25E0              ADD     A,ACC
01A2 25E0              ADD     A,ACC
01A4 2400        R     ADD     A,#LOW LIN_1_pidInfoTable+01H
01A6 F582              MOV     DPL,A
01A8 E4                CLR     A
01A9 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable+01H
01AB F583              MOV     DPH,A
01AD 120000      E     LCALL   ?C?PLDCODE
01B0 900000      R     MOV     DPTR,#LIN_1_frameData
01B3 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1826
01B6 900000      R     MOV     DPTR,#LIN_1_frameData
01B9 120000      E     LCALL   ?C?PLDXDATA
01BC 120000      E     LCALL   ?C?CLDPTR
01BF FF                MOV     R7,A
01C0 900000      R     MOV     DPTR,#LIN_1_tmpData
01C3 EF                MOV     A,R7
01C4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1827
01C5 900000      R     MOV     DPTR,#LIN_1_frameData+01H
01C8 E4                CLR     A
01C9 75F001            MOV     B,#01H
01CC 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1828
01CF 900000      R     MOV     DPTR,#LIN_1_tmpData
01D2 E0                MOVX    A,@DPTR
01D3 FF                MOV     R7,A
01D4 120000      E     LCALL   _LIN_1_UART_WriteTxData
                                           ; SOURCE LINE # 1829
01D7 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
01DA 7401              MOV     A,#01H
01DC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1832
01DD 900000      R     MOV     DPTR,#LIN_1_uartFsmState
01E0 7402              MOV     A,#02H
01E2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1834
01E3 22                RET     
01E4         ?C0075:
                                           ; SOURCE LINE # 1836
                                           ; SOURCE LINE # 1838
01E4 7B01              MOV     R3,#01H
01E6 7A00        R     MOV     R2,#HIGH LIN_1_tmpRxFrameData
01E8 7900        R     MOV     R1,#LOW LIN_1_tmpRxFrameData
01EA 900000      R     MOV     DPTR,#LIN_1_frameData
01ED 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1841
01F0 900000      R     MOV     DPTR,#LIN_1_uartFsmState
01F3 7403              MOV     A,#03H
01F5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1842
                                           ; SOURCE LINE # 1843
01F6 22                RET     
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 107 

01F7         ?C0074:
                                           ; SOURCE LINE # 1845
                                           ; SOURCE LINE # 1847
01F7 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
01FA E0                MOVX    A,@DPTR
01FB FF                MOV     R7,A
01FC EF                MOV     A,R7
01FD 4401              ORL     A,#01H
01FF FF                MOV     R7,A
0200 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0203 EF                MOV     A,R7
0204 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1858
0205 120000      E     LCALL   CyEnterCriticalSection
0208 900000      R     MOV     DPTR,#interruptState
020B EF                MOV     A,R7
020C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1860
020D 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0210 E0                MOVX    A,@DPTR
0211 FF                MOV     R7,A
0212 EF                MOV     A,R7
0213 4404              ORL     A,#04H
0215 FF                MOV     R7,A
0216 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0219 EF                MOV     A,R7
021A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1864
021B 900000      R     MOV     DPTR,#interruptState
021E E0                MOVX    A,@DPTR
021F FF                MOV     R7,A
0220 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1868
0223 7F01              MOV     R7,#01H
0225 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1869
                                           ; SOURCE LINE # 1870
                                           ; SOURCE LINE # 1871
                                           ; SOURCE LINE # 1873
0228 22                RET     
                                           ; SOURCE LINE # 1883
0229         ?C0080:
                                           ; SOURCE LINE # 1886
0229 900000      R     MOV     DPTR,#LIN_1_status
022C E0                MOVX    A,@DPTR
022D FF                MOV     R7,A
022E EF                MOV     A,R7
022F 4410              ORL     A,#010H
0231 FF                MOV     R7,A
0232 900000      R     MOV     DPTR,#LIN_1_status
0235 EF                MOV     A,R7
0236 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1889
0237 120000      E     LCALL   LIN_1_UART_ReadRxData
023A 900000      R     MOV     DPTR,#LIN_1_tmpData
023D E0                MOVX    A,@DPTR
023E FE                MOV     R6,A
023F EF                MOV     A,R7
0240 6E                XRL     A,R6
0241 7003              JNZ     $ + 5H
0243 020000      R     LJMP    ?C0081
                                           ; SOURCE LINE # 1890
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 108 

                                           ; SOURCE LINE # 1904
0246 900000      R     MOV     DPTR,#LIN_1_pidIndex
0249 E0                MOVX    A,@DPTR
024A FF                MOV     R7,A
024B EF                MOV     A,R7
024C 25E0              ADD     A,ACC
024E 25E0              ADD     A,ACC
0250 2400        R     ADD     A,#LOW LIN_1_pidInfoTable
0252 F582              MOV     DPL,A
0254 E4                CLR     A
0255 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable
0257 F583              MOV     DPH,A
0259 E4                CLR     A
025A 93                MOVC    A,@A+DPTR
025B FF                MOV     R7,A
025C EF                MOV     A,R7
025D 5420              ANL     A,#020H
025F FF                MOV     R7,A
0260 7E00              MOV     R6,#00H
0262 EF                MOV     A,R7
0263 4E                ORL     A,R6
0264 700E              JNZ     ?C0082
                                           ; SOURCE LINE # 1906
                                           ; SOURCE LINE # 1908
0266 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0269 E0                MOVX    A,@DPTR
026A FF                MOV     R7,A
026B EF                MOV     A,R7
026C 4401              ORL     A,#01H
026E FF                MOV     R7,A
026F 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0272 EF                MOV     A,R7
0273 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1909
0274         ?C0082:
                                           ; SOURCE LINE # 1915
0274 120000      E     LCALL   CyEnterCriticalSection
0277 900000      R     MOV     DPTR,#interruptState
027A EF                MOV     A,R7
027B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1917
027C 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
027F E0                MOVX    A,@DPTR
0280 FF                MOV     R7,A
0281 EF                MOV     A,R7
0282 4404              ORL     A,#04H
0284 FF                MOV     R7,A
0285 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0288 EF                MOV     A,R7
0289 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1921
028A 900000      R     MOV     DPTR,#interruptState
028D E0                MOVX    A,@DPTR
028E FF                MOV     R7,A
028F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1925
0292 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0295 E0                MOVX    A,@DPTR
0296 FF                MOV     R7,A
0297 EF                MOV     A,R7
0298 5480              ANL     A,#080H
029A FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 109 

029B 7E00              MOV     R6,#00H
029D EF                MOV     A,R7
029E 4E                ORL     A,R6
029F 702F              JNZ     ?C0083
                                           ; SOURCE LINE # 1926
                                           ; SOURCE LINE # 1928
02A1 900000      R     MOV     DPTR,#LIN_1_ifcStatus
02A4 E0                MOVX    A,@DPTR
02A5 FF                MOV     R7,A
02A6 EF                MOV     A,R7
02A7 5400              ANL     A,#00H
02A9 FF                MOV     R7,A
02AA 900000      R     MOV     DPTR,#LIN_1_ifcStatus
02AD EF                MOV     A,R7
02AE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1929
02AF 900000      R     MOV     DPTR,#LIN_1_ifcStatus
02B2 E0                MOVX    A,@DPTR
02B3 FC                MOV     R4,A
02B4 A3                INC     DPTR
02B5 E0                MOVX    A,@DPTR
02B6 FD                MOV     R5,A
02B7 900000      R     MOV     DPTR,#LIN_1_framePid
02BA E0                MOVX    A,@DPTR
02BB FF                MOV     R7,A
02BC 7E00              MOV     R6,#00H
02BE EF                MOV     A,R7
02BF 7F00              MOV     R7,#00H
02C1 FE                MOV     R6,A
02C2 EC                MOV     A,R4
02C3 4E                ORL     A,R6
02C4 FE                MOV     R6,A
02C5 ED                MOV     A,R5
02C6 4F                ORL     A,R7
02C7 FF                MOV     R7,A
02C8 900000      R     MOV     DPTR,#LIN_1_ifcStatus
02CB EE                MOV     A,R6
02CC F0                MOVX    @DPTR,A
02CD A3                INC     DPTR
02CE EF                MOV     A,R7
02CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1930
02D0         ?C0083:
                                           ; SOURCE LINE # 1933
02D0 7F10              MOV     R7,#010H
02D2 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 1934
02D5 22                RET     
02D6         ?C0081:
                                           ; SOURCE LINE # 1936
                                           ; SOURCE LINE # 1938
02D6 900000      R     MOV     DPTR,#LIN_1_tmpData
02D9 E0                MOVX    A,@DPTR
02DA FF                MOV     R7,A
02DB 7E00              MOV     R6,#00H
02DD 900000      R     MOV     DPTR,#LIN_1_interimChecksum
02E0 EE                MOV     A,R6
02E1 8FF0              MOV     B,R7
02E3 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1939
02E6 900000      R     MOV     DPTR,#LIN_1_interimChecksum
02E9 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 110 

02EA FE                MOV     R6,A
02EB A3                INC     DPTR
02EC E0                MOVX    A,@DPTR
02ED FF                MOV     R7,A
02EE C3                CLR     C
02EF EE                MOV     A,R6
02F0 9401              SUBB    A,#01H
02F2 400B              JC      ?C0085
                                           ; SOURCE LINE # 1940
                                           ; SOURCE LINE # 1941
02F4 900000      R     MOV     DPTR,#LIN_1_interimChecksum
02F7 74FF              MOV     A,#0FFH
02F9 75F001            MOV     B,#01H
02FC 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1942
02FF         ?C0085:
                                           ; SOURCE LINE # 1945
02FF 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
0302 E0                MOVX    A,@DPTR
0303 FF                MOV     R7,A
0304 900000      R     MOV     DPTR,#LIN_1_frameSize
0307 E0                MOVX    A,@DPTR
0308 FE                MOV     R6,A
0309 EE                MOV     A,R6
030A D3                SETB    C
030B 9F                SUBB    A,R7
030C 4028              JC      ?C0086
                                           ; SOURCE LINE # 1946
                                           ; SOURCE LINE # 1948
030E 900000      R     MOV     DPTR,#LIN_1_frameData
0311 120000      E     LCALL   ?C?PLDXDATA
0314 120000      E     LCALL   ?C?CLDPTR
0317 FF                MOV     R7,A
0318 900000      R     MOV     DPTR,#LIN_1_tmpData
031B EF                MOV     A,R7
031C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1949
031D 900000      R     MOV     DPTR,#LIN_1_frameData+01H
0320 E4                CLR     A
0321 75F001            MOV     B,#01H
0324 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1950
0327 900000      R     MOV     DPTR,#LIN_1_tmpData
032A E0                MOVX    A,@DPTR
032B FF                MOV     R7,A
032C 120000      E     LCALL   _LIN_1_UART_WriteTxData
                                           ; SOURCE LINE # 1951
032F 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
0332 E0                MOVX    A,@DPTR
0333 04                INC     A
0334 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1952
0335 22                RET     
0336         ?C0086:
                                           ; SOURCE LINE # 1954
                                           ; SOURCE LINE # 1956
0336 900000      R     MOV     DPTR,#LIN_1_interimChecksum
0339 E0                MOVX    A,@DPTR
033A FE                MOV     R6,A
033B A3                INC     DPTR
033C E0                MOVX    A,@DPTR
033D FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 111 

033E EF                MOV     A,R7
033F 64FF              XRL     A,#0FFH
0341 FF                MOV     R7,A
0342 120000      E     LCALL   _LIN_1_UART_WriteTxData
                                           ; SOURCE LINE # 1958
0345 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
0348 E4                CLR     A
0349 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1961
034A 900000      R     MOV     DPTR,#LIN_1_uartFsmState
034D 7404              MOV     A,#04H
034F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1962
                                           ; SOURCE LINE # 1963
                                           ; SOURCE LINE # 1964
0350 22                RET     
                                           ; SOURCE LINE # 1973
0351         ?C0088:
                                           ; SOURCE LINE # 1976
0351 120000      E     LCALL   LIN_1_UART_ReadRxData
0354 900000      R     MOV     DPTR,#LIN_1_tmpData
0357 EF                MOV     A,R7
0358 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1977
0359 900000      R     MOV     DPTR,#LIN_1_tmpData
035C E0                MOVX    A,@DPTR
035D FF                MOV     R7,A
035E 900000      R     MOV     DPTR,#LIN_1_frameData
0361 120000      E     LCALL   ?C?PLDXDATA
0364 EF                MOV     A,R7
0365 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1978
0368 900000      R     MOV     DPTR,#LIN_1_frameData+01H
036B E4                CLR     A
036C 75F001            MOV     B,#01H
036F 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1979
0372 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
0375 E0                MOVX    A,@DPTR
0376 04                INC     A
0377 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1982
0378 900000      R     MOV     DPTR,#LIN_1_status
037B E0                MOVX    A,@DPTR
037C FF                MOV     R7,A
037D EF                MOV     A,R7
037E 4410              ORL     A,#010H
0380 FF                MOV     R7,A
0381 900000      R     MOV     DPTR,#LIN_1_status
0384 EF                MOV     A,R7
0385 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1985
0386 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0389 E0                MOVX    A,@DPTR
038A FF                MOV     R7,A
038B EF                MOV     A,R7
038C 4404              ORL     A,#04H
038E FF                MOV     R7,A
038F 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0392 EF                MOV     A,R7
0393 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1988
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 112 

0394 900000      R     MOV     DPTR,#LIN_1_tmpData
0397 E0                MOVX    A,@DPTR
0398 FF                MOV     R7,A
0399 7E00              MOV     R6,#00H
039B 900000      R     MOV     DPTR,#LIN_1_interimChecksum
039E EE                MOV     A,R6
039F 8FF0              MOV     B,R7
03A1 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1989
03A4 900000      R     MOV     DPTR,#LIN_1_interimChecksum
03A7 E0                MOVX    A,@DPTR
03A8 FE                MOV     R6,A
03A9 A3                INC     DPTR
03AA E0                MOVX    A,@DPTR
03AB FF                MOV     R7,A
03AC C3                CLR     C
03AD EE                MOV     A,R6
03AE 9401              SUBB    A,#01H
03B0 400B              JC      ?C0089
                                           ; SOURCE LINE # 1990
                                           ; SOURCE LINE # 1991
03B2 900000      R     MOV     DPTR,#LIN_1_interimChecksum
03B5 74FF              MOV     A,#0FFH
03B7 75F001            MOV     B,#01H
03BA 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1992
03BD         ?C0089:
                                           ; SOURCE LINE # 1995
03BD 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
03C0 E0                MOVX    A,@DPTR
03C1 FF                MOV     R7,A
03C2 900000      R     MOV     DPTR,#LIN_1_frameSize
03C5 E0                MOVX    A,@DPTR
03C6 FE                MOV     R6,A
03C7 EE                MOV     A,R6
03C8 D3                SETB    C
03C9 9F                SUBB    A,R7
03CA 4003              JC      $ + 5H
03CC 020000      R     LJMP    ?C0104
                                           ; SOURCE LINE # 1996
                                           ; SOURCE LINE # 1998
03CF         ?C0090:
                                           ; SOURCE LINE # 2000
                                           ; SOURCE LINE # 2003
03CF 900000      R     MOV     DPTR,#LIN_1_bytesTransferred
03D2 E4                CLR     A
03D3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2006
03D4 900000      R     MOV     DPTR,#LIN_1_uartFsmState
03D7 7404              MOV     A,#04H
03D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2007
                                           ; SOURCE LINE # 2009
03DA 22                RET     
                                           ; SOURCE LINE # 2016
03DB         ?C0092:
                                           ; SOURCE LINE # 2019
03DB 120000      E     LCALL   LIN_1_UART_ReadRxData
03DE 7E00              MOV     R6,#00H
03E0 900000      R     MOV     DPTR,#LIN_1_interimChecksum
03E3 E0                MOVX    A,@DPTR
03E4 FC                MOV     R4,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 113 

03E5 A3                INC     DPTR
03E6 E0                MOVX    A,@DPTR
03E7 FD                MOV     R5,A
03E8 7C00              MOV     R4,#00H
03EA ED                MOV     A,R5
03EB 64FF              XRL     A,#0FFH
03ED FD                MOV     R5,A
03EE ED                MOV     A,R5
03EF 6F                XRL     A,R7
03F0 7002              JNZ     ?C0163
03F2 EC                MOV     A,R4
03F3 6E                XRL     A,R6
03F4         ?C0163:
03F4 6072              JZ      ?C0093
                                           ; SOURCE LINE # 2020
                                           ; SOURCE LINE # 2024
03F6 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
03F9 E0                MOVX    A,@DPTR
03FA FF                MOV     R7,A
03FB EF                MOV     A,R7
03FC 4401              ORL     A,#01H
03FE FF                MOV     R7,A
03FF 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0402 EF                MOV     A,R7
0403 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2035
0404 120000      E     LCALL   CyEnterCriticalSection
0407 900000      R     MOV     DPTR,#interruptState
040A EF                MOV     A,R7
040B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2037
040C 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
040F E0                MOVX    A,@DPTR
0410 FF                MOV     R7,A
0411 EF                MOV     A,R7
0412 4404              ORL     A,#04H
0414 FF                MOV     R7,A
0415 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
0418 EF                MOV     A,R7
0419 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2041
041A 900000      R     MOV     DPTR,#interruptState
041D E0                MOVX    A,@DPTR
041E FF                MOV     R7,A
041F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2045
0422 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0425 E0                MOVX    A,@DPTR
0426 FF                MOV     R7,A
0427 EF                MOV     A,R7
0428 5480              ANL     A,#080H
042A FF                MOV     R7,A
042B 7E00              MOV     R6,#00H
042D EF                MOV     A,R7
042E 4E                ORL     A,R6
042F 702F              JNZ     ?C0094
                                           ; SOURCE LINE # 2046
                                           ; SOURCE LINE # 2048
0431 900000      R     MOV     DPTR,#LIN_1_ifcStatus
0434 E0                MOVX    A,@DPTR
0435 FF                MOV     R7,A
0436 EF                MOV     A,R7
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 114 

0437 5400              ANL     A,#00H
0439 FF                MOV     R7,A
043A 900000      R     MOV     DPTR,#LIN_1_ifcStatus
043D EF                MOV     A,R7
043E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2049
043F 900000      R     MOV     DPTR,#LIN_1_ifcStatus
0442 E0                MOVX    A,@DPTR
0443 FC                MOV     R4,A
0444 A3                INC     DPTR
0445 E0                MOVX    A,@DPTR
0446 FD                MOV     R5,A
0447 900000      R     MOV     DPTR,#LIN_1_framePid
044A E0                MOVX    A,@DPTR
044B FF                MOV     R7,A
044C 7E00              MOV     R6,#00H
044E EF                MOV     A,R7
044F 7F00              MOV     R7,#00H
0451 FE                MOV     R6,A
0452 EC                MOV     A,R4
0453 4E                ORL     A,R6
0454 FE                MOV     R6,A
0455 ED                MOV     A,R5
0456 4F                ORL     A,R7
0457 FF                MOV     R7,A
0458 900000      R     MOV     DPTR,#LIN_1_ifcStatus
045B EE                MOV     A,R6
045C F0                MOVX    @DPTR,A
045D A3                INC     DPTR
045E EF                MOV     A,R7
045F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2050
0460         ?C0094:
                                           ; SOURCE LINE # 2053
0460 7F10              MOV     R7,#010H
0462 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 2054
0465 020000      R     LJMP    ?C0095
0468         ?C0093:
                                           ; SOURCE LINE # 2056
                                           ; SOURCE LINE # 2067
0468 900000      R     MOV     DPTR,#LIN_1_fsmFlags
046B E0                MOVX    A,@DPTR
046C FF                MOV     R7,A
046D EF                MOV     A,R7
046E 547B              ANL     A,#07BH
0470 FF                MOV     R7,A
0471 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0474 EF                MOV     A,R7
0475 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2070
0476 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0479 E0                MOVX    A,@DPTR
047A FF                MOV     R7,A
047B EF                MOV     A,R7
047C 4402              ORL     A,#02H
047E FF                MOV     R7,A
047F 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0482 EF                MOV     A,R7
0483 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2073
0484 900000      R     MOV     DPTR,#LIN_1_ifcStatus
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 115 

0487 E0                MOVX    A,@DPTR
0488 FF                MOV     R7,A
0489 EF                MOV     A,R7
048A 5400              ANL     A,#00H
048C FF                MOV     R7,A
048D 900000      R     MOV     DPTR,#LIN_1_ifcStatus
0490 EF                MOV     A,R7
0491 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2074
0492 900000      R     MOV     DPTR,#LIN_1_ifcStatus
0495 E0                MOVX    A,@DPTR
0496 FC                MOV     R4,A
0497 A3                INC     DPTR
0498 E0                MOVX    A,@DPTR
0499 FD                MOV     R5,A
049A 900000      R     MOV     DPTR,#LIN_1_framePid
049D E0                MOVX    A,@DPTR
049E FF                MOV     R7,A
049F 7E00              MOV     R6,#00H
04A1 EF                MOV     A,R7
04A2 7F00              MOV     R7,#00H
04A4 FE                MOV     R6,A
04A5 EC                MOV     A,R4
04A6 4E                ORL     A,R6
04A7 FE                MOV     R6,A
04A8 ED                MOV     A,R5
04A9 4F                ORL     A,R7
04AA FF                MOV     R7,A
04AB 900000      R     MOV     DPTR,#LIN_1_ifcStatus
04AE EE                MOV     A,R6
04AF F0                MOVX    @DPTR,A
04B0 A3                INC     DPTR
04B1 EF                MOV     A,R7
04B2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2077
04B3 900000      R     MOV     DPTR,#LIN_1_fsmFlags
04B6 E0                MOVX    A,@DPTR
04B7 FF                MOV     R7,A
04B8 EF                MOV     A,R7
04B9 5440              ANL     A,#040H
04BB FF                MOV     R7,A
04BC 7E00              MOV     R6,#00H
04BE EF                MOV     A,R7
04BF 4E                ORL     A,R6
04C0 600E              JZ      ?C0096
                                           ; SOURCE LINE # 2078
                                           ; SOURCE LINE # 2079
04C2 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
04C5 E0                MOVX    A,@DPTR
04C6 FF                MOV     R7,A
04C7 EF                MOV     A,R7
04C8 4404              ORL     A,#04H
04CA FF                MOV     R7,A
04CB 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
04CE EF                MOV     A,R7
04CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2080
04D0         ?C0096:
                                           ; SOURCE LINE # 2083
04D0 900000      R     MOV     DPTR,#LIN_1_fsmFlags
04D3 E0                MOVX    A,@DPTR
04D4 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 116 

04D5 EF                MOV     A,R7
04D6 4440              ORL     A,#040H
04D8 FF                MOV     R7,A
04D9 900000      R     MOV     DPTR,#LIN_1_fsmFlags
04DC EF                MOV     A,R7
04DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2088
04DE 900000      R     MOV     DPTR,#LIN_1_pidIndex
04E1 E0                MOVX    A,@DPTR
04E2 FF                MOV     R7,A
04E3 EF                MOV     A,R7
04E4 701E              JNZ     ?C0097
                                           ; SOURCE LINE # 2089
                                           ; SOURCE LINE # 2092
04E6 120000      E     LCALL   CyEnterCriticalSection
04E9 900000      R     MOV     DPTR,#interruptState
04EC EF                MOV     A,R7
04ED F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2095
04EE 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
04F1 E0                MOVX    A,@DPTR
04F2 FF                MOV     R7,A
04F3 EF                MOV     A,R7
04F4 54FB              ANL     A,#0FBH
04F6 FF                MOV     R7,A
04F7 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
04FA EF                MOV     A,R7
04FB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2098
04FC 900000      R     MOV     DPTR,#interruptState
04FF E0                MOVX    A,@DPTR
0500 FF                MOV     R7,A
0501 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2100
0504         ?C0097:
                                           ; SOURCE LINE # 2136
0504 900000      R     MOV     DPTR,#LIN_1_pidIndex
0507 E0                MOVX    A,@DPTR
0508 FF                MOV     R7,A
0509 EF                MOV     A,R7
050A 25E0              ADD     A,ACC
050C 25E0              ADD     A,ACC
050E 2400        R     ADD     A,#LOW LIN_1_pidInfoTable
0510 F582              MOV     DPL,A
0512 E4                CLR     A
0513 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable
0515 F583              MOV     DPH,A
0517 E4                CLR     A
0518 93                MOVC    A,@A+DPTR
0519 FF                MOV     R7,A
051A EF                MOV     A,R7
051B 5420              ANL     A,#020H
051D FF                MOV     R7,A
051E 7E00              MOV     R6,#00H
0520 EF                MOV     A,R7
0521 4E                ORL     A,R6
0522 600D              JZ      ?C0098
                                           ; SOURCE LINE # 2138
                                           ; SOURCE LINE # 2140
0524 900000      R     MOV     DPTR,#LIN_1_pidIndex
0527 E0                MOVX    A,@DPTR
0528 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 117 

0529 120000      R     LCALL   _LIN_1_ClearEtFlagValue
                                           ; SOURCE LINE # 2143
052C 7F01              MOV     R7,#01H
052E 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 2144
0531         ?C0098:
                                           ; SOURCE LINE # 2149
0531 900000      R     MOV     DPTR,#LIN_1_pidIndex
0534 E0                MOVX    A,@DPTR
0535 FF                MOV     R7,A
0536 120000      R     LCALL   _LIN_1_SetAssociatedFlags
                                           ; SOURCE LINE # 2264
0539 900000      R     MOV     DPTR,#LIN_1_pidIndex
053C E0                MOVX    A,@DPTR
053D FF                MOV     R7,A
053E EF                MOV     A,R7
053F 25E0              ADD     A,ACC
0541 25E0              ADD     A,ACC
0543 2400        R     ADD     A,#LOW LIN_1_pidInfoTable
0545 F582              MOV     DPL,A
0547 E4                CLR     A
0548 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable
054A F583              MOV     DPH,A
054C E4                CLR     A
054D 93                MOVC    A,@A+DPTR
054E FF                MOV     R7,A
054F EF                MOV     A,R7
0550 5410              ANL     A,#010H
0552 FF                MOV     R7,A
0553 7E00              MOV     R6,#00H
0555 EF                MOV     A,R7
0556 4E                ORL     A,R6
0557 7062              JNZ     ?C0099
                                           ; SOURCE LINE # 2266
                                           ; SOURCE LINE # 2267
0559 120000      E     LCALL   CyEnterCriticalSection
055C 900000      R     MOV     DPTR,#interruptState
055F EF                MOV     A,R7
0560 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2270
0561 900000      R     MOV     DPTR,#i
0564 E4                CLR     A
0565 F0                MOVX    @DPTR,A
0566         ?C0100:
0566 900000      R     MOV     DPTR,#LIN_1_frameSize
0569 E0                MOVX    A,@DPTR
056A FF                MOV     R7,A
056B 900000      R     MOV     DPTR,#i
056E E0                MOVX    A,@DPTR
056F FE                MOV     R6,A
0570 EE                MOV     A,R6
0571 C3                CLR     C
0572 9F                SUBB    A,R7
0573 503E              JNC     ?C0101
                                           ; SOURCE LINE # 2271
                                           ; SOURCE LINE # 2272
0575 900000      R     MOV     DPTR,#i
0578 E0                MOVX    A,@DPTR
0579 FF                MOV     R7,A
057A 7400        R     MOV     A,#LOW LIN_1_tmpRxFrameData
057C 2F                ADD     A,R7
057D F582              MOV     DPL,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 118 

057F E4                CLR     A
0580 3400        R     ADDC    A,#HIGH LIN_1_tmpRxFrameData
0582 F583              MOV     DPH,A
0584 E0                MOVX    A,@DPTR
0585 FF                MOV     R7,A
0586 900000      R     MOV     DPTR,#LIN_1_pidIndex
0589 E0                MOVX    A,@DPTR
058A FE                MOV     R6,A
058B EE                MOV     A,R6
058C 25E0              ADD     A,ACC
058E 25E0              ADD     A,ACC
0590 2400        R     ADD     A,#LOW LIN_1_pidInfoTable+01H
0592 F582              MOV     DPL,A
0594 E4                CLR     A
0595 3400        R     ADDC    A,#HIGH LIN_1_pidInfoTable+01H
0597 F583              MOV     DPH,A
0599 120000      E     LCALL   ?C?PLDCODE
059C 900000      R     MOV     DPTR,#i
059F E0                MOVX    A,@DPTR
05A0 FE                MOV     R6,A
05A1 E9                MOV     A,R1
05A2 2E                ADD     A,R6
05A3 F9                MOV     R1,A
05A4 E4                CLR     A
05A5 3A                ADDC    A,R2
05A6 FA                MOV     R2,A
05A7 EF                MOV     A,R7
05A8 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 2274
05AB 900000      R     MOV     DPTR,#i
05AE E0                MOVX    A,@DPTR
05AF 04                INC     A
05B0 F0                MOVX    @DPTR,A
05B1 80B3              SJMP    ?C0100
05B3         ?C0101:
                                           ; SOURCE LINE # 2276
05B3 900000      R     MOV     DPTR,#interruptState
05B6 E0                MOVX    A,@DPTR
05B7 FF                MOV     R7,A
05B8 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2277
05BB         ?C0099:
                                           ; SOURCE LINE # 2280
05BB 7F01              MOV     R7,#01H
05BD 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 2284
05C0         ?C0095:
                                           ; SOURCE LINE # 2286
05C0 900000      R     MOV     DPTR,#LIN_1_interimChecksum
05C3 E4                CLR     A
05C4 F0                MOVX    @DPTR,A
05C5 A3                INC     DPTR
05C6 E4                CLR     A
05C7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2288
05C8 22                RET     
                                           ; SOURCE LINE # 2291
05C9         ?C0103:
                                           ; SOURCE LINE # 2293
05C9 7F01              MOV     R7,#01H
05CB 120000      R     LCALL   _LIN_1_EndFrame
                                           ; SOURCE LINE # 2294
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 119 

                                           ; SOURCE LINE # 2295
                                           ; SOURCE LINE # 2304
05CE         ?C0104:
05CE 22                RET     
             ; FUNCTION l_ifc_rx_LIN_1 (END)

             ; FUNCTION _l_ifc_rx (BEGIN)
                                           ; SOURCE LINE # 2325
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2326
                                           ; SOURCE LINE # 2327
0005 900000      R     MOV     DPTR,#iii
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0106
0010 00                DB      00H
0011 0000              DW      00H
0013 0000        R     DW      ?C0108
                                           ; SOURCE LINE # 2328
                                           ; SOURCE LINE # 2329
0015         ?C0106:
                                           ; SOURCE LINE # 2330
0015 120000      R     LCALL   l_ifc_rx_LIN_1
                                           ; SOURCE LINE # 2331
                                           ; SOURCE LINE # 2333
                                           ; SOURCE LINE # 2334
                                           ; SOURCE LINE # 2335
                                           ; SOURCE LINE # 2336
0018         ?C0108:
0018 22                RET     
             ; FUNCTION _l_ifc_rx (END)

             ; FUNCTION l_ifc_tx_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 2357
                                           ; SOURCE LINE # 2358
                                           ; SOURCE LINE # 2359
0000 120000      R     LCALL   l_ifc_rx_LIN_1
                                           ; SOURCE LINE # 2360
0003 22                RET     
             ; FUNCTION l_ifc_tx_LIN_1 (END)

             ; FUNCTION _l_ifc_tx (BEGIN)
                                           ; SOURCE LINE # 2381
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2382
                                           ; SOURCE LINE # 2383
0005 900000      R     MOV     DPTR,#iii
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0111
0010 00                DB      00H
0011 0000              DW      00H
0013 0000        R     DW      ?C0113
                                           ; SOURCE LINE # 2384
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 120 

                                           ; SOURCE LINE # 2385
0015         ?C0111:
                                           ; SOURCE LINE # 2386
0015 120000      R     LCALL   l_ifc_tx_LIN_1
                                           ; SOURCE LINE # 2387
                                           ; SOURCE LINE # 2389
                                           ; SOURCE LINE # 2390
                                           ; SOURCE LINE # 2391
                                           ; SOURCE LINE # 2392
0018         ?C0113:
0018 22                RET     
             ; FUNCTION _l_ifc_tx (END)

             ; FUNCTION l_ifc_aux_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 2413
                                           ; SOURCE LINE # 2414
                                           ; SOURCE LINE # 2418
0000 900000      R     MOV     DPTR,#LIN_1_auxStatus
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 906468            MOV     DPTR,#06468H
0008 E0                MOVX    A,@DPTR
0009 FE                MOV     R6,A
000A EF                MOV     A,R7
000B 4E                ORL     A,R6
000C FF                MOV     R7,A
000D 900000      R     MOV     DPTR,#LIN_1_auxStatus
0010 EF                MOV     A,R7
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2423
0012 900000      R     MOV     DPTR,#LIN_1_auxStatus
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 EF                MOV     A,R7
0018 5402              ANL     A,#02H
001A FF                MOV     R7,A
001B 7E00              MOV     R6,#00H
001D EF                MOV     A,R7
001E 4E                ORL     A,R6
001F 6013              JZ      ?C0114
                                           ; SOURCE LINE # 2424
                                           ; SOURCE LINE # 2426
0021 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 4410              ORL     A,#010H
0029 FF                MOV     R7,A
002A 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2431
002F 900000      R     MOV     DPTR,#LIN_1_periodCounter
0032 E4                CLR     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2434
0034         ?C0114:
                                           ; SOURCE LINE # 2442
0034 900000      R     MOV     DPTR,#LIN_1_auxStatus
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 EF                MOV     A,R7
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 121 

003A 5404              ANL     A,#04H
003C FF                MOV     R7,A
003D 7E00              MOV     R6,#00H
003F EF                MOV     A,R7
0040 4E                ORL     A,R6
0041 601F              JZ      ?C0115
                                           ; SOURCE LINE # 2443
                                           ; SOURCE LINE # 2479
0043 900000      R     MOV     DPTR,#LIN_1_periodCounter
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 B44610            CJNE    A,#046H,?C0116
                                           ; SOURCE LINE # 2480
                                           ; SOURCE LINE # 2484
004C 900000      R     MOV     DPTR,#LIN_1_ioctlStatus+01H
004F E0                MOVX    A,@DPTR
0050 FF                MOV     R7,A
0051 EF                MOV     A,R7
0052 4401              ORL     A,#01H
0054 FF                MOV     R7,A
0055 900000      R     MOV     DPTR,#LIN_1_ioctlStatus+01H
0058 EF                MOV     A,R7
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2485
005A 8006              SJMP    ?C0115
005C         ?C0116:
                                           ; SOURCE LINE # 2487
                                           ; SOURCE LINE # 2488
005C 900000      R     MOV     DPTR,#LIN_1_periodCounter
005F E0                MOVX    A,@DPTR
0060 04                INC     A
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2489
                                           ; SOURCE LINE # 2490
0062         ?C0115:
                                           ; SOURCE LINE # 2498
0062 900000      R     MOV     DPTR,#LIN_1_auxStatus
0065 E0                MOVX    A,@DPTR
0066 FF                MOV     R7,A
0067 EF                MOV     A,R7
0068 5401              ANL     A,#01H
006A FF                MOV     R7,A
006B 7E00              MOV     R6,#00H
006D EF                MOV     A,R7
006E 4E                ORL     A,R6
006F 606F              JZ      ?C0118
                                           ; SOURCE LINE # 2499
                                           ; SOURCE LINE # 2501
0071 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 EF                MOV     A,R7
0077 5484              ANL     A,#084H
0079 FF                MOV     R7,A
007A 7E00              MOV     R6,#00H
007C EF                MOV     A,R7
007D 4E                ORL     A,R6
007E 603A              JZ      ?C0119
                                           ; SOURCE LINE # 2503
                                           ; SOURCE LINE # 2505
0080 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 122 

0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 EF                MOV     A,R7
0086 4401              ORL     A,#01H
0088 FF                MOV     R7,A
0089 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
008C EF                MOV     A,R7
008D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2508
008E 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0091 E0                MOVX    A,@DPTR
0092 FF                MOV     R7,A
0093 EF                MOV     A,R7
0094 547F              ANL     A,#07FH
0096 FF                MOV     R7,A
0097 900000      R     MOV     DPTR,#LIN_1_fsmFlags
009A EF                MOV     A,R7
009B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2519
009C 120000      E     LCALL   CyEnterCriticalSection
009F 900000      R     MOV     DPTR,#interruptState
00A2 EF                MOV     A,R7
00A3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2521
00A4 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
00A7 E0                MOVX    A,@DPTR
00A8 FF                MOV     R7,A
00A9 EF                MOV     A,R7
00AA 4404              ORL     A,#04H
00AC FF                MOV     R7,A
00AD 900000      R     MOV     DPTR,#LIN_1_Buffer_Frame1
00B0 EF                MOV     A,R7
00B1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2525
00B2 900000      R     MOV     DPTR,#interruptState
00B5 E0                MOVX    A,@DPTR
00B6 FF                MOV     R7,A
00B7 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2528
00BA         ?C0119:
                                           ; SOURCE LINE # 2531
00BA 900000      R     MOV     DPTR,#LIN_1_fsmFlags
00BD E0                MOVX    A,@DPTR
00BE FF                MOV     R7,A
00BF EF                MOV     A,R7
00C0 4401              ORL     A,#01H
00C2 FF                MOV     R7,A
00C3 900000      R     MOV     DPTR,#LIN_1_fsmFlags
00C6 EF                MOV     A,R7
00C7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2541
00C8 90647C            MOV     DPTR,#0647CH
00CB E0                MOVX    A,@DPTR
00CC FF                MOV     R7,A
00CD EF                MOV     A,R7
00CE 54FB              ANL     A,#0FBH
00D0 FF                MOV     R7,A
00D1 EF                MOV     A,R7
00D2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2547
00D3 900000      R     MOV     DPTR,#LIN_1_initialClockDivider
00D6 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 123 

00D7 FE                MOV     R6,A
00D8 A3                INC     DPTR
00D9 E0                MOVX    A,@DPTR
00DA FF                MOV     R7,A
00DB 7D00              MOV     R5,#00H
00DD 120000      E     LCALL   _LIN_1_IntClk_SetDividerRegister
                                           ; SOURCE LINE # 2567
00E0         ?C0118:
                                           ; SOURCE LINE # 2576
00E0 900000      R     MOV     DPTR,#LIN_1_auxStatus
00E3 E0                MOVX    A,@DPTR
00E4 FF                MOV     R7,A
00E5 EF                MOV     A,R7
00E6 5408              ANL     A,#08H
00E8 FF                MOV     R7,A
00E9 7E00              MOV     R6,#00H
00EB EF                MOV     A,R7
00EC 4E                ORL     A,R6
00ED 7003              JNZ     $ + 5H
00EF 020000      R     LJMP    ?C0120
                                           ; SOURCE LINE # 2577
                                           ; SOURCE LINE # 2579
00F2 906448            MOV     DPTR,#06448H
00F5 E0                MOVX    A,@DPTR
00F6 FF                MOV     R7,A
00F7 900000      R     MOV     DPTR,#LIN_1_syncCounts
00FA EF                MOV     A,R7
00FB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2580
00FC 906448            MOV     DPTR,#06448H
00FF E0                MOVX    A,@DPTR
0100 FF                MOV     R7,A
0101 900000      R     MOV     DPTR,#LIN_1_syncCounts
0104 EF                MOV     A,R7
0105 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2581
0106 906448            MOV     DPTR,#06448H
0109 E0                MOVX    A,@DPTR
010A FF                MOV     R7,A
010B 900000      R     MOV     DPTR,#LIN_1_syncCounts
010E EF                MOV     A,R7
010F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2583
0110 906458            MOV     DPTR,#06458H
0113 E0                MOVX    A,@DPTR
0114 FF                MOV     R7,A
0115 906448            MOV     DPTR,#06448H
0118 E0                MOVX    A,@DPTR
0119 FE                MOV     R6,A
011A EE                MOV     A,R6
011B 2F                ADD     A,R7
011C FF                MOV     R7,A
011D 900000      R     MOV     DPTR,#LIN_1_syncCounts
0120 EF                MOV     A,R7
0121 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2586
0122 900000      R     MOV     DPTR,#LIN_1_syncCounts
0125 E0                MOVX    A,@DPTR
0126 FF                MOV     R7,A
0127 EF                MOV     A,R7
0128 6480              XRL     A,#080H
012A 6022              JZ      ?C0121
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 124 

                                           ; SOURCE LINE # 2587
                                           ; SOURCE LINE # 2589
012C 900000      R     MOV     DPTR,#LIN_1_initialClockDivider
012F E0                MOVX    A,@DPTR
0130 FE                MOV     R6,A
0131 A3                INC     DPTR
0132 E0                MOVX    A,@DPTR
0133 FF                MOV     R7,A
0134 900000      R     MOV     DPTR,#LIN_1_syncCounts
0137 E0                MOVX    A,@DPTR
0138 FD                MOV     R5,A
0139 7C00              MOV     R4,#00H
013B 120000      E     LCALL   ?C?LIMUL
013E 7B80              MOV     R3,#080H
0140 7A00              MOV     R2,#00H
0142 7900              MOV     R1,#00H
0144 7800              MOV     R0,#00H
0146 120000      E     LCALL   ?C?ULDIV
0149 7D00              MOV     R5,#00H
014B 120000      E     LCALL   _LIN_1_IntClk_SetDividerRegister
                                           ; SOURCE LINE # 2590
014E         ?C0121:
                                           ; SOURCE LINE # 2593
014E 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0151 E0                MOVX    A,@DPTR
0152 FF                MOV     R7,A
0153 EF                MOV     A,R7
0154 54FB              ANL     A,#0FBH
0156 FF                MOV     R7,A
0157 900000      R     MOV     DPTR,#LIN_1_fsmFlags
015A EF                MOV     A,R7
015B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2596
015C 900000      R     MOV     DPTR,#LIN_1_uartFsmState
015F 7401              MOV     A,#01H
0161 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2599
0162 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0165 E0                MOVX    A,@DPTR
0166 FF                MOV     R7,A
0167 EF                MOV     A,R7
0168 4408              ORL     A,#08H
016A FF                MOV     R7,A
016B 900000      R     MOV     DPTR,#LIN_1_fsmFlags
016E EF                MOV     A,R7
016F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2602
0170 9044D8            MOV     DPTR,#044D8H
0173 7402              MOV     A,#02H
0175 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2605
0176 9044C0            MOV     DPTR,#044C0H
0179 7402              MOV     A,#02H
017B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2606
017C         ?C0120:
                                           ; SOURCE LINE # 2620
017C 900000      R     MOV     DPTR,#LIN_1_auxStatus
017F E4                CLR     A
0180 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2621
0181 22                RET     
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 125 

             ; FUNCTION l_ifc_aux_LIN_1 (END)

             ; FUNCTION _l_ifc_aux (BEGIN)
                                           ; SOURCE LINE # 2642
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2643
                                           ; SOURCE LINE # 2644
0005 900000      R     MOV     DPTR,#iii
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0124
0010 00                DB      00H
0011 0000              DW      00H
0013 0000        R     DW      ?C0126
                                           ; SOURCE LINE # 2645
                                           ; SOURCE LINE # 2646
0015         ?C0124:
                                           ; SOURCE LINE # 2647
0015 120000      R     LCALL   l_ifc_aux_LIN_1
                                           ; SOURCE LINE # 2648
                                           ; SOURCE LINE # 2650
                                           ; SOURCE LINE # 2651
                                           ; SOURCE LINE # 2652
                                           ; SOURCE LINE # 2653
0018         ?C0126:
0018 22                RET     
             ; FUNCTION _l_ifc_aux (END)

             ; FUNCTION l_ifc_read_status_LIN_1 (BEGIN)
                                           ; SOURCE LINE # 2685
                                           ; SOURCE LINE # 2686
                                           ; SOURCE LINE # 2690
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2698
0008 900000      R     MOV     DPTR,#LIN_1_auxStatus
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D 906468            MOV     DPTR,#06468H
0010 E0                MOVX    A,@DPTR
0011 FE                MOV     R6,A
0012 EF                MOV     A,R7
0013 4E                ORL     A,R6
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#LIN_1_auxStatus
0018 EF                MOV     A,R7
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2701
001A 900000      R     MOV     DPTR,#LIN_1_auxStatus
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 5402              ANL     A,#02H
0022 FF                MOV     R7,A
0023 7E00              MOV     R6,#00H
0025 EF                MOV     A,R7
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 126 

0026 4E                ORL     A,R6
0027 6021              JZ      ?C0127
                                           ; SOURCE LINE # 2702
                                           ; SOURCE LINE # 2704
0029 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 4410              ORL     A,#010H
0031 FF                MOV     R7,A
0032 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2707
0037 900000      R     MOV     DPTR,#LIN_1_auxStatus
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C EF                MOV     A,R7
003D 54FD              ANL     A,#0FDH
003F FF                MOV     R7,A
0040 900000      R     MOV     DPTR,#LIN_1_auxStatus
0043 EF                MOV     A,R7
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2712
0045 900000      R     MOV     DPTR,#LIN_1_periodCounter
0048 E4                CLR     A
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2715
004A         ?C0127:
                                           ; SOURCE LINE # 2718
004A 900000      R     MOV     DPTR,#LIN_1_ifcStatus
004D E0                MOVX    A,@DPTR
004E FE                MOV     R6,A
004F A3                INC     DPTR
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 900000      R     MOV     DPTR,#returnValue
0055 EE                MOV     A,R6
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 EF                MOV     A,R7
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2721
005A 900000      R     MOV     DPTR,#LIN_1_ifcStatus
005D E0                MOVX    A,@DPTR
005E FE                MOV     R6,A
005F A3                INC     DPTR
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 7E00              MOV     R6,#00H
0064 7F00              MOV     R7,#00H
0066 900000      R     MOV     DPTR,#LIN_1_ifcStatus
0069 EE                MOV     A,R6
006A F0                MOVX    @DPTR,A
006B A3                INC     DPTR
006C EF                MOV     A,R7
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2723
006E 900000      R     MOV     DPTR,#interruptState
0071 E0                MOVX    A,@DPTR
0072 FF                MOV     R7,A
0073 120000      E     LCALL   _CyExitCriticalSection
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 127 

                                           ; SOURCE LINE # 2726
0076 900000      R     MOV     DPTR,#LIN_1_status
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 54FB              ANL     A,#0FBH
007E FF                MOV     R7,A
007F 900000      R     MOV     DPTR,#LIN_1_status
0082 EF                MOV     A,R7
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2729
0084 900000      R     MOV     DPTR,#returnValue
0087 E0                MOVX    A,@DPTR
0088 FE                MOV     R6,A
0089 A3                INC     DPTR
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
                                           ; SOURCE LINE # 2730
008C         ?C0128:
008C 22                RET     
             ; FUNCTION l_ifc_read_status_LIN_1 (END)

             ; FUNCTION _l_ifc_read_status (BEGIN)
                                           ; SOURCE LINE # 2763
0000 900000      R     MOV     DPTR,#iii
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2764
                                           ; SOURCE LINE # 2768
0005 900000      R     MOV     DPTR,#iii
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0130
0010 00                DB      00H
0011 0000              DW      00H
0013 0000        R     DW      ?C0131
                                           ; SOURCE LINE # 2769
                                           ; SOURCE LINE # 2771
0015         ?C0130:
                                           ; SOURCE LINE # 2772
0015 120000      R     LCALL   l_ifc_read_status_LIN_1
0018 900000      R     MOV     DPTR,#returnValue
001B EE                MOV     A,R6
001C F0                MOVX    @DPTR,A
001D A3                INC     DPTR
001E EF                MOV     A,R7
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2773
0020 8009              SJMP    ?C0129
                                           ; SOURCE LINE # 2775
0022         ?C0131:
                                           ; SOURCE LINE # 2776
0022 900000      R     MOV     DPTR,#returnValue
0025 E4                CLR     A
0026 F0                MOVX    @DPTR,A
0027 A3                INC     DPTR
0028 7401              MOV     A,#01H
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2777
                                           ; SOURCE LINE # 2778
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 128 

002B         ?C0129:
                                           ; SOURCE LINE # 2780
002B 900000      R     MOV     DPTR,#returnValue
002E E0                MOVX    A,@DPTR
002F FE                MOV     R6,A
0030 A3                INC     DPTR
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
                                           ; SOURCE LINE # 2781
0033         ?C0132:
0033 22                RET     
             ; FUNCTION _l_ifc_read_status (END)

             ; FUNCTION l_sys_irq_disable (BEGIN)
                                           ; SOURCE LINE # 2811
                                           ; SOURCE LINE # 2812
                                           ; SOURCE LINE # 2813
0000 900000      R     MOV     DPTR,#irqMask
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2815
0005 7F01              MOV     R7,#01H
0007 120000      E     LCALL   _CyIntGetState
000A EF                MOV     A,R7
000B B4010C            CJNE    A,#01H,?C0133
                                           ; SOURCE LINE # 2816
                                           ; SOURCE LINE # 2817
000E 900000      R     MOV     DPTR,#irqMask
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2818
0014 9044C8            MOV     DPTR,#044C8H
0017 7402              MOV     A,#02H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2819
001A         ?C0133:
                                           ; SOURCE LINE # 2821
001A 7F00              MOV     R7,#00H
001C 120000      E     LCALL   _CyIntGetState
001F EF                MOV     A,R7
0020 B40114            CJNE    A,#01H,?C0134
                                           ; SOURCE LINE # 2822
                                           ; SOURCE LINE # 2823
0023 900000      R     MOV     DPTR,#irqMask
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 EF                MOV     A,R7
0029 4402              ORL     A,#02H
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#irqMask
002F EF                MOV     A,R7
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2824
0031 9044C8            MOV     DPTR,#044C8H
0034 7401              MOV     A,#01H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2825
0037         ?C0134:
                                           ; SOURCE LINE # 2827
0037 900000      R     MOV     DPTR,#irqMask
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 129 

                                           ; SOURCE LINE # 2828
003C         ?C0135:
003C 22                RET     
             ; FUNCTION l_sys_irq_disable (END)

             ; FUNCTION _l_sys_irq_restore (BEGIN)
                                           ; SOURCE LINE # 2853
0000 900000      R     MOV     DPTR,#previous
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2854
                                           ; SOURCE LINE # 2855
0005 900000      R     MOV     DPTR,#previous
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5401              ANL     A,#01H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0136
                                           ; SOURCE LINE # 2856
                                           ; SOURCE LINE # 2857
0014 9044C0            MOV     DPTR,#044C0H
0017 7402              MOV     A,#02H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2858
001A         ?C0136:
                                           ; SOURCE LINE # 2860
001A 900000      R     MOV     DPTR,#previous
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 30E106            JNB     ACC.1,?C0138
                                           ; SOURCE LINE # 2861
                                           ; SOURCE LINE # 2862
0023 9044C0            MOV     DPTR,#044C0H
0026 7401              MOV     A,#01H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2863
                                           ; SOURCE LINE # 2864
0029         ?C0138:
0029 22                RET     
             ; FUNCTION _l_sys_irq_restore (END)

             ; FUNCTION _LIN_1_FindPidIndex (BEGIN)
                                           ; SOURCE LINE # 2882
0000 900000      R     MOV     DPTR,#pid
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2883
                                           ; SOURCE LINE # 2885
0005 900000      R     MOV     DPTR,#returnValue
0008 74FF              MOV     A,#0FFH
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2887
000B 900000      R     MOV     DPTR,#i
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
0010         ?C0139:
0010 900000      R     MOV     DPTR,#i
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 130 

0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9402              SUBB    A,#02H
0019 502E              JNC     ?C0140
                                           ; SOURCE LINE # 2888
                                           ; SOURCE LINE # 2889
001B 900000      R     MOV     DPTR,#i
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 7400        R     MOV     A,#LOW LIN_1_volatileConfig
0022 2F                ADD     A,R7
0023 F582              MOV     DPL,A
0025 E4                CLR     A
0026 3400        R     ADDC    A,#HIGH LIN_1_volatileConfig
0028 F583              MOV     DPH,A
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#pid
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 EE                MOV     A,R6
0032 B5070C            CJNE    A,AR7,?C0141
                                           ; SOURCE LINE # 2890
                                           ; SOURCE LINE # 2891
0035 900000      R     MOV     DPTR,#i
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A 900000      R     MOV     DPTR,#returnValue
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2894
003F 8008              SJMP    ?C0140
                                           ; SOURCE LINE # 2895
                                           ; SOURCE LINE # 2896
0041         ?C0141:
0041 900000      R     MOV     DPTR,#i
0044 E0                MOVX    A,@DPTR
0045 04                INC     A
0046 F0                MOVX    @DPTR,A
0047 80C7              SJMP    ?C0139
0049         ?C0140:
                                           ; SOURCE LINE # 2898
0049 900000      R     MOV     DPTR,#returnValue
004C E0                MOVX    A,@DPTR
004D FF                MOV     R7,A
                                           ; SOURCE LINE # 2899
004E         ?C0143:
004E 22                RET     
             ; FUNCTION _LIN_1_FindPidIndex (END)

             ; FUNCTION _LIN_1_EndFrame (BEGIN)
                                           ; SOURCE LINE # 2919
0000 900000      R     MOV     DPTR,#status
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2920
                                           ; SOURCE LINE # 2923
0005 900000      R     MOV     DPTR,#status
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 131 

000A EF                MOV     A,R7
000B B4102F            CJNE    A,#010H,?C0144
                                           ; SOURCE LINE # 2924
                                           ; SOURCE LINE # 2926
000E 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 54FB              ANL     A,#0FBH
0016 FF                MOV     R7,A
0017 900000      R     MOV     DPTR,#LIN_1_fsmFlags
001A EF                MOV     A,R7
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2928
001C 900000      R     MOV     DPTR,#LIN_1_fsmFlags
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 5440              ANL     A,#040H
0024 FF                MOV     R7,A
0025 7E00              MOV     R6,#00H
0027 EF                MOV     A,R7
0028 4E                ORL     A,R6
0029 7003              JNZ     $ + 5H
002B 020000      R     LJMP    ?C0151
                                           ; SOURCE LINE # 2929
                                           ; SOURCE LINE # 2931
002E 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 4404              ORL     A,#04H
0036 FF                MOV     R7,A
0037 900000      R     MOV     DPTR,#LIN_1_ifcStatus+01H
003A EF                MOV     A,R7
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2932
                                           ; SOURCE LINE # 2933
003C 22                RET     
003D         ?C0144:
                                           ; SOURCE LINE # 2934
003D 900000      R     MOV     DPTR,#status
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 EF                MOV     A,R7
0043 B4200F            CJNE    A,#020H,?C0147
                                           ; SOURCE LINE # 2935
                                           ; SOURCE LINE # 2937
0046 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
004B EF                MOV     A,R7
004C 4440              ORL     A,#040H
004E FF                MOV     R7,A
004F 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0052 EF                MOV     A,R7
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2980
0054 22                RET     
0055         ?C0147:
                                           ; SOURCE LINE # 2981
0055 900000      R     MOV     DPTR,#status
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 132 

0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A EF                MOV     A,R7
005B 6401              XRL     A,#01H
005D 7051              JNZ     ?C0151
                                           ; SOURCE LINE # 2982
                                           ; SOURCE LINE # 2984
005F 900000      R     MOV     DPTR,#LIN_1_fsmFlags
0062 E0                MOVX    A,@DPTR
0063 FF                MOV     R7,A
0064 EF                MOV     A,R7
0065 54F7              ANL     A,#0F7H
0067 FF                MOV     R7,A
0068 900000      R     MOV     DPTR,#LIN_1_fsmFlags
006B EF                MOV     A,R7
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2987
006D 9044C8            MOV     DPTR,#044C8H
0070 7402              MOV     A,#02H
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2990
0073 90647C            MOV     DPTR,#0647CH
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 4404              ORL     A,#04H
007B FF                MOV     R7,A
007C EF                MOV     A,R7
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2998
007E 120000      E     LCALL   CyEnterCriticalSection
0081 900000      R     MOV     DPTR,#interruptState
0084 EF                MOV     A,R7
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3000
0086 90649A            MOV     DPTR,#0649AH
0089 E0                MOVX    A,@DPTR
008A FF                MOV     R7,A
008B EF                MOV     A,R7
008C 4401              ORL     A,#01H
008E FF                MOV     R7,A
008F EF                MOV     A,R7
0090 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3001
0091 90649A            MOV     DPTR,#0649AH
0094 E0                MOVX    A,@DPTR
0095 FF                MOV     R7,A
0096 EF                MOV     A,R7
0097 54FE              ANL     A,#0FEH
0099 FF                MOV     R7,A
009A EF                MOV     A,R7
009B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3003
009C 900000      R     MOV     DPTR,#interruptState
009F E0                MOVX    A,@DPTR
00A0 FF                MOV     R7,A
00A1 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 3006
00A4 9044D8            MOV     DPTR,#044D8H
00A7 7402              MOV     A,#02H
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3012
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 133 

00AA 900000      R     MOV     DPTR,#LIN_1_uartFsmState
00AD 7401              MOV     A,#01H
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3020
                                           ; SOURCE LINE # 3022
                                           ; SOURCE LINE # 3024
                                           ; SOURCE LINE # 3025
00B0         ?C0151:
00B0 22                RET     
             ; FUNCTION _LIN_1_EndFrame (END)

             ; FUNCTION _LIN_1_SetAssociatedFlags (BEGIN)
                                           ; SOURCE LINE # 3045
0000 900000      R     MOV     DPTR,#pIndex
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3046
                                           ; SOURCE LINE # 3047
0005 900000      R     MOV     DPTR,#pIndex
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 120000      E     LCALL   ?C?CCASE
000E 0000        R     DW      ?C0153
0010 00                DB      00H
0011 0000        R     DW      ?C0154
0013 01                DB      01H
0014 0000              DW      00H
0016 0000        R     DW      ?C0156
                                           ; SOURCE LINE # 3048
                                           ; SOURCE LINE # 3049
0018         ?C0153:
                                           ; SOURCE LINE # 3051
0018 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 4402              ORL     A,#02H
0020 FF                MOV     R7,A
0021 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0024 EF                MOV     A,R7
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3053
0026 22                RET     
                                           ; SOURCE LINE # 3055
0027         ?C0154:
                                           ; SOURCE LINE # 3057
0027 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 4405              ORL     A,#05H
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#LIN_1_statusFlagArray
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3059
                                           ; SOURCE LINE # 3062
                                           ; SOURCE LINE # 3063
                                           ; SOURCE LINE # 3064
                                           ; SOURCE LINE # 3065
0035         ?C0156:
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 134 

0035 22                RET     
             ; FUNCTION _LIN_1_SetAssociatedFlags (END)

             ; FUNCTION _LIN_1_GetEtFlagValue (BEGIN)
                                           ; SOURCE LINE # 3087
0000 900000      R     MOV     DPTR,#pidIndex
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3088
                                           ; SOURCE LINE # 3091
0005 900000      R     MOV     DPTR,#pidIndex
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 8000              SJMP    ?C0158
                                           ; SOURCE LINE # 3092
                                           ; SOURCE LINE # 3093
000C         ?C0158:
                                           ; SOURCE LINE # 3094
000C 900000      R     MOV     DPTR,#returnValue
000F E4                CLR     A
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3095
                                           ; SOURCE LINE # 3096
0011         ?C0157:
                                           ; SOURCE LINE # 3098
0011 900000      R     MOV     DPTR,#returnValue
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
                                           ; SOURCE LINE # 3099
0016         ?C0159:
0016 22                RET     
             ; FUNCTION _LIN_1_GetEtFlagValue (END)

             ; FUNCTION _LIN_1_ClearEtFlagValue (BEGIN)
                                           ; SOURCE LINE # 3120
0000 900000      R     MOV     DPTR,#pidIndex
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 3121
                                           ; SOURCE LINE # 3122
0005 900000      R     MOV     DPTR,#pidIndex
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 8000              SJMP    ?C0162
                                           ; SOURCE LINE # 3123
                                           ; SOURCE LINE # 3124
                                           ; SOURCE LINE # 3125
                                           ; SOURCE LINE # 3126
                                           ; SOURCE LINE # 3127
000C         ?C0162:
000C 22                RET     
             ; FUNCTION _LIN_1_ClearEtFlagValue (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3768    ----
   CONSTANT SIZE    =     74    ----
   XDATA SIZE       =     41      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.51   LIN_1                                                                 03/21/2014 22:17:42 PAGE 135 

   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
