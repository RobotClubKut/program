C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE LIN_1_UART
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\LIN_1_UART.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\LIN_1_UART.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_951\Debug\LIN_1_UART.lst) CD 
                    -DB NOIP OT(2,SIZE) DF(DEBUG) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_951\Debug\LIN_1_UART.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: LIN_1_UART.c
   3          * Version 2.30
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "LIN_1_UART.h"
  18          #include "CyLib.h"
  19          #if(LIN_1_UART_INTERNAL_CLOCK_USED)
                  #include "LIN_1_UART_IntClock.h"
              #endif /* End LIN_1_UART_INTERNAL_CLOCK_USED */
  22          
  23          
  24          /***************************************
  25          * Global data allocation
  26          ***************************************/
  27          
  28          uint8 LIN_1_UART_initVar = 0u;
  29          #if( LIN_1_UART_TX_ENABLED && (LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                  volatile uint8 LIN_1_UART_txBuffer[LIN_1_UART_TXBUFFERSIZE];
                  volatile uint8 LIN_1_UART_txBufferRead = 0u;
                  uint8 LIN_1_UART_txBufferWrite = 0u;
              #endif /* End LIN_1_UART_TX_ENABLED */
  34          #if( ( LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED ) && \
  35               (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH) )
                  volatile uint8 LIN_1_UART_rxBuffer[LIN_1_UART_RXBUFFERSIZE];
                  volatile uint8 LIN_1_UART_rxBufferRead = 0u;
                  volatile uint8 LIN_1_UART_rxBufferWrite = 0u;
                  volatile uint8 LIN_1_UART_rxBufferLoopDetect = 0u;
                  volatile uint8 LIN_1_UART_rxBufferOverflow = 0u;
                  #if (LIN_1_UART_RXHW_ADDRESS_ENABLED)
                      volatile uint8 LIN_1_UART_rxAddressMode = LIN_1_UART_RXADDRESSMODE;
                      volatile uint8 LIN_1_UART_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */
              #endif /* End LIN_1_UART_RX_ENABLED */
  46          
  47          
  48          /*******************************************************************************
  49          * Function Name: LIN_1_UART_Start
  50          ********************************************************************************
  51          *
  52          * Summary:
  53          *  Initialize and Enable the UART component.
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 2   

  54          *  Enable the clock input to enable operation.
  55          *
  56          * Parameters:
  57          *  None.
  58          *
  59          * Return:
  60          *  None.
  61          *
  62          * Global variables:
  63          *  The LIN_1_UART_intiVar variable is used to indicate initial
  64          *  configuration of this component. The variable is initialized to zero (0u)
  65          *  and set to one (1u) the first time UART_Start() is called. This allows for
  66          *  component initialization without re-initialization in all subsequent calls
  67          *  to the LIN_1_UART_Start() routine.
  68          *
  69          * Reentrant:
  70          *  No.
  71          *
  72          *******************************************************************************/
  73          void LIN_1_UART_Start(void) 
  74          {
  75   1          /* If not Initialized then initialize all required hardware and software */
  76   1          if(LIN_1_UART_initVar == 0u)
  77   1          {
  78   2              LIN_1_UART_Init();
  79   2              LIN_1_UART_initVar = 1u;
  80   2          }
  81   1          LIN_1_UART_Enable();
  82   1      }
  83          
  84          
  85          /*******************************************************************************
  86          * Function Name: LIN_1_UART_Init
  87          ********************************************************************************
  88          *
  89          * Summary:
  90          *  Initialize component's parameters to the parameters set by user in the
  91          *  customizer of the component placed onto schematic. Usually called in
  92          *  LIN_1_UART_Start().
  93          *
  94          * Parameters:
  95          *  None.
  96          *
  97          * Return:
  98          *  None.
  99          *
 100          *******************************************************************************/
 101          void LIN_1_UART_Init(void) 
 102          {
 103   1          #if(LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED)
 104   1      
 105   1              #if(LIN_1_UART_RX_INTERRUPT_ENABLED && (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          /* Set the RX Interrupt. */
                          (void)CyIntSetVector(LIN_1_UART_RX_VECT_NUM, &LIN_1_UART_RXISR);
                          CyIntSetPriority(LIN_1_UART_RX_VECT_NUM, LIN_1_UART_RX_PRIOR_NUM);
                      #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
 110   1      
 111   1              #if (LIN_1_UART_RXHW_ADDRESS_ENABLED)
                          LIN_1_UART_SetRxAddressMode(LIN_1_UART_RXAddressMode);
                          LIN_1_UART_SetRxAddress1(LIN_1_UART_RXHWADDRESS1);
                          LIN_1_UART_SetRxAddress2(LIN_1_UART_RXHWADDRESS2);
                      #endif /* End LIN_1_UART_RXHW_ADDRESS_ENABLED */
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 3   

 116   1      
 117   1              /* Init Count7 period */
 118   1              LIN_1_UART_RXBITCTR_PERIOD_REG = LIN_1_UART_RXBITCTR_INIT;
 119   1              /* Configure the Initial RX interrupt mask */
 120   1              LIN_1_UART_RXSTATUS_MASK_REG  = LIN_1_UART_INIT_RX_INTERRUPTS_MASK;
 121   1          #endif /* End LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED*/
 122   1      
 123   1          #if(LIN_1_UART_TX_ENABLED)
 124   1              #if(LIN_1_UART_TX_INTERRUPT_ENABLED && (LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          /* Set the TX Interrupt. */
                          (void)CyIntSetVector(LIN_1_UART_TX_VECT_NUM, &LIN_1_UART_TXISR);
                          CyIntSetPriority(LIN_1_UART_TX_VECT_NUM, LIN_1_UART_TX_PRIOR_NUM);
                      #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
 129   1      
 130   1              /* Write Counter Value for TX Bit Clk Generator*/
 131   1              #if(LIN_1_UART_TXCLKGEN_DP)
                          LIN_1_UART_TXBITCLKGEN_CTR_REG = LIN_1_UART_BIT_CENTER;
                          LIN_1_UART_TXBITCLKTX_COMPLETE_REG = (LIN_1_UART_NUMBER_OF_DATA_BITS +
                                      LIN_1_UART_NUMBER_OF_START_BIT) * LIN_1_UART_OVER_SAMPLE_COUNT;
                      #else
 136   1                  LIN_1_UART_TXBITCTR_PERIOD_REG = ((LIN_1_UART_NUMBER_OF_DATA_BITS +
 137   1                              LIN_1_UART_NUMBER_OF_START_BIT) * LIN_1_UART_OVER_SAMPLE_8) - 1u;
 138   1              #endif /* End LIN_1_UART_TXCLKGEN_DP */
 139   1      
 140   1              /* Configure the Initial TX interrupt mask */
 141   1              #if(LIN_1_UART_TX_INTERRUPT_ENABLED && (LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          LIN_1_UART_TXSTATUS_MASK_REG = LIN_1_UART_TX_STS_FIFO_EMPTY;
                      #else
 144   1                  LIN_1_UART_TXSTATUS_MASK_REG = LIN_1_UART_INIT_TX_INTERRUPTS_MASK;
 145   1              #endif /*End LIN_1_UART_TX_INTERRUPT_ENABLED*/
 146   1      
 147   1          #endif /* End LIN_1_UART_TX_ENABLED */
 148   1      
 149   1          #if(LIN_1_UART_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      LIN_1_UART_WriteControlRegister( \
                          (LIN_1_UART_ReadControlRegister() & (uint8)~LIN_1_UART_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(LIN_1_UART_PARITY_TYPE << LIN_1_UART_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End LIN_1_UART_PARITY_TYPE_SW */
 154   1      }
 155          
 156          
 157          /*******************************************************************************
 158          * Function Name: LIN_1_UART_Enable
 159          ********************************************************************************
 160          *
 161          * Summary:
 162          *  Enables the UART block operation
 163          *
 164          * Parameters:
 165          *  None.
 166          *
 167          * Return:
 168          *  None.
 169          *
 170          * Global Variables:
 171          *  LIN_1_UART_rxAddressDetected - set to initial state (0).
 172          *
 173          *******************************************************************************/
 174          void LIN_1_UART_Enable(void) 
 175          {
 176   1          uint8 enableInterrupts;
 177   1          enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 4   

 178   1      
 179   1          #if(LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED)
 180   1              /*RX Counter (Count7) Enable */
 181   1              LIN_1_UART_RXBITCTR_CONTROL_REG |= LIN_1_UART_CNTR_ENABLE;
 182   1              /* Enable the RX Interrupt. */
 183   1              LIN_1_UART_RXSTATUS_ACTL_REG  |= LIN_1_UART_INT_ENABLE;
 184   1              #if(LIN_1_UART_RX_INTERRUPT_ENABLED && (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          CyIntEnable(LIN_1_UART_RX_VECT_NUM);
                          #if (LIN_1_UART_RXHW_ADDRESS_ENABLED)
                              LIN_1_UART_rxAddressDetected = 0u;
                          #endif /* End LIN_1_UART_RXHW_ADDRESS_ENABLED */
                      #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
 190   1          #endif /* End LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED*/
 191   1      
 192   1          #if(LIN_1_UART_TX_ENABLED)
 193   1              /*TX Counter (DP/Count7) Enable */
 194   1              #if(!LIN_1_UART_TXCLKGEN_DP)
 195   1                  LIN_1_UART_TXBITCTR_CONTROL_REG |= LIN_1_UART_CNTR_ENABLE;
 196   1              #endif /* End LIN_1_UART_TXCLKGEN_DP */
 197   1              /* Enable the TX Interrupt. */
 198   1              LIN_1_UART_TXSTATUS_ACTL_REG |= LIN_1_UART_INT_ENABLE;
 199   1              #if(LIN_1_UART_TX_INTERRUPT_ENABLED && (LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          CyIntEnable(LIN_1_UART_TX_VECT_NUM);
                      #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED*/
 202   1           #endif /* End LIN_1_UART_TX_ENABLED */
 203   1      
 204   1          #if(LIN_1_UART_INTERNAL_CLOCK_USED)
                      /* Enable the clock. */
                      LIN_1_UART_IntClock_Start();
                  #endif /* End LIN_1_UART_INTERNAL_CLOCK_USED */
 208   1      
 209   1          CyExitCriticalSection(enableInterrupts);
 210   1      }
 211          
 212          
 213          /*******************************************************************************
 214          * Function Name: LIN_1_UART_Stop
 215          ********************************************************************************
 216          *
 217          * Summary:
 218          *  Disable the UART component
 219          *
 220          * Parameters:
 221          *  None.
 222          *
 223          * Return:
 224          *  None.
 225          *
 226          *******************************************************************************/
 227          void LIN_1_UART_Stop(void) 
 228          {
 229   1          uint8 enableInterrupts;
 230   1          enableInterrupts = CyEnterCriticalSection();
 231   1      
 232   1          /* Write Bit Counter Disable */
 233   1          #if(LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED)
 234   1              LIN_1_UART_RXBITCTR_CONTROL_REG &= (uint8)~LIN_1_UART_CNTR_ENABLE;
 235   1          #endif /* End LIN_1_UART_RX_ENABLED */
 236   1      
 237   1          #if(LIN_1_UART_TX_ENABLED)
 238   1              #if(!LIN_1_UART_TXCLKGEN_DP)
 239   1                  LIN_1_UART_TXBITCTR_CONTROL_REG &= (uint8)~LIN_1_UART_CNTR_ENABLE;
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 5   

 240   1              #endif /* End LIN_1_UART_TXCLKGEN_DP */
 241   1          #endif /* LIN_1_UART_TX_ENABLED */
 242   1      
 243   1          #if(LIN_1_UART_INTERNAL_CLOCK_USED)
                      /* Disable the clock. */
                      LIN_1_UART_IntClock_Stop();
                  #endif /* End LIN_1_UART_INTERNAL_CLOCK_USED */
 247   1      
 248   1          /* Disable internal interrupt component */
 249   1          #if(LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED)
 250   1              LIN_1_UART_RXSTATUS_ACTL_REG  &= (uint8)~LIN_1_UART_INT_ENABLE;
 251   1              #if(LIN_1_UART_RX_INTERRUPT_ENABLED && (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          LIN_1_UART_DisableRxInt();
                      #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
 254   1          #endif /* End LIN_1_UART_RX_ENABLED */
 255   1      
 256   1          #if(LIN_1_UART_TX_ENABLED)
 257   1              LIN_1_UART_TXSTATUS_ACTL_REG &= (uint8)~LIN_1_UART_INT_ENABLE;
 258   1              #if(LIN_1_UART_TX_INTERRUPT_ENABLED && (LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          LIN_1_UART_DisableTxInt();
                      #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
 261   1          #endif /* End LIN_1_UART_TX_ENABLED */
 262   1      
 263   1          CyExitCriticalSection(enableInterrupts);
 264   1      }
 265          
 266          
 267          /*******************************************************************************
 268          * Function Name: LIN_1_UART_ReadControlRegister
 269          ********************************************************************************
 270          *
 271          * Summary:
 272          *  Read the current state of the control register
 273          *
 274          * Parameters:
 275          *  None.
 276          *
 277          * Return:
 278          *  Current state of the control register.
 279          *
 280          *******************************************************************************/
 281          uint8 LIN_1_UART_ReadControlRegister(void) 
 282          {
 283   1          #if( LIN_1_UART_CONTROL_REG_REMOVED )
 284   1              return(0u);
 285   1          #else
                      return(LIN_1_UART_CONTROL_REG);
                  #endif /* End LIN_1_UART_CONTROL_REG_REMOVED */
 288   1      }
 289          
 290          
 291          /*******************************************************************************
 292          * Function Name: LIN_1_UART_WriteControlRegister
 293          ********************************************************************************
 294          *
 295          * Summary:
 296          *  Writes an 8-bit value into the control register
 297          *
 298          * Parameters:
 299          *  control:  control register value
 300          *
 301          * Return:
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 6   

 302          *  None.
 303          *
 304          *******************************************************************************/
 305          void  LIN_1_UART_WriteControlRegister(uint8 control) 
 306          {
 307   1          #if( LIN_1_UART_CONTROL_REG_REMOVED )
 308   1              if(control != 0u) { }      /* release compiler warning */
 309   1          #else
                     LIN_1_UART_CONTROL_REG = control;
                  #endif /* End LIN_1_UART_CONTROL_REG_REMOVED */
 312   1      }
 313          
 314          
 315          #if(LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED)
 316          
 317              #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: LIN_1_UART_EnableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void LIN_1_UART_EnableRxInt(void) 
                      {
                          CyIntEnable(LIN_1_UART_RX_VECT_NUM);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: LIN_1_UART_DisableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void LIN_1_UART_DisableRxInt(void) 
                      {
                          CyIntDisable(LIN_1_UART_RX_VECT_NUM);
                      }
              
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 7   

                  #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
 365          
 366          
 367              /*******************************************************************************
 368              * Function Name: LIN_1_UART_SetRxInterruptMode
 369              ********************************************************************************
 370              *
 371              * Summary:
 372              *  Configure which status bits trigger an interrupt event
 373              *
 374              * Parameters:
 375              *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376              *           the header file)
 377              *
 378              * Return:
 379              *  None.
 380              *
 381              * Theory:
 382              *  Enables the output of specific status bits to the interrupt controller
 383              *
 384              *******************************************************************************/
 385              void LIN_1_UART_SetRxInterruptMode(uint8 intSrc) 
 386              {
 387   1              LIN_1_UART_RXSTATUS_MASK_REG  = intSrc;
 388   1          }
 389          
 390          
 391              /*******************************************************************************
 392              * Function Name: LIN_1_UART_ReadRxData
 393              ********************************************************************************
 394              *
 395              * Summary:
 396              *  Returns data in RX Data register without checking status register to
 397              *  determine if data is valid
 398              *
 399              * Parameters:
 400              *  None.
 401              *
 402              * Return:
 403              *  Received data from RX register
 404              *
 405              * Global Variables:
 406              *  LIN_1_UART_rxBuffer - RAM buffer pointer for save received data.
 407              *  LIN_1_UART_rxBufferWrite - cyclic index for write to rxBuffer,
 408              *     checked to identify new data.
 409              *  LIN_1_UART_rxBufferRead - cyclic index for read from rxBuffer,
 410              *     incremented after each byte has been read from buffer.
 411              *  LIN_1_UART_rxBufferLoopDetect - creared if loop condition was detected
 412              *     in RX ISR.
 413              *
 414              * Reentrant:
 415              *  No.
 416              *
 417              *******************************************************************************/
 418              uint8 LIN_1_UART_ReadRxData(void) 
 419              {
 420   1              uint8 rxData;
 421   1      
 422   1              #if(LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 8   

                          /* Disable Rx interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_DisableRxInt();
                          #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = LIN_1_UART_rxBufferRead;
                          loc_rxBufferWrite = LIN_1_UART_rxBufferWrite;
              
                          if( (LIN_1_UART_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = LIN_1_UART_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
              
                              if(loc_rxBufferRead >= LIN_1_UART_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              LIN_1_UART_rxBufferRead = loc_rxBufferRead;
              
                              if(LIN_1_UART_rxBufferLoopDetect != 0u )
                              {
                                  LIN_1_UART_rxBufferLoopDetect = 0u;
                                  #if( (LIN_1_UART_RX_INTERRUPT_ENABLED) && (LIN_1_UART_FLOW_CONTROL != 0u) && \
                                       (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( LIN_1_UART_HD_ENABLED )
                                          if((LIN_1_UART_CONTROL_REG & LIN_1_UART_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only in RX
                                              *  configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              LIN_1_UART_RXSTATUS_MASK_REG  |= LIN_1_UART_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          LIN_1_UART_RXSTATUS_MASK_REG  |= LIN_1_UART_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end LIN_1_UART_HD_ENABLED */
                                  #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
                          }
                          else
                          {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                              rxData = LIN_1_UART_RXDATA_REG;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_EnableRxInt();
                          #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
              
                      #else /* LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 476   1      
 477   1                  /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478   1                  rxData = LIN_1_UART_RXDATA_REG;
 479   1      
 480   1              #endif /* LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 481   1      
 482   1              return(rxData);
 483   1          }
 484          
 485          
 486              /*******************************************************************************
 487              * Function Name: LIN_1_UART_ReadRxStatus
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 9   

 488              ********************************************************************************
 489              *
 490              * Summary:
 491              *  Read the current state of the status register
 492              *  And detect software buffer overflow.
 493              *
 494              * Parameters:
 495              *  None.
 496              *
 497              * Return:
 498              *  Current state of the status register.
 499              *
 500              * Global Variables:
 501              *  LIN_1_UART_rxBufferOverflow - used to indicate overload condition.
 502              *   It set to one in RX interrupt when there isn?t free space in
 503              *   LIN_1_UART_rxBufferRead to write new data. This condition returned
 504              *   and cleared to zero by this API as an
 505              *   LIN_1_UART_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506              *   bits.
 507              *
 508              *******************************************************************************/
 509              uint8 LIN_1_UART_ReadRxStatus(void) 
 510              {
 511   1              uint8 status;
 512   1      
 513   1              status = LIN_1_UART_RXSTATUS_REG & LIN_1_UART_RX_HW_MASK;
 514   1      
 515   1              #if(LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
                          if( LIN_1_UART_rxBufferOverflow != 0u )
                          {
                              status |= LIN_1_UART_RX_STS_SOFT_BUFF_OVER;
                              LIN_1_UART_rxBufferOverflow = 0u;
                          }
                      #endif /* LIN_1_UART_RXBUFFERSIZE */
 522   1      
 523   1              return(status);
 524   1          }
 525          
 526          
 527              /*******************************************************************************
 528              * Function Name: LIN_1_UART_GetChar
 529              ********************************************************************************
 530              *
 531              * Summary:
 532              *  Reads UART RX buffer immediately, if data is not available or an error
 533              *  condition exists, zero is returned; otherwise, character is read and
 534              *  returned.
 535              *
 536              * Parameters:
 537              *  None.
 538              *
 539              * Return:
 540              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541              *  A returned zero signifies an error condition or no data available.
 542              *
 543              * Global Variables:
 544              *  LIN_1_UART_rxBuffer - RAM buffer pointer for save received data.
 545              *  LIN_1_UART_rxBufferWrite - cyclic index for write to rxBuffer,
 546              *     checked to identify new data.
 547              *  LIN_1_UART_rxBufferRead - cyclic index for read from rxBuffer,
 548              *     incremented after each byte has been read from buffer.
 549              *  LIN_1_UART_rxBufferLoopDetect - creared if loop condition was detected
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 10  

 550              *     in RX ISR.
 551              *
 552              * Reentrant:
 553              *  No.
 554              *
 555              *******************************************************************************/
 556              uint8 LIN_1_UART_GetChar(void) 
 557              {
 558   1              uint8 rxData = 0u;
 559   1              uint8 rxStatus;
 560   1      
 561   1              #if(LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
                          /* Disable Rx interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_DisableRxInt();
                          #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = LIN_1_UART_rxBufferRead;
                          loc_rxBufferWrite = LIN_1_UART_rxBufferWrite;
              
                          if( (LIN_1_UART_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = LIN_1_UART_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
                              if(loc_rxBufferRead >= LIN_1_UART_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              LIN_1_UART_rxBufferRead = loc_rxBufferRead;
              
                              if(LIN_1_UART_rxBufferLoopDetect > 0u )
                              {
                                  LIN_1_UART_rxBufferLoopDetect = 0u;
                                  #if( (LIN_1_UART_RX_INTERRUPT_ENABLED) && (LIN_1_UART_FLOW_CONTROL != 0u) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( LIN_1_UART_HD_ENABLED )
                                          if((LIN_1_UART_CONTROL_REG & LIN_1_UART_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only if
                                              *  RX configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              LIN_1_UART_RXSTATUS_MASK_REG  |= LIN_1_UART_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          LIN_1_UART_RXSTATUS_MASK_REG  |= LIN_1_UART_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end LIN_1_UART_HD_ENABLED */
                                  #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
              
                          }
                          else
                          {   rxStatus = LIN_1_UART_RXSTATUS_REG;
                              if((rxStatus & LIN_1_UART_RX_STS_FIFO_NOTEMPTY) != 0u)
                              {   /* Read received data from FIFO*/
                                  rxData = LIN_1_UART_RXDATA_REG;
                                  /*Check status on error*/
                                  if((rxStatus & (LIN_1_UART_RX_STS_BREAK | LIN_1_UART_RX_STS_PAR_ERROR |
                                                 LIN_1_UART_RX_STS_STOP_ERROR | LIN_1_UART_RX_STS_OVERRUN)) != 0u)
                                  {
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 11  

                                      rxData = 0u;
                                  }
                              }
                          }
              
                          /* Enable Rx interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_EnableRxInt();
                          #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
              
                      #else /* LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 623   1      
 624   1                  rxStatus =LIN_1_UART_RXSTATUS_REG;
 625   1                  if((rxStatus & LIN_1_UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 626   1                  {   /* Read received data from FIFO*/
 627   2                      rxData = LIN_1_UART_RXDATA_REG;
 628   2                      /*Check status on error*/
 629   2                      if((rxStatus & (LIN_1_UART_RX_STS_BREAK | LIN_1_UART_RX_STS_PAR_ERROR |
 630   2                                     LIN_1_UART_RX_STS_STOP_ERROR | LIN_1_UART_RX_STS_OVERRUN)) != 0u)
 631   2                      {
 632   3                          rxData = 0u;
 633   3                      }
 634   2                  }
 635   1              #endif /* LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 636   1      
 637   1              return(rxData);
 638   1          }
 639          
 640          
 641              /*******************************************************************************
 642              * Function Name: LIN_1_UART_GetByte
 643              ********************************************************************************
 644              *
 645              * Summary:
 646              *  Grab the next available byte of data from the recieve FIFO
 647              *
 648              * Parameters:
 649              *  None.
 650              *
 651              * Return:
 652              *  MSB contains Status Register and LSB contains UART RX data
 653              *
 654              * Reentrant:
 655              *  No.
 656              *
 657              *******************************************************************************/
 658              uint16 LIN_1_UART_GetByte(void) 
 659              {
 660   1              return ( ((uint16)LIN_1_UART_ReadRxStatus() << 8u) | LIN_1_UART_ReadRxData() );
 661   1          }
 662          
 663          
 664              /*******************************************************************************
 665              * Function Name: LIN_1_UART_GetRxBufferSize
 666              ********************************************************************************
 667              *
 668              * Summary:
 669              *  Determine the amount of bytes left in the RX buffer and return the count in
 670              *  bytes
 671              *
 672              * Parameters:
 673              *  None.
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 12  

 674              *
 675              * Return:
 676              *  uint8: Integer count of the number of bytes left
 677              *  in the RX buffer
 678              *
 679              * Global Variables:
 680              *  LIN_1_UART_rxBufferWrite - used to calculate left bytes.
 681              *  LIN_1_UART_rxBufferRead - used to calculate left bytes.
 682              *  LIN_1_UART_rxBufferLoopDetect - checked to decide left bytes amount.
 683              *
 684              * Reentrant:
 685              *  No.
 686              *
 687              * Theory:
 688              *  Allows the user to find out how full the RX Buffer is.
 689              *
 690              *******************************************************************************/
 691              uint8 LIN_1_UART_GetRxBufferSize(void)
 692                                                                      
 693              {
 694   1              uint8 size;
 695   1      
 696   1              #if(LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_DisableRxInt();
                          #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
              
                          if(LIN_1_UART_rxBufferRead == LIN_1_UART_rxBufferWrite)
                          {
                              if(LIN_1_UART_rxBufferLoopDetect > 0u)
                              {
                                  size = LIN_1_UART_RXBUFFERSIZE;
                              }
                              else
                              {
                                  size = 0u;
                              }
                          }
                          else if(LIN_1_UART_rxBufferRead < LIN_1_UART_rxBufferWrite)
                          {
                              size = (LIN_1_UART_rxBufferWrite - LIN_1_UART_rxBufferRead);
                          }
                          else
                          {
                              size = (LIN_1_UART_RXBUFFERSIZE - LIN_1_UART_rxBufferRead) + LIN_1_UART_rxBufferWrite;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_EnableRxInt();
                          #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
              
                      #else /* LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 730   1      
 731   1                  /* We can only know if there is data in the fifo. */
 732   1                  size = ((LIN_1_UART_RXSTATUS_REG & LIN_1_UART_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 733   1      
 734   1              #endif /* End LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 735   1      
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 13  

 736   1              return(size);
 737   1          }
 738          
 739          
 740              /*******************************************************************************
 741              * Function Name: LIN_1_UART_ClearRxBuffer
 742              ********************************************************************************
 743              *
 744              * Summary:
 745              *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746              *  Clears hardware RX FIFO.
 747              *
 748              * Parameters:
 749              *  None.
 750              *
 751              * Return:
 752              *  None.
 753              *
 754              * Global Variables:
 755              *  LIN_1_UART_rxBufferWrite - cleared to zero.
 756              *  LIN_1_UART_rxBufferRead - cleared to zero.
 757              *  LIN_1_UART_rxBufferLoopDetect - cleared to zero.
 758              *  LIN_1_UART_rxBufferOverflow - cleared to zero.
 759              *
 760              * Reentrant:
 761              *  No.
 762              *
 763              * Theory:
 764              *  Setting the pointers to zero makes the system believe there is no data to
 765              *  read and writing will resume at address 0 overwriting any data that may
 766              *  have remained in the RAM.
 767              *
 768              * Side Effects:
 769              *  Any received data not read from the RAM or FIFO buffer will be lost.
 770              *******************************************************************************/
 771              void LIN_1_UART_ClearRxBuffer(void) 
 772              {
 773   1              uint8 enableInterrupts;
 774   1      
 775   1              /* clear the HW FIFO */
 776   1              /* Enter critical section */
 777   1              enableInterrupts = CyEnterCriticalSection();
 778   1              LIN_1_UART_RXDATA_AUX_CTL_REG |=  LIN_1_UART_RX_FIFO_CLR;
 779   1              LIN_1_UART_RXDATA_AUX_CTL_REG &= (uint8)~LIN_1_UART_RX_FIFO_CLR;
 780   1              /* Exit critical section */
 781   1              CyExitCriticalSection(enableInterrupts);
 782   1      
 783   1              #if(LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_DisableRxInt();
                          #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
              
                          LIN_1_UART_rxBufferRead = 0u;
                          LIN_1_UART_rxBufferWrite = 0u;
                          LIN_1_UART_rxBufferLoopDetect = 0u;
                          LIN_1_UART_rxBufferOverflow = 0u;
              
                          /* Enable Rx interrupt. */
                          #if(LIN_1_UART_RX_INTERRUPT_ENABLED)
                              LIN_1_UART_EnableRxInt();
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 14  

                          #endif /* End LIN_1_UART_RX_INTERRUPT_ENABLED */
                      #endif /* End LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
 800   1      
 801   1          }
 802          
 803          
 804              /*******************************************************************************
 805              * Function Name: LIN_1_UART_SetRxAddressMode
 806              ********************************************************************************
 807              *
 808              * Summary:
 809              *  Set the receive addressing mode
 810              *
 811              * Parameters:
 812              *  addressMode: Enumerated value indicating the mode of RX addressing
 813              *  LIN_1_UART__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814              *                                               detection
 815              *  LIN_1_UART__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816              *                                               address detection
 817              *  LIN_1_UART__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818              *                                               detection
 819              *  LIN_1_UART__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820              *                                               address detection
 821              *  LIN_1_UART__B_UART__AM_NONE - No address detection
 822              *
 823              * Return:
 824              *  None.
 825              *
 826              * Global Variables:
 827              *  LIN_1_UART_rxAddressMode - the parameter stored in this variable for
 828              *   the farther usage in RX ISR.
 829              *  LIN_1_UART_rxAddressDetected - set to initial state (0).
 830              *
 831              *******************************************************************************/
 832              void LIN_1_UART_SetRxAddressMode(uint8 addressMode)
 833                                                                  
 834              {
 835   1              #if(LIN_1_UART_RXHW_ADDRESS_ENABLED)
                          #if(LIN_1_UART_CONTROL_REG_REMOVED)
                              if(addressMode != 0u) { }     /* release compiler warning */
                          #else /* LIN_1_UART_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = LIN_1_UART_CONTROL_REG & (uint8)~LIN_1_UART_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << LIN_1_UART_CTRL_RXADDR_MODE0_SHIFT);
                              LIN_1_UART_CONTROL_REG = tmpCtrl;
                              #if(LIN_1_UART_RX_INTERRUPT_ENABLED && \
                                 (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH) )
                                  LIN_1_UART_rxAddressMode = addressMode;
                                  LIN_1_UART_rxAddressDetected = 0u;
                              #endif /* End LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH*/
                          #endif /* End LIN_1_UART_CONTROL_REG_REMOVED */
                      #else /* LIN_1_UART_RXHW_ADDRESS_ENABLED */
 850   1                  if(addressMode != 0u) { }     /* release compiler warning */
 851   1              #endif /* End LIN_1_UART_RXHW_ADDRESS_ENABLED */
 852   1          }
 853          
 854          
 855              /*******************************************************************************
 856              * Function Name: LIN_1_UART_SetRxAddress1
 857              ********************************************************************************
 858              *
 859              * Summary:
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 15  

 860              *  Set the first hardware address compare value
 861              *
 862              * Parameters:
 863              *  address
 864              *
 865              * Return:
 866              *  None.
 867              *
 868              *******************************************************************************/
 869              void LIN_1_UART_SetRxAddress1(uint8 address) 
 870          
 871              {
 872   1              LIN_1_UART_RXADDRESS1_REG = address;
 873   1          }
 874          
 875          
 876              /*******************************************************************************
 877              * Function Name: LIN_1_UART_SetRxAddress2
 878              ********************************************************************************
 879              *
 880              * Summary:
 881              *  Set the second hardware address compare value
 882              *
 883              * Parameters:
 884              *  address
 885              *
 886              * Return:
 887              *  None.
 888              *
 889              *******************************************************************************/
 890              void LIN_1_UART_SetRxAddress2(uint8 address) 
 891              {
 892   1              LIN_1_UART_RXADDRESS2_REG = address;
 893   1          }
 894          
 895          #endif  /* LIN_1_UART_RX_ENABLED || LIN_1_UART_HD_ENABLED*/
 896          
 897          
 898          #if( (LIN_1_UART_TX_ENABLED) || (LIN_1_UART_HD_ENABLED) )
 899          
 900              #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: LIN_1_UART_EnableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void LIN_1_UART_EnableTxInt(void) 
                      {
                          CyIntEnable(LIN_1_UART_TX_VECT_NUM);
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 16  

                      }
              
              
                      /*******************************************************************************
                      * Function Name: LIN_1_UART_DisableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void LIN_1_UART_DisableTxInt(void) 
                      {
                          CyIntDisable(LIN_1_UART_TX_VECT_NUM);
                      }
              
                  #endif /* LIN_1_UART_TX_INTERRUPT_ENABLED */
 948          
 949          
 950              /*******************************************************************************
 951              * Function Name: LIN_1_UART_SetTxInterruptMode
 952              ********************************************************************************
 953              *
 954              * Summary:
 955              *  Configure which status bits trigger an interrupt event
 956              *
 957              * Parameters:
 958              *  intSrc: An or'd combination of the desired status bit masks (defined in
 959              *          the header file)
 960              *
 961              * Return:
 962              *  None.
 963              *
 964              * Theory:
 965              *  Enables the output of specific status bits to the interrupt controller
 966              *
 967              *******************************************************************************/
 968              void LIN_1_UART_SetTxInterruptMode(uint8 intSrc) 
 969              {
 970   1              LIN_1_UART_TXSTATUS_MASK_REG = intSrc;
 971   1          }
 972          
 973          
 974              /*******************************************************************************
 975              * Function Name: LIN_1_UART_WriteTxData
 976              ********************************************************************************
 977              *
 978              * Summary:
 979              *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980              *  bus is available. WriteTxData sends a byte without checking for buffer room
 981              *  or status. It is up to the user to separately check status.
 982              *
 983              * Parameters:
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 17  

 984              *  TXDataByte: byte of data to place in the transmit FIFO
 985              *
 986              * Return:
 987              * void
 988              *
 989              * Global Variables:
 990              *  LIN_1_UART_txBuffer - RAM buffer pointer for save data for transmission
 991              *  LIN_1_UART_txBufferWrite - cyclic index for write to txBuffer,
 992              *    incremented after each byte saved to buffer.
 993              *  LIN_1_UART_txBufferRead - cyclic index for read from txBuffer,
 994              *    checked to identify the condition to write to FIFO directly or to TX buffer
 995              *  LIN_1_UART_initVar - checked to identify that the component has been
 996              *    initialized.
 997              *
 998              * Reentrant:
 999              *  No.
1000              *
1001              *******************************************************************************/
1002              void LIN_1_UART_WriteTxData(uint8 txDataByte) 
1003              {
1004   1              /* If not Initialized then skip this function*/
1005   1              if(LIN_1_UART_initVar != 0u)
1006   1              {
1007   2                  #if(LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
              
                              /* Disable Tx interrupt. */
                              /* Protect variables that could change on interrupt. */
                              #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
                                  LIN_1_UART_DisableTxInt();
                              #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
              
                              if( (LIN_1_UART_txBufferRead == LIN_1_UART_txBufferWrite) &&
                                  ((LIN_1_UART_TXSTATUS_REG & LIN_1_UART_TX_STS_FIFO_FULL) == 0u) )
                              {
                                  /* Add directly to the FIFO. */
                                  LIN_1_UART_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(LIN_1_UART_txBufferWrite >= LIN_1_UART_TXBUFFERSIZE)
                                  {
                                      LIN_1_UART_txBufferWrite = 0u;
                                  }
              
                                  LIN_1_UART_txBuffer[LIN_1_UART_txBufferWrite] = txDataByte;
              
                                  /* Add to the software buffer. */
                                  LIN_1_UART_txBufferWrite++;
              
                              }
              
                              /* Enable Tx interrupt. */
                              #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
                                  LIN_1_UART_EnableTxInt();
                              #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
              
                          #else /* LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
1041   2      
1042   2                      /* Add directly to the FIFO. */
1043   2                      LIN_1_UART_TXDATA_REG = txDataByte;
1044   2      
1045   2                  #endif /* End LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 18  

1046   2              }
1047   1          }
1048          
1049          
1050              /*******************************************************************************
1051              * Function Name: LIN_1_UART_ReadTxStatus
1052              ********************************************************************************
1053              *
1054              * Summary:
1055              *  Read the status register for the component
1056              *
1057              * Parameters:
1058              *  None.
1059              *
1060              * Return:
1061              *  Contents of the status register
1062              *
1063              * Theory:
1064              *  This function reads the status register which is clear on read. It is up to
1065              *  the user to handle all bits in this return value accordingly, even if the bit
1066              *  was not enabled as an interrupt source the event happened and must be handled
1067              *  accordingly.
1068              *
1069              *******************************************************************************/
1070              uint8 LIN_1_UART_ReadTxStatus(void) 
1071              {
1072   1              return(LIN_1_UART_TXSTATUS_REG);
1073   1          }
1074          
1075          
1076              /*******************************************************************************
1077              * Function Name: LIN_1_UART_PutChar
1078              ********************************************************************************
1079              *
1080              * Summary:
1081              *  Wait to send byte until TX register or buffer has room.
1082              *
1083              * Parameters:
1084              *  txDataByte: The 8-bit data value to send across the UART.
1085              *
1086              * Return:
1087              *  None.
1088              *
1089              * Global Variables:
1090              *  LIN_1_UART_txBuffer - RAM buffer pointer for save data for transmission
1091              *  LIN_1_UART_txBufferWrite - cyclic index for write to txBuffer,
1092              *     checked to identify free space in txBuffer and incremented after each byte
1093              *     saved to buffer.
1094              *  LIN_1_UART_txBufferRead - cyclic index for read from txBuffer,
1095              *     checked to identify free space in txBuffer.
1096              *  LIN_1_UART_initVar - checked to identify that the component has been
1097              *     initialized.
1098              *
1099              * Reentrant:
1100              *  No.
1101              *
1102              * Theory:
1103              *  Allows the user to transmit any byte of data in a single transfer
1104              *
1105              *******************************************************************************/
1106              void LIN_1_UART_PutChar(uint8 txDataByte) 
1107              {
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 19  

1108   1                  #if(LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
                              /* The temporary output pointer is used since it takes two instructions
                              *  to increment with a wrap, and we can't risk doing that with the real
                              *  pointer and getting an interrupt in between instructions.
                              */
                              uint8 loc_txBufferWrite;
                              uint8 loc_txBufferRead;
              
                              do{
                                  /* Block if software buffer is full, so we don't overwrite. */
                                  #if ((LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Disable TX interrupt to protect variables that could change on interrupt */
                                      CyIntDisable(LIN_1_UART_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                                  loc_txBufferWrite = LIN_1_UART_txBufferWrite;
                                  loc_txBufferRead = LIN_1_UART_txBufferRead;
                                  #if ((LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Enable interrupt to continue transmission */
                                      CyIntEnable(LIN_1_UART_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                              }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBufferRead -
             - 1u)) :
                                                      ((loc_txBufferWrite - loc_txBufferRead) ==
                                                      (uint8)(LIN_1_UART_TXBUFFERSIZE - 1u)) );
              
                              if( (loc_txBufferRead == loc_txBufferWrite) &&
                                  ((LIN_1_UART_TXSTATUS_REG & LIN_1_UART_TX_STS_FIFO_FULL) == 0u) )
                              {
                                  /* Add directly to the FIFO. */
                                  LIN_1_UART_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(loc_txBufferWrite >= LIN_1_UART_TXBUFFERSIZE)
                                  {
                                      loc_txBufferWrite = 0u;
                                  }
                                  /* Add to the software buffer. */
                                  LIN_1_UART_txBuffer[loc_txBufferWrite] = txDataByte;
                                  loc_txBufferWrite++;
              
                                  /* Finally, update the real output pointer */
                                  #if ((LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntDisable(LIN_1_UART_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                                  LIN_1_UART_txBufferWrite = loc_txBufferWrite;
                                  #if ((LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntEnable(LIN_1_UART_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                              }
              
                          #else /* LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
1159   1      
1160   1                      while((LIN_1_UART_TXSTATUS_REG & LIN_1_UART_TX_STS_FIFO_FULL) != 0u)
1161   1                      {
1162   2                          ; /* Wait for room in the FIFO. */
1163   2                      }
1164   1      
1165   1                      /* Add directly to the FIFO. */
1166   1                      LIN_1_UART_TXDATA_REG = txDataByte;
1167   1      
1168   1                  #endif /* End LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 20  

1169   1          }
1170          
1171          
1172              /*******************************************************************************
1173              * Function Name: LIN_1_UART_PutString
1174              ********************************************************************************
1175              *
1176              * Summary:
1177              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178              *
1179              * Parameters:
1180              *  string: char pointer to character string of Data to Send.
1181              *
1182              * Return:
1183              *  None.
1184              *
1185              * Global Variables:
1186              *  LIN_1_UART_initVar - checked to identify that the component has been
1187              *     initialized.
1188              *
1189              * Reentrant:
1190              *  No.
1191              *
1192              * Theory:
1193              *  This function will block if there is not enough memory to place the whole
1194              *  string, it will block until the entire string has been written to the
1195              *  transmit buffer.
1196              *
1197              *******************************************************************************/
1198              void LIN_1_UART_PutString(const char8 string[]) 
1199              {
1200   1              uint16 buf_index = 0u;
1201   1              /* If not Initialized then skip this function*/
1202   1              if(LIN_1_UART_initVar != 0u)
1203   1              {
1204   2                  /* This is a blocking function, it will not exit until all data is sent*/
1205   2                  while(string[buf_index] != (char8)0)
1206   2                  {
1207   3                      LIN_1_UART_PutChar((uint8)string[buf_index]);
1208   3                      buf_index++;
1209   3                  }
1210   2              }
1211   1          }
1212          
1213          
1214              /*******************************************************************************
1215              * Function Name: LIN_1_UART_PutArray
1216              ********************************************************************************
1217              *
1218              * Summary:
1219              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220              *
1221              * Parameters:
1222              *  string: Address of the memory array residing in RAM or ROM.
1223              *  byteCount: Number of Bytes to be transmitted.
1224              *
1225              * Return:
1226              *  None.
1227              *
1228              * Global Variables:
1229              *  LIN_1_UART_initVar - checked to identify that the component has been
1230              *     initialized.
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 21  

1231              *
1232              * Reentrant:
1233              *  No.
1234              *
1235              *******************************************************************************/
1236              void LIN_1_UART_PutArray(const uint8 string[], uint8 byteCount)
1237                                                                              
1238              {
1239   1              uint8 buf_index = 0u;
1240   1              /* If not Initialized then skip this function*/
1241   1              if(LIN_1_UART_initVar != 0u)
1242   1              {
1243   2                  do
1244   2                  {
1245   3                      LIN_1_UART_PutChar(string[buf_index]);
1246   3                      buf_index++;
1247   3                  }while(buf_index < byteCount);
1248   2              }
1249   1          }
1250          
1251          
1252              /*******************************************************************************
1253              * Function Name: LIN_1_UART_PutCRLF
1254              ********************************************************************************
1255              *
1256              * Summary:
1257              *  Write a character and then carriage return and line feed.
1258              *
1259              * Parameters:
1260              *  txDataByte: uint8 Character to send.
1261              *
1262              * Return:
1263              *  None.
1264              *
1265              * Global Variables:
1266              *  LIN_1_UART_initVar - checked to identify that the component has been
1267              *     initialized.
1268              *
1269              * Reentrant:
1270              *  No.
1271              *
1272              *******************************************************************************/
1273              void LIN_1_UART_PutCRLF(uint8 txDataByte) 
1274              {
1275   1              /* If not Initialized then skip this function*/
1276   1              if(LIN_1_UART_initVar != 0u)
1277   1              {
1278   2                  LIN_1_UART_PutChar(txDataByte);
1279   2                  LIN_1_UART_PutChar(0x0Du);
1280   2                  LIN_1_UART_PutChar(0x0Au);
1281   2              }
1282   1          }
1283          
1284          
1285              /*******************************************************************************
1286              * Function Name: LIN_1_UART_GetTxBufferSize
1287              ********************************************************************************
1288              *
1289              * Summary:
1290              *  Determine the amount of space left in the TX buffer and return the count in
1291              *  bytes
1292              *
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 22  

1293              * Parameters:
1294              *  None.
1295              *
1296              * Return:
1297              *  Integer count of the number of bytes left in the TX buffer
1298              *
1299              * Global Variables:
1300              *  LIN_1_UART_txBufferWrite - used to calculate left space.
1301              *  LIN_1_UART_txBufferRead - used to calculate left space.
1302              *
1303              * Reentrant:
1304              *  No.
1305              *
1306              * Theory:
1307              *  Allows the user to find out how full the TX Buffer is.
1308              *
1309              *******************************************************************************/
1310              uint8 LIN_1_UART_GetTxBufferSize(void)
1311                                                                      
1312              {
1313   1              uint8 size;
1314   1      
1315   1              #if(LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
                              LIN_1_UART_DisableTxInt();
                          #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
              
                          if(LIN_1_UART_txBufferRead == LIN_1_UART_txBufferWrite)
                          {
                              size = 0u;
                          }
                          else if(LIN_1_UART_txBufferRead < LIN_1_UART_txBufferWrite)
                          {
                              size = (LIN_1_UART_txBufferWrite - LIN_1_UART_txBufferRead);
                          }
                          else
                          {
                              size = (LIN_1_UART_TXBUFFERSIZE - LIN_1_UART_txBufferRead) + LIN_1_UART_txBufferWrite;
                          }
              
                          /* Enable Tx interrupt. */
                          #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
                              LIN_1_UART_EnableTxInt();
                          #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
              
                      #else /* LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
1342   1      
1343   1                  size = LIN_1_UART_TXSTATUS_REG;
1344   1      
1345   1                  /* Is the fifo is full. */
1346   1                  if((size & LIN_1_UART_TX_STS_FIFO_FULL) != 0u)
1347   1                  {
1348   2                      size = LIN_1_UART_FIFO_LENGTH;
1349   2                  }
1350   1                  else if((size & LIN_1_UART_TX_STS_FIFO_EMPTY) != 0u)
1351   1                  {
1352   2                      size = 0u;
1353   2                  }
1354   1                  else
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 23  

1355   1                  {
1356   2                      /* We only know there is data in the fifo. */
1357   2                      size = 1u;
1358   2                  }
1359   1      
1360   1              #endif /* End LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
1361   1      
1362   1              return(size);
1363   1          }
1364          
1365          
1366              /*******************************************************************************
1367              * Function Name: LIN_1_UART_ClearTxBuffer
1368              ********************************************************************************
1369              *
1370              * Summary:
1371              *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372              *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373              *
1374              * Parameters:
1375              *  None.
1376              *
1377              * Return:
1378              *  None.
1379              *
1380              * Global Variables:
1381              *  LIN_1_UART_txBufferWrite - cleared to zero.
1382              *  LIN_1_UART_txBufferRead - cleared to zero.
1383              *
1384              * Reentrant:
1385              *  No.
1386              *
1387              * Theory:
1388              *  Setting the pointers to zero makes the system believe there is no data to
1389              *  read and writing will resume at address 0 overwriting any data that may have
1390              *  remained in the RAM.
1391              *
1392              * Side Effects:
1393              *  Any received data not read from the RAM buffer will be lost when overwritten.
1394              *
1395              *******************************************************************************/
1396              void LIN_1_UART_ClearTxBuffer(void) 
1397              {
1398   1              uint8 enableInterrupts;
1399   1      
1400   1              /* Enter critical section */
1401   1              enableInterrupts = CyEnterCriticalSection();
1402   1              /* clear the HW FIFO */
1403   1              LIN_1_UART_TXDATA_AUX_CTL_REG |=  LIN_1_UART_TX_FIFO_CLR;
1404   1              LIN_1_UART_TXDATA_AUX_CTL_REG &= (uint8)~LIN_1_UART_TX_FIFO_CLR;
1405   1              /* Exit critical section */
1406   1              CyExitCriticalSection(enableInterrupts);
1407   1      
1408   1              #if(LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
                              LIN_1_UART_DisableTxInt();
                          #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
              
                          LIN_1_UART_txBufferRead = 0u;
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 24  

                          LIN_1_UART_txBufferWrite = 0u;
              
                          /* Enable Tx interrupt. */
                          #if(LIN_1_UART_TX_INTERRUPT_ENABLED)
                              LIN_1_UART_EnableTxInt();
                          #endif /* End LIN_1_UART_TX_INTERRUPT_ENABLED */
              
                      #endif /* End LIN_1_UART_TXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH */
1425   1          }
1426          
1427          
1428              /*******************************************************************************
1429              * Function Name: LIN_1_UART_SendBreak
1430              ********************************************************************************
1431              *
1432              * Summary:
1433              *  Write a Break command to the UART
1434              *
1435              * Parameters:
1436              *  uint8 retMode:  Wait mode,
1437              *   0 - Initialize registers for Break, sends the Break signal and return
1438              *       imediately.
1439              *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440              *       transmission mode then return.
1441              *   2 - Reinitialize registers to normal transmission mode then return.
1442              *   3 - both steps: 0 and 1
1443              *       init registers for Break, send Break signal
1444              *       wait until Break sending is complete, reinit registers to normal
1445              *       transmission mode then return.
1446              *
1447              * Return:
1448              *  None.
1449              *
1450              * Global Variables:
1451              *  LIN_1_UART_initVar - checked to identify that the component has been
1452              *     initialized.
1453              *  tx_period - static variable, used for keeping TX period configuration.
1454              *
1455              * Reentrant:
1456              *  No.
1457              *
1458              * Theory:
1459              *  SendBreak function initializes registers to send 13-bit break signal. It is
1460              *  important to return the registers configuration to normal for continue 8-bit
1461              *  operation.
1462              *  Trere are 3 variants for this API usage:
1463              *  1) SendBreak(3) - function will send the Break signal and take care on the
1464              *     configuration returning. Funcition will block CPU untill transmition
1465              *     complete.
1466              *  2) User may want to use bloking time if UART configured to the low speed
1467              *     operation
1468              *     Emample for this case:
1469              *     SendBreak(0);     - init Break signal transmition
1470              *         Add your code here to use CPU time
1471              *     SendBreak(1);     - complete Break operation
1472              *  3) Same to 2) but user may want to init and use the interrupt for complete
1473              *     break operation.
1474              *     Example for this case:
1475              *     Init TX interrupt whith "TX - On TX Complete" parameter
1476              *     SendBreak(0);     - init Break signal transmition
1477              *         Add your code here to use CPU time
1478              *     When interrupt appear with UART_TX_STS_COMPLETE status:
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 25  

1479              *     SendBreak(2);     - complete Break operation
1480              *
1481              * Side Effects:
1482              *   Uses static variable to keep registers configuration.
1483              *
1484              *******************************************************************************/
1485              void LIN_1_UART_SendBreak(uint8 retMode) 
1486              {
1487   1      
1488   1              /* If not Initialized then skip this function*/
1489   1              if(LIN_1_UART_initVar != 0u)
1490   1              {
1491   2                  /*Set the Counter to 13-bits and transmit a 00 byte*/
1492   2                  /*When that is done then reset the counter value back*/
1493   2                  uint8 tmpStat;
1494   2      
1495   2                  #if(LIN_1_UART_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == LIN_1_UART_SEND_BREAK) ||
                                  (retMode == LIN_1_UART_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() |
                                                                        LIN_1_UART_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  LIN_1_UART_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = LIN_1_UART_TXSTATUS_REG;
                                  }while((tmpStat & LIN_1_UART_TX_STS_FIFO_EMPTY) != 0u);
                              }
              
                              if( (retMode == LIN_1_UART_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == LIN_1_UART_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = LIN_1_UART_TXSTATUS_REG;
                                  }while(((uint8)~tmpStat & LIN_1_UART_TX_STS_COMPLETE) != 0u);
                              }
              
                              if( (retMode == LIN_1_UART_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == LIN_1_UART_REINIT) ||
                                  (retMode == LIN_1_UART_SEND_WAIT_REINIT) )
                              {
                                  LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() &
                                                                (uint8)~LIN_1_UART_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* LIN_1_UART_HD_ENABLED Full Duplex mode */
1530   2      
1531   2                      static uint8 tx_period;
1532   2      
1533   2                      if( (retMode == LIN_1_UART_SEND_BREAK) ||
1534   2                          (retMode == LIN_1_UART_SEND_WAIT_REINIT) )
1535   2                      {
1536   3                          /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode*/
1537   3                          #if( (LIN_1_UART_PARITY_TYPE != LIN_1_UART__B_UART__NONE_REVB) || \
1538   3                                              (LIN_1_UART_PARITY_TYPE_SW != 0u) )
                                      LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() |
                                                                            LIN_1_UART_CTRL_HD_SEND_BREAK);
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 26  

                                  #endif /* End LIN_1_UART_PARITY_TYPE != LIN_1_UART__B_UART__NONE_REVB  */
1542   3      
1543   3                          #if(LIN_1_UART_TXCLKGEN_DP)
                                      tx_period = LIN_1_UART_TXBITCLKTX_COMPLETE_REG;
                                      LIN_1_UART_TXBITCLKTX_COMPLETE_REG = LIN_1_UART_TXBITCTR_BREAKBITS;
                                  #else
1547   3                              tx_period = LIN_1_UART_TXBITCTR_PERIOD_REG;
1548   3                              LIN_1_UART_TXBITCTR_PERIOD_REG = LIN_1_UART_TXBITCTR_BREAKBITS8X;
1549   3                          #endif /* End LIN_1_UART_TXCLKGEN_DP */
1550   3      
1551   3                          /* Send zeros*/
1552   3                          LIN_1_UART_TXDATA_REG = 0u;
1553   3      
1554   3                          do /* wait until transmit starts */
1555   3                          {
1556   4                              tmpStat = LIN_1_UART_TXSTATUS_REG;
1557   4                          }while((tmpStat & LIN_1_UART_TX_STS_FIFO_EMPTY) != 0u);
1558   3                      }
1559   2      
1560   2                      if( (retMode == LIN_1_UART_WAIT_FOR_COMPLETE_REINIT) ||
1561   2                          (retMode == LIN_1_UART_SEND_WAIT_REINIT) )
1562   2                      {
1563   3                          do /*wait until transmit complete*/
1564   3                          {
1565   4                              tmpStat = LIN_1_UART_TXSTATUS_REG;
1566   4                          }while(((uint8)~tmpStat & LIN_1_UART_TX_STS_COMPLETE) != 0u);
1567   3                      }
1568   2      
1569   2                      if( (retMode == LIN_1_UART_WAIT_FOR_COMPLETE_REINIT) ||
1570   2                          (retMode == LIN_1_UART_REINIT) ||
1571   2                          (retMode == LIN_1_UART_SEND_WAIT_REINIT) )
1572   2                      {
1573   3      
1574   3                          #if(LIN_1_UART_TXCLKGEN_DP)
                                      LIN_1_UART_TXBITCLKTX_COMPLETE_REG = tx_period;
                                  #else
1577   3                              LIN_1_UART_TXBITCTR_PERIOD_REG = tx_period;
1578   3                          #endif /* End LIN_1_UART_TXCLKGEN_DP */
1579   3      
1580   3                          #if( (LIN_1_UART_PARITY_TYPE != LIN_1_UART__B_UART__NONE_REVB) || \
1581   3                               (LIN_1_UART_PARITY_TYPE_SW != 0u) )
                                      LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() &
                                                                    (uint8)~LIN_1_UART_CTRL_HD_SEND_BREAK);
                                  #endif /* End LIN_1_UART_PARITY_TYPE != NONE */
1585   3                      }
1586   2                  #endif    /* End LIN_1_UART_HD_ENABLED */
1587   2              }
1588   1          }
1589          
1590          
1591              /*******************************************************************************
1592              * Function Name: LIN_1_UART_SetTxAddressMode
1593              ********************************************************************************
1594              *
1595              * Summary:
1596              *  Set the transmit addressing mode
1597              *
1598              * Parameters:
1599              *  addressMode: 0 -> Space
1600              *               1 -> Mark
1601              *
1602              * Return:
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 27  

1603              *  None.
1604              *
1605              *******************************************************************************/
1606              void LIN_1_UART_SetTxAddressMode(uint8 addressMode) 
1607              {
1608   1              /* Mark/Space sending enable*/
1609   1              if(addressMode != 0u)
1610   1              {
1611   2                  #if( LIN_1_UART_CONTROL_REG_REMOVED == 0u )
                              LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() |
                                                                    LIN_1_UART_CTRL_MARK);
                          #endif /* End LIN_1_UART_CONTROL_REG_REMOVED == 0u */
1615   2              }
1616   1              else
1617   1              {
1618   2                  #if( LIN_1_UART_CONTROL_REG_REMOVED == 0u )
                              LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() &
                                                                  (uint8)~LIN_1_UART_CTRL_MARK);
                          #endif /* End LIN_1_UART_CONTROL_REG_REMOVED == 0u */
1622   2              }
1623   1          }
1624          
1625          #endif  /* EndLIN_1_UART_TX_ENABLED */
1626          
1627          #if(LIN_1_UART_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: LIN_1_UART_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART.
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void LIN_1_UART_LoadTxConfig(void) 
                  {
                      #if((LIN_1_UART_RX_INTERRUPT_ENABLED) && (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          LIN_1_UART_SetRxInterruptMode(0u);
                      #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
              
                      LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() | LIN_1_UART_CTRL_HD_SEND);
                      LIN_1_UART_RXBITCTR_PERIOD_REG = LIN_1_UART_HD_TXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(LIN_1_UART_RXSTATUS_PTR);
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 28  

                      #endif /* CY_UDB_V0 */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: LIN_1_UART_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer
                  *  has been used.
                  *
                  *******************************************************************************/
                  void LIN_1_UART_LoadRxConfig(void) 
                  {
                      LIN_1_UART_WriteControlRegister(LIN_1_UART_ReadControlRegister() &
                                                              (uint8)~LIN_1_UART_CTRL_HD_SEND);
                      LIN_1_UART_RXBITCTR_PERIOD_REG = LIN_1_UART_HD_RXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(LIN_1_UART_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
              
                      #if((LIN_1_UART_RX_INTERRUPT_ENABLED) && (LIN_1_UART_RXBUFFERSIZE > LIN_1_UART_FIFO_LENGTH))
                          /* Enable RX interrupt after set RX configuration */
                          LIN_1_UART_SetRxInterruptMode(LIN_1_UART_INIT_RX_INTERRUPTS_MASK);
                      #endif /* LIN_1_UART_RX_INTERRUPT_ENABLED */
                  }
              
              #endif  /* LIN_1_UART_HD_ENABLED */
1710          
1711          
1712          /* [] END OF FILE */
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION LIN_1_UART_Start (BEGIN)
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 76
0000 900000      R     MOV     DPTR,#LIN_1_UART_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 78
0008 120000      R     LCALL   LIN_1_UART_Init
                                           ; SOURCE LINE # 79
000B 900000      R     MOV     DPTR,#LIN_1_UART_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
0011         ?C0001:
                                           ; SOURCE LINE # 81
0011 120000      R     LCALL   LIN_1_UART_Enable
                                           ; SOURCE LINE # 82
0014 22                RET     
             ; FUNCTION LIN_1_UART_Start (END)

             ; FUNCTION LIN_1_UART_Init (BEGIN)
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 118
0000 90648E            MOV     DPTR,#0648EH
0003 7472              MOV     A,#072H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
0006 90648A            MOV     DPTR,#0648AH
0009 7420              MOV     A,#020H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
000C 906589            MOV     DPTR,#06589H
000F 7447              MOV     A,#047H
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 144
0012 90648D            MOV     DPTR,#0648DH
0015 E4                CLR     A
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
0017 22                RET     
             ; FUNCTION LIN_1_UART_Init (END)

             ; FUNCTION LIN_1_UART_Enable (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 181
0008 90649E            MOV     DPTR,#0649EH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 30  

000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
0013 90649A            MOV     DPTR,#0649AH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 195
001E 906599            MOV     DPTR,#06599H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 4420              ORL     A,#020H
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0029 90649D            MOV     DPTR,#0649DH
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 4410              ORL     A,#010H
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
0034 900000      R     MOV     DPTR,#enableInterrupts
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 210
003C 22                RET     
             ; FUNCTION LIN_1_UART_Enable (END)

             ; FUNCTION LIN_1_UART_Stop (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 230
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
0008 90649E            MOV     DPTR,#0649EH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 239
0013 906599            MOV     DPTR,#06599H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 31  

0018 EF                MOV     A,R7
0019 54DF              ANL     A,#0DFH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 250
001E 90649A            MOV     DPTR,#0649AH
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 54EF              ANL     A,#0EFH
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0029 90649D            MOV     DPTR,#0649DH
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 54EF              ANL     A,#0EFH
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
0034 900000      R     MOV     DPTR,#enableInterrupts
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 264
003C 22                RET     
             ; FUNCTION LIN_1_UART_Stop (END)

             ; FUNCTION LIN_1_UART_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 284
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 288
0002         ?C0006:
0002 22                RET     
             ; FUNCTION LIN_1_UART_ReadControlRegister (END)

             ; FUNCTION _LIN_1_UART_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 305
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 312
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _LIN_1_UART_WriteControlRegister (END)

             ; FUNCTION _LIN_1_UART_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 385
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0005 900000      R     MOV     DPTR,#intSrc
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 32  

0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648A            MOV     DPTR,#0648AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
000F 22                RET     
             ; FUNCTION _LIN_1_UART_SetRxInterruptMode (END)

             ; FUNCTION LIN_1_UART_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 478
0000 90644A            MOV     DPTR,#0644AH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#rxData
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
000A 900000      R     MOV     DPTR,#rxData
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 483
000F         ?C0010:
000F 22                RET     
             ; FUNCTION LIN_1_UART_ReadRxData (END)

             ; FUNCTION LIN_1_UART_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
                                           ; SOURCE LINE # 513
0000 90646A            MOV     DPTR,#0646AH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#status
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
000E 900000      R     MOV     DPTR,#status
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
                                           ; SOURCE LINE # 524
0013         ?C0011:
0013 22                RET     
             ; FUNCTION LIN_1_UART_ReadRxStatus (END)

             ; FUNCTION LIN_1_UART_GetChar (BEGIN)
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 624
0005 90646A            MOV     DPTR,#0646AH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#rxStatus
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 33  

000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 625
000F 900000      R     MOV     DPTR,#rxStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 30E51E            JNB     ACC.5,?C0012
                                           ; SOURCE LINE # 626
                                           ; SOURCE LINE # 627
0018 90644A            MOV     DPTR,#0644AH
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#rxData
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
0022 900000      R     MOV     DPTR,#rxStatus
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 541E              ANL     A,#01EH
002A FF                MOV     R7,A
002B 7E00              MOV     R6,#00H
002D EF                MOV     A,R7
002E 4E                ORL     A,R6
002F 6005              JZ      ?C0012
                                           ; SOURCE LINE # 631
                                           ; SOURCE LINE # 632
0031 900000      R     MOV     DPTR,#rxData
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 633
                                           ; SOURCE LINE # 634
0036         ?C0012:
                                           ; SOURCE LINE # 637
0036 900000      R     MOV     DPTR,#rxData
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
                                           ; SOURCE LINE # 638
003B         ?C0014:
003B 22                RET     
             ; FUNCTION LIN_1_UART_GetChar (END)

             ; FUNCTION LIN_1_UART_GetByte (BEGIN)
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0000 120000      R     LCALL   LIN_1_UART_ReadRxStatus
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 7D00              MOV     R5,#00H
0008 FC                MOV     R4,A
0009 120000      R     LCALL   LIN_1_UART_ReadRxData
000C 7E00              MOV     R6,#00H
000E EC                MOV     A,R4
000F 4E                ORL     A,R6
0010 FE                MOV     R6,A
0011 ED                MOV     A,R5
0012 4F                ORL     A,R7
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 661
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 34  

0014         ?C0015:
0014 22                RET     
             ; FUNCTION LIN_1_UART_GetByte (END)

             ; FUNCTION LIN_1_UART_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 732
0000 90646A            MOV     DPTR,#0646AH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E504            JNB     ACC.5,?C0016
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0017
000D         ?C0016:
000D 7F00              MOV     R7,#00H
000F         ?C0017:
000F 900000      R     MOV     DPTR,#size
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 736
0014 900000      R     MOV     DPTR,#size
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
                                           ; SOURCE LINE # 737
0019         ?C0018:
0019 22                RET     
             ; FUNCTION LIN_1_UART_GetRxBufferSize (END)

             ; FUNCTION LIN_1_UART_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 777
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0008 90649A            MOV     DPTR,#0649AH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0013 90649A            MOV     DPTR,#0649AH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 801
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 35  

0026 22                RET     
             ; FUNCTION LIN_1_UART_ClearRxBuffer (END)

             ; FUNCTION _LIN_1_UART_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 832
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 850
                                           ; SOURCE LINE # 852
0005         ?C0021:
0005 22                RET     
             ; FUNCTION _LIN_1_UART_SetRxAddressMode (END)

             ; FUNCTION _LIN_1_UART_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 869
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90642A            MOV     DPTR,#0642AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 873
000F 22                RET     
             ; FUNCTION _LIN_1_UART_SetRxAddress1 (END)

             ; FUNCTION _LIN_1_UART_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 890
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 891
                                           ; SOURCE LINE # 892
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90643A            MOV     DPTR,#0643AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 893
000F 22                RET     
             ; FUNCTION _LIN_1_UART_SetRxAddress2 (END)

             ; FUNCTION _LIN_1_UART_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 968
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648D            MOV     DPTR,#0648DH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 36  

                                           ; SOURCE LINE # 971
000F 22                RET     
             ; FUNCTION _LIN_1_UART_SetTxInterruptMode (END)

             ; FUNCTION _LIN_1_UART_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 1002
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1003
                                           ; SOURCE LINE # 1005
0005 900000      R     MOV     DPTR,#LIN_1_UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600A              JZ      ?C0026
                                           ; SOURCE LINE # 1006
                                           ; SOURCE LINE # 1043
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 90644E            MOV     DPTR,#0644EH
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1046
                                           ; SOURCE LINE # 1047
0017         ?C0026:
0017 22                RET     
             ; FUNCTION _LIN_1_UART_WriteTxData (END)

             ; FUNCTION LIN_1_UART_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1070
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
0000 90646D            MOV     DPTR,#0646DH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1073
0005         ?C0027:
0005 22                RET     
             ; FUNCTION LIN_1_UART_ReadTxStatus (END)

             ; FUNCTION _LIN_1_UART_PutChar (BEGIN)
                                           ; SOURCE LINE # 1106
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1107
0005         ?C0028:
                                           ; SOURCE LINE # 1160
0005 90646D            MOV     DPTR,#0646DH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 20E2F7            JB      ACC.2,?C0028
                                           ; SOURCE LINE # 1161
                                           ; SOURCE LINE # 1163
000E         ?C0029:
                                           ; SOURCE LINE # 1166
000E 900000      R     MOV     DPTR,#txDataByte
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 37  

0013 90644E            MOV     DPTR,#0644EH
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1169
0018 22                RET     
             ; FUNCTION _LIN_1_UART_PutChar (END)

             ; FUNCTION _LIN_1_UART_PutString (BEGIN)
                                           ; SOURCE LINE # 1198
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1199
                                           ; SOURCE LINE # 1200
0006 900000      R     MOV     DPTR,#buf_index
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1202
000E 900000      R     MOV     DPTR,#LIN_1_UART_initVar
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6042              JZ      ?C0034
                                           ; SOURCE LINE # 1203
0016         ?C0032:
                                           ; SOURCE LINE # 1205
0016 900000      R     MOV     DPTR,#string
0019 120000      E     LCALL   ?C?PLDXDATA
001C 900000      R     MOV     DPTR,#buf_index
001F E0                MOVX    A,@DPTR
0020 FE                MOV     R6,A
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E9                MOV     A,R1
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 EA                MOV     A,R2
0028 3E                ADDC    A,R6
0029 FA                MOV     R2,A
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 6027              JZ      ?C0034
                                           ; SOURCE LINE # 1206
                                           ; SOURCE LINE # 1207
0031 900000      R     MOV     DPTR,#string
0034 120000      E     LCALL   ?C?PLDXDATA
0037 900000      R     MOV     DPTR,#buf_index
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F E9                MOV     A,R1
0040 2F                ADD     A,R7
0041 F9                MOV     R1,A
0042 EA                MOV     A,R2
0043 3E                ADDC    A,R6
0044 FA                MOV     R2,A
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 38  

0045 120000      E     LCALL   ?C?CLDPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _LIN_1_UART_PutChar
                                           ; SOURCE LINE # 1208
004C 900000      R     MOV     DPTR,#buf_index
004F E4                CLR     A
0050 75F001            MOV     B,#01H
0053 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1209
0056 80BE              SJMP    ?C0032
                                           ; SOURCE LINE # 1210
                                           ; SOURCE LINE # 1211
0058         ?C0034:
0058 22                RET     
             ; FUNCTION _LIN_1_UART_PutString (END)

             ; FUNCTION _LIN_1_UART_PutArray (BEGIN)
                                           ; SOURCE LINE # 1236
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
000B 900000      R     MOV     DPTR,#buf_index
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1241
0010 900000      R     MOV     DPTR,#LIN_1_UART_initVar
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 602D              JZ      ?C0039
                                           ; SOURCE LINE # 1242
0018         ?C0038:
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
0018 900000      R     MOV     DPTR,#string
001B 120000      E     LCALL   ?C?PLDXDATA
001E 900000      R     MOV     DPTR,#buf_index
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 E9                MOV     A,R1
0024 2F                ADD     A,R7
0025 F9                MOV     R1,A
0026 E4                CLR     A
0027 3A                ADDC    A,R2
0028 FA                MOV     R2,A
0029 120000      E     LCALL   ?C?CLDPTR
002C FF                MOV     R7,A
002D 120000      R     LCALL   _LIN_1_UART_PutChar
                                           ; SOURCE LINE # 1246
0030 900000      R     MOV     DPTR,#buf_index
0033 E0                MOVX    A,@DPTR
0034 04                INC     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1247
0036 900000      R     MOV     DPTR,#byteCount
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 900000      R     MOV     DPTR,#buf_index
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 39  

003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 EE                MOV     A,R6
0041 C3                CLR     C
0042 9F                SUBB    A,R7
0043 40D3              JC      ?C0038
                                           ; SOURCE LINE # 1248
                                           ; SOURCE LINE # 1249
0045         ?C0039:
0045 22                RET     
             ; FUNCTION _LIN_1_UART_PutArray (END)

             ; FUNCTION _LIN_1_UART_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1273
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
                                           ; SOURCE LINE # 1276
0005 900000      R     MOV     DPTR,#LIN_1_UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0041
                                           ; SOURCE LINE # 1277
                                           ; SOURCE LINE # 1278
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _LIN_1_UART_PutChar
                                           ; SOURCE LINE # 1279
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _LIN_1_UART_PutChar
                                           ; SOURCE LINE # 1280
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _LIN_1_UART_PutChar
                                           ; SOURCE LINE # 1281
                                           ; SOURCE LINE # 1282
001F         ?C0041:
001F 22                RET     
             ; FUNCTION _LIN_1_UART_PutCRLF (END)

             ; FUNCTION LIN_1_UART_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1310
                                           ; SOURCE LINE # 1312
                                           ; SOURCE LINE # 1343
0000 90646D            MOV     DPTR,#0646DH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#size
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1346
000A 900000      R     MOV     DPTR,#size
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 30E208            JNB     ACC.2,?C0042
                                           ; SOURCE LINE # 1347
                                           ; SOURCE LINE # 1348
0013 900000      R     MOV     DPTR,#size
0016 7404              MOV     A,#04H
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 40  

0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1349
0019 8016              SJMP    ?C0043
001B         ?C0042:
                                           ; SOURCE LINE # 1350
001B 900000      R     MOV     DPTR,#size
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 30E107            JNB     ACC.1,?C0044
                                           ; SOURCE LINE # 1351
                                           ; SOURCE LINE # 1352
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1353
0029 8006              SJMP    ?C0043
002B         ?C0044:
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1357
002B 900000      R     MOV     DPTR,#size
002E 7401              MOV     A,#01H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1358
0031         ?C0043:
                                           ; SOURCE LINE # 1362
0031 900000      R     MOV     DPTR,#size
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 1363
0036         ?C0046:
0036 22                RET     
             ; FUNCTION LIN_1_UART_GetTxBufferSize (END)

             ; FUNCTION LIN_1_UART_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1396
                                           ; SOURCE LINE # 1397
                                           ; SOURCE LINE # 1401
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
0008 90649E            MOV     DPTR,#0649EH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1404
0013 90649E            MOV     DPTR,#0649EH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1406
001E 900000      R     MOV     DPTR,#enableInterrupts
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 41  

0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1425
0026 22                RET     
             ; FUNCTION LIN_1_UART_ClearTxBuffer (END)

             ; FUNCTION _LIN_1_UART_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1485
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1486
                                           ; SOURCE LINE # 1489
0005 900000      R     MOV     DPTR,#LIN_1_UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0061
                                           ; SOURCE LINE # 1490
                                           ; SOURCE LINE # 1533
0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0050
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7028              JNZ     ?C0049
0022         ?C0050:
                                           ; SOURCE LINE # 1535
                                           ; SOURCE LINE # 1547
0022 906589            MOV     DPTR,#06589H
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#tx_period
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1548
002C 906589            MOV     DPTR,#06589H
002F 7467              MOV     A,#067H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1552
0032 90644E            MOV     DPTR,#0644EH
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
0037         ?C0053:
                                           ; SOURCE LINE # 1555
                                           ; SOURCE LINE # 1556
0037 90646D            MOV     DPTR,#0646DH
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#tmpStat
003F EF                MOV     A,R7
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1557
0041 900000      R     MOV     DPTR,#tmpStat
0044 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 42  

0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 20E1ED            JB      ACC.1,?C0053
                                           ; SOURCE LINE # 1558
004A         ?C0049:
                                           ; SOURCE LINE # 1560
004A 900000      R     MOV     DPTR,#retMode
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
0050 6401              XRL     A,#01H
0052 6009              JZ      ?C0058
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A B40316            CJNE    A,#03H,?C0054
                                           ; SOURCE LINE # 1562
005D         ?C0058:
                                           ; SOURCE LINE # 1564
                                           ; SOURCE LINE # 1565
005D 90646D            MOV     DPTR,#0646DH
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#tmpStat
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1566
0067 900000      R     MOV     DPTR,#tmpStat
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D F4                CPL     A
006E FF                MOV     R7,A
006F EF                MOV     A,R7
0070 20E0EA            JB      ACC.0,?C0058
                                           ; SOURCE LINE # 1567
0073         ?C0054:
                                           ; SOURCE LINE # 1569
0073 900000      R     MOV     DPTR,#retMode
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 6401              XRL     A,#01H
007B 6013              JZ      ?C0060
007D 900000      R     MOV     DPTR,#retMode
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 6402              XRL     A,#02H
0085 6009              JZ      ?C0060
0087 900000      R     MOV     DPTR,#retMode
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C EF                MOV     A,R7
008D B4030A            CJNE    A,#03H,?C0061
0090         ?C0060:
                                           ; SOURCE LINE # 1572
                                           ; SOURCE LINE # 1577
0090 900000      R     MOV     DPTR,#tx_period
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
C51 COMPILER V9.51   LIN_1_UART                                                            03/21/2014 22:17:43 PAGE 43  

0095 906589            MOV     DPTR,#06589H
0098 EF                MOV     A,R7
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
                                           ; SOURCE LINE # 1587
                                           ; SOURCE LINE # 1588
009A         ?C0061:
009A 22                RET     
             ; FUNCTION _LIN_1_UART_SendBreak (END)

             ; FUNCTION _LIN_1_UART_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1606
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1607
                                           ; SOURCE LINE # 1609
                                           ; SOURCE LINE # 1610
                                           ; SOURCE LINE # 1615
0005         ?C0062:
                                           ; SOURCE LINE # 1617
                                           ; SOURCE LINE # 1622
                                           ; SOURCE LINE # 1623
0005         ?C0064:
0005 22                RET     
             ; FUNCTION _LIN_1_UART_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    929    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
