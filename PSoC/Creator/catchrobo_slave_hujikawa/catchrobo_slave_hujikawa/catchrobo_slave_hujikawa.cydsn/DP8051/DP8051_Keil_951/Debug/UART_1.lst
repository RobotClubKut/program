C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_1
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_1.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\UART_1.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_951\Debug\UART_1.lst) CD DB NOIP OT(2,S
                    -IZE) DF(DEBUG) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_951\Debug\UART_1.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_1.c
   3          * Version 2.30
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_1.h"
  18          #include "CyLib.h"
  19          #if(UART_1_INTERNAL_CLOCK_USED)
  20              #include "UART_1_IntClock.h"
  21          #endif /* End UART_1_INTERNAL_CLOCK_USED */
  22          
  23          
  24          /***************************************
  25          * Global data allocation
  26          ***************************************/
  27          
  28          uint8 UART_1_initVar = 0u;
  29          #if( UART_1_TX_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
  30              volatile uint8 UART_1_txBuffer[UART_1_TXBUFFERSIZE];
  31              volatile uint8 UART_1_txBufferRead = 0u;
  32              uint8 UART_1_txBufferWrite = 0u;
  33          #endif /* End UART_1_TX_ENABLED */
  34          #if( ( UART_1_RX_ENABLED || UART_1_HD_ENABLED ) && \
  35               (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
  36              volatile uint8 UART_1_rxBuffer[UART_1_RXBUFFERSIZE];
  37              volatile uint8 UART_1_rxBufferRead = 0u;
  38              volatile uint8 UART_1_rxBufferWrite = 0u;
  39              volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  40              volatile uint8 UART_1_rxBufferOverflow = 0u;
  41              #if (UART_1_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_1_rxAddressMode = UART_1_RXADDRESSMODE;
                      volatile uint8 UART_1_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */
  45          #endif /* End UART_1_RX_ENABLED */
  46          
  47          
  48          /*******************************************************************************
  49          * Function Name: UART_1_Start
  50          ********************************************************************************
  51          *
  52          * Summary:
  53          *  Initialize and Enable the UART component.
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 2   

  54          *  Enable the clock input to enable operation.
  55          *
  56          * Parameters:
  57          *  None.
  58          *
  59          * Return:
  60          *  None.
  61          *
  62          * Global variables:
  63          *  The UART_1_intiVar variable is used to indicate initial
  64          *  configuration of this component. The variable is initialized to zero (0u)
  65          *  and set to one (1u) the first time UART_Start() is called. This allows for
  66          *  component initialization without re-initialization in all subsequent calls
  67          *  to the UART_1_Start() routine.
  68          *
  69          * Reentrant:
  70          *  No.
  71          *
  72          *******************************************************************************/
  73          void UART_1_Start(void) 
  74          {
  75   1          /* If not Initialized then initialize all required hardware and software */
  76   1          if(UART_1_initVar == 0u)
  77   1          {
  78   2              UART_1_Init();
  79   2              UART_1_initVar = 1u;
  80   2          }
  81   1          UART_1_Enable();
  82   1      }
  83          
  84          
  85          /*******************************************************************************
  86          * Function Name: UART_1_Init
  87          ********************************************************************************
  88          *
  89          * Summary:
  90          *  Initialize component's parameters to the parameters set by user in the
  91          *  customizer of the component placed onto schematic. Usually called in
  92          *  UART_1_Start().
  93          *
  94          * Parameters:
  95          *  None.
  96          *
  97          * Return:
  98          *  None.
  99          *
 100          *******************************************************************************/
 101          void UART_1_Init(void) 
 102          {
 103   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 104   1      
 105   1              #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 106   1                  /* Set the RX Interrupt. */
 107   1                  (void)CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 108   1                  CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 109   1              #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 110   1      
 111   1              #if (UART_1_RXHW_ADDRESS_ENABLED)
                          UART_1_SetRxAddressMode(UART_1_RXAddressMode);
                          UART_1_SetRxAddress1(UART_1_RXHWADDRESS1);
                          UART_1_SetRxAddress2(UART_1_RXHWADDRESS2);
                      #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 3   

 116   1      
 117   1              /* Init Count7 period */
 118   1              UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 119   1              /* Configure the Initial RX interrupt mask */
 120   1              UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 121   1          #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 122   1      
 123   1          #if(UART_1_TX_ENABLED)
 124   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 125   1                  /* Set the TX Interrupt. */
 126   1                  (void)CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 127   1                  CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 128   1              #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 129   1      
 130   1              /* Write Counter Value for TX Bit Clk Generator*/
 131   1              #if(UART_1_TXCLKGEN_DP)
 132   1                  UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
 133   1                  UART_1_TXBITCLKTX_COMPLETE_REG = (UART_1_NUMBER_OF_DATA_BITS +
 134   1                              UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT;
 135   1              #else
                          UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
                                      UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_1_TXCLKGEN_DP */
 139   1      
 140   1              /* Configure the Initial TX interrupt mask */
 141   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 142   1                  UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 143   1              #else
                          UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
                      #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 146   1      
 147   1          #endif /* End UART_1_TX_ENABLED */
 148   1      
 149   1          #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_1_WriteControlRegister( \
                          (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_1_PARITY_TYPE_SW */
 154   1      }
 155          
 156          
 157          /*******************************************************************************
 158          * Function Name: UART_1_Enable
 159          ********************************************************************************
 160          *
 161          * Summary:
 162          *  Enables the UART block operation
 163          *
 164          * Parameters:
 165          *  None.
 166          *
 167          * Return:
 168          *  None.
 169          *
 170          * Global Variables:
 171          *  UART_1_rxAddressDetected - set to initial state (0).
 172          *
 173          *******************************************************************************/
 174          void UART_1_Enable(void) 
 175          {
 176   1          uint8 enableInterrupts;
 177   1          enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 4   

 178   1      
 179   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 180   1              /*RX Counter (Count7) Enable */
 181   1              UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 182   1              /* Enable the RX Interrupt. */
 183   1              UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 184   1              #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 185   1                  CyIntEnable(UART_1_RX_VECT_NUM);
 186   1                  #if (UART_1_RXHW_ADDRESS_ENABLED)
                              UART_1_rxAddressDetected = 0u;
                          #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 189   1              #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 190   1          #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 191   1      
 192   1          #if(UART_1_TX_ENABLED)
 193   1              /*TX Counter (DP/Count7) Enable */
 194   1              #if(!UART_1_TXCLKGEN_DP)
                          UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
                      #endif /* End UART_1_TXCLKGEN_DP */
 197   1              /* Enable the TX Interrupt. */
 198   1              UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 199   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 200   1                  CyIntEnable(UART_1_TX_VECT_NUM);
 201   1              #endif /* End UART_1_TX_INTERRUPT_ENABLED*/
 202   1           #endif /* End UART_1_TX_ENABLED */
 203   1      
 204   1          #if(UART_1_INTERNAL_CLOCK_USED)
 205   1              /* Enable the clock. */
 206   1              UART_1_IntClock_Start();
 207   1          #endif /* End UART_1_INTERNAL_CLOCK_USED */
 208   1      
 209   1          CyExitCriticalSection(enableInterrupts);
 210   1      }
 211          
 212          
 213          /*******************************************************************************
 214          * Function Name: UART_1_Stop
 215          ********************************************************************************
 216          *
 217          * Summary:
 218          *  Disable the UART component
 219          *
 220          * Parameters:
 221          *  None.
 222          *
 223          * Return:
 224          *  None.
 225          *
 226          *******************************************************************************/
 227          void UART_1_Stop(void) 
 228          {
 229   1          uint8 enableInterrupts;
 230   1          enableInterrupts = CyEnterCriticalSection();
 231   1      
 232   1          /* Write Bit Counter Disable */
 233   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 234   1              UART_1_RXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 235   1          #endif /* End UART_1_RX_ENABLED */
 236   1      
 237   1          #if(UART_1_TX_ENABLED)
 238   1              #if(!UART_1_TXCLKGEN_DP)
                          UART_1_TXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 5   

                      #endif /* End UART_1_TXCLKGEN_DP */
 241   1          #endif /* UART_1_TX_ENABLED */
 242   1      
 243   1          #if(UART_1_INTERNAL_CLOCK_USED)
 244   1              /* Disable the clock. */
 245   1              UART_1_IntClock_Stop();
 246   1          #endif /* End UART_1_INTERNAL_CLOCK_USED */
 247   1      
 248   1          /* Disable internal interrupt component */
 249   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 250   1              UART_1_RXSTATUS_ACTL_REG  &= (uint8)~UART_1_INT_ENABLE;
 251   1              #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 252   1                  UART_1_DisableRxInt();
 253   1              #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 254   1          #endif /* End UART_1_RX_ENABLED */
 255   1      
 256   1          #if(UART_1_TX_ENABLED)
 257   1              UART_1_TXSTATUS_ACTL_REG &= (uint8)~UART_1_INT_ENABLE;
 258   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 259   1                  UART_1_DisableTxInt();
 260   1              #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 261   1          #endif /* End UART_1_TX_ENABLED */
 262   1      
 263   1          CyExitCriticalSection(enableInterrupts);
 264   1      }
 265          
 266          
 267          /*******************************************************************************
 268          * Function Name: UART_1_ReadControlRegister
 269          ********************************************************************************
 270          *
 271          * Summary:
 272          *  Read the current state of the control register
 273          *
 274          * Parameters:
 275          *  None.
 276          *
 277          * Return:
 278          *  Current state of the control register.
 279          *
 280          *******************************************************************************/
 281          uint8 UART_1_ReadControlRegister(void) 
 282          {
 283   1          #if( UART_1_CONTROL_REG_REMOVED )
 284   1              return(0u);
 285   1          #else
                      return(UART_1_CONTROL_REG);
                  #endif /* End UART_1_CONTROL_REG_REMOVED */
 288   1      }
 289          
 290          
 291          /*******************************************************************************
 292          * Function Name: UART_1_WriteControlRegister
 293          ********************************************************************************
 294          *
 295          * Summary:
 296          *  Writes an 8-bit value into the control register
 297          *
 298          * Parameters:
 299          *  control:  control register value
 300          *
 301          * Return:
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 6   

 302          *  None.
 303          *
 304          *******************************************************************************/
 305          void  UART_1_WriteControlRegister(uint8 control) 
 306          {
 307   1          #if( UART_1_CONTROL_REG_REMOVED )
 308   1              if(control != 0u) { }      /* release compiler warning */
 309   1          #else
                     UART_1_CONTROL_REG = control;
                  #endif /* End UART_1_CONTROL_REG_REMOVED */
 312   1      }
 313          
 314          
 315          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 316          
 317              #if(UART_1_RX_INTERRUPT_ENABLED)
 318          
 319                  /*******************************************************************************
 320                  * Function Name: UART_1_EnableRxInt
 321                  ********************************************************************************
 322                  *
 323                  * Summary:
 324                  *  Enable RX interrupt generation
 325                  *
 326                  * Parameters:
 327                  *  None.
 328                  *
 329                  * Return:
 330                  *  None.
 331                  *
 332                  * Theory:
 333                  *  Enable the interrupt output -or- the interrupt component itself
 334                  *
 335                  *******************************************************************************/
 336                  void UART_1_EnableRxInt(void) 
 337                  {
 338   1                  CyIntEnable(UART_1_RX_VECT_NUM);
 339   1              }
 340          
 341          
 342                  /*******************************************************************************
 343                  * Function Name: UART_1_DisableRxInt
 344                  ********************************************************************************
 345                  *
 346                  * Summary:
 347                  *  Disable RX interrupt generation
 348                  *
 349                  * Parameters:
 350                  *  None.
 351                  *
 352                  * Return:
 353                  *  None.
 354                  *
 355                  * Theory:
 356                  *  Disable the interrupt output -or- the interrupt component itself
 357                  *
 358                  *******************************************************************************/
 359                  void UART_1_DisableRxInt(void) 
 360                  {
 361   1                  CyIntDisable(UART_1_RX_VECT_NUM);
 362   1              }
 363          
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 7   

 364              #endif /* UART_1_RX_INTERRUPT_ENABLED */
 365          
 366          
 367              /*******************************************************************************
 368              * Function Name: UART_1_SetRxInterruptMode
 369              ********************************************************************************
 370              *
 371              * Summary:
 372              *  Configure which status bits trigger an interrupt event
 373              *
 374              * Parameters:
 375              *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376              *           the header file)
 377              *
 378              * Return:
 379              *  None.
 380              *
 381              * Theory:
 382              *  Enables the output of specific status bits to the interrupt controller
 383              *
 384              *******************************************************************************/
 385              void UART_1_SetRxInterruptMode(uint8 intSrc) 
 386              {
 387   1              UART_1_RXSTATUS_MASK_REG  = intSrc;
 388   1          }
 389          
 390          
 391              /*******************************************************************************
 392              * Function Name: UART_1_ReadRxData
 393              ********************************************************************************
 394              *
 395              * Summary:
 396              *  Returns data in RX Data register without checking status register to
 397              *  determine if data is valid
 398              *
 399              * Parameters:
 400              *  None.
 401              *
 402              * Return:
 403              *  Received data from RX register
 404              *
 405              * Global Variables:
 406              *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 407              *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 408              *     checked to identify new data.
 409              *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 410              *     incremented after each byte has been read from buffer.
 411              *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 412              *     in RX ISR.
 413              *
 414              * Reentrant:
 415              *  No.
 416              *
 417              *******************************************************************************/
 418              uint8 UART_1_ReadRxData(void) 
 419              {
 420   1              uint8 rxData;
 421   1      
 422   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 423   1                  uint8 loc_rxBufferRead;
 424   1                  uint8 loc_rxBufferWrite;
 425   1                  /* Protect variables that could change on interrupt. */
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 8   

 426   1                  /* Disable Rx interrupt. */
 427   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 428   1                      UART_1_DisableRxInt();
 429   1                  #endif /* UART_1_RX_INTERRUPT_ENABLED */
 430   1                  loc_rxBufferRead = UART_1_rxBufferRead;
 431   1                  loc_rxBufferWrite = UART_1_rxBufferWrite;
 432   1      
 433   1                  if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 434   1                  {
 435   2                      rxData = UART_1_rxBuffer[loc_rxBufferRead];
 436   2                      loc_rxBufferRead++;
 437   2      
 438   2                      if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 439   2                      {
 440   3                          loc_rxBufferRead = 0u;
 441   3                      }
 442   2                      /* Update the real pointer */
 443   2                      UART_1_rxBufferRead = loc_rxBufferRead;
 444   2      
 445   2                      if(UART_1_rxBufferLoopDetect != 0u )
 446   2                      {
 447   3                          UART_1_rxBufferLoopDetect = 0u;
 448   3                          #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) && \
 449   3                               (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_1_HD_ENABLED )
                                          if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only in RX
                                              *  configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_1_HD_ENABLED */
                                  #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 463   3                      }
 464   2                  }
 465   1                  else
 466   1                  {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 467   2                      rxData = UART_1_RXDATA_REG;
 468   2                  }
 469   1      
 470   1                  /* Enable Rx interrupt. */
 471   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 472   1                      UART_1_EnableRxInt();
 473   1                  #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 474   1      
 475   1              #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
              
                          /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                          rxData = UART_1_RXDATA_REG;
              
                      #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 481   1      
 482   1              return(rxData);
 483   1          }
 484          
 485          
 486              /*******************************************************************************
 487              * Function Name: UART_1_ReadRxStatus
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 9   

 488              ********************************************************************************
 489              *
 490              * Summary:
 491              *  Read the current state of the status register
 492              *  And detect software buffer overflow.
 493              *
 494              * Parameters:
 495              *  None.
 496              *
 497              * Return:
 498              *  Current state of the status register.
 499              *
 500              * Global Variables:
 501              *  UART_1_rxBufferOverflow - used to indicate overload condition.
 502              *   It set to one in RX interrupt when there isn?t free space in
 503              *   UART_1_rxBufferRead to write new data. This condition returned
 504              *   and cleared to zero by this API as an
 505              *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506              *   bits.
 507              *
 508              *******************************************************************************/
 509              uint8 UART_1_ReadRxStatus(void) 
 510              {
 511   1              uint8 status;
 512   1      
 513   1              status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 514   1      
 515   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 516   1                  if( UART_1_rxBufferOverflow != 0u )
 517   1                  {
 518   2                      status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 519   2                      UART_1_rxBufferOverflow = 0u;
 520   2                  }
 521   1              #endif /* UART_1_RXBUFFERSIZE */
 522   1      
 523   1              return(status);
 524   1          }
 525          
 526          
 527              /*******************************************************************************
 528              * Function Name: UART_1_GetChar
 529              ********************************************************************************
 530              *
 531              * Summary:
 532              *  Reads UART RX buffer immediately, if data is not available or an error
 533              *  condition exists, zero is returned; otherwise, character is read and
 534              *  returned.
 535              *
 536              * Parameters:
 537              *  None.
 538              *
 539              * Return:
 540              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541              *  A returned zero signifies an error condition or no data available.
 542              *
 543              * Global Variables:
 544              *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 545              *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 546              *     checked to identify new data.
 547              *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 548              *     incremented after each byte has been read from buffer.
 549              *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 10  

 550              *     in RX ISR.
 551              *
 552              * Reentrant:
 553              *  No.
 554              *
 555              *******************************************************************************/
 556              uint8 UART_1_GetChar(void) 
 557              {
 558   1              uint8 rxData = 0u;
 559   1              uint8 rxStatus;
 560   1      
 561   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 562   1                  uint8 loc_rxBufferRead;
 563   1                  uint8 loc_rxBufferWrite;
 564   1                  /* Protect variables that could change on interrupt. */
 565   1                  /* Disable Rx interrupt. */
 566   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 567   1                      UART_1_DisableRxInt();
 568   1                  #endif /* UART_1_RX_INTERRUPT_ENABLED */
 569   1                  loc_rxBufferRead = UART_1_rxBufferRead;
 570   1                  loc_rxBufferWrite = UART_1_rxBufferWrite;
 571   1      
 572   1                  if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 573   1                  {
 574   2                      rxData = UART_1_rxBuffer[loc_rxBufferRead];
 575   2                      loc_rxBufferRead++;
 576   2                      if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 577   2                      {
 578   3                          loc_rxBufferRead = 0u;
 579   3                      }
 580   2                      /* Update the real pointer */
 581   2                      UART_1_rxBufferRead = loc_rxBufferRead;
 582   2      
 583   2                      if(UART_1_rxBufferLoopDetect > 0u )
 584   2                      {
 585   3                          UART_1_rxBufferLoopDetect = 0u;
 586   3                          #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_1_HD_ENABLED )
                                          if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only if
                                              *  RX configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_1_HD_ENABLED */
                                  #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 600   3                      }
 601   2      
 602   2                  }
 603   1                  else
 604   1                  {   rxStatus = UART_1_RXSTATUS_REG;
 605   2                      if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 606   2                      {   /* Read received data from FIFO*/
 607   3                          rxData = UART_1_RXDATA_REG;
 608   3                          /*Check status on error*/
 609   3                          if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 610   3                                         UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 611   3                          {
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 11  

 612   4                              rxData = 0u;
 613   4                          }
 614   3                      }
 615   2                  }
 616   1      
 617   1                  /* Enable Rx interrupt. */
 618   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 619   1                      UART_1_EnableRxInt();
 620   1                  #endif /* UART_1_RX_INTERRUPT_ENABLED */
 621   1      
 622   1              #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
              
                          rxStatus =UART_1_RXSTATUS_REG;
                          if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
                          {   /* Read received data from FIFO*/
                              rxData = UART_1_RXDATA_REG;
                              /*Check status on error*/
                              if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
                                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
                              {
                                  rxData = 0u;
                              }
                          }
                      #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 636   1      
 637   1              return(rxData);
 638   1          }
 639          
 640          
 641              /*******************************************************************************
 642              * Function Name: UART_1_GetByte
 643              ********************************************************************************
 644              *
 645              * Summary:
 646              *  Grab the next available byte of data from the recieve FIFO
 647              *
 648              * Parameters:
 649              *  None.
 650              *
 651              * Return:
 652              *  MSB contains Status Register and LSB contains UART RX data
 653              *
 654              * Reentrant:
 655              *  No.
 656              *
 657              *******************************************************************************/
 658              uint16 UART_1_GetByte(void) 
 659              {
 660   1              return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 661   1          }
 662          
 663          
 664              /*******************************************************************************
 665              * Function Name: UART_1_GetRxBufferSize
 666              ********************************************************************************
 667              *
 668              * Summary:
 669              *  Determine the amount of bytes left in the RX buffer and return the count in
 670              *  bytes
 671              *
 672              * Parameters:
 673              *  None.
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 12  

 674              *
 675              * Return:
 676              *  uint8: Integer count of the number of bytes left
 677              *  in the RX buffer
 678              *
 679              * Global Variables:
 680              *  UART_1_rxBufferWrite - used to calculate left bytes.
 681              *  UART_1_rxBufferRead - used to calculate left bytes.
 682              *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 683              *
 684              * Reentrant:
 685              *  No.
 686              *
 687              * Theory:
 688              *  Allows the user to find out how full the RX Buffer is.
 689              *
 690              *******************************************************************************/
 691              uint8 UART_1_GetRxBufferSize(void)
 692                                                                      
 693              {
 694   1              uint8 size;
 695   1      
 696   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 697   1      
 698   1                  /* Disable Rx interrupt. */
 699   1                  /* Protect variables that could change on interrupt. */
 700   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 701   1                      UART_1_DisableRxInt();
 702   1                  #endif /* UART_1_RX_INTERRUPT_ENABLED */
 703   1      
 704   1                  if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 705   1                  {
 706   2                      if(UART_1_rxBufferLoopDetect > 0u)
 707   2                      {
 708   3                          size = UART_1_RXBUFFERSIZE;
 709   3                      }
 710   2                      else
 711   2                      {
 712   3                          size = 0u;
 713   3                      }
 714   2                  }
 715   1                  else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 716   1                  {
 717   2                      size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 718   2                  }
 719   1                  else
 720   1                  {
 721   2                      size = (UART_1_RXBUFFERSIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 722   2                  }
 723   1      
 724   1                  /* Enable Rx interrupt. */
 725   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 726   1                      UART_1_EnableRxInt();
 727   1                  #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 728   1      
 729   1              #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
              
                          /* We can only know if there is data in the fifo. */
                          size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
              
                      #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 735   1      
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 13  

 736   1              return(size);
 737   1          }
 738          
 739          
 740              /*******************************************************************************
 741              * Function Name: UART_1_ClearRxBuffer
 742              ********************************************************************************
 743              *
 744              * Summary:
 745              *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746              *  Clears hardware RX FIFO.
 747              *
 748              * Parameters:
 749              *  None.
 750              *
 751              * Return:
 752              *  None.
 753              *
 754              * Global Variables:
 755              *  UART_1_rxBufferWrite - cleared to zero.
 756              *  UART_1_rxBufferRead - cleared to zero.
 757              *  UART_1_rxBufferLoopDetect - cleared to zero.
 758              *  UART_1_rxBufferOverflow - cleared to zero.
 759              *
 760              * Reentrant:
 761              *  No.
 762              *
 763              * Theory:
 764              *  Setting the pointers to zero makes the system believe there is no data to
 765              *  read and writing will resume at address 0 overwriting any data that may
 766              *  have remained in the RAM.
 767              *
 768              * Side Effects:
 769              *  Any received data not read from the RAM or FIFO buffer will be lost.
 770              *******************************************************************************/
 771              void UART_1_ClearRxBuffer(void) 
 772              {
 773   1              uint8 enableInterrupts;
 774   1      
 775   1              /* clear the HW FIFO */
 776   1              /* Enter critical section */
 777   1              enableInterrupts = CyEnterCriticalSection();
 778   1              UART_1_RXDATA_AUX_CTL_REG |=  UART_1_RX_FIFO_CLR;
 779   1              UART_1_RXDATA_AUX_CTL_REG &= (uint8)~UART_1_RX_FIFO_CLR;
 780   1              /* Exit critical section */
 781   1              CyExitCriticalSection(enableInterrupts);
 782   1      
 783   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 784   1                  /* Disable Rx interrupt. */
 785   1                  /* Protect variables that could change on interrupt. */
 786   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 787   1                      UART_1_DisableRxInt();
 788   1                  #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 789   1      
 790   1                  UART_1_rxBufferRead = 0u;
 791   1                  UART_1_rxBufferWrite = 0u;
 792   1                  UART_1_rxBufferLoopDetect = 0u;
 793   1                  UART_1_rxBufferOverflow = 0u;
 794   1      
 795   1                  /* Enable Rx interrupt. */
 796   1                  #if(UART_1_RX_INTERRUPT_ENABLED)
 797   1                      UART_1_EnableRxInt();
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 14  

 798   1                  #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 799   1              #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 800   1      
 801   1          }
 802          
 803          
 804              /*******************************************************************************
 805              * Function Name: UART_1_SetRxAddressMode
 806              ********************************************************************************
 807              *
 808              * Summary:
 809              *  Set the receive addressing mode
 810              *
 811              * Parameters:
 812              *  addressMode: Enumerated value indicating the mode of RX addressing
 813              *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814              *                                               detection
 815              *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816              *                                               address detection
 817              *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818              *                                               detection
 819              *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820              *                                               address detection
 821              *  UART_1__B_UART__AM_NONE - No address detection
 822              *
 823              * Return:
 824              *  None.
 825              *
 826              * Global Variables:
 827              *  UART_1_rxAddressMode - the parameter stored in this variable for
 828              *   the farther usage in RX ISR.
 829              *  UART_1_rxAddressDetected - set to initial state (0).
 830              *
 831              *******************************************************************************/
 832              void UART_1_SetRxAddressMode(uint8 addressMode)
 833                                                                  
 834              {
 835   1              #if(UART_1_RXHW_ADDRESS_ENABLED)
                          #if(UART_1_CONTROL_REG_REMOVED)
                              if(addressMode != 0u) { }     /* release compiler warning */
                          #else /* UART_1_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
                              UART_1_CONTROL_REG = tmpCtrl;
                              #if(UART_1_RX_INTERRUPT_ENABLED && \
                                 (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
                                  UART_1_rxAddressMode = addressMode;
                                  UART_1_rxAddressDetected = 0u;
                              #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
                          #endif /* End UART_1_CONTROL_REG_REMOVED */
                      #else /* UART_1_RXHW_ADDRESS_ENABLED */
 850   1                  if(addressMode != 0u) { }     /* release compiler warning */
 851   1              #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 852   1          }
 853          
 854          
 855              /*******************************************************************************
 856              * Function Name: UART_1_SetRxAddress1
 857              ********************************************************************************
 858              *
 859              * Summary:
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 15  

 860              *  Set the first hardware address compare value
 861              *
 862              * Parameters:
 863              *  address
 864              *
 865              * Return:
 866              *  None.
 867              *
 868              *******************************************************************************/
 869              void UART_1_SetRxAddress1(uint8 address) 
 870          
 871              {
 872   1              UART_1_RXADDRESS1_REG = address;
 873   1          }
 874          
 875          
 876              /*******************************************************************************
 877              * Function Name: UART_1_SetRxAddress2
 878              ********************************************************************************
 879              *
 880              * Summary:
 881              *  Set the second hardware address compare value
 882              *
 883              * Parameters:
 884              *  address
 885              *
 886              * Return:
 887              *  None.
 888              *
 889              *******************************************************************************/
 890              void UART_1_SetRxAddress2(uint8 address) 
 891              {
 892   1              UART_1_RXADDRESS2_REG = address;
 893   1          }
 894          
 895          #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 896          
 897          
 898          #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 899          
 900              #if(UART_1_TX_INTERRUPT_ENABLED)
 901          
 902                  /*******************************************************************************
 903                  * Function Name: UART_1_EnableTxInt
 904                  ********************************************************************************
 905                  *
 906                  * Summary:
 907                  *  Enable TX interrupt generation
 908                  *
 909                  * Parameters:
 910                  *  None.
 911                  *
 912                  * Return:
 913                  *  None.
 914                  *
 915                  * Theory:
 916                  *  Enable the interrupt output -or- the interrupt component itself
 917                  *
 918                  *******************************************************************************/
 919                  void UART_1_EnableTxInt(void) 
 920                  {
 921   1                  CyIntEnable(UART_1_TX_VECT_NUM);
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 16  

 922   1              }
 923          
 924          
 925                  /*******************************************************************************
 926                  * Function Name: UART_1_DisableTxInt
 927                  ********************************************************************************
 928                  *
 929                  * Summary:
 930                  *  Disable TX interrupt generation
 931                  *
 932                  * Parameters:
 933                  *  None.
 934                  *
 935                  * Return:
 936                  *  None.
 937                  *
 938                  * Theory:
 939                  *  Disable the interrupt output -or- the interrupt component itself
 940                  *
 941                  *******************************************************************************/
 942                  void UART_1_DisableTxInt(void) 
 943                  {
 944   1                  CyIntDisable(UART_1_TX_VECT_NUM);
 945   1              }
 946          
 947              #endif /* UART_1_TX_INTERRUPT_ENABLED */
 948          
 949          
 950              /*******************************************************************************
 951              * Function Name: UART_1_SetTxInterruptMode
 952              ********************************************************************************
 953              *
 954              * Summary:
 955              *  Configure which status bits trigger an interrupt event
 956              *
 957              * Parameters:
 958              *  intSrc: An or'd combination of the desired status bit masks (defined in
 959              *          the header file)
 960              *
 961              * Return:
 962              *  None.
 963              *
 964              * Theory:
 965              *  Enables the output of specific status bits to the interrupt controller
 966              *
 967              *******************************************************************************/
 968              void UART_1_SetTxInterruptMode(uint8 intSrc) 
 969              {
 970   1              UART_1_TXSTATUS_MASK_REG = intSrc;
 971   1          }
 972          
 973          
 974              /*******************************************************************************
 975              * Function Name: UART_1_WriteTxData
 976              ********************************************************************************
 977              *
 978              * Summary:
 979              *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980              *  bus is available. WriteTxData sends a byte without checking for buffer room
 981              *  or status. It is up to the user to separately check status.
 982              *
 983              * Parameters:
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 17  

 984              *  TXDataByte: byte of data to place in the transmit FIFO
 985              *
 986              * Return:
 987              * void
 988              *
 989              * Global Variables:
 990              *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 991              *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 992              *    incremented after each byte saved to buffer.
 993              *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 994              *    checked to identify the condition to write to FIFO directly or to TX buffer
 995              *  UART_1_initVar - checked to identify that the component has been
 996              *    initialized.
 997              *
 998              * Reentrant:
 999              *  No.
1000              *
1001              *******************************************************************************/
1002              void UART_1_WriteTxData(uint8 txDataByte) 
1003              {
1004   1              /* If not Initialized then skip this function*/
1005   1              if(UART_1_initVar != 0u)
1006   1              {
1007   2                  #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1008   2      
1009   2                      /* Disable Tx interrupt. */
1010   2                      /* Protect variables that could change on interrupt. */
1011   2                      #if(UART_1_TX_INTERRUPT_ENABLED)
1012   2                          UART_1_DisableTxInt();
1013   2                      #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1014   2      
1015   2                      if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
1016   2                          ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1017   2                      {
1018   3                          /* Add directly to the FIFO. */
1019   3                          UART_1_TXDATA_REG = txDataByte;
1020   3                      }
1021   2                      else
1022   2                      {
1023   3                          if(UART_1_txBufferWrite >= UART_1_TXBUFFERSIZE)
1024   3                          {
1025   4                              UART_1_txBufferWrite = 0u;
1026   4                          }
1027   3      
1028   3                          UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
1029   3      
1030   3                          /* Add to the software buffer. */
1031   3                          UART_1_txBufferWrite++;
1032   3      
1033   3                      }
1034   2      
1035   2                      /* Enable Tx interrupt. */
1036   2                      #if(UART_1_TX_INTERRUPT_ENABLED)
1037   2                          UART_1_EnableTxInt();
1038   2                      #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1039   2      
1040   2                  #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
              
                              /* Add directly to the FIFO. */
                              UART_1_TXDATA_REG = txDataByte;
              
                          #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 18  

1046   2              }
1047   1          }
1048          
1049          
1050              /*******************************************************************************
1051              * Function Name: UART_1_ReadTxStatus
1052              ********************************************************************************
1053              *
1054              * Summary:
1055              *  Read the status register for the component
1056              *
1057              * Parameters:
1058              *  None.
1059              *
1060              * Return:
1061              *  Contents of the status register
1062              *
1063              * Theory:
1064              *  This function reads the status register which is clear on read. It is up to
1065              *  the user to handle all bits in this return value accordingly, even if the bit
1066              *  was not enabled as an interrupt source the event happened and must be handled
1067              *  accordingly.
1068              *
1069              *******************************************************************************/
1070              uint8 UART_1_ReadTxStatus(void) 
1071              {
1072   1              return(UART_1_TXSTATUS_REG);
1073   1          }
1074          
1075          
1076              /*******************************************************************************
1077              * Function Name: UART_1_PutChar
1078              ********************************************************************************
1079              *
1080              * Summary:
1081              *  Wait to send byte until TX register or buffer has room.
1082              *
1083              * Parameters:
1084              *  txDataByte: The 8-bit data value to send across the UART.
1085              *
1086              * Return:
1087              *  None.
1088              *
1089              * Global Variables:
1090              *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1091              *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1092              *     checked to identify free space in txBuffer and incremented after each byte
1093              *     saved to buffer.
1094              *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1095              *     checked to identify free space in txBuffer.
1096              *  UART_1_initVar - checked to identify that the component has been
1097              *     initialized.
1098              *
1099              * Reentrant:
1100              *  No.
1101              *
1102              * Theory:
1103              *  Allows the user to transmit any byte of data in a single transfer
1104              *
1105              *******************************************************************************/
1106              void UART_1_PutChar(uint8 txDataByte) 
1107              {
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 19  

1108   1                  #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1109   1                      /* The temporary output pointer is used since it takes two instructions
1110   1                      *  to increment with a wrap, and we can't risk doing that with the real
1111   1                      *  pointer and getting an interrupt in between instructions.
1112   1                      */
1113   1                      uint8 loc_txBufferWrite;
1114   1                      uint8 loc_txBufferRead;
1115   1      
1116   1                      do{
1117   2                          /* Block if software buffer is full, so we don't overwrite. */
1118   2                          #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Disable TX interrupt to protect variables that could change on interrupt */
                                      CyIntDisable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1122   2                          loc_txBufferWrite = UART_1_txBufferWrite;
1123   2                          loc_txBufferRead = UART_1_txBufferRead;
1124   2                          #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Enable interrupt to continue transmission */
                                      CyIntEnable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1128   2                      }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBufferRead -
             - 1u)) :
1129   1                                              ((loc_txBufferWrite - loc_txBufferRead) ==
1130   1                                              (uint8)(UART_1_TXBUFFERSIZE - 1u)) );
1131   1      
1132   1                      if( (loc_txBufferRead == loc_txBufferWrite) &&
1133   1                          ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1134   1                      {
1135   2                          /* Add directly to the FIFO. */
1136   2                          UART_1_TXDATA_REG = txDataByte;
1137   2                      }
1138   1                      else
1139   1                      {
1140   2                          if(loc_txBufferWrite >= UART_1_TXBUFFERSIZE)
1141   2                          {
1142   3                              loc_txBufferWrite = 0u;
1143   3                          }
1144   2                          /* Add to the software buffer. */
1145   2                          UART_1_txBuffer[loc_txBufferWrite] = txDataByte;
1146   2                          loc_txBufferWrite++;
1147   2      
1148   2                          /* Finally, update the real output pointer */
1149   2                          #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntDisable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1152   2                          UART_1_txBufferWrite = loc_txBufferWrite;
1153   2                          #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntEnable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1156   2                      }
1157   1      
1158   1                  #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
              
                              while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
                              {
                                  ; /* Wait for room in the FIFO. */
                              }
              
                              /* Add directly to the FIFO. */
                              UART_1_TXDATA_REG = txDataByte;
              
                          #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 20  

1169   1          }
1170          
1171          
1172              /*******************************************************************************
1173              * Function Name: UART_1_PutString
1174              ********************************************************************************
1175              *
1176              * Summary:
1177              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178              *
1179              * Parameters:
1180              *  string: char pointer to character string of Data to Send.
1181              *
1182              * Return:
1183              *  None.
1184              *
1185              * Global Variables:
1186              *  UART_1_initVar - checked to identify that the component has been
1187              *     initialized.
1188              *
1189              * Reentrant:
1190              *  No.
1191              *
1192              * Theory:
1193              *  This function will block if there is not enough memory to place the whole
1194              *  string, it will block until the entire string has been written to the
1195              *  transmit buffer.
1196              *
1197              *******************************************************************************/
1198              void UART_1_PutString(const char8 string[]) 
1199              {
1200   1              uint16 buf_index = 0u;
1201   1              /* If not Initialized then skip this function*/
1202   1              if(UART_1_initVar != 0u)
1203   1              {
1204   2                  /* This is a blocking function, it will not exit until all data is sent*/
1205   2                  while(string[buf_index] != (char8)0)
1206   2                  {
1207   3                      UART_1_PutChar((uint8)string[buf_index]);
1208   3                      buf_index++;
1209   3                  }
1210   2              }
1211   1          }
1212          
1213          
1214              /*******************************************************************************
1215              * Function Name: UART_1_PutArray
1216              ********************************************************************************
1217              *
1218              * Summary:
1219              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220              *
1221              * Parameters:
1222              *  string: Address of the memory array residing in RAM or ROM.
1223              *  byteCount: Number of Bytes to be transmitted.
1224              *
1225              * Return:
1226              *  None.
1227              *
1228              * Global Variables:
1229              *  UART_1_initVar - checked to identify that the component has been
1230              *     initialized.
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 21  

1231              *
1232              * Reentrant:
1233              *  No.
1234              *
1235              *******************************************************************************/
1236              void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1237                                                                              
1238              {
1239   1              uint8 buf_index = 0u;
1240   1              /* If not Initialized then skip this function*/
1241   1              if(UART_1_initVar != 0u)
1242   1              {
1243   2                  do
1244   2                  {
1245   3                      UART_1_PutChar(string[buf_index]);
1246   3                      buf_index++;
1247   3                  }while(buf_index < byteCount);
1248   2              }
1249   1          }
1250          
1251          
1252              /*******************************************************************************
1253              * Function Name: UART_1_PutCRLF
1254              ********************************************************************************
1255              *
1256              * Summary:
1257              *  Write a character and then carriage return and line feed.
1258              *
1259              * Parameters:
1260              *  txDataByte: uint8 Character to send.
1261              *
1262              * Return:
1263              *  None.
1264              *
1265              * Global Variables:
1266              *  UART_1_initVar - checked to identify that the component has been
1267              *     initialized.
1268              *
1269              * Reentrant:
1270              *  No.
1271              *
1272              *******************************************************************************/
1273              void UART_1_PutCRLF(uint8 txDataByte) 
1274              {
1275   1              /* If not Initialized then skip this function*/
1276   1              if(UART_1_initVar != 0u)
1277   1              {
1278   2                  UART_1_PutChar(txDataByte);
1279   2                  UART_1_PutChar(0x0Du);
1280   2                  UART_1_PutChar(0x0Au);
1281   2              }
1282   1          }
1283          
1284          
1285              /*******************************************************************************
1286              * Function Name: UART_1_GetTxBufferSize
1287              ********************************************************************************
1288              *
1289              * Summary:
1290              *  Determine the amount of space left in the TX buffer and return the count in
1291              *  bytes
1292              *
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 22  

1293              * Parameters:
1294              *  None.
1295              *
1296              * Return:
1297              *  Integer count of the number of bytes left in the TX buffer
1298              *
1299              * Global Variables:
1300              *  UART_1_txBufferWrite - used to calculate left space.
1301              *  UART_1_txBufferRead - used to calculate left space.
1302              *
1303              * Reentrant:
1304              *  No.
1305              *
1306              * Theory:
1307              *  Allows the user to find out how full the TX Buffer is.
1308              *
1309              *******************************************************************************/
1310              uint8 UART_1_GetTxBufferSize(void)
1311                                                                      
1312              {
1313   1              uint8 size;
1314   1      
1315   1              #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1316   1      
1317   1                  /* Disable Tx interrupt. */
1318   1                  /* Protect variables that could change on interrupt. */
1319   1                  #if(UART_1_TX_INTERRUPT_ENABLED)
1320   1                      UART_1_DisableTxInt();
1321   1                  #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1322   1      
1323   1                  if(UART_1_txBufferRead == UART_1_txBufferWrite)
1324   1                  {
1325   2                      size = 0u;
1326   2                  }
1327   1                  else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1328   1                  {
1329   2                      size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1330   2                  }
1331   1                  else
1332   1                  {
1333   2                      size = (UART_1_TXBUFFERSIZE - UART_1_txBufferRead) + UART_1_txBufferWrite;
1334   2                  }
1335   1      
1336   1                  /* Enable Tx interrupt. */
1337   1                  #if(UART_1_TX_INTERRUPT_ENABLED)
1338   1                      UART_1_EnableTxInt();
1339   1                  #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1340   1      
1341   1              #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
              
                          size = UART_1_TXSTATUS_REG;
              
                          /* Is the fifo is full. */
                          if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
                          {
                              size = UART_1_FIFO_LENGTH;
                          }
                          else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
                          {
                              size = 0u;
                          }
                          else
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 23  

                          {
                              /* We only know there is data in the fifo. */
                              size = 1u;
                          }
              
                      #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1361   1      
1362   1              return(size);
1363   1          }
1364          
1365          
1366              /*******************************************************************************
1367              * Function Name: UART_1_ClearTxBuffer
1368              ********************************************************************************
1369              *
1370              * Summary:
1371              *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372              *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373              *
1374              * Parameters:
1375              *  None.
1376              *
1377              * Return:
1378              *  None.
1379              *
1380              * Global Variables:
1381              *  UART_1_txBufferWrite - cleared to zero.
1382              *  UART_1_txBufferRead - cleared to zero.
1383              *
1384              * Reentrant:
1385              *  No.
1386              *
1387              * Theory:
1388              *  Setting the pointers to zero makes the system believe there is no data to
1389              *  read and writing will resume at address 0 overwriting any data that may have
1390              *  remained in the RAM.
1391              *
1392              * Side Effects:
1393              *  Any received data not read from the RAM buffer will be lost when overwritten.
1394              *
1395              *******************************************************************************/
1396              void UART_1_ClearTxBuffer(void) 
1397              {
1398   1              uint8 enableInterrupts;
1399   1      
1400   1              /* Enter critical section */
1401   1              enableInterrupts = CyEnterCriticalSection();
1402   1              /* clear the HW FIFO */
1403   1              UART_1_TXDATA_AUX_CTL_REG |=  UART_1_TX_FIFO_CLR;
1404   1              UART_1_TXDATA_AUX_CTL_REG &= (uint8)~UART_1_TX_FIFO_CLR;
1405   1              /* Exit critical section */
1406   1              CyExitCriticalSection(enableInterrupts);
1407   1      
1408   1              #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1409   1      
1410   1                  /* Disable Tx interrupt. */
1411   1                  /* Protect variables that could change on interrupt. */
1412   1                  #if(UART_1_TX_INTERRUPT_ENABLED)
1413   1                      UART_1_DisableTxInt();
1414   1                  #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1415   1      
1416   1                  UART_1_txBufferRead = 0u;
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 24  

1417   1                  UART_1_txBufferWrite = 0u;
1418   1      
1419   1                  /* Enable Tx interrupt. */
1420   1                  #if(UART_1_TX_INTERRUPT_ENABLED)
1421   1                      UART_1_EnableTxInt();
1422   1                  #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1423   1      
1424   1              #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1425   1          }
1426          
1427          
1428              /*******************************************************************************
1429              * Function Name: UART_1_SendBreak
1430              ********************************************************************************
1431              *
1432              * Summary:
1433              *  Write a Break command to the UART
1434              *
1435              * Parameters:
1436              *  uint8 retMode:  Wait mode,
1437              *   0 - Initialize registers for Break, sends the Break signal and return
1438              *       imediately.
1439              *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440              *       transmission mode then return.
1441              *   2 - Reinitialize registers to normal transmission mode then return.
1442              *   3 - both steps: 0 and 1
1443              *       init registers for Break, send Break signal
1444              *       wait until Break sending is complete, reinit registers to normal
1445              *       transmission mode then return.
1446              *
1447              * Return:
1448              *  None.
1449              *
1450              * Global Variables:
1451              *  UART_1_initVar - checked to identify that the component has been
1452              *     initialized.
1453              *  tx_period - static variable, used for keeping TX period configuration.
1454              *
1455              * Reentrant:
1456              *  No.
1457              *
1458              * Theory:
1459              *  SendBreak function initializes registers to send 13-bit break signal. It is
1460              *  important to return the registers configuration to normal for continue 8-bit
1461              *  operation.
1462              *  Trere are 3 variants for this API usage:
1463              *  1) SendBreak(3) - function will send the Break signal and take care on the
1464              *     configuration returning. Funcition will block CPU untill transmition
1465              *     complete.
1466              *  2) User may want to use bloking time if UART configured to the low speed
1467              *     operation
1468              *     Emample for this case:
1469              *     SendBreak(0);     - init Break signal transmition
1470              *         Add your code here to use CPU time
1471              *     SendBreak(1);     - complete Break operation
1472              *  3) Same to 2) but user may want to init and use the interrupt for complete
1473              *     break operation.
1474              *     Example for this case:
1475              *     Init TX interrupt whith "TX - On TX Complete" parameter
1476              *     SendBreak(0);     - init Break signal transmition
1477              *         Add your code here to use CPU time
1478              *     When interrupt appear with UART_TX_STS_COMPLETE status:
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 25  

1479              *     SendBreak(2);     - complete Break operation
1480              *
1481              * Side Effects:
1482              *   Uses static variable to keep registers configuration.
1483              *
1484              *******************************************************************************/
1485              void UART_1_SendBreak(uint8 retMode) 
1486              {
1487   1      
1488   1              /* If not Initialized then skip this function*/
1489   1              if(UART_1_initVar != 0u)
1490   1              {
1491   2                  /*Set the Counter to 13-bits and transmit a 00 byte*/
1492   2                  /*When that is done then reset the counter value back*/
1493   2                  uint8 tmpStat;
1494   2      
1495   2                  #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == UART_1_SEND_BREAK) ||
                                  (retMode == UART_1_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                        UART_1_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  UART_1_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = UART_1_TXSTATUS_REG;
                                  }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
                              }
              
                              if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_1_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = UART_1_TXSTATUS_REG;
                                  }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
                              }
              
                              if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_1_REINIT) ||
                                  (retMode == UART_1_SEND_WAIT_REINIT) )
                              {
                                  UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                (uint8)~UART_1_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* UART_1_HD_ENABLED Full Duplex mode */
1530   2      
1531   2                      static uint8 tx_period;
1532   2      
1533   2                      if( (retMode == UART_1_SEND_BREAK) ||
1534   2                          (retMode == UART_1_SEND_WAIT_REINIT) )
1535   2                      {
1536   3                          /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode*/
1537   3                          #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1538   3                                              (UART_1_PARITY_TYPE_SW != 0u) )
                                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                            UART_1_CTRL_HD_SEND_BREAK);
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 26  

                                  #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1542   3      
1543   3                          #if(UART_1_TXCLKGEN_DP)
1544   3                              tx_period = UART_1_TXBITCLKTX_COMPLETE_REG;
1545   3                              UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
1546   3                          #else
                                      tx_period = UART_1_TXBITCTR_PERIOD_REG;
                                      UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
                                  #endif /* End UART_1_TXCLKGEN_DP */
1550   3      
1551   3                          /* Send zeros*/
1552   3                          UART_1_TXDATA_REG = 0u;
1553   3      
1554   3                          do /* wait until transmit starts */
1555   3                          {
1556   4                              tmpStat = UART_1_TXSTATUS_REG;
1557   4                          }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1558   3                      }
1559   2      
1560   2                      if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1561   2                          (retMode == UART_1_SEND_WAIT_REINIT) )
1562   2                      {
1563   3                          do /*wait until transmit complete*/
1564   3                          {
1565   4                              tmpStat = UART_1_TXSTATUS_REG;
1566   4                          }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1567   3                      }
1568   2      
1569   2                      if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1570   2                          (retMode == UART_1_REINIT) ||
1571   2                          (retMode == UART_1_SEND_WAIT_REINIT) )
1572   2                      {
1573   3      
1574   3                          #if(UART_1_TXCLKGEN_DP)
1575   3                              UART_1_TXBITCLKTX_COMPLETE_REG = tx_period;
1576   3                          #else
                                      UART_1_TXBITCTR_PERIOD_REG = tx_period;
                                  #endif /* End UART_1_TXCLKGEN_DP */
1579   3      
1580   3                          #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1581   3                               (UART_1_PARITY_TYPE_SW != 0u) )
                                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                    (uint8)~UART_1_CTRL_HD_SEND_BREAK);
                                  #endif /* End UART_1_PARITY_TYPE != NONE */
1585   3                      }
1586   2                  #endif    /* End UART_1_HD_ENABLED */
1587   2              }
1588   1          }
1589          
1590          
1591              /*******************************************************************************
1592              * Function Name: UART_1_SetTxAddressMode
1593              ********************************************************************************
1594              *
1595              * Summary:
1596              *  Set the transmit addressing mode
1597              *
1598              * Parameters:
1599              *  addressMode: 0 -> Space
1600              *               1 -> Mark
1601              *
1602              * Return:
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 27  

1603              *  None.
1604              *
1605              *******************************************************************************/
1606              void UART_1_SetTxAddressMode(uint8 addressMode) 
1607              {
1608   1              /* Mark/Space sending enable*/
1609   1              if(addressMode != 0u)
1610   1              {
1611   2                  #if( UART_1_CONTROL_REG_REMOVED == 0u )
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                    UART_1_CTRL_MARK);
                          #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1615   2              }
1616   1              else
1617   1              {
1618   2                  #if( UART_1_CONTROL_REG_REMOVED == 0u )
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                  (uint8)~UART_1_CTRL_MARK);
                          #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1622   2              }
1623   1          }
1624          
1625          #endif  /* EndUART_1_TX_ENABLED */
1626          
1627          #if(UART_1_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART.
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void UART_1_LoadTxConfig(void) 
                  {
                      #if((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          UART_1_SetRxInterruptMode(0u);
                      #endif /* UART_1_RX_INTERRUPT_ENABLED */
              
                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() | UART_1_CTRL_HD_SEND);
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_HD_TXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_1_RXSTATUS_PTR);
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 28  

                      #endif /* CY_UDB_V0 */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer
                  *  has been used.
                  *
                  *******************************************************************************/
                  void UART_1_LoadRxConfig(void) 
                  {
                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                              (uint8)~UART_1_CTRL_HD_SEND);
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_HD_RXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_1_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
              
                      #if((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          /* Enable RX interrupt after set RX configuration */
                          UART_1_SetRxInterruptMode(UART_1_INIT_RX_INTERRUPTS_MASK);
                      #endif /* UART_1_RX_INTERRUPT_ENABLED */
                  }
              
              #endif  /* UART_1_HD_ENABLED */
1710          
1711          
1712          /* [] END OF FILE */
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_1_Start (BEGIN)
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 76
0000 900000      R     MOV     DPTR,#UART_1_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 78
0008 120000      R     LCALL   UART_1_Init
                                           ; SOURCE LINE # 79
000B 900000      R     MOV     DPTR,#UART_1_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
0011         ?C0001:
                                           ; SOURCE LINE # 81
0011 120000      R     LCALL   UART_1_Enable
                                           ; SOURCE LINE # 82
0014 22                RET     
             ; FUNCTION UART_1_Start (END)

             ; FUNCTION UART_1_Init (BEGIN)
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 107
0000 7C00        E     MOV     R4,#HIGH UART_1_RXISR
0002 7D00        E     MOV     R5,#LOW UART_1_RXISR
0004 7F00              MOV     R7,#00H
0006 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 108
0009 7D07              MOV     R5,#07H
000B 7F00              MOV     R7,#00H
000D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 118
0010 906483            MOV     DPTR,#06483H
0013 7472              MOV     A,#072H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
0016 906485            MOV     DPTR,#06485H
0019 7420              MOV     A,#020H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
001C 7C00        E     MOV     R4,#HIGH UART_1_TXISR
001E 7D00        E     MOV     R5,#LOW UART_1_TXISR
0020 7F01              MOV     R7,#01H
0022 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 127
0025 7D07              MOV     R5,#07H
0027 7F01              MOV     R7,#01H
0029 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 132
002C 906426            MOV     DPTR,#06426H
002F 7407              MOV     A,#07H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
0032 906436            MOV     DPTR,#06436H
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 30  

0035 7448              MOV     A,#048H
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 142
0038 906486            MOV     DPTR,#06486H
003B 7402              MOV     A,#02H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
003E 22                RET     
             ; FUNCTION UART_1_Init (END)

             ; FUNCTION UART_1_Enable (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 181
0008 906493            MOV     DPTR,#06493H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
0013 906495            MOV     DPTR,#06495H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 185
001E 9044C0            MOV     DPTR,#044C0H
0021 7401              MOV     A,#01H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0024 906496            MOV     DPTR,#06496H
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 EF                MOV     A,R7
002A 4410              ORL     A,#010H
002C FF                MOV     R7,A
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 200
002F 9044C0            MOV     DPTR,#044C0H
0032 7402              MOV     A,#02H
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0035 120000      E     LCALL   UART_1_IntClock_Start
                                           ; SOURCE LINE # 209
0038 900000      R     MOV     DPTR,#enableInterrupts
003B E0                MOVX    A,@DPTR
003C FF                MOV     R7,A
003D 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 210
0040 22                RET     
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 31  

             ; FUNCTION UART_1_Enable (END)

             ; FUNCTION UART_1_Stop (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 230
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
0008 906493            MOV     DPTR,#06493H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
0013 120000      E     LCALL   UART_1_IntClock_Stop
                                           ; SOURCE LINE # 250
0016 906495            MOV     DPTR,#06495H
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 54EF              ANL     A,#0EFH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 252
0021 120000      R     LCALL   UART_1_DisableRxInt
                                           ; SOURCE LINE # 257
0024 906496            MOV     DPTR,#06496H
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 EF                MOV     A,R7
002A 54EF              ANL     A,#0EFH
002C FF                MOV     R7,A
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
002F 120000      R     LCALL   UART_1_DisableTxInt
                                           ; SOURCE LINE # 263
0032 900000      R     MOV     DPTR,#enableInterrupts
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 264
003A 22                RET     
             ; FUNCTION UART_1_Stop (END)

             ; FUNCTION UART_1_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 284
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 288
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_1_ReadControlRegister (END)

C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 32  

             ; FUNCTION _UART_1_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 305
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 312
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_1_WriteControlRegister (END)

             ; FUNCTION UART_1_EnableRxInt (BEGIN)
                                           ; SOURCE LINE # 336
                                           ; SOURCE LINE # 337
                                           ; SOURCE LINE # 338
0000 9044C0            MOV     DPTR,#044C0H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 339
0006 22                RET     
             ; FUNCTION UART_1_EnableRxInt (END)

             ; FUNCTION UART_1_DisableRxInt (BEGIN)
                                           ; SOURCE LINE # 359
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 361
0000 9044C8            MOV     DPTR,#044C8H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 362
0006 22                RET     
             ; FUNCTION UART_1_DisableRxInt (END)

             ; FUNCTION _UART_1_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 385
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906485            MOV     DPTR,#06485H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
000F 22                RET     
             ; FUNCTION _UART_1_SetRxInterruptMode (END)

             ; FUNCTION UART_1_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 428
0000 120000      R     LCALL   UART_1_DisableRxInt
                                           ; SOURCE LINE # 430
0003 900000      R     MOV     DPTR,#UART_1_rxBufferRead
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#loc_rxBufferRead
000B EF                MOV     A,R7
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 33  

000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 431
000D 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 900000      R     MOV     DPTR,#loc_rxBufferWrite
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 433
0017 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D 700E              JNZ     ?C0013
001F 900000      R     MOV     DPTR,#loc_rxBufferWrite
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 900000      R     MOV     DPTR,#loc_rxBufferRead
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
0029 EE                MOV     A,R6
002A 6F                XRL     A,R7
002B 6045              JZ      ?C0012
002D         ?C0013:
                                           ; SOURCE LINE # 434
                                           ; SOURCE LINE # 435
002D 900000      R     MOV     DPTR,#loc_rxBufferRead
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 7400        R     MOV     A,#LOW UART_1_rxBuffer
0034 2F                ADD     A,R7
0035 F582              MOV     DPL,A
0037 E4                CLR     A
0038 3400        R     ADDC    A,#HIGH UART_1_rxBuffer
003A F583              MOV     DPH,A
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E 900000      R     MOV     DPTR,#rxData
0041 EF                MOV     A,R7
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
0043 900000      R     MOV     DPTR,#loc_rxBufferRead
0046 E0                MOVX    A,@DPTR
0047 04                INC     A
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
0049 900000      R     MOV     DPTR,#loc_rxBufferRead
004C E0                MOVX    A,@DPTR
004D FF                MOV     R7,A
004E EF                MOV     A,R7
004F C3                CLR     C
0050 94FF              SUBB    A,#0FFH
0052 4005              JC      ?C0014
                                           ; SOURCE LINE # 439
                                           ; SOURCE LINE # 440
0054 900000      R     MOV     DPTR,#loc_rxBufferRead
0057 E4                CLR     A
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 441
0059         ?C0014:
                                           ; SOURCE LINE # 443
0059 900000      R     MOV     DPTR,#loc_rxBufferRead
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 34  

005C E0                MOVX    A,@DPTR
005D FF                MOV     R7,A
005E 900000      R     MOV     DPTR,#UART_1_rxBufferRead
0061 EF                MOV     A,R7
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 445
0063 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
0066 E0                MOVX    A,@DPTR
0067 FF                MOV     R7,A
0068 EF                MOV     A,R7
0069 6011              JZ      ?C0016
                                           ; SOURCE LINE # 446
                                           ; SOURCE LINE # 447
006B 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
006E E4                CLR     A
006F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 463
                                           ; SOURCE LINE # 464
0070 800A              SJMP    ?C0016
0072         ?C0012:
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 467
0072 906443            MOV     DPTR,#06443H
0075 E0                MOVX    A,@DPTR
0076 FF                MOV     R7,A
0077 900000      R     MOV     DPTR,#rxData
007A EF                MOV     A,R7
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 468
007C         ?C0016:
                                           ; SOURCE LINE # 472
007C 120000      R     LCALL   UART_1_EnableRxInt
                                           ; SOURCE LINE # 482
007F 900000      R     MOV     DPTR,#rxData
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
                                           ; SOURCE LINE # 483
0084         ?C0017:
0084 22                RET     
             ; FUNCTION UART_1_ReadRxData (END)

             ; FUNCTION UART_1_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
                                           ; SOURCE LINE # 513
0000 906465            MOV     DPTR,#06465H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#status
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 516
000E 900000      R     MOV     DPTR,#UART_1_rxBufferOverflow
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6013              JZ      ?C0018
                                           ; SOURCE LINE # 517
                                           ; SOURCE LINE # 518
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 35  

0016 900000      R     MOV     DPTR,#status
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 4480              ORL     A,#080H
001E FF                MOV     R7,A
001F 900000      R     MOV     DPTR,#status
0022 EF                MOV     A,R7
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
0024 900000      R     MOV     DPTR,#UART_1_rxBufferOverflow
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 520
0029         ?C0018:
                                           ; SOURCE LINE # 523
0029 900000      R     MOV     DPTR,#status
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
                                           ; SOURCE LINE # 524
002E         ?C0019:
002E 22                RET     
             ; FUNCTION UART_1_ReadRxStatus (END)

             ; FUNCTION UART_1_GetChar (BEGIN)
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 567
0005 120000      R     LCALL   UART_1_DisableRxInt
                                           ; SOURCE LINE # 569
0008 900000      R     MOV     DPTR,#UART_1_rxBufferRead
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D 900000      R     MOV     DPTR,#loc_rxBufferRead
0010 EF                MOV     A,R7
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 570
0012 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 900000      R     MOV     DPTR,#loc_rxBufferWrite
001A EF                MOV     A,R7
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 572
001C 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 700E              JNZ     ?C0021
0024 900000      R     MOV     DPTR,#loc_rxBufferWrite
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 900000      R     MOV     DPTR,#loc_rxBufferRead
002C E0                MOVX    A,@DPTR
002D FE                MOV     R6,A
002E EE                MOV     A,R6
002F 6F                XRL     A,R7
0030 6048              JZ      ?C0020
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 36  

0032         ?C0021:
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
0032 900000      R     MOV     DPTR,#loc_rxBufferRead
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 7400        R     MOV     A,#LOW UART_1_rxBuffer
0039 2F                ADD     A,R7
003A F582              MOV     DPL,A
003C E4                CLR     A
003D 3400        R     ADDC    A,#HIGH UART_1_rxBuffer
003F F583              MOV     DPH,A
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 900000      R     MOV     DPTR,#rxData
0046 EF                MOV     A,R7
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 575
0048 900000      R     MOV     DPTR,#loc_rxBufferRead
004B E0                MOVX    A,@DPTR
004C 04                INC     A
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
004E 900000      R     MOV     DPTR,#loc_rxBufferRead
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
0053 EF                MOV     A,R7
0054 C3                CLR     C
0055 94FF              SUBB    A,#0FFH
0057 4005              JC      ?C0022
                                           ; SOURCE LINE # 577
                                           ; SOURCE LINE # 578
0059 900000      R     MOV     DPTR,#loc_rxBufferRead
005C E4                CLR     A
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 579
005E         ?C0022:
                                           ; SOURCE LINE # 581
005E 900000      R     MOV     DPTR,#loc_rxBufferRead
0061 E0                MOVX    A,@DPTR
0062 FF                MOV     R7,A
0063 900000      R     MOV     DPTR,#UART_1_rxBufferRead
0066 EF                MOV     A,R7
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 583
0068 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
006D EF                MOV     A,R7
006E D3                SETB    C
006F 9400              SUBB    A,#00H
0071 4038              JC      ?C0024
                                           ; SOURCE LINE # 584
                                           ; SOURCE LINE # 585
0073 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
0076 E4                CLR     A
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 600
                                           ; SOURCE LINE # 602
0078 8031              SJMP    ?C0024
007A         ?C0020:
                                           ; SOURCE LINE # 604
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 37  

007A 906465            MOV     DPTR,#06465H
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 900000      R     MOV     DPTR,#rxStatus
0082 EF                MOV     A,R7
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 605
0084 900000      R     MOV     DPTR,#rxStatus
0087 E0                MOVX    A,@DPTR
0088 FF                MOV     R7,A
0089 EF                MOV     A,R7
008A 30E51E            JNB     ACC.5,?C0024
                                           ; SOURCE LINE # 606
                                           ; SOURCE LINE # 607
008D 906443            MOV     DPTR,#06443H
0090 E0                MOVX    A,@DPTR
0091 FF                MOV     R7,A
0092 900000      R     MOV     DPTR,#rxData
0095 EF                MOV     A,R7
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 610
0097 900000      R     MOV     DPTR,#rxStatus
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D 541E              ANL     A,#01EH
009F FF                MOV     R7,A
00A0 7E00              MOV     R6,#00H
00A2 EF                MOV     A,R7
00A3 4E                ORL     A,R6
00A4 6005              JZ      ?C0024
                                           ; SOURCE LINE # 611
                                           ; SOURCE LINE # 612
00A6 900000      R     MOV     DPTR,#rxData
00A9 E4                CLR     A
00AA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
00AB         ?C0024:
                                           ; SOURCE LINE # 619
00AB 120000      R     LCALL   UART_1_EnableRxInt
                                           ; SOURCE LINE # 637
00AE 900000      R     MOV     DPTR,#rxData
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
                                           ; SOURCE LINE # 638
00B3         ?C0027:
00B3 22                RET     
             ; FUNCTION UART_1_GetChar (END)

             ; FUNCTION UART_1_GetByte (BEGIN)
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0000 120000      R     LCALL   UART_1_ReadRxStatus
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 7D00              MOV     R5,#00H
0008 FC                MOV     R4,A
0009 120000      R     LCALL   UART_1_ReadRxData
000C 7E00              MOV     R6,#00H
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 38  

000E EC                MOV     A,R4
000F 4E                ORL     A,R6
0010 FE                MOV     R6,A
0011 ED                MOV     A,R5
0012 4F                ORL     A,R7
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 661
0014         ?C0028:
0014 22                RET     
             ; FUNCTION UART_1_GetByte (END)

             ; FUNCTION UART_1_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 701
0000 120000      R     LCALL   UART_1_DisableRxInt
                                           ; SOURCE LINE # 704
0003 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#UART_1_rxBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D EE                MOV     A,R6
000E B5071A            CJNE    A,AR7,?C0029
                                           ; SOURCE LINE # 705
                                           ; SOURCE LINE # 706
0011 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 D3                SETB    C
0018 9400              SUBB    A,#00H
001A 4008              JC      ?C0030
                                           ; SOURCE LINE # 707
                                           ; SOURCE LINE # 708
001C 900000      R     MOV     DPTR,#size
001F 74FF              MOV     A,#0FFH
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 709
0022 8042              SJMP    ?C0032
0024         ?C0030:
                                           ; SOURCE LINE # 711
                                           ; SOURCE LINE # 712
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 713
                                           ; SOURCE LINE # 714
0029 803B              SJMP    ?C0032
002B         ?C0029:
                                           ; SOURCE LINE # 715
002B 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#UART_1_rxBufferRead
0033 E0                MOVX    A,@DPTR
0034 FE                MOV     R6,A
0035 EE                MOV     A,R6
0036 C3                CLR     C
0037 9F                SUBB    A,R7
0038 5015              JNC     ?C0033
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 39  

                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
003A 900000      R     MOV     DPTR,#UART_1_rxBufferRead
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
0042 E0                MOVX    A,@DPTR
0043 FE                MOV     R6,A
0044 C3                CLR     C
0045 EE                MOV     A,R6
0046 9F                SUBB    A,R7
0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#size
004B EF                MOV     A,R7
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
004D 8017              SJMP    ?C0032
004F         ?C0033:
                                           ; SOURCE LINE # 720
                                           ; SOURCE LINE # 721
004F 900000      R     MOV     DPTR,#UART_1_rxBufferRead
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 C3                CLR     C
0055 74FF              MOV     A,#0FFH
0057 9F                SUBB    A,R7
0058 FF                MOV     R7,A
0059 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E EF                MOV     A,R7
005F 2E                ADD     A,R6
0060 FF                MOV     R7,A
0061 900000      R     MOV     DPTR,#size
0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
0066         ?C0032:
                                           ; SOURCE LINE # 726
0066 120000      R     LCALL   UART_1_EnableRxInt
                                           ; SOURCE LINE # 736
0069 900000      R     MOV     DPTR,#size
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
                                           ; SOURCE LINE # 737
006E         ?C0035:
006E 22                RET     
             ; FUNCTION UART_1_GetRxBufferSize (END)

             ; FUNCTION UART_1_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 777
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0008 906493            MOV     DPTR,#06493H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 40  

000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0013 906493            MOV     DPTR,#06493H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 787
0026 120000      R     LCALL   UART_1_DisableRxInt
                                           ; SOURCE LINE # 790
0029 900000      R     MOV     DPTR,#UART_1_rxBufferRead
002C E4                CLR     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 791
002E 900000      R     MOV     DPTR,#UART_1_rxBufferWrite
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 792
0033 900000      R     MOV     DPTR,#UART_1_rxBufferLoopDetect
0036 E4                CLR     A
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 793
0038 900000      R     MOV     DPTR,#UART_1_rxBufferOverflow
003B E4                CLR     A
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 797
003D 120000      R     LCALL   UART_1_EnableRxInt
                                           ; SOURCE LINE # 801
0040 22                RET     
             ; FUNCTION UART_1_ClearRxBuffer (END)

             ; FUNCTION _UART_1_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 832
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 850
                                           ; SOURCE LINE # 852
0005         ?C0038:
0005 22                RET     
             ; FUNCTION _UART_1_SetRxAddressMode (END)

             ; FUNCTION _UART_1_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 869
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0005 900000      R     MOV     DPTR,#address
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 41  

0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906423            MOV     DPTR,#06423H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 873
000F 22                RET     
             ; FUNCTION _UART_1_SetRxAddress1 (END)

             ; FUNCTION _UART_1_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 890
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 891
                                           ; SOURCE LINE # 892
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906433            MOV     DPTR,#06433H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 893
000F 22                RET     
             ; FUNCTION _UART_1_SetRxAddress2 (END)

             ; FUNCTION UART_1_EnableTxInt (BEGIN)
                                           ; SOURCE LINE # 919
                                           ; SOURCE LINE # 920
                                           ; SOURCE LINE # 921
0000 9044C0            MOV     DPTR,#044C0H
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 922
0006 22                RET     
             ; FUNCTION UART_1_EnableTxInt (END)

             ; FUNCTION UART_1_DisableTxInt (BEGIN)
                                           ; SOURCE LINE # 942
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 944
0000 9044C8            MOV     DPTR,#044C8H
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 945
0006 22                RET     
             ; FUNCTION UART_1_DisableTxInt (END)

             ; FUNCTION _UART_1_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 968
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906486            MOV     DPTR,#06486H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 971
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 42  

000F 22                RET     
             ; FUNCTION _UART_1_SetTxInterruptMode (END)

             ; FUNCTION _UART_1_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 1002
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1003
                                           ; SOURCE LINE # 1005
0005 900000      R     MOV     DPTR,#UART_1_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6055              JZ      ?C0048
                                           ; SOURCE LINE # 1006
                                           ; SOURCE LINE # 1012
000D 120000      R     LCALL   UART_1_DisableTxInt
                                           ; SOURCE LINE # 1016
0010 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#UART_1_txBufferRead
0018 E0                MOVX    A,@DPTR
0019 FE                MOV     R6,A
001A EE                MOV     A,R6
001B B50715            CJNE    A,AR7,?C0045
001E 906466            MOV     DPTR,#06466H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 20E20C            JB      ACC.2,?C0045
                                           ; SOURCE LINE # 1017
                                           ; SOURCE LINE # 1019
0027 900000      R     MOV     DPTR,#txDataByte
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 906445            MOV     DPTR,#06445H
002F EF                MOV     A,R7
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1020
0031 802C              SJMP    ?C0046
0033         ?C0045:
                                           ; SOURCE LINE # 1022
                                           ; SOURCE LINE # 1023
0033 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 EF                MOV     A,R7
0039 C3                CLR     C
003A 94FF              SUBB    A,#0FFH
003C 4005              JC      ?C0047
                                           ; SOURCE LINE # 1024
                                           ; SOURCE LINE # 1025
003E 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1026
0043         ?C0047:
                                           ; SOURCE LINE # 1028
0043 900000      R     MOV     DPTR,#txDataByte
0046 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 43  

0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#UART_1_txBufferWrite
004B E0                MOVX    A,@DPTR
004C FE                MOV     R6,A
004D 7400        R     MOV     A,#LOW UART_1_txBuffer
004F 2E                ADD     A,R6
0050 F582              MOV     DPL,A
0052 E4                CLR     A
0053 3400        R     ADDC    A,#HIGH UART_1_txBuffer
0055 F583              MOV     DPH,A
0057 EF                MOV     A,R7
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1031
0059 900000      R     MOV     DPTR,#UART_1_txBufferWrite
005C E0                MOVX    A,@DPTR
005D 04                INC     A
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1033
005F         ?C0046:
                                           ; SOURCE LINE # 1037
005F 120000      R     LCALL   UART_1_EnableTxInt
                                           ; SOURCE LINE # 1046
                                           ; SOURCE LINE # 1047
0062         ?C0048:
0062 22                RET     
             ; FUNCTION _UART_1_WriteTxData (END)

             ; FUNCTION UART_1_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1070
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
0000 906466            MOV     DPTR,#06466H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1073
0005         ?C0049:
0005 22                RET     
             ; FUNCTION UART_1_ReadTxStatus (END)

             ; FUNCTION _UART_1_PutChar (BEGIN)
                                           ; SOURCE LINE # 1106
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1107
0005         ?C0052:
                                           ; SOURCE LINE # 1116
                                           ; SOURCE LINE # 1122
0005 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#loc_txBufferWrite
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1123
000F 900000      R     MOV     DPTR,#UART_1_txBufferRead
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#loc_txBufferRead
0017 EF                MOV     A,R7
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1128
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 44  

                                           ; SOURCE LINE # 1130
0019 900000      R     MOV     DPTR,#loc_txBufferRead
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E 900000      R     MOV     DPTR,#loc_txBufferWrite
0021 E0                MOVX    A,@DPTR
0022 FE                MOV     R6,A
0023 EE                MOV     A,R6
0024 C3                CLR     C
0025 9F                SUBB    A,R7
0026 5026              JNC     ?C0053
0028 900000      R     MOV     DPTR,#loc_txBufferRead
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 7E00              MOV     R6,#00H
002F EF                MOV     A,R7
0030 24FF              ADD     A,#0FFH
0032 FF                MOV     R7,A
0033 EE                MOV     A,R6
0034 34FF              ADDC    A,#0FFH
0036 FE                MOV     R6,A
0037 900000      R     MOV     DPTR,#loc_txBufferWrite
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C 7C00              MOV     R4,#00H
003E EF                MOV     A,R7
003F B50508            CJNE    A,AR5,?C0055
0042 EE                MOV     A,R6
0043 B50404            CJNE    A,AR4,?C0055
0046 7F01              MOV     R7,#01H
0048 8002              SJMP    ?C0056
004A         ?C0055:
004A 7F00              MOV     R7,#00H
004C         ?C0056:
004C 8018              SJMP    ?C0054
004E         ?C0053:
004E 900000      R     MOV     DPTR,#loc_txBufferRead
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
0053 900000      R     MOV     DPTR,#loc_txBufferWrite
0056 E0                MOVX    A,@DPTR
0057 FE                MOV     R6,A
0058 C3                CLR     C
0059 EE                MOV     A,R6
005A 9F                SUBB    A,R7
005B FF                MOV     R7,A
005C EF                MOV     A,R7
005D B4FE04            CJNE    A,#0FEH,?C0057
0060 7F01              MOV     R7,#01H
0062 8002              SJMP    ?C0058
0064         ?C0057:
0064 7F00              MOV     R7,#00H
0066         ?C0058:
0066         ?C0054:
0066 EF                MOV     A,R7
0067 709C              JNZ     ?C0052
                                           ; SOURCE LINE # 1133
0069 900000      R     MOV     DPTR,#loc_txBufferWrite
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
006E 900000      R     MOV     DPTR,#loc_txBufferRead
0071 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 45  

0072 FE                MOV     R6,A
0073 EE                MOV     A,R6
0074 B50714            CJNE    A,AR7,?C0059
0077 906466            MOV     DPTR,#06466H
007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C EF                MOV     A,R7
007D 20E20B            JB      ACC.2,?C0059
                                           ; SOURCE LINE # 1134
                                           ; SOURCE LINE # 1136
0080 900000      R     MOV     DPTR,#txDataByte
0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 906445            MOV     DPTR,#06445H
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1137
008A 22                RET     
008B         ?C0059:
                                           ; SOURCE LINE # 1139
                                           ; SOURCE LINE # 1140
008B 900000      R     MOV     DPTR,#loc_txBufferWrite
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 EF                MOV     A,R7
0091 C3                CLR     C
0092 94FF              SUBB    A,#0FFH
0094 4005              JC      ?C0061
                                           ; SOURCE LINE # 1141
                                           ; SOURCE LINE # 1142
0096 900000      R     MOV     DPTR,#loc_txBufferWrite
0099 E4                CLR     A
009A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1143
009B         ?C0061:
                                           ; SOURCE LINE # 1145
009B 900000      R     MOV     DPTR,#txDataByte
009E E0                MOVX    A,@DPTR
009F FF                MOV     R7,A
00A0 900000      R     MOV     DPTR,#loc_txBufferWrite
00A3 E0                MOVX    A,@DPTR
00A4 FE                MOV     R6,A
00A5 7400        R     MOV     A,#LOW UART_1_txBuffer
00A7 2E                ADD     A,R6
00A8 F582              MOV     DPL,A
00AA E4                CLR     A
00AB 3400        R     ADDC    A,#HIGH UART_1_txBuffer
00AD F583              MOV     DPH,A
00AF EF                MOV     A,R7
00B0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1146
00B1 900000      R     MOV     DPTR,#loc_txBufferWrite
00B4 E0                MOVX    A,@DPTR
00B5 04                INC     A
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1152
00B7 900000      R     MOV     DPTR,#loc_txBufferWrite
00BA E0                MOVX    A,@DPTR
00BB FF                MOV     R7,A
00BC 900000      R     MOV     DPTR,#UART_1_txBufferWrite
00BF EF                MOV     A,R7
00C0 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 46  

                                           ; SOURCE LINE # 1156
                                           ; SOURCE LINE # 1169
00C1         ?C0062:
00C1 22                RET     
             ; FUNCTION _UART_1_PutChar (END)

             ; FUNCTION _UART_1_PutString (BEGIN)
                                           ; SOURCE LINE # 1198
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1199
                                           ; SOURCE LINE # 1200
0006 900000      R     MOV     DPTR,#buf_index
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1202
000E 900000      R     MOV     DPTR,#UART_1_initVar
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6042              JZ      ?C0066
                                           ; SOURCE LINE # 1203
0016         ?C0064:
                                           ; SOURCE LINE # 1205
0016 900000      R     MOV     DPTR,#string
0019 120000      E     LCALL   ?C?PLDXDATA
001C 900000      R     MOV     DPTR,#buf_index
001F E0                MOVX    A,@DPTR
0020 FE                MOV     R6,A
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E9                MOV     A,R1
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 EA                MOV     A,R2
0028 3E                ADDC    A,R6
0029 FA                MOV     R2,A
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 6027              JZ      ?C0066
                                           ; SOURCE LINE # 1206
                                           ; SOURCE LINE # 1207
0031 900000      R     MOV     DPTR,#string
0034 120000      E     LCALL   ?C?PLDXDATA
0037 900000      R     MOV     DPTR,#buf_index
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F E9                MOV     A,R1
0040 2F                ADD     A,R7
0041 F9                MOV     R1,A
0042 EA                MOV     A,R2
0043 3E                ADDC    A,R6
0044 FA                MOV     R2,A
0045 120000      E     LCALL   ?C?CLDPTR
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 47  

0048 FF                MOV     R7,A
0049 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1208
004C 900000      R     MOV     DPTR,#buf_index
004F E4                CLR     A
0050 75F001            MOV     B,#01H
0053 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1209
0056 80BE              SJMP    ?C0064
                                           ; SOURCE LINE # 1210
                                           ; SOURCE LINE # 1211
0058         ?C0066:
0058 22                RET     
             ; FUNCTION _UART_1_PutString (END)

             ; FUNCTION _UART_1_PutArray (BEGIN)
                                           ; SOURCE LINE # 1236
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
000B 900000      R     MOV     DPTR,#buf_index
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1241
0010 900000      R     MOV     DPTR,#UART_1_initVar
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 602D              JZ      ?C0071
                                           ; SOURCE LINE # 1242
0018         ?C0070:
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
0018 900000      R     MOV     DPTR,#string
001B 120000      E     LCALL   ?C?PLDXDATA
001E 900000      R     MOV     DPTR,#buf_index
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 E9                MOV     A,R1
0024 2F                ADD     A,R7
0025 F9                MOV     R1,A
0026 E4                CLR     A
0027 3A                ADDC    A,R2
0028 FA                MOV     R2,A
0029 120000      E     LCALL   ?C?CLDPTR
002C FF                MOV     R7,A
002D 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1246
0030 900000      R     MOV     DPTR,#buf_index
0033 E0                MOVX    A,@DPTR
0034 04                INC     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1247
0036 900000      R     MOV     DPTR,#byteCount
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 900000      R     MOV     DPTR,#buf_index
003E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 48  

003F FE                MOV     R6,A
0040 EE                MOV     A,R6
0041 C3                CLR     C
0042 9F                SUBB    A,R7
0043 40D3              JC      ?C0070
                                           ; SOURCE LINE # 1248
                                           ; SOURCE LINE # 1249
0045         ?C0071:
0045 22                RET     
             ; FUNCTION _UART_1_PutArray (END)

             ; FUNCTION _UART_1_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1273
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
                                           ; SOURCE LINE # 1276
0005 900000      R     MOV     DPTR,#UART_1_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0073
                                           ; SOURCE LINE # 1277
                                           ; SOURCE LINE # 1278
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1279
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1280
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1281
                                           ; SOURCE LINE # 1282
001F         ?C0073:
001F 22                RET     
             ; FUNCTION _UART_1_PutCRLF (END)

             ; FUNCTION UART_1_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1310
                                           ; SOURCE LINE # 1312
                                           ; SOURCE LINE # 1320
0000 120000      R     LCALL   UART_1_DisableTxInt
                                           ; SOURCE LINE # 1323
0003 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#UART_1_txBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D EE                MOV     A,R6
000E B50707            CJNE    A,AR7,?C0074
                                           ; SOURCE LINE # 1324
                                           ; SOURCE LINE # 1325
0011 900000      R     MOV     DPTR,#size
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1326
0016 803B              SJMP    ?C0075
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 49  

0018         ?C0074:
                                           ; SOURCE LINE # 1327
0018 900000      R     MOV     DPTR,#UART_1_txBufferWrite
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#UART_1_txBufferRead
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 EE                MOV     A,R6
0023 C3                CLR     C
0024 9F                SUBB    A,R7
0025 5015              JNC     ?C0076
                                           ; SOURCE LINE # 1328
                                           ; SOURCE LINE # 1329
0027 900000      R     MOV     DPTR,#UART_1_txBufferRead
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#UART_1_txBufferWrite
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 C3                CLR     C
0032 EE                MOV     A,R6
0033 9F                SUBB    A,R7
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#size
0038 EF                MOV     A,R7
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1330
003A 8017              SJMP    ?C0075
003C         ?C0076:
                                           ; SOURCE LINE # 1332
                                           ; SOURCE LINE # 1333
003C 900000      R     MOV     DPTR,#UART_1_txBufferRead
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 C3                CLR     C
0042 74FF              MOV     A,#0FFH
0044 9F                SUBB    A,R7
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0049 E0                MOVX    A,@DPTR
004A FE                MOV     R6,A
004B EF                MOV     A,R7
004C 2E                ADD     A,R6
004D FF                MOV     R7,A
004E 900000      R     MOV     DPTR,#size
0051 EF                MOV     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1334
0053         ?C0075:
                                           ; SOURCE LINE # 1338
0053 120000      R     LCALL   UART_1_EnableTxInt
                                           ; SOURCE LINE # 1362
0056 900000      R     MOV     DPTR,#size
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
                                           ; SOURCE LINE # 1363
005B         ?C0078:
005B 22                RET     
             ; FUNCTION UART_1_GetTxBufferSize (END)

             ; FUNCTION UART_1_ClearTxBuffer (BEGIN)
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 50  

                                           ; SOURCE LINE # 1396
                                           ; SOURCE LINE # 1397
                                           ; SOURCE LINE # 1401
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
0008 906495            MOV     DPTR,#06495H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1404
0013 906495            MOV     DPTR,#06495H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1406
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1413
0026 120000      R     LCALL   UART_1_DisableTxInt
                                           ; SOURCE LINE # 1416
0029 900000      R     MOV     DPTR,#UART_1_txBufferRead
002C E4                CLR     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1417
002E 900000      R     MOV     DPTR,#UART_1_txBufferWrite
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1421
0033 120000      R     LCALL   UART_1_EnableTxInt
                                           ; SOURCE LINE # 1425
0036 22                RET     
             ; FUNCTION UART_1_ClearTxBuffer (END)

             ; FUNCTION _UART_1_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1485
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1486
                                           ; SOURCE LINE # 1489
0005 900000      R     MOV     DPTR,#UART_1_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0093
                                           ; SOURCE LINE # 1490
                                           ; SOURCE LINE # 1533
0010 900000      R     MOV     DPTR,#retMode
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 51  

0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0082
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7028              JNZ     ?C0081
0022         ?C0082:
                                           ; SOURCE LINE # 1535
                                           ; SOURCE LINE # 1544
0022 906436            MOV     DPTR,#06436H
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#tx_period
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1545
002C 906436            MOV     DPTR,#06436H
002F 7467              MOV     A,#067H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1552
0032 906445            MOV     DPTR,#06445H
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
0037         ?C0085:
                                           ; SOURCE LINE # 1555
                                           ; SOURCE LINE # 1556
0037 906466            MOV     DPTR,#06466H
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#tmpStat
003F EF                MOV     A,R7
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1557
0041 900000      R     MOV     DPTR,#tmpStat
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 20E1ED            JB      ACC.1,?C0085
                                           ; SOURCE LINE # 1558
004A         ?C0081:
                                           ; SOURCE LINE # 1560
004A 900000      R     MOV     DPTR,#retMode
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
0050 6401              XRL     A,#01H
0052 6009              JZ      ?C0090
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A B40316            CJNE    A,#03H,?C0086
                                           ; SOURCE LINE # 1562
005D         ?C0090:
                                           ; SOURCE LINE # 1564
                                           ; SOURCE LINE # 1565
005D 906466            MOV     DPTR,#06466H
0060 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 52  

0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#tmpStat
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1566
0067 900000      R     MOV     DPTR,#tmpStat
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D F4                CPL     A
006E FF                MOV     R7,A
006F EF                MOV     A,R7
0070 20E0EA            JB      ACC.0,?C0090
                                           ; SOURCE LINE # 1567
0073         ?C0086:
                                           ; SOURCE LINE # 1569
0073 900000      R     MOV     DPTR,#retMode
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 6401              XRL     A,#01H
007B 6013              JZ      ?C0092
007D 900000      R     MOV     DPTR,#retMode
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 6402              XRL     A,#02H
0085 6009              JZ      ?C0092
0087 900000      R     MOV     DPTR,#retMode
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C EF                MOV     A,R7
008D B4030A            CJNE    A,#03H,?C0093
0090         ?C0092:
                                           ; SOURCE LINE # 1572
                                           ; SOURCE LINE # 1575
0090 900000      R     MOV     DPTR,#tx_period
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 906436            MOV     DPTR,#06436H
0098 EF                MOV     A,R7
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
                                           ; SOURCE LINE # 1587
                                           ; SOURCE LINE # 1588
009A         ?C0093:
009A 22                RET     
             ; FUNCTION _UART_1_SendBreak (END)

             ; FUNCTION _UART_1_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1606
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1607
                                           ; SOURCE LINE # 1609
                                           ; SOURCE LINE # 1610
                                           ; SOURCE LINE # 1615
0005         ?C0094:
                                           ; SOURCE LINE # 1617
                                           ; SOURCE LINE # 1622
                                           ; SOURCE LINE # 1623
C51 COMPILER V9.51   UART_1                                                                05/16/2014 17:11:39 PAGE 53  

0005         ?C0096:
0005 22                RET     
             ; FUNCTION _UART_1_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1670    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    518      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
