C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_2
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_2.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\UART_2.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_951\Debug\UART_2.lst) CD DB NOIP OT(2,S
                    -IZE) DF(DEBUG) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_951\Debug\UART_2.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_2.c
   3          * Version 2.30
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_2.h"
  18          #include "CyLib.h"
  19          #if(UART_2_INTERNAL_CLOCK_USED)
  20              #include "UART_2_IntClock.h"
  21          #endif /* End UART_2_INTERNAL_CLOCK_USED */
  22          
  23          
  24          /***************************************
  25          * Global data allocation
  26          ***************************************/
  27          
  28          uint8 UART_2_initVar = 0u;
  29          #if( UART_2_TX_ENABLED && (UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH))
  30              volatile uint8 UART_2_txBuffer[UART_2_TXBUFFERSIZE];
  31              volatile uint8 UART_2_txBufferRead = 0u;
  32              uint8 UART_2_txBufferWrite = 0u;
  33          #endif /* End UART_2_TX_ENABLED */
  34          #if( ( UART_2_RX_ENABLED || UART_2_HD_ENABLED ) && \
  35               (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH) )
                  volatile uint8 UART_2_rxBuffer[UART_2_RXBUFFERSIZE];
                  volatile uint8 UART_2_rxBufferRead = 0u;
                  volatile uint8 UART_2_rxBufferWrite = 0u;
                  volatile uint8 UART_2_rxBufferLoopDetect = 0u;
                  volatile uint8 UART_2_rxBufferOverflow = 0u;
                  #if (UART_2_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_2_rxAddressMode = UART_2_RXADDRESSMODE;
                      volatile uint8 UART_2_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */
              #endif /* End UART_2_RX_ENABLED */
  46          
  47          
  48          /*******************************************************************************
  49          * Function Name: UART_2_Start
  50          ********************************************************************************
  51          *
  52          * Summary:
  53          *  Initialize and Enable the UART component.
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 2   

  54          *  Enable the clock input to enable operation.
  55          *
  56          * Parameters:
  57          *  None.
  58          *
  59          * Return:
  60          *  None.
  61          *
  62          * Global variables:
  63          *  The UART_2_intiVar variable is used to indicate initial
  64          *  configuration of this component. The variable is initialized to zero (0u)
  65          *  and set to one (1u) the first time UART_Start() is called. This allows for
  66          *  component initialization without re-initialization in all subsequent calls
  67          *  to the UART_2_Start() routine.
  68          *
  69          * Reentrant:
  70          *  No.
  71          *
  72          *******************************************************************************/
  73          void UART_2_Start(void) 
  74          {
  75   1          /* If not Initialized then initialize all required hardware and software */
  76   1          if(UART_2_initVar == 0u)
  77   1          {
  78   2              UART_2_Init();
  79   2              UART_2_initVar = 1u;
  80   2          }
  81   1          UART_2_Enable();
  82   1      }
  83          
  84          
  85          /*******************************************************************************
  86          * Function Name: UART_2_Init
  87          ********************************************************************************
  88          *
  89          * Summary:
  90          *  Initialize component's parameters to the parameters set by user in the
  91          *  customizer of the component placed onto schematic. Usually called in
  92          *  UART_2_Start().
  93          *
  94          * Parameters:
  95          *  None.
  96          *
  97          * Return:
  98          *  None.
  99          *
 100          *******************************************************************************/
 101          void UART_2_Init(void) 
 102          {
 103   1          #if(UART_2_RX_ENABLED || UART_2_HD_ENABLED)
              
                      #if(UART_2_RX_INTERRUPT_ENABLED && (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH))
                          /* Set the RX Interrupt. */
                          (void)CyIntSetVector(UART_2_RX_VECT_NUM, &UART_2_RXISR);
                          CyIntSetPriority(UART_2_RX_VECT_NUM, UART_2_RX_PRIOR_NUM);
                      #endif /* End UART_2_RX_INTERRUPT_ENABLED */
              
                      #if (UART_2_RXHW_ADDRESS_ENABLED)
                          UART_2_SetRxAddressMode(UART_2_RXAddressMode);
                          UART_2_SetRxAddress1(UART_2_RXHWADDRESS1);
                          UART_2_SetRxAddress2(UART_2_RXHWADDRESS2);
                      #endif /* End UART_2_RXHW_ADDRESS_ENABLED */
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 3   

              
                      /* Init Count7 period */
                      UART_2_RXBITCTR_PERIOD_REG = UART_2_RXBITCTR_INIT;
                      /* Configure the Initial RX interrupt mask */
                      UART_2_RXSTATUS_MASK_REG  = UART_2_INIT_RX_INTERRUPTS_MASK;
                  #endif /* End UART_2_RX_ENABLED || UART_2_HD_ENABLED*/
 122   1      
 123   1          #if(UART_2_TX_ENABLED)
 124   1              #if(UART_2_TX_INTERRUPT_ENABLED && (UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH))
 125   1                  /* Set the TX Interrupt. */
 126   1                  (void)CyIntSetVector(UART_2_TX_VECT_NUM, &UART_2_TXISR);
 127   1                  CyIntSetPriority(UART_2_TX_VECT_NUM, UART_2_TX_PRIOR_NUM);
 128   1              #endif /* End UART_2_TX_INTERRUPT_ENABLED */
 129   1      
 130   1              /* Write Counter Value for TX Bit Clk Generator*/
 131   1              #if(UART_2_TXCLKGEN_DP)
 132   1                  UART_2_TXBITCLKGEN_CTR_REG = UART_2_BIT_CENTER;
 133   1                  UART_2_TXBITCLKTX_COMPLETE_REG = (UART_2_NUMBER_OF_DATA_BITS +
 134   1                              UART_2_NUMBER_OF_START_BIT) * UART_2_OVER_SAMPLE_COUNT;
 135   1              #else
                          UART_2_TXBITCTR_PERIOD_REG = ((UART_2_NUMBER_OF_DATA_BITS +
                                      UART_2_NUMBER_OF_START_BIT) * UART_2_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_2_TXCLKGEN_DP */
 139   1      
 140   1              /* Configure the Initial TX interrupt mask */
 141   1              #if(UART_2_TX_INTERRUPT_ENABLED && (UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH))
 142   1                  UART_2_TXSTATUS_MASK_REG = UART_2_TX_STS_FIFO_EMPTY;
 143   1              #else
                          UART_2_TXSTATUS_MASK_REG = UART_2_INIT_TX_INTERRUPTS_MASK;
                      #endif /*End UART_2_TX_INTERRUPT_ENABLED*/
 146   1      
 147   1          #endif /* End UART_2_TX_ENABLED */
 148   1      
 149   1          #if(UART_2_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_2_WriteControlRegister( \
                          (UART_2_ReadControlRegister() & (uint8)~UART_2_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_2_PARITY_TYPE << UART_2_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_2_PARITY_TYPE_SW */
 154   1      }
 155          
 156          
 157          /*******************************************************************************
 158          * Function Name: UART_2_Enable
 159          ********************************************************************************
 160          *
 161          * Summary:
 162          *  Enables the UART block operation
 163          *
 164          * Parameters:
 165          *  None.
 166          *
 167          * Return:
 168          *  None.
 169          *
 170          * Global Variables:
 171          *  UART_2_rxAddressDetected - set to initial state (0).
 172          *
 173          *******************************************************************************/
 174          void UART_2_Enable(void) 
 175          {
 176   1          uint8 enableInterrupts;
 177   1          enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 4   

 178   1      
 179   1          #if(UART_2_RX_ENABLED || UART_2_HD_ENABLED)
                      /*RX Counter (Count7) Enable */
                      UART_2_RXBITCTR_CONTROL_REG |= UART_2_CNTR_ENABLE;
                      /* Enable the RX Interrupt. */
                      UART_2_RXSTATUS_ACTL_REG  |= UART_2_INT_ENABLE;
                      #if(UART_2_RX_INTERRUPT_ENABLED && (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH))
                          CyIntEnable(UART_2_RX_VECT_NUM);
                          #if (UART_2_RXHW_ADDRESS_ENABLED)
                              UART_2_rxAddressDetected = 0u;
                          #endif /* End UART_2_RXHW_ADDRESS_ENABLED */
                      #endif /* End UART_2_RX_INTERRUPT_ENABLED */
                  #endif /* End UART_2_RX_ENABLED || UART_2_HD_ENABLED*/
 191   1      
 192   1          #if(UART_2_TX_ENABLED)
 193   1              /*TX Counter (DP/Count7) Enable */
 194   1              #if(!UART_2_TXCLKGEN_DP)
                          UART_2_TXBITCTR_CONTROL_REG |= UART_2_CNTR_ENABLE;
                      #endif /* End UART_2_TXCLKGEN_DP */
 197   1              /* Enable the TX Interrupt. */
 198   1              UART_2_TXSTATUS_ACTL_REG |= UART_2_INT_ENABLE;
 199   1              #if(UART_2_TX_INTERRUPT_ENABLED && (UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH))
 200   1                  CyIntEnable(UART_2_TX_VECT_NUM);
 201   1              #endif /* End UART_2_TX_INTERRUPT_ENABLED*/
 202   1           #endif /* End UART_2_TX_ENABLED */
 203   1      
 204   1          #if(UART_2_INTERNAL_CLOCK_USED)
 205   1              /* Enable the clock. */
 206   1              UART_2_IntClock_Start();
 207   1          #endif /* End UART_2_INTERNAL_CLOCK_USED */
 208   1      
 209   1          CyExitCriticalSection(enableInterrupts);
 210   1      }
 211          
 212          
 213          /*******************************************************************************
 214          * Function Name: UART_2_Stop
 215          ********************************************************************************
 216          *
 217          * Summary:
 218          *  Disable the UART component
 219          *
 220          * Parameters:
 221          *  None.
 222          *
 223          * Return:
 224          *  None.
 225          *
 226          *******************************************************************************/
 227          void UART_2_Stop(void) 
 228          {
 229   1          uint8 enableInterrupts;
 230   1          enableInterrupts = CyEnterCriticalSection();
 231   1      
 232   1          /* Write Bit Counter Disable */
 233   1          #if(UART_2_RX_ENABLED || UART_2_HD_ENABLED)
                      UART_2_RXBITCTR_CONTROL_REG &= (uint8)~UART_2_CNTR_ENABLE;
                  #endif /* End UART_2_RX_ENABLED */
 236   1      
 237   1          #if(UART_2_TX_ENABLED)
 238   1              #if(!UART_2_TXCLKGEN_DP)
                          UART_2_TXBITCTR_CONTROL_REG &= (uint8)~UART_2_CNTR_ENABLE;
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 5   

                      #endif /* End UART_2_TXCLKGEN_DP */
 241   1          #endif /* UART_2_TX_ENABLED */
 242   1      
 243   1          #if(UART_2_INTERNAL_CLOCK_USED)
 244   1              /* Disable the clock. */
 245   1              UART_2_IntClock_Stop();
 246   1          #endif /* End UART_2_INTERNAL_CLOCK_USED */
 247   1      
 248   1          /* Disable internal interrupt component */
 249   1          #if(UART_2_RX_ENABLED || UART_2_HD_ENABLED)
                      UART_2_RXSTATUS_ACTL_REG  &= (uint8)~UART_2_INT_ENABLE;
                      #if(UART_2_RX_INTERRUPT_ENABLED && (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH))
                          UART_2_DisableRxInt();
                      #endif /* End UART_2_RX_INTERRUPT_ENABLED */
                  #endif /* End UART_2_RX_ENABLED */
 255   1      
 256   1          #if(UART_2_TX_ENABLED)
 257   1              UART_2_TXSTATUS_ACTL_REG &= (uint8)~UART_2_INT_ENABLE;
 258   1              #if(UART_2_TX_INTERRUPT_ENABLED && (UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH))
 259   1                  UART_2_DisableTxInt();
 260   1              #endif /* End UART_2_TX_INTERRUPT_ENABLED */
 261   1          #endif /* End UART_2_TX_ENABLED */
 262   1      
 263   1          CyExitCriticalSection(enableInterrupts);
 264   1      }
 265          
 266          
 267          /*******************************************************************************
 268          * Function Name: UART_2_ReadControlRegister
 269          ********************************************************************************
 270          *
 271          * Summary:
 272          *  Read the current state of the control register
 273          *
 274          * Parameters:
 275          *  None.
 276          *
 277          * Return:
 278          *  Current state of the control register.
 279          *
 280          *******************************************************************************/
 281          uint8 UART_2_ReadControlRegister(void) 
 282          {
 283   1          #if( UART_2_CONTROL_REG_REMOVED )
 284   1              return(0u);
 285   1          #else
                      return(UART_2_CONTROL_REG);
                  #endif /* End UART_2_CONTROL_REG_REMOVED */
 288   1      }
 289          
 290          
 291          /*******************************************************************************
 292          * Function Name: UART_2_WriteControlRegister
 293          ********************************************************************************
 294          *
 295          * Summary:
 296          *  Writes an 8-bit value into the control register
 297          *
 298          * Parameters:
 299          *  control:  control register value
 300          *
 301          * Return:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 6   

 302          *  None.
 303          *
 304          *******************************************************************************/
 305          void  UART_2_WriteControlRegister(uint8 control) 
 306          {
 307   1          #if( UART_2_CONTROL_REG_REMOVED )
 308   1              if(control != 0u) { }      /* release compiler warning */
 309   1          #else
                     UART_2_CONTROL_REG = control;
                  #endif /* End UART_2_CONTROL_REG_REMOVED */
 312   1      }
 313          
 314          
 315          #if(UART_2_RX_ENABLED || UART_2_HD_ENABLED)
              
                  #if(UART_2_RX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: UART_2_EnableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_2_EnableRxInt(void) 
                      {
                          CyIntEnable(UART_2_RX_VECT_NUM);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: UART_2_DisableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_2_DisableRxInt(void) 
                      {
                          CyIntDisable(UART_2_RX_VECT_NUM);
                      }
              
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 7   

                  #endif /* UART_2_RX_INTERRUPT_ENABLED */
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_SetRxInterruptMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configure which status bits trigger an interrupt event
                  *
                  * Parameters:
                  *  IntSrc:  An or'd combination of the desired status bit masks (defined in
                  *           the header file)
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Enables the output of specific status bits to the interrupt controller
                  *
                  *******************************************************************************/
                  void UART_2_SetRxInterruptMode(uint8 intSrc) 
                  {
                      UART_2_RXSTATUS_MASK_REG  = intSrc;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_ReadRxData
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns data in RX Data register without checking status register to
                  *  determine if data is valid
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Received data from RX register
                  *
                  * Global Variables:
                  *  UART_2_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_2_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     checked to identify new data.
                  *  UART_2_rxBufferRead - cyclic index for read from rxBuffer,
                  *     incremented after each byte has been read from buffer.
                  *  UART_2_rxBufferLoopDetect - creared if loop condition was detected
                  *     in RX ISR.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_2_ReadRxData(void) 
                  {
                      uint8 rxData;
              
                      #if(UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 8   

                          /* Disable Rx interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_DisableRxInt();
                          #endif /* UART_2_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = UART_2_rxBufferRead;
                          loc_rxBufferWrite = UART_2_rxBufferWrite;
              
                          if( (UART_2_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = UART_2_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
              
                              if(loc_rxBufferRead >= UART_2_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              UART_2_rxBufferRead = loc_rxBufferRead;
              
                              if(UART_2_rxBufferLoopDetect != 0u )
                              {
                                  UART_2_rxBufferLoopDetect = 0u;
                                  #if( (UART_2_RX_INTERRUPT_ENABLED) && (UART_2_FLOW_CONTROL != 0u) && \
                                       (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_2_HD_ENABLED )
                                          if((UART_2_CONTROL_REG & UART_2_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only in RX
                                              *  configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              UART_2_RXSTATUS_MASK_REG  |= UART_2_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_2_RXSTATUS_MASK_REG  |= UART_2_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_2_HD_ENABLED */
                                  #endif /* UART_2_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
                          }
                          else
                          {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                              rxData = UART_2_RXDATA_REG;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_EnableRxInt();
                          #endif /* End UART_2_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                          /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                          rxData = UART_2_RXDATA_REG;
              
                      #endif /* UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                      return(rxData);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_ReadRxStatus
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 9   

                  ********************************************************************************
                  *
                  * Summary:
                  *  Read the current state of the status register
                  *  And detect software buffer overflow.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Current state of the status register.
                  *
                  * Global Variables:
                  *  UART_2_rxBufferOverflow - used to indicate overload condition.
                  *   It set to one in RX interrupt when there isn?t free space in
                  *   UART_2_rxBufferRead to write new data. This condition returned
                  *   and cleared to zero by this API as an
                  *   UART_2_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
                  *   bits.
                  *
                  *******************************************************************************/
                  uint8 UART_2_ReadRxStatus(void) 
                  {
                      uint8 status;
              
                      status = UART_2_RXSTATUS_REG & UART_2_RX_HW_MASK;
              
                      #if(UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH)
                          if( UART_2_rxBufferOverflow != 0u )
                          {
                              status |= UART_2_RX_STS_SOFT_BUFF_OVER;
                              UART_2_rxBufferOverflow = 0u;
                          }
                      #endif /* UART_2_RXBUFFERSIZE */
              
                      return(status);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_GetChar
                  ********************************************************************************
                  *
                  * Summary:
                  *  Reads UART RX buffer immediately, if data is not available or an error
                  *  condition exists, zero is returned; otherwise, character is read and
                  *  returned.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
                  *  A returned zero signifies an error condition or no data available.
                  *
                  * Global Variables:
                  *  UART_2_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_2_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     checked to identify new data.
                  *  UART_2_rxBufferRead - cyclic index for read from rxBuffer,
                  *     incremented after each byte has been read from buffer.
                  *  UART_2_rxBufferLoopDetect - creared if loop condition was detected
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 10  

                  *     in RX ISR.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_2_GetChar(void) 
                  {
                      uint8 rxData = 0u;
                      uint8 rxStatus;
              
                      #if(UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
                          /* Disable Rx interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_DisableRxInt();
                          #endif /* UART_2_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = UART_2_rxBufferRead;
                          loc_rxBufferWrite = UART_2_rxBufferWrite;
              
                          if( (UART_2_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = UART_2_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
                              if(loc_rxBufferRead >= UART_2_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              UART_2_rxBufferRead = loc_rxBufferRead;
              
                              if(UART_2_rxBufferLoopDetect > 0u )
                              {
                                  UART_2_rxBufferLoopDetect = 0u;
                                  #if( (UART_2_RX_INTERRUPT_ENABLED) && (UART_2_FLOW_CONTROL != 0u) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_2_HD_ENABLED )
                                          if((UART_2_CONTROL_REG & UART_2_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only if
                                              *  RX configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              UART_2_RXSTATUS_MASK_REG  |= UART_2_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_2_RXSTATUS_MASK_REG  |= UART_2_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_2_HD_ENABLED */
                                  #endif /* UART_2_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
              
                          }
                          else
                          {   rxStatus = UART_2_RXSTATUS_REG;
                              if((rxStatus & UART_2_RX_STS_FIFO_NOTEMPTY) != 0u)
                              {   /* Read received data from FIFO*/
                                  rxData = UART_2_RXDATA_REG;
                                  /*Check status on error*/
                                  if((rxStatus & (UART_2_RX_STS_BREAK | UART_2_RX_STS_PAR_ERROR |
                                                 UART_2_RX_STS_STOP_ERROR | UART_2_RX_STS_OVERRUN)) != 0u)
                                  {
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 11  

                                      rxData = 0u;
                                  }
                              }
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_EnableRxInt();
                          #endif /* UART_2_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                          rxStatus =UART_2_RXSTATUS_REG;
                          if((rxStatus & UART_2_RX_STS_FIFO_NOTEMPTY) != 0u)
                          {   /* Read received data from FIFO*/
                              rxData = UART_2_RXDATA_REG;
                              /*Check status on error*/
                              if((rxStatus & (UART_2_RX_STS_BREAK | UART_2_RX_STS_PAR_ERROR |
                                             UART_2_RX_STS_STOP_ERROR | UART_2_RX_STS_OVERRUN)) != 0u)
                              {
                                  rxData = 0u;
                              }
                          }
                      #endif /* UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                      return(rxData);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_GetByte
                  ********************************************************************************
                  *
                  * Summary:
                  *  Grab the next available byte of data from the recieve FIFO
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  MSB contains Status Register and LSB contains UART RX data
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint16 UART_2_GetByte(void) 
                  {
                      return ( ((uint16)UART_2_ReadRxStatus() << 8u) | UART_2_ReadRxData() );
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_GetRxBufferSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Determine the amount of bytes left in the RX buffer and return the count in
                  *  bytes
                  *
                  * Parameters:
                  *  None.
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 12  

                  *
                  * Return:
                  *  uint8: Integer count of the number of bytes left
                  *  in the RX buffer
                  *
                  * Global Variables:
                  *  UART_2_rxBufferWrite - used to calculate left bytes.
                  *  UART_2_rxBufferRead - used to calculate left bytes.
                  *  UART_2_rxBufferLoopDetect - checked to decide left bytes amount.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to find out how full the RX Buffer is.
                  *
                  *******************************************************************************/
                  uint8 UART_2_GetRxBufferSize(void)
                                                                          
                  {
                      uint8 size;
              
                      #if(UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH)
              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_DisableRxInt();
                          #endif /* UART_2_RX_INTERRUPT_ENABLED */
              
                          if(UART_2_rxBufferRead == UART_2_rxBufferWrite)
                          {
                              if(UART_2_rxBufferLoopDetect > 0u)
                              {
                                  size = UART_2_RXBUFFERSIZE;
                              }
                              else
                              {
                                  size = 0u;
                              }
                          }
                          else if(UART_2_rxBufferRead < UART_2_rxBufferWrite)
                          {
                              size = (UART_2_rxBufferWrite - UART_2_rxBufferRead);
                          }
                          else
                          {
                              size = (UART_2_RXBUFFERSIZE - UART_2_rxBufferRead) + UART_2_rxBufferWrite;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_EnableRxInt();
                          #endif /* End UART_2_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                          /* We can only know if there is data in the fifo. */
                          size = ((UART_2_RXSTATUS_REG & UART_2_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
              
                      #endif /* End UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 13  

                      return(size);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_ClearRxBuffer
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
                  *  Clears hardware RX FIFO.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_2_rxBufferWrite - cleared to zero.
                  *  UART_2_rxBufferRead - cleared to zero.
                  *  UART_2_rxBufferLoopDetect - cleared to zero.
                  *  UART_2_rxBufferOverflow - cleared to zero.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Setting the pointers to zero makes the system believe there is no data to
                  *  read and writing will resume at address 0 overwriting any data that may
                  *  have remained in the RAM.
                  *
                  * Side Effects:
                  *  Any received data not read from the RAM or FIFO buffer will be lost.
                  *******************************************************************************/
                  void UART_2_ClearRxBuffer(void) 
                  {
                      uint8 enableInterrupts;
              
                      /* clear the HW FIFO */
                      /* Enter critical section */
                      enableInterrupts = CyEnterCriticalSection();
                      UART_2_RXDATA_AUX_CTL_REG |=  UART_2_RX_FIFO_CLR;
                      UART_2_RXDATA_AUX_CTL_REG &= (uint8)~UART_2_RX_FIFO_CLR;
                      /* Exit critical section */
                      CyExitCriticalSection(enableInterrupts);
              
                      #if(UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH)
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_DisableRxInt();
                          #endif /* End UART_2_RX_INTERRUPT_ENABLED */
              
                          UART_2_rxBufferRead = 0u;
                          UART_2_rxBufferWrite = 0u;
                          UART_2_rxBufferLoopDetect = 0u;
                          UART_2_rxBufferOverflow = 0u;
              
                          /* Enable Rx interrupt. */
                          #if(UART_2_RX_INTERRUPT_ENABLED)
                              UART_2_EnableRxInt();
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 14  

                          #endif /* End UART_2_RX_INTERRUPT_ENABLED */
                      #endif /* End UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_SetRxAddressMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Set the receive addressing mode
                  *
                  * Parameters:
                  *  addressMode: Enumerated value indicating the mode of RX addressing
                  *  UART_2__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
                  *                                               detection
                  *  UART_2__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
                  *                                               address detection
                  *  UART_2__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
                  *                                               detection
                  *  UART_2__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
                  *                                               address detection
                  *  UART_2__B_UART__AM_NONE - No address detection
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_2_rxAddressMode - the parameter stored in this variable for
                  *   the farther usage in RX ISR.
                  *  UART_2_rxAddressDetected - set to initial state (0).
                  *
                  *******************************************************************************/
                  void UART_2_SetRxAddressMode(uint8 addressMode)
                                                                      
                  {
                      #if(UART_2_RXHW_ADDRESS_ENABLED)
                          #if(UART_2_CONTROL_REG_REMOVED)
                              if(addressMode != 0u) { }     /* release compiler warning */
                          #else /* UART_2_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_2_CONTROL_REG & (uint8)~UART_2_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_2_CTRL_RXADDR_MODE0_SHIFT);
                              UART_2_CONTROL_REG = tmpCtrl;
                              #if(UART_2_RX_INTERRUPT_ENABLED && \
                                 (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH) )
                                  UART_2_rxAddressMode = addressMode;
                                  UART_2_rxAddressDetected = 0u;
                              #endif /* End UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH*/
                          #endif /* End UART_2_CONTROL_REG_REMOVED */
                      #else /* UART_2_RXHW_ADDRESS_ENABLED */
                          if(addressMode != 0u) { }     /* release compiler warning */
                      #endif /* End UART_2_RXHW_ADDRESS_ENABLED */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_SetRxAddress1
                  ********************************************************************************
                  *
                  * Summary:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 15  

                  *  Set the first hardware address compare value
                  *
                  * Parameters:
                  *  address
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_2_SetRxAddress1(uint8 address) 
              
                  {
                      UART_2_RXADDRESS1_REG = address;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_SetRxAddress2
                  ********************************************************************************
                  *
                  * Summary:
                  *  Set the second hardware address compare value
                  *
                  * Parameters:
                  *  address
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_2_SetRxAddress2(uint8 address) 
                  {
                      UART_2_RXADDRESS2_REG = address;
                  }
              
              #endif  /* UART_2_RX_ENABLED || UART_2_HD_ENABLED*/
 896          
 897          
 898          #if( (UART_2_TX_ENABLED) || (UART_2_HD_ENABLED) )
 899          
 900              #if(UART_2_TX_INTERRUPT_ENABLED)
 901          
 902                  /*******************************************************************************
 903                  * Function Name: UART_2_EnableTxInt
 904                  ********************************************************************************
 905                  *
 906                  * Summary:
 907                  *  Enable TX interrupt generation
 908                  *
 909                  * Parameters:
 910                  *  None.
 911                  *
 912                  * Return:
 913                  *  None.
 914                  *
 915                  * Theory:
 916                  *  Enable the interrupt output -or- the interrupt component itself
 917                  *
 918                  *******************************************************************************/
 919                  void UART_2_EnableTxInt(void) 
 920                  {
 921   1                  CyIntEnable(UART_2_TX_VECT_NUM);
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 16  

 922   1              }
 923          
 924          
 925                  /*******************************************************************************
 926                  * Function Name: UART_2_DisableTxInt
 927                  ********************************************************************************
 928                  *
 929                  * Summary:
 930                  *  Disable TX interrupt generation
 931                  *
 932                  * Parameters:
 933                  *  None.
 934                  *
 935                  * Return:
 936                  *  None.
 937                  *
 938                  * Theory:
 939                  *  Disable the interrupt output -or- the interrupt component itself
 940                  *
 941                  *******************************************************************************/
 942                  void UART_2_DisableTxInt(void) 
 943                  {
 944   1                  CyIntDisable(UART_2_TX_VECT_NUM);
 945   1              }
 946          
 947              #endif /* UART_2_TX_INTERRUPT_ENABLED */
 948          
 949          
 950              /*******************************************************************************
 951              * Function Name: UART_2_SetTxInterruptMode
 952              ********************************************************************************
 953              *
 954              * Summary:
 955              *  Configure which status bits trigger an interrupt event
 956              *
 957              * Parameters:
 958              *  intSrc: An or'd combination of the desired status bit masks (defined in
 959              *          the header file)
 960              *
 961              * Return:
 962              *  None.
 963              *
 964              * Theory:
 965              *  Enables the output of specific status bits to the interrupt controller
 966              *
 967              *******************************************************************************/
 968              void UART_2_SetTxInterruptMode(uint8 intSrc) 
 969              {
 970   1              UART_2_TXSTATUS_MASK_REG = intSrc;
 971   1          }
 972          
 973          
 974              /*******************************************************************************
 975              * Function Name: UART_2_WriteTxData
 976              ********************************************************************************
 977              *
 978              * Summary:
 979              *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980              *  bus is available. WriteTxData sends a byte without checking for buffer room
 981              *  or status. It is up to the user to separately check status.
 982              *
 983              * Parameters:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 17  

 984              *  TXDataByte: byte of data to place in the transmit FIFO
 985              *
 986              * Return:
 987              * void
 988              *
 989              * Global Variables:
 990              *  UART_2_txBuffer - RAM buffer pointer for save data for transmission
 991              *  UART_2_txBufferWrite - cyclic index for write to txBuffer,
 992              *    incremented after each byte saved to buffer.
 993              *  UART_2_txBufferRead - cyclic index for read from txBuffer,
 994              *    checked to identify the condition to write to FIFO directly or to TX buffer
 995              *  UART_2_initVar - checked to identify that the component has been
 996              *    initialized.
 997              *
 998              * Reentrant:
 999              *  No.
1000              *
1001              *******************************************************************************/
1002              void UART_2_WriteTxData(uint8 txDataByte) 
1003              {
1004   1              /* If not Initialized then skip this function*/
1005   1              if(UART_2_initVar != 0u)
1006   1              {
1007   2                  #if(UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH)
1008   2      
1009   2                      /* Disable Tx interrupt. */
1010   2                      /* Protect variables that could change on interrupt. */
1011   2                      #if(UART_2_TX_INTERRUPT_ENABLED)
1012   2                          UART_2_DisableTxInt();
1013   2                      #endif /* End UART_2_TX_INTERRUPT_ENABLED */
1014   2      
1015   2                      if( (UART_2_txBufferRead == UART_2_txBufferWrite) &&
1016   2                          ((UART_2_TXSTATUS_REG & UART_2_TX_STS_FIFO_FULL) == 0u) )
1017   2                      {
1018   3                          /* Add directly to the FIFO. */
1019   3                          UART_2_TXDATA_REG = txDataByte;
1020   3                      }
1021   2                      else
1022   2                      {
1023   3                          if(UART_2_txBufferWrite >= UART_2_TXBUFFERSIZE)
1024   3                          {
1025   4                              UART_2_txBufferWrite = 0u;
1026   4                          }
1027   3      
1028   3                          UART_2_txBuffer[UART_2_txBufferWrite] = txDataByte;
1029   3      
1030   3                          /* Add to the software buffer. */
1031   3                          UART_2_txBufferWrite++;
1032   3      
1033   3                      }
1034   2      
1035   2                      /* Enable Tx interrupt. */
1036   2                      #if(UART_2_TX_INTERRUPT_ENABLED)
1037   2                          UART_2_EnableTxInt();
1038   2                      #endif /* End UART_2_TX_INTERRUPT_ENABLED */
1039   2      
1040   2                  #else /* UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                              /* Add directly to the FIFO. */
                              UART_2_TXDATA_REG = txDataByte;
              
                          #endif /* End UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 18  

1046   2              }
1047   1          }
1048          
1049          
1050              /*******************************************************************************
1051              * Function Name: UART_2_ReadTxStatus
1052              ********************************************************************************
1053              *
1054              * Summary:
1055              *  Read the status register for the component
1056              *
1057              * Parameters:
1058              *  None.
1059              *
1060              * Return:
1061              *  Contents of the status register
1062              *
1063              * Theory:
1064              *  This function reads the status register which is clear on read. It is up to
1065              *  the user to handle all bits in this return value accordingly, even if the bit
1066              *  was not enabled as an interrupt source the event happened and must be handled
1067              *  accordingly.
1068              *
1069              *******************************************************************************/
1070              uint8 UART_2_ReadTxStatus(void) 
1071              {
1072   1              return(UART_2_TXSTATUS_REG);
1073   1          }
1074          
1075          
1076              /*******************************************************************************
1077              * Function Name: UART_2_PutChar
1078              ********************************************************************************
1079              *
1080              * Summary:
1081              *  Wait to send byte until TX register or buffer has room.
1082              *
1083              * Parameters:
1084              *  txDataByte: The 8-bit data value to send across the UART.
1085              *
1086              * Return:
1087              *  None.
1088              *
1089              * Global Variables:
1090              *  UART_2_txBuffer - RAM buffer pointer for save data for transmission
1091              *  UART_2_txBufferWrite - cyclic index for write to txBuffer,
1092              *     checked to identify free space in txBuffer and incremented after each byte
1093              *     saved to buffer.
1094              *  UART_2_txBufferRead - cyclic index for read from txBuffer,
1095              *     checked to identify free space in txBuffer.
1096              *  UART_2_initVar - checked to identify that the component has been
1097              *     initialized.
1098              *
1099              * Reentrant:
1100              *  No.
1101              *
1102              * Theory:
1103              *  Allows the user to transmit any byte of data in a single transfer
1104              *
1105              *******************************************************************************/
1106              void UART_2_PutChar(uint8 txDataByte) 
1107              {
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 19  

1108   1                  #if(UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH)
1109   1                      /* The temporary output pointer is used since it takes two instructions
1110   1                      *  to increment with a wrap, and we can't risk doing that with the real
1111   1                      *  pointer and getting an interrupt in between instructions.
1112   1                      */
1113   1                      uint8 loc_txBufferWrite;
1114   1                      uint8 loc_txBufferRead;
1115   1      
1116   1                      do{
1117   2                          /* Block if software buffer is full, so we don't overwrite. */
1118   2                          #if ((UART_2_TXBUFFERSIZE > UART_2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Disable TX interrupt to protect variables that could change on interrupt */
                                      CyIntDisable(UART_2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1122   2                          loc_txBufferWrite = UART_2_txBufferWrite;
1123   2                          loc_txBufferRead = UART_2_txBufferRead;
1124   2                          #if ((UART_2_TXBUFFERSIZE > UART_2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Enable interrupt to continue transmission */
                                      CyIntEnable(UART_2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1128   2                      }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBufferRead -
             - 1u)) :
1129   1                                              ((loc_txBufferWrite - loc_txBufferRead) ==
1130   1                                              (uint8)(UART_2_TXBUFFERSIZE - 1u)) );
1131   1      
1132   1                      if( (loc_txBufferRead == loc_txBufferWrite) &&
1133   1                          ((UART_2_TXSTATUS_REG & UART_2_TX_STS_FIFO_FULL) == 0u) )
1134   1                      {
1135   2                          /* Add directly to the FIFO. */
1136   2                          UART_2_TXDATA_REG = txDataByte;
1137   2                      }
1138   1                      else
1139   1                      {
1140   2                          if(loc_txBufferWrite >= UART_2_TXBUFFERSIZE)
1141   2                          {
1142   3                              loc_txBufferWrite = 0u;
1143   3                          }
1144   2                          /* Add to the software buffer. */
1145   2                          UART_2_txBuffer[loc_txBufferWrite] = txDataByte;
1146   2                          loc_txBufferWrite++;
1147   2      
1148   2                          /* Finally, update the real output pointer */
1149   2                          #if ((UART_2_TXBUFFERSIZE > UART_2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntDisable(UART_2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1152   2                          UART_2_txBufferWrite = loc_txBufferWrite;
1153   2                          #if ((UART_2_TXBUFFERSIZE > UART_2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntEnable(UART_2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
1156   2                      }
1157   1      
1158   1                  #else /* UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                              while((UART_2_TXSTATUS_REG & UART_2_TX_STS_FIFO_FULL) != 0u)
                              {
                                  ; /* Wait for room in the FIFO. */
                              }
              
                              /* Add directly to the FIFO. */
                              UART_2_TXDATA_REG = txDataByte;
              
                          #endif /* End UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 20  

1169   1          }
1170          
1171          
1172              /*******************************************************************************
1173              * Function Name: UART_2_PutString
1174              ********************************************************************************
1175              *
1176              * Summary:
1177              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178              *
1179              * Parameters:
1180              *  string: char pointer to character string of Data to Send.
1181              *
1182              * Return:
1183              *  None.
1184              *
1185              * Global Variables:
1186              *  UART_2_initVar - checked to identify that the component has been
1187              *     initialized.
1188              *
1189              * Reentrant:
1190              *  No.
1191              *
1192              * Theory:
1193              *  This function will block if there is not enough memory to place the whole
1194              *  string, it will block until the entire string has been written to the
1195              *  transmit buffer.
1196              *
1197              *******************************************************************************/
1198              void UART_2_PutString(const char8 string[]) 
1199              {
1200   1              uint16 buf_index = 0u;
1201   1              /* If not Initialized then skip this function*/
1202   1              if(UART_2_initVar != 0u)
1203   1              {
1204   2                  /* This is a blocking function, it will not exit until all data is sent*/
1205   2                  while(string[buf_index] != (char8)0)
1206   2                  {
1207   3                      UART_2_PutChar((uint8)string[buf_index]);
1208   3                      buf_index++;
1209   3                  }
1210   2              }
1211   1          }
1212          
1213          
1214              /*******************************************************************************
1215              * Function Name: UART_2_PutArray
1216              ********************************************************************************
1217              *
1218              * Summary:
1219              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220              *
1221              * Parameters:
1222              *  string: Address of the memory array residing in RAM or ROM.
1223              *  byteCount: Number of Bytes to be transmitted.
1224              *
1225              * Return:
1226              *  None.
1227              *
1228              * Global Variables:
1229              *  UART_2_initVar - checked to identify that the component has been
1230              *     initialized.
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 21  

1231              *
1232              * Reentrant:
1233              *  No.
1234              *
1235              *******************************************************************************/
1236              void UART_2_PutArray(const uint8 string[], uint8 byteCount)
1237                                                                              
1238              {
1239   1              uint8 buf_index = 0u;
1240   1              /* If not Initialized then skip this function*/
1241   1              if(UART_2_initVar != 0u)
1242   1              {
1243   2                  do
1244   2                  {
1245   3                      UART_2_PutChar(string[buf_index]);
1246   3                      buf_index++;
1247   3                  }while(buf_index < byteCount);
1248   2              }
1249   1          }
1250          
1251          
1252              /*******************************************************************************
1253              * Function Name: UART_2_PutCRLF
1254              ********************************************************************************
1255              *
1256              * Summary:
1257              *  Write a character and then carriage return and line feed.
1258              *
1259              * Parameters:
1260              *  txDataByte: uint8 Character to send.
1261              *
1262              * Return:
1263              *  None.
1264              *
1265              * Global Variables:
1266              *  UART_2_initVar - checked to identify that the component has been
1267              *     initialized.
1268              *
1269              * Reentrant:
1270              *  No.
1271              *
1272              *******************************************************************************/
1273              void UART_2_PutCRLF(uint8 txDataByte) 
1274              {
1275   1              /* If not Initialized then skip this function*/
1276   1              if(UART_2_initVar != 0u)
1277   1              {
1278   2                  UART_2_PutChar(txDataByte);
1279   2                  UART_2_PutChar(0x0Du);
1280   2                  UART_2_PutChar(0x0Au);
1281   2              }
1282   1          }
1283          
1284          
1285              /*******************************************************************************
1286              * Function Name: UART_2_GetTxBufferSize
1287              ********************************************************************************
1288              *
1289              * Summary:
1290              *  Determine the amount of space left in the TX buffer and return the count in
1291              *  bytes
1292              *
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 22  

1293              * Parameters:
1294              *  None.
1295              *
1296              * Return:
1297              *  Integer count of the number of bytes left in the TX buffer
1298              *
1299              * Global Variables:
1300              *  UART_2_txBufferWrite - used to calculate left space.
1301              *  UART_2_txBufferRead - used to calculate left space.
1302              *
1303              * Reentrant:
1304              *  No.
1305              *
1306              * Theory:
1307              *  Allows the user to find out how full the TX Buffer is.
1308              *
1309              *******************************************************************************/
1310              uint8 UART_2_GetTxBufferSize(void)
1311                                                                      
1312              {
1313   1              uint8 size;
1314   1      
1315   1              #if(UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH)
1316   1      
1317   1                  /* Disable Tx interrupt. */
1318   1                  /* Protect variables that could change on interrupt. */
1319   1                  #if(UART_2_TX_INTERRUPT_ENABLED)
1320   1                      UART_2_DisableTxInt();
1321   1                  #endif /* End UART_2_TX_INTERRUPT_ENABLED */
1322   1      
1323   1                  if(UART_2_txBufferRead == UART_2_txBufferWrite)
1324   1                  {
1325   2                      size = 0u;
1326   2                  }
1327   1                  else if(UART_2_txBufferRead < UART_2_txBufferWrite)
1328   1                  {
1329   2                      size = (UART_2_txBufferWrite - UART_2_txBufferRead);
1330   2                  }
1331   1                  else
1332   1                  {
1333   2                      size = (UART_2_TXBUFFERSIZE - UART_2_txBufferRead) + UART_2_txBufferWrite;
1334   2                  }
1335   1      
1336   1                  /* Enable Tx interrupt. */
1337   1                  #if(UART_2_TX_INTERRUPT_ENABLED)
1338   1                      UART_2_EnableTxInt();
1339   1                  #endif /* End UART_2_TX_INTERRUPT_ENABLED */
1340   1      
1341   1              #else /* UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
              
                          size = UART_2_TXSTATUS_REG;
              
                          /* Is the fifo is full. */
                          if((size & UART_2_TX_STS_FIFO_FULL) != 0u)
                          {
                              size = UART_2_FIFO_LENGTH;
                          }
                          else if((size & UART_2_TX_STS_FIFO_EMPTY) != 0u)
                          {
                              size = 0u;
                          }
                          else
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 23  

                          {
                              /* We only know there is data in the fifo. */
                              size = 1u;
                          }
              
                      #endif /* End UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
1361   1      
1362   1              return(size);
1363   1          }
1364          
1365          
1366              /*******************************************************************************
1367              * Function Name: UART_2_ClearTxBuffer
1368              ********************************************************************************
1369              *
1370              * Summary:
1371              *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372              *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373              *
1374              * Parameters:
1375              *  None.
1376              *
1377              * Return:
1378              *  None.
1379              *
1380              * Global Variables:
1381              *  UART_2_txBufferWrite - cleared to zero.
1382              *  UART_2_txBufferRead - cleared to zero.
1383              *
1384              * Reentrant:
1385              *  No.
1386              *
1387              * Theory:
1388              *  Setting the pointers to zero makes the system believe there is no data to
1389              *  read and writing will resume at address 0 overwriting any data that may have
1390              *  remained in the RAM.
1391              *
1392              * Side Effects:
1393              *  Any received data not read from the RAM buffer will be lost when overwritten.
1394              *
1395              *******************************************************************************/
1396              void UART_2_ClearTxBuffer(void) 
1397              {
1398   1              uint8 enableInterrupts;
1399   1      
1400   1              /* Enter critical section */
1401   1              enableInterrupts = CyEnterCriticalSection();
1402   1              /* clear the HW FIFO */
1403   1              UART_2_TXDATA_AUX_CTL_REG |=  UART_2_TX_FIFO_CLR;
1404   1              UART_2_TXDATA_AUX_CTL_REG &= (uint8)~UART_2_TX_FIFO_CLR;
1405   1              /* Exit critical section */
1406   1              CyExitCriticalSection(enableInterrupts);
1407   1      
1408   1              #if(UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH)
1409   1      
1410   1                  /* Disable Tx interrupt. */
1411   1                  /* Protect variables that could change on interrupt. */
1412   1                  #if(UART_2_TX_INTERRUPT_ENABLED)
1413   1                      UART_2_DisableTxInt();
1414   1                  #endif /* End UART_2_TX_INTERRUPT_ENABLED */
1415   1      
1416   1                  UART_2_txBufferRead = 0u;
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 24  

1417   1                  UART_2_txBufferWrite = 0u;
1418   1      
1419   1                  /* Enable Tx interrupt. */
1420   1                  #if(UART_2_TX_INTERRUPT_ENABLED)
1421   1                      UART_2_EnableTxInt();
1422   1                  #endif /* End UART_2_TX_INTERRUPT_ENABLED */
1423   1      
1424   1              #endif /* End UART_2_TXBUFFERSIZE > UART_2_FIFO_LENGTH */
1425   1          }
1426          
1427          
1428              /*******************************************************************************
1429              * Function Name: UART_2_SendBreak
1430              ********************************************************************************
1431              *
1432              * Summary:
1433              *  Write a Break command to the UART
1434              *
1435              * Parameters:
1436              *  uint8 retMode:  Wait mode,
1437              *   0 - Initialize registers for Break, sends the Break signal and return
1438              *       imediately.
1439              *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440              *       transmission mode then return.
1441              *   2 - Reinitialize registers to normal transmission mode then return.
1442              *   3 - both steps: 0 and 1
1443              *       init registers for Break, send Break signal
1444              *       wait until Break sending is complete, reinit registers to normal
1445              *       transmission mode then return.
1446              *
1447              * Return:
1448              *  None.
1449              *
1450              * Global Variables:
1451              *  UART_2_initVar - checked to identify that the component has been
1452              *     initialized.
1453              *  tx_period - static variable, used for keeping TX period configuration.
1454              *
1455              * Reentrant:
1456              *  No.
1457              *
1458              * Theory:
1459              *  SendBreak function initializes registers to send 13-bit break signal. It is
1460              *  important to return the registers configuration to normal for continue 8-bit
1461              *  operation.
1462              *  Trere are 3 variants for this API usage:
1463              *  1) SendBreak(3) - function will send the Break signal and take care on the
1464              *     configuration returning. Funcition will block CPU untill transmition
1465              *     complete.
1466              *  2) User may want to use bloking time if UART configured to the low speed
1467              *     operation
1468              *     Emample for this case:
1469              *     SendBreak(0);     - init Break signal transmition
1470              *         Add your code here to use CPU time
1471              *     SendBreak(1);     - complete Break operation
1472              *  3) Same to 2) but user may want to init and use the interrupt for complete
1473              *     break operation.
1474              *     Example for this case:
1475              *     Init TX interrupt whith "TX - On TX Complete" parameter
1476              *     SendBreak(0);     - init Break signal transmition
1477              *         Add your code here to use CPU time
1478              *     When interrupt appear with UART_TX_STS_COMPLETE status:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 25  

1479              *     SendBreak(2);     - complete Break operation
1480              *
1481              * Side Effects:
1482              *   Uses static variable to keep registers configuration.
1483              *
1484              *******************************************************************************/
1485              void UART_2_SendBreak(uint8 retMode) 
1486              {
1487   1      
1488   1              /* If not Initialized then skip this function*/
1489   1              if(UART_2_initVar != 0u)
1490   1              {
1491   2                  /*Set the Counter to 13-bits and transmit a 00 byte*/
1492   2                  /*When that is done then reset the counter value back*/
1493   2                  uint8 tmpStat;
1494   2      
1495   2                  #if(UART_2_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == UART_2_SEND_BREAK) ||
                                  (retMode == UART_2_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  UART_2_WriteControlRegister(UART_2_ReadControlRegister() |
                                                                        UART_2_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  UART_2_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = UART_2_TXSTATUS_REG;
                                  }while((tmpStat & UART_2_TX_STS_FIFO_EMPTY) != 0u);
                              }
              
                              if( (retMode == UART_2_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_2_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = UART_2_TXSTATUS_REG;
                                  }while(((uint8)~tmpStat & UART_2_TX_STS_COMPLETE) != 0u);
                              }
              
                              if( (retMode == UART_2_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_2_REINIT) ||
                                  (retMode == UART_2_SEND_WAIT_REINIT) )
                              {
                                  UART_2_WriteControlRegister(UART_2_ReadControlRegister() &
                                                                (uint8)~UART_2_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* UART_2_HD_ENABLED Full Duplex mode */
1530   2      
1531   2                      static uint8 tx_period;
1532   2      
1533   2                      if( (retMode == UART_2_SEND_BREAK) ||
1534   2                          (retMode == UART_2_SEND_WAIT_REINIT) )
1535   2                      {
1536   3                          /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode*/
1537   3                          #if( (UART_2_PARITY_TYPE != UART_2__B_UART__NONE_REVB) || \
1538   3                                              (UART_2_PARITY_TYPE_SW != 0u) )
                                      UART_2_WriteControlRegister(UART_2_ReadControlRegister() |
                                                                            UART_2_CTRL_HD_SEND_BREAK);
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 26  

                                  #endif /* End UART_2_PARITY_TYPE != UART_2__B_UART__NONE_REVB  */
1542   3      
1543   3                          #if(UART_2_TXCLKGEN_DP)
1544   3                              tx_period = UART_2_TXBITCLKTX_COMPLETE_REG;
1545   3                              UART_2_TXBITCLKTX_COMPLETE_REG = UART_2_TXBITCTR_BREAKBITS;
1546   3                          #else
                                      tx_period = UART_2_TXBITCTR_PERIOD_REG;
                                      UART_2_TXBITCTR_PERIOD_REG = UART_2_TXBITCTR_BREAKBITS8X;
                                  #endif /* End UART_2_TXCLKGEN_DP */
1550   3      
1551   3                          /* Send zeros*/
1552   3                          UART_2_TXDATA_REG = 0u;
1553   3      
1554   3                          do /* wait until transmit starts */
1555   3                          {
1556   4                              tmpStat = UART_2_TXSTATUS_REG;
1557   4                          }while((tmpStat & UART_2_TX_STS_FIFO_EMPTY) != 0u);
1558   3                      }
1559   2      
1560   2                      if( (retMode == UART_2_WAIT_FOR_COMPLETE_REINIT) ||
1561   2                          (retMode == UART_2_SEND_WAIT_REINIT) )
1562   2                      {
1563   3                          do /*wait until transmit complete*/
1564   3                          {
1565   4                              tmpStat = UART_2_TXSTATUS_REG;
1566   4                          }while(((uint8)~tmpStat & UART_2_TX_STS_COMPLETE) != 0u);
1567   3                      }
1568   2      
1569   2                      if( (retMode == UART_2_WAIT_FOR_COMPLETE_REINIT) ||
1570   2                          (retMode == UART_2_REINIT) ||
1571   2                          (retMode == UART_2_SEND_WAIT_REINIT) )
1572   2                      {
1573   3      
1574   3                          #if(UART_2_TXCLKGEN_DP)
1575   3                              UART_2_TXBITCLKTX_COMPLETE_REG = tx_period;
1576   3                          #else
                                      UART_2_TXBITCTR_PERIOD_REG = tx_period;
                                  #endif /* End UART_2_TXCLKGEN_DP */
1579   3      
1580   3                          #if( (UART_2_PARITY_TYPE != UART_2__B_UART__NONE_REVB) || \
1581   3                               (UART_2_PARITY_TYPE_SW != 0u) )
                                      UART_2_WriteControlRegister(UART_2_ReadControlRegister() &
                                                                    (uint8)~UART_2_CTRL_HD_SEND_BREAK);
                                  #endif /* End UART_2_PARITY_TYPE != NONE */
1585   3                      }
1586   2                  #endif    /* End UART_2_HD_ENABLED */
1587   2              }
1588   1          }
1589          
1590          
1591              /*******************************************************************************
1592              * Function Name: UART_2_SetTxAddressMode
1593              ********************************************************************************
1594              *
1595              * Summary:
1596              *  Set the transmit addressing mode
1597              *
1598              * Parameters:
1599              *  addressMode: 0 -> Space
1600              *               1 -> Mark
1601              *
1602              * Return:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 27  

1603              *  None.
1604              *
1605              *******************************************************************************/
1606              void UART_2_SetTxAddressMode(uint8 addressMode) 
1607              {
1608   1              /* Mark/Space sending enable*/
1609   1              if(addressMode != 0u)
1610   1              {
1611   2                  #if( UART_2_CONTROL_REG_REMOVED == 0u )
                              UART_2_WriteControlRegister(UART_2_ReadControlRegister() |
                                                                    UART_2_CTRL_MARK);
                          #endif /* End UART_2_CONTROL_REG_REMOVED == 0u */
1615   2              }
1616   1              else
1617   1              {
1618   2                  #if( UART_2_CONTROL_REG_REMOVED == 0u )
                              UART_2_WriteControlRegister(UART_2_ReadControlRegister() &
                                                                  (uint8)~UART_2_CTRL_MARK);
                          #endif /* End UART_2_CONTROL_REG_REMOVED == 0u */
1622   2              }
1623   1          }
1624          
1625          #endif  /* EndUART_2_TX_ENABLED */
1626          
1627          #if(UART_2_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART.
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void UART_2_LoadTxConfig(void) 
                  {
                      #if((UART_2_RX_INTERRUPT_ENABLED) && (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          UART_2_SetRxInterruptMode(0u);
                      #endif /* UART_2_RX_INTERRUPT_ENABLED */
              
                      UART_2_WriteControlRegister(UART_2_ReadControlRegister() | UART_2_CTRL_HD_SEND);
                      UART_2_RXBITCTR_PERIOD_REG = UART_2_HD_TXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_2_RXSTATUS_PTR);
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 28  

                      #endif /* CY_UDB_V0 */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_2_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer
                  *  has been used.
                  *
                  *******************************************************************************/
                  void UART_2_LoadRxConfig(void) 
                  {
                      UART_2_WriteControlRegister(UART_2_ReadControlRegister() &
                                                              (uint8)~UART_2_CTRL_HD_SEND);
                      UART_2_RXBITCTR_PERIOD_REG = UART_2_HD_RXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_2_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
              
                      #if((UART_2_RX_INTERRUPT_ENABLED) && (UART_2_RXBUFFERSIZE > UART_2_FIFO_LENGTH))
                          /* Enable RX interrupt after set RX configuration */
                          UART_2_SetRxInterruptMode(UART_2_INIT_RX_INTERRUPTS_MASK);
                      #endif /* UART_2_RX_INTERRUPT_ENABLED */
                  }
              
              #endif  /* UART_2_HD_ENABLED */
1710          
1711          
1712          /* [] END OF FILE */
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_2_Start (BEGIN)
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 76
0000 900000      R     MOV     DPTR,#UART_2_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 78
0008 120000      R     LCALL   UART_2_Init
                                           ; SOURCE LINE # 79
000B 900000      R     MOV     DPTR,#UART_2_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
0011         ?C0001:
                                           ; SOURCE LINE # 81
0011 120000      R     LCALL   UART_2_Enable
                                           ; SOURCE LINE # 82
0014 22                RET     
             ; FUNCTION UART_2_Start (END)

             ; FUNCTION UART_2_Init (BEGIN)
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 126
0000 7C00        E     MOV     R4,#HIGH UART_2_TXISR
0002 7D00        E     MOV     R5,#LOW UART_2_TXISR
0004 7F03              MOV     R7,#03H
0006 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 127
0009 7D07              MOV     R5,#07H
000B 7F03              MOV     R7,#03H
000D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 132
0010 906429            MOV     DPTR,#06429H
0013 7407              MOV     A,#07H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
0016 906439            MOV     DPTR,#06439H
0019 7448              MOV     A,#048H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 142
001C 90648C            MOV     DPTR,#0648CH
001F 7402              MOV     A,#02H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
0022 22                RET     
             ; FUNCTION UART_2_Init (END)

             ; FUNCTION UART_2_Enable (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 30  

0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0008 90649C            MOV     DPTR,#0649CH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4410              ORL     A,#010H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 200
0013 9044C0            MOV     DPTR,#044C0H
0016 7408              MOV     A,#08H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0019 120000      E     LCALL   UART_2_IntClock_Start
                                           ; SOURCE LINE # 209
001C 900000      R     MOV     DPTR,#enableInterrupts
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 210
0024 22                RET     
             ; FUNCTION UART_2_Enable (END)

             ; FUNCTION UART_2_Stop (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 230
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
0008 120000      E     LCALL   UART_2_IntClock_Stop
                                           ; SOURCE LINE # 257
000B 90649C            MOV     DPTR,#0649CH
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 54EF              ANL     A,#0EFH
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
0016 120000      R     LCALL   UART_2_DisableTxInt
                                           ; SOURCE LINE # 263
0019 900000      R     MOV     DPTR,#enableInterrupts
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 264
0021 22                RET     
             ; FUNCTION UART_2_Stop (END)

             ; FUNCTION UART_2_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 284
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 288
0002         ?C0006:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 31  

0002 22                RET     
             ; FUNCTION UART_2_ReadControlRegister (END)

             ; FUNCTION _UART_2_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 305
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 312
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_2_WriteControlRegister (END)

             ; FUNCTION UART_2_EnableTxInt (BEGIN)
                                           ; SOURCE LINE # 919
                                           ; SOURCE LINE # 920
                                           ; SOURCE LINE # 921
0000 9044C0            MOV     DPTR,#044C0H
0003 7408              MOV     A,#08H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 922
0006 22                RET     
             ; FUNCTION UART_2_EnableTxInt (END)

             ; FUNCTION UART_2_DisableTxInt (BEGIN)
                                           ; SOURCE LINE # 942
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 944
0000 9044C8            MOV     DPTR,#044C8H
0003 7408              MOV     A,#08H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 945
0006 22                RET     
             ; FUNCTION UART_2_DisableTxInt (END)

             ; FUNCTION _UART_2_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 968
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648C            MOV     DPTR,#0648CH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 971
000F 22                RET     
             ; FUNCTION _UART_2_SetTxInterruptMode (END)

             ; FUNCTION _UART_2_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 1002
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1003
                                           ; SOURCE LINE # 1005
0005 900000      R     MOV     DPTR,#UART_2_initVar
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 32  

0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6055              JZ      ?C0016
                                           ; SOURCE LINE # 1006
                                           ; SOURCE LINE # 1012
000D 120000      R     LCALL   UART_2_DisableTxInt
                                           ; SOURCE LINE # 1016
0010 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#UART_2_txBufferRead
0018 E0                MOVX    A,@DPTR
0019 FE                MOV     R6,A
001A EE                MOV     A,R6
001B B50715            CJNE    A,AR7,?C0013
001E 90646C            MOV     DPTR,#0646CH
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 20E20C            JB      ACC.2,?C0013
                                           ; SOURCE LINE # 1017
                                           ; SOURCE LINE # 1019
0027 900000      R     MOV     DPTR,#txDataByte
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 90644C            MOV     DPTR,#0644CH
002F EF                MOV     A,R7
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1020
0031 802C              SJMP    ?C0014
0033         ?C0013:
                                           ; SOURCE LINE # 1022
                                           ; SOURCE LINE # 1023
0033 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 EF                MOV     A,R7
0039 C3                CLR     C
003A 94FF              SUBB    A,#0FFH
003C 4005              JC      ?C0015
                                           ; SOURCE LINE # 1024
                                           ; SOURCE LINE # 1025
003E 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1026
0043         ?C0015:
                                           ; SOURCE LINE # 1028
0043 900000      R     MOV     DPTR,#txDataByte
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#UART_2_txBufferWrite
004B E0                MOVX    A,@DPTR
004C FE                MOV     R6,A
004D 7400        R     MOV     A,#LOW UART_2_txBuffer
004F 2E                ADD     A,R6
0050 F582              MOV     DPL,A
0052 E4                CLR     A
0053 3400        R     ADDC    A,#HIGH UART_2_txBuffer
0055 F583              MOV     DPH,A
0057 EF                MOV     A,R7
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 33  

0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1031
0059 900000      R     MOV     DPTR,#UART_2_txBufferWrite
005C E0                MOVX    A,@DPTR
005D 04                INC     A
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1033
005F         ?C0014:
                                           ; SOURCE LINE # 1037
005F 120000      R     LCALL   UART_2_EnableTxInt
                                           ; SOURCE LINE # 1046
                                           ; SOURCE LINE # 1047
0062         ?C0016:
0062 22                RET     
             ; FUNCTION _UART_2_WriteTxData (END)

             ; FUNCTION UART_2_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1070
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
0000 90646C            MOV     DPTR,#0646CH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1073
0005         ?C0017:
0005 22                RET     
             ; FUNCTION UART_2_ReadTxStatus (END)

             ; FUNCTION _UART_2_PutChar (BEGIN)
                                           ; SOURCE LINE # 1106
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1107
0005         ?C0020:
                                           ; SOURCE LINE # 1116
                                           ; SOURCE LINE # 1122
0005 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#loc_txBufferWrite
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1123
000F 900000      R     MOV     DPTR,#UART_2_txBufferRead
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#loc_txBufferRead
0017 EF                MOV     A,R7
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1128
                                           ; SOURCE LINE # 1130
0019 900000      R     MOV     DPTR,#loc_txBufferRead
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E 900000      R     MOV     DPTR,#loc_txBufferWrite
0021 E0                MOVX    A,@DPTR
0022 FE                MOV     R6,A
0023 EE                MOV     A,R6
0024 C3                CLR     C
0025 9F                SUBB    A,R7
0026 5026              JNC     ?C0021
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 34  

0028 900000      R     MOV     DPTR,#loc_txBufferRead
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 7E00              MOV     R6,#00H
002F EF                MOV     A,R7
0030 24FF              ADD     A,#0FFH
0032 FF                MOV     R7,A
0033 EE                MOV     A,R6
0034 34FF              ADDC    A,#0FFH
0036 FE                MOV     R6,A
0037 900000      R     MOV     DPTR,#loc_txBufferWrite
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C 7C00              MOV     R4,#00H
003E EF                MOV     A,R7
003F B50508            CJNE    A,AR5,?C0023
0042 EE                MOV     A,R6
0043 B50404            CJNE    A,AR4,?C0023
0046 7F01              MOV     R7,#01H
0048 8002              SJMP    ?C0024
004A         ?C0023:
004A 7F00              MOV     R7,#00H
004C         ?C0024:
004C 8018              SJMP    ?C0022
004E         ?C0021:
004E 900000      R     MOV     DPTR,#loc_txBufferRead
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
0053 900000      R     MOV     DPTR,#loc_txBufferWrite
0056 E0                MOVX    A,@DPTR
0057 FE                MOV     R6,A
0058 C3                CLR     C
0059 EE                MOV     A,R6
005A 9F                SUBB    A,R7
005B FF                MOV     R7,A
005C EF                MOV     A,R7
005D B4FE04            CJNE    A,#0FEH,?C0025
0060 7F01              MOV     R7,#01H
0062 8002              SJMP    ?C0026
0064         ?C0025:
0064 7F00              MOV     R7,#00H
0066         ?C0026:
0066         ?C0022:
0066 EF                MOV     A,R7
0067 709C              JNZ     ?C0020
                                           ; SOURCE LINE # 1133
0069 900000      R     MOV     DPTR,#loc_txBufferWrite
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
006E 900000      R     MOV     DPTR,#loc_txBufferRead
0071 E0                MOVX    A,@DPTR
0072 FE                MOV     R6,A
0073 EE                MOV     A,R6
0074 B50714            CJNE    A,AR7,?C0027
0077 90646C            MOV     DPTR,#0646CH
007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C EF                MOV     A,R7
007D 20E20B            JB      ACC.2,?C0027
                                           ; SOURCE LINE # 1134
                                           ; SOURCE LINE # 1136
0080 900000      R     MOV     DPTR,#txDataByte
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 35  

0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 90644C            MOV     DPTR,#0644CH
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1137
008A 22                RET     
008B         ?C0027:
                                           ; SOURCE LINE # 1139
                                           ; SOURCE LINE # 1140
008B 900000      R     MOV     DPTR,#loc_txBufferWrite
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 EF                MOV     A,R7
0091 C3                CLR     C
0092 94FF              SUBB    A,#0FFH
0094 4005              JC      ?C0029
                                           ; SOURCE LINE # 1141
                                           ; SOURCE LINE # 1142
0096 900000      R     MOV     DPTR,#loc_txBufferWrite
0099 E4                CLR     A
009A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1143
009B         ?C0029:
                                           ; SOURCE LINE # 1145
009B 900000      R     MOV     DPTR,#txDataByte
009E E0                MOVX    A,@DPTR
009F FF                MOV     R7,A
00A0 900000      R     MOV     DPTR,#loc_txBufferWrite
00A3 E0                MOVX    A,@DPTR
00A4 FE                MOV     R6,A
00A5 7400        R     MOV     A,#LOW UART_2_txBuffer
00A7 2E                ADD     A,R6
00A8 F582              MOV     DPL,A
00AA E4                CLR     A
00AB 3400        R     ADDC    A,#HIGH UART_2_txBuffer
00AD F583              MOV     DPH,A
00AF EF                MOV     A,R7
00B0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1146
00B1 900000      R     MOV     DPTR,#loc_txBufferWrite
00B4 E0                MOVX    A,@DPTR
00B5 04                INC     A
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1152
00B7 900000      R     MOV     DPTR,#loc_txBufferWrite
00BA E0                MOVX    A,@DPTR
00BB FF                MOV     R7,A
00BC 900000      R     MOV     DPTR,#UART_2_txBufferWrite
00BF EF                MOV     A,R7
00C0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1156
                                           ; SOURCE LINE # 1169
00C1         ?C0030:
00C1 22                RET     
             ; FUNCTION _UART_2_PutChar (END)

             ; FUNCTION _UART_2_PutString (BEGIN)
                                           ; SOURCE LINE # 1198
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1199
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 36  

                                           ; SOURCE LINE # 1200
0006 900000      R     MOV     DPTR,#buf_index
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1202
000E 900000      R     MOV     DPTR,#UART_2_initVar
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6042              JZ      ?C0034
                                           ; SOURCE LINE # 1203
0016         ?C0032:
                                           ; SOURCE LINE # 1205
0016 900000      R     MOV     DPTR,#string
0019 120000      E     LCALL   ?C?PLDXDATA
001C 900000      R     MOV     DPTR,#buf_index
001F E0                MOVX    A,@DPTR
0020 FE                MOV     R6,A
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E9                MOV     A,R1
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 EA                MOV     A,R2
0028 3E                ADDC    A,R6
0029 FA                MOV     R2,A
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 6027              JZ      ?C0034
                                           ; SOURCE LINE # 1206
                                           ; SOURCE LINE # 1207
0031 900000      R     MOV     DPTR,#string
0034 120000      E     LCALL   ?C?PLDXDATA
0037 900000      R     MOV     DPTR,#buf_index
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F E9                MOV     A,R1
0040 2F                ADD     A,R7
0041 F9                MOV     R1,A
0042 EA                MOV     A,R2
0043 3E                ADDC    A,R6
0044 FA                MOV     R2,A
0045 120000      E     LCALL   ?C?CLDPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _UART_2_PutChar
                                           ; SOURCE LINE # 1208
004C 900000      R     MOV     DPTR,#buf_index
004F E4                CLR     A
0050 75F001            MOV     B,#01H
0053 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1209
0056 80BE              SJMP    ?C0032
                                           ; SOURCE LINE # 1210
                                           ; SOURCE LINE # 1211
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 37  

0058         ?C0034:
0058 22                RET     
             ; FUNCTION _UART_2_PutString (END)

             ; FUNCTION _UART_2_PutArray (BEGIN)
                                           ; SOURCE LINE # 1236
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
000B 900000      R     MOV     DPTR,#buf_index
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1241
0010 900000      R     MOV     DPTR,#UART_2_initVar
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 602D              JZ      ?C0039
                                           ; SOURCE LINE # 1242
0018         ?C0038:
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
0018 900000      R     MOV     DPTR,#string
001B 120000      E     LCALL   ?C?PLDXDATA
001E 900000      R     MOV     DPTR,#buf_index
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 E9                MOV     A,R1
0024 2F                ADD     A,R7
0025 F9                MOV     R1,A
0026 E4                CLR     A
0027 3A                ADDC    A,R2
0028 FA                MOV     R2,A
0029 120000      E     LCALL   ?C?CLDPTR
002C FF                MOV     R7,A
002D 120000      R     LCALL   _UART_2_PutChar
                                           ; SOURCE LINE # 1246
0030 900000      R     MOV     DPTR,#buf_index
0033 E0                MOVX    A,@DPTR
0034 04                INC     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1247
0036 900000      R     MOV     DPTR,#byteCount
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 900000      R     MOV     DPTR,#buf_index
003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 EE                MOV     A,R6
0041 C3                CLR     C
0042 9F                SUBB    A,R7
0043 40D3              JC      ?C0038
                                           ; SOURCE LINE # 1248
                                           ; SOURCE LINE # 1249
0045         ?C0039:
0045 22                RET     
             ; FUNCTION _UART_2_PutArray (END)

C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 38  

             ; FUNCTION _UART_2_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1273
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
                                           ; SOURCE LINE # 1276
0005 900000      R     MOV     DPTR,#UART_2_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0041
                                           ; SOURCE LINE # 1277
                                           ; SOURCE LINE # 1278
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_2_PutChar
                                           ; SOURCE LINE # 1279
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_2_PutChar
                                           ; SOURCE LINE # 1280
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_2_PutChar
                                           ; SOURCE LINE # 1281
                                           ; SOURCE LINE # 1282
001F         ?C0041:
001F 22                RET     
             ; FUNCTION _UART_2_PutCRLF (END)

             ; FUNCTION UART_2_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1310
                                           ; SOURCE LINE # 1312
                                           ; SOURCE LINE # 1320
0000 120000      R     LCALL   UART_2_DisableTxInt
                                           ; SOURCE LINE # 1323
0003 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#UART_2_txBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D EE                MOV     A,R6
000E B50707            CJNE    A,AR7,?C0042
                                           ; SOURCE LINE # 1324
                                           ; SOURCE LINE # 1325
0011 900000      R     MOV     DPTR,#size
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1326
0016 803B              SJMP    ?C0043
0018         ?C0042:
                                           ; SOURCE LINE # 1327
0018 900000      R     MOV     DPTR,#UART_2_txBufferWrite
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#UART_2_txBufferRead
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 EE                MOV     A,R6
0023 C3                CLR     C
0024 9F                SUBB    A,R7
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 39  

0025 5015              JNC     ?C0044
                                           ; SOURCE LINE # 1328
                                           ; SOURCE LINE # 1329
0027 900000      R     MOV     DPTR,#UART_2_txBufferRead
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#UART_2_txBufferWrite
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 C3                CLR     C
0032 EE                MOV     A,R6
0033 9F                SUBB    A,R7
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#size
0038 EF                MOV     A,R7
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1330
003A 8017              SJMP    ?C0043
003C         ?C0044:
                                           ; SOURCE LINE # 1332
                                           ; SOURCE LINE # 1333
003C 900000      R     MOV     DPTR,#UART_2_txBufferRead
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 C3                CLR     C
0042 74FF              MOV     A,#0FFH
0044 9F                SUBB    A,R7
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0049 E0                MOVX    A,@DPTR
004A FE                MOV     R6,A
004B EF                MOV     A,R7
004C 2E                ADD     A,R6
004D FF                MOV     R7,A
004E 900000      R     MOV     DPTR,#size
0051 EF                MOV     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1334
0053         ?C0043:
                                           ; SOURCE LINE # 1338
0053 120000      R     LCALL   UART_2_EnableTxInt
                                           ; SOURCE LINE # 1362
0056 900000      R     MOV     DPTR,#size
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
                                           ; SOURCE LINE # 1363
005B         ?C0046:
005B 22                RET     
             ; FUNCTION UART_2_GetTxBufferSize (END)

             ; FUNCTION UART_2_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1396
                                           ; SOURCE LINE # 1397
                                           ; SOURCE LINE # 1401
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
0008 90649C            MOV     DPTR,#0649CH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 40  

000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1404
0013 90649C            MOV     DPTR,#0649CH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1406
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1413
0026 120000      R     LCALL   UART_2_DisableTxInt
                                           ; SOURCE LINE # 1416
0029 900000      R     MOV     DPTR,#UART_2_txBufferRead
002C E4                CLR     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1417
002E 900000      R     MOV     DPTR,#UART_2_txBufferWrite
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1421
0033 120000      R     LCALL   UART_2_EnableTxInt
                                           ; SOURCE LINE # 1425
0036 22                RET     
             ; FUNCTION UART_2_ClearTxBuffer (END)

             ; FUNCTION _UART_2_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1485
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1486
                                           ; SOURCE LINE # 1489
0005 900000      R     MOV     DPTR,#UART_2_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0061
                                           ; SOURCE LINE # 1490
                                           ; SOURCE LINE # 1533
0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0050
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7028              JNZ     ?C0049
0022         ?C0050:
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 41  

                                           ; SOURCE LINE # 1535
                                           ; SOURCE LINE # 1544
0022 906439            MOV     DPTR,#06439H
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#tx_period
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1545
002C 906439            MOV     DPTR,#06439H
002F 7467              MOV     A,#067H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1552
0032 90644C            MOV     DPTR,#0644CH
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
0037         ?C0053:
                                           ; SOURCE LINE # 1555
                                           ; SOURCE LINE # 1556
0037 90646C            MOV     DPTR,#0646CH
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#tmpStat
003F EF                MOV     A,R7
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1557
0041 900000      R     MOV     DPTR,#tmpStat
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 20E1ED            JB      ACC.1,?C0053
                                           ; SOURCE LINE # 1558
004A         ?C0049:
                                           ; SOURCE LINE # 1560
004A 900000      R     MOV     DPTR,#retMode
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
0050 6401              XRL     A,#01H
0052 6009              JZ      ?C0058
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A B40316            CJNE    A,#03H,?C0054
                                           ; SOURCE LINE # 1562
005D         ?C0058:
                                           ; SOURCE LINE # 1564
                                           ; SOURCE LINE # 1565
005D 90646C            MOV     DPTR,#0646CH
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#tmpStat
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1566
0067 900000      R     MOV     DPTR,#tmpStat
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D F4                CPL     A
006E FF                MOV     R7,A
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 42  

006F EF                MOV     A,R7
0070 20E0EA            JB      ACC.0,?C0058
                                           ; SOURCE LINE # 1567
0073         ?C0054:
                                           ; SOURCE LINE # 1569
0073 900000      R     MOV     DPTR,#retMode
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 6401              XRL     A,#01H
007B 6013              JZ      ?C0060
007D 900000      R     MOV     DPTR,#retMode
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 6402              XRL     A,#02H
0085 6009              JZ      ?C0060
0087 900000      R     MOV     DPTR,#retMode
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C EF                MOV     A,R7
008D B4030A            CJNE    A,#03H,?C0061
0090         ?C0060:
                                           ; SOURCE LINE # 1572
                                           ; SOURCE LINE # 1575
0090 900000      R     MOV     DPTR,#tx_period
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 906439            MOV     DPTR,#06439H
0098 EF                MOV     A,R7
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
                                           ; SOURCE LINE # 1587
                                           ; SOURCE LINE # 1588
009A         ?C0061:
009A 22                RET     
             ; FUNCTION _UART_2_SendBreak (END)

             ; FUNCTION _UART_2_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1606
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1607
                                           ; SOURCE LINE # 1609
                                           ; SOURCE LINE # 1610
                                           ; SOURCE LINE # 1615
0005         ?C0062:
                                           ; SOURCE LINE # 1617
                                           ; SOURCE LINE # 1622
                                           ; SOURCE LINE # 1623
0005         ?C0064:
0005 22                RET     
             ; FUNCTION _UART_2_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    964    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    259      24
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.51   UART_2                                                                01/05/2014 19:16:05 PAGE 43  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
