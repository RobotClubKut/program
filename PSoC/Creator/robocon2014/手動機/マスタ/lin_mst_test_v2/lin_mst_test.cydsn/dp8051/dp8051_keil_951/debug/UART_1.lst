C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_1
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_1.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\UART_1.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_951\Debug\UART_1.lst) CD DB NOIP OT(2,S
                    -IZE) DF(DEBUG) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_951\Debug\UART_1.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_1.c
   3          * Version 2.30
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_1.h"
  18          #include "CyLib.h"
  19          #if(UART_1_INTERNAL_CLOCK_USED)
  20              #include "UART_1_IntClock.h"
  21          #endif /* End UART_1_INTERNAL_CLOCK_USED */
  22          
  23          
  24          /***************************************
  25          * Global data allocation
  26          ***************************************/
  27          
  28          uint8 UART_1_initVar = 0u;
  29          #if( UART_1_TX_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
                  volatile uint8 UART_1_txBuffer[UART_1_TXBUFFERSIZE];
                  volatile uint8 UART_1_txBufferRead = 0u;
                  uint8 UART_1_txBufferWrite = 0u;
              #endif /* End UART_1_TX_ENABLED */
  34          #if( ( UART_1_RX_ENABLED || UART_1_HD_ENABLED ) && \
  35               (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
                  volatile uint8 UART_1_rxBuffer[UART_1_RXBUFFERSIZE];
                  volatile uint8 UART_1_rxBufferRead = 0u;
                  volatile uint8 UART_1_rxBufferWrite = 0u;
                  volatile uint8 UART_1_rxBufferLoopDetect = 0u;
                  volatile uint8 UART_1_rxBufferOverflow = 0u;
                  #if (UART_1_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_1_rxAddressMode = UART_1_RXADDRESSMODE;
                      volatile uint8 UART_1_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */
              #endif /* End UART_1_RX_ENABLED */
  46          
  47          
  48          /*******************************************************************************
  49          * Function Name: UART_1_Start
  50          ********************************************************************************
  51          *
  52          * Summary:
  53          *  Initialize and Enable the UART component.
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 2   

  54          *  Enable the clock input to enable operation.
  55          *
  56          * Parameters:
  57          *  None.
  58          *
  59          * Return:
  60          *  None.
  61          *
  62          * Global variables:
  63          *  The UART_1_intiVar variable is used to indicate initial
  64          *  configuration of this component. The variable is initialized to zero (0u)
  65          *  and set to one (1u) the first time UART_Start() is called. This allows for
  66          *  component initialization without re-initialization in all subsequent calls
  67          *  to the UART_1_Start() routine.
  68          *
  69          * Reentrant:
  70          *  No.
  71          *
  72          *******************************************************************************/
  73          void UART_1_Start(void) 
  74          {
  75   1          /* If not Initialized then initialize all required hardware and software */
  76   1          if(UART_1_initVar == 0u)
  77   1          {
  78   2              UART_1_Init();
  79   2              UART_1_initVar = 1u;
  80   2          }
  81   1          UART_1_Enable();
  82   1      }
  83          
  84          
  85          /*******************************************************************************
  86          * Function Name: UART_1_Init
  87          ********************************************************************************
  88          *
  89          * Summary:
  90          *  Initialize component's parameters to the parameters set by user in the
  91          *  customizer of the component placed onto schematic. Usually called in
  92          *  UART_1_Start().
  93          *
  94          * Parameters:
  95          *  None.
  96          *
  97          * Return:
  98          *  None.
  99          *
 100          *******************************************************************************/
 101          void UART_1_Init(void) 
 102          {
 103   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 104   1      
 105   1              #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          /* Set the RX Interrupt. */
                          (void)CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
                          CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
                      #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 110   1      
 111   1              #if (UART_1_RXHW_ADDRESS_ENABLED)
                          UART_1_SetRxAddressMode(UART_1_RXAddressMode);
                          UART_1_SetRxAddress1(UART_1_RXHWADDRESS1);
                          UART_1_SetRxAddress2(UART_1_RXHWADDRESS2);
                      #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 3   

 116   1      
 117   1              /* Init Count7 period */
 118   1              UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 119   1              /* Configure the Initial RX interrupt mask */
 120   1              UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 121   1          #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 122   1      
 123   1          #if(UART_1_TX_ENABLED)
 124   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          /* Set the TX Interrupt. */
                          (void)CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
                          CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
                      #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 129   1      
 130   1              /* Write Counter Value for TX Bit Clk Generator*/
 131   1              #if(UART_1_TXCLKGEN_DP)
 132   1                  UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
 133   1                  UART_1_TXBITCLKTX_COMPLETE_REG = (UART_1_NUMBER_OF_DATA_BITS +
 134   1                              UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT;
 135   1              #else
                          UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
                                      UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_1_TXCLKGEN_DP */
 139   1      
 140   1              /* Configure the Initial TX interrupt mask */
 141   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
                      #else
 144   1                  UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
 145   1              #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 146   1      
 147   1          #endif /* End UART_1_TX_ENABLED */
 148   1      
 149   1          #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_1_WriteControlRegister( \
                          (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_1_PARITY_TYPE_SW */
 154   1      }
 155          
 156          
 157          /*******************************************************************************
 158          * Function Name: UART_1_Enable
 159          ********************************************************************************
 160          *
 161          * Summary:
 162          *  Enables the UART block operation
 163          *
 164          * Parameters:
 165          *  None.
 166          *
 167          * Return:
 168          *  None.
 169          *
 170          * Global Variables:
 171          *  UART_1_rxAddressDetected - set to initial state (0).
 172          *
 173          *******************************************************************************/
 174          void UART_1_Enable(void) 
 175          {
 176   1          uint8 enableInterrupts;
 177   1          enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 4   

 178   1      
 179   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 180   1              /*RX Counter (Count7) Enable */
 181   1              UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 182   1              /* Enable the RX Interrupt. */
 183   1              UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 184   1              #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          CyIntEnable(UART_1_RX_VECT_NUM);
                          #if (UART_1_RXHW_ADDRESS_ENABLED)
                              UART_1_rxAddressDetected = 0u;
                          #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
                      #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 190   1          #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 191   1      
 192   1          #if(UART_1_TX_ENABLED)
 193   1              /*TX Counter (DP/Count7) Enable */
 194   1              #if(!UART_1_TXCLKGEN_DP)
                          UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
                      #endif /* End UART_1_TXCLKGEN_DP */
 197   1              /* Enable the TX Interrupt. */
 198   1              UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 199   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          CyIntEnable(UART_1_TX_VECT_NUM);
                      #endif /* End UART_1_TX_INTERRUPT_ENABLED*/
 202   1           #endif /* End UART_1_TX_ENABLED */
 203   1      
 204   1          #if(UART_1_INTERNAL_CLOCK_USED)
 205   1              /* Enable the clock. */
 206   1              UART_1_IntClock_Start();
 207   1          #endif /* End UART_1_INTERNAL_CLOCK_USED */
 208   1      
 209   1          CyExitCriticalSection(enableInterrupts);
 210   1      }
 211          
 212          
 213          /*******************************************************************************
 214          * Function Name: UART_1_Stop
 215          ********************************************************************************
 216          *
 217          * Summary:
 218          *  Disable the UART component
 219          *
 220          * Parameters:
 221          *  None.
 222          *
 223          * Return:
 224          *  None.
 225          *
 226          *******************************************************************************/
 227          void UART_1_Stop(void) 
 228          {
 229   1          uint8 enableInterrupts;
 230   1          enableInterrupts = CyEnterCriticalSection();
 231   1      
 232   1          /* Write Bit Counter Disable */
 233   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 234   1              UART_1_RXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 235   1          #endif /* End UART_1_RX_ENABLED */
 236   1      
 237   1          #if(UART_1_TX_ENABLED)
 238   1              #if(!UART_1_TXCLKGEN_DP)
                          UART_1_TXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 5   

                      #endif /* End UART_1_TXCLKGEN_DP */
 241   1          #endif /* UART_1_TX_ENABLED */
 242   1      
 243   1          #if(UART_1_INTERNAL_CLOCK_USED)
 244   1              /* Disable the clock. */
 245   1              UART_1_IntClock_Stop();
 246   1          #endif /* End UART_1_INTERNAL_CLOCK_USED */
 247   1      
 248   1          /* Disable internal interrupt component */
 249   1          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 250   1              UART_1_RXSTATUS_ACTL_REG  &= (uint8)~UART_1_INT_ENABLE;
 251   1              #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          UART_1_DisableRxInt();
                      #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 254   1          #endif /* End UART_1_RX_ENABLED */
 255   1      
 256   1          #if(UART_1_TX_ENABLED)
 257   1              UART_1_TXSTATUS_ACTL_REG &= (uint8)~UART_1_INT_ENABLE;
 258   1              #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          UART_1_DisableTxInt();
                      #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 261   1          #endif /* End UART_1_TX_ENABLED */
 262   1      
 263   1          CyExitCriticalSection(enableInterrupts);
 264   1      }
 265          
 266          
 267          /*******************************************************************************
 268          * Function Name: UART_1_ReadControlRegister
 269          ********************************************************************************
 270          *
 271          * Summary:
 272          *  Read the current state of the control register
 273          *
 274          * Parameters:
 275          *  None.
 276          *
 277          * Return:
 278          *  Current state of the control register.
 279          *
 280          *******************************************************************************/
 281          uint8 UART_1_ReadControlRegister(void) 
 282          {
 283   1          #if( UART_1_CONTROL_REG_REMOVED )
 284   1              return(0u);
 285   1          #else
                      return(UART_1_CONTROL_REG);
                  #endif /* End UART_1_CONTROL_REG_REMOVED */
 288   1      }
 289          
 290          
 291          /*******************************************************************************
 292          * Function Name: UART_1_WriteControlRegister
 293          ********************************************************************************
 294          *
 295          * Summary:
 296          *  Writes an 8-bit value into the control register
 297          *
 298          * Parameters:
 299          *  control:  control register value
 300          *
 301          * Return:
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 6   

 302          *  None.
 303          *
 304          *******************************************************************************/
 305          void  UART_1_WriteControlRegister(uint8 control) 
 306          {
 307   1          #if( UART_1_CONTROL_REG_REMOVED )
 308   1              if(control != 0u) { }      /* release compiler warning */
 309   1          #else
                     UART_1_CONTROL_REG = control;
                  #endif /* End UART_1_CONTROL_REG_REMOVED */
 312   1      }
 313          
 314          
 315          #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 316          
 317              #if(UART_1_RX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: UART_1_EnableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_1_EnableRxInt(void) 
                      {
                          CyIntEnable(UART_1_RX_VECT_NUM);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: UART_1_DisableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_1_DisableRxInt(void) 
                      {
                          CyIntDisable(UART_1_RX_VECT_NUM);
                      }
              
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 7   

                  #endif /* UART_1_RX_INTERRUPT_ENABLED */
 365          
 366          
 367              /*******************************************************************************
 368              * Function Name: UART_1_SetRxInterruptMode
 369              ********************************************************************************
 370              *
 371              * Summary:
 372              *  Configure which status bits trigger an interrupt event
 373              *
 374              * Parameters:
 375              *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376              *           the header file)
 377              *
 378              * Return:
 379              *  None.
 380              *
 381              * Theory:
 382              *  Enables the output of specific status bits to the interrupt controller
 383              *
 384              *******************************************************************************/
 385              void UART_1_SetRxInterruptMode(uint8 intSrc) 
 386              {
 387   1              UART_1_RXSTATUS_MASK_REG  = intSrc;
 388   1          }
 389          
 390          
 391              /*******************************************************************************
 392              * Function Name: UART_1_ReadRxData
 393              ********************************************************************************
 394              *
 395              * Summary:
 396              *  Returns data in RX Data register without checking status register to
 397              *  determine if data is valid
 398              *
 399              * Parameters:
 400              *  None.
 401              *
 402              * Return:
 403              *  Received data from RX register
 404              *
 405              * Global Variables:
 406              *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 407              *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 408              *     checked to identify new data.
 409              *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 410              *     incremented after each byte has been read from buffer.
 411              *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 412              *     in RX ISR.
 413              *
 414              * Reentrant:
 415              *  No.
 416              *
 417              *******************************************************************************/
 418              uint8 UART_1_ReadRxData(void) 
 419              {
 420   1              uint8 rxData;
 421   1      
 422   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 8   

                          /* Disable Rx interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_DisableRxInt();
                          #endif /* UART_1_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = UART_1_rxBufferRead;
                          loc_rxBufferWrite = UART_1_rxBufferWrite;
              
                          if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = UART_1_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
              
                              if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              UART_1_rxBufferRead = loc_rxBufferRead;
              
                              if(UART_1_rxBufferLoopDetect != 0u )
                              {
                                  UART_1_rxBufferLoopDetect = 0u;
                                  #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) && \
                                       (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_1_HD_ENABLED )
                                          if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only in RX
                                              *  configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_1_HD_ENABLED */
                                  #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
                          }
                          else
                          {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                              rxData = UART_1_RXDATA_REG;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_EnableRxInt();
                          #endif /* End UART_1_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 476   1      
 477   1                  /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478   1                  rxData = UART_1_RXDATA_REG;
 479   1      
 480   1              #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 481   1      
 482   1              return(rxData);
 483   1          }
 484          
 485          
 486              /*******************************************************************************
 487              * Function Name: UART_1_ReadRxStatus
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 9   

 488              ********************************************************************************
 489              *
 490              * Summary:
 491              *  Read the current state of the status register
 492              *  And detect software buffer overflow.
 493              *
 494              * Parameters:
 495              *  None.
 496              *
 497              * Return:
 498              *  Current state of the status register.
 499              *
 500              * Global Variables:
 501              *  UART_1_rxBufferOverflow - used to indicate overload condition.
 502              *   It set to one in RX interrupt when there isn?t free space in
 503              *   UART_1_rxBufferRead to write new data. This condition returned
 504              *   and cleared to zero by this API as an
 505              *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506              *   bits.
 507              *
 508              *******************************************************************************/
 509              uint8 UART_1_ReadRxStatus(void) 
 510              {
 511   1              uint8 status;
 512   1      
 513   1              status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 514   1      
 515   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
                          if( UART_1_rxBufferOverflow != 0u )
                          {
                              status |= UART_1_RX_STS_SOFT_BUFF_OVER;
                              UART_1_rxBufferOverflow = 0u;
                          }
                      #endif /* UART_1_RXBUFFERSIZE */
 522   1      
 523   1              return(status);
 524   1          }
 525          
 526          
 527              /*******************************************************************************
 528              * Function Name: UART_1_GetChar
 529              ********************************************************************************
 530              *
 531              * Summary:
 532              *  Reads UART RX buffer immediately, if data is not available or an error
 533              *  condition exists, zero is returned; otherwise, character is read and
 534              *  returned.
 535              *
 536              * Parameters:
 537              *  None.
 538              *
 539              * Return:
 540              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541              *  A returned zero signifies an error condition or no data available.
 542              *
 543              * Global Variables:
 544              *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 545              *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 546              *     checked to identify new data.
 547              *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 548              *     incremented after each byte has been read from buffer.
 549              *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 10  

 550              *     in RX ISR.
 551              *
 552              * Reentrant:
 553              *  No.
 554              *
 555              *******************************************************************************/
 556              uint8 UART_1_GetChar(void) 
 557              {
 558   1              uint8 rxData = 0u;
 559   1              uint8 rxStatus;
 560   1      
 561   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
                          /* Disable Rx interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_DisableRxInt();
                          #endif /* UART_1_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = UART_1_rxBufferRead;
                          loc_rxBufferWrite = UART_1_rxBufferWrite;
              
                          if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = UART_1_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
                              if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              UART_1_rxBufferRead = loc_rxBufferRead;
              
                              if(UART_1_rxBufferLoopDetect > 0u )
                              {
                                  UART_1_rxBufferLoopDetect = 0u;
                                  #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_1_HD_ENABLED )
                                          if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only if
                                              *  RX configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_1_HD_ENABLED */
                                  #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
              
                          }
                          else
                          {   rxStatus = UART_1_RXSTATUS_REG;
                              if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
                              {   /* Read received data from FIFO*/
                                  rxData = UART_1_RXDATA_REG;
                                  /*Check status on error*/
                                  if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
                                                 UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
                                  {
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 11  

                                      rxData = 0u;
                                  }
                              }
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_EnableRxInt();
                          #endif /* UART_1_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 623   1      
 624   1                  rxStatus =UART_1_RXSTATUS_REG;
 625   1                  if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 626   1                  {   /* Read received data from FIFO*/
 627   2                      rxData = UART_1_RXDATA_REG;
 628   2                      /*Check status on error*/
 629   2                      if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 630   2                                     UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 631   2                      {
 632   3                          rxData = 0u;
 633   3                      }
 634   2                  }
 635   1              #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 636   1      
 637   1              return(rxData);
 638   1          }
 639          
 640          
 641              /*******************************************************************************
 642              * Function Name: UART_1_GetByte
 643              ********************************************************************************
 644              *
 645              * Summary:
 646              *  Grab the next available byte of data from the recieve FIFO
 647              *
 648              * Parameters:
 649              *  None.
 650              *
 651              * Return:
 652              *  MSB contains Status Register and LSB contains UART RX data
 653              *
 654              * Reentrant:
 655              *  No.
 656              *
 657              *******************************************************************************/
 658              uint16 UART_1_GetByte(void) 
 659              {
 660   1              return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 661   1          }
 662          
 663          
 664              /*******************************************************************************
 665              * Function Name: UART_1_GetRxBufferSize
 666              ********************************************************************************
 667              *
 668              * Summary:
 669              *  Determine the amount of bytes left in the RX buffer and return the count in
 670              *  bytes
 671              *
 672              * Parameters:
 673              *  None.
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 12  

 674              *
 675              * Return:
 676              *  uint8: Integer count of the number of bytes left
 677              *  in the RX buffer
 678              *
 679              * Global Variables:
 680              *  UART_1_rxBufferWrite - used to calculate left bytes.
 681              *  UART_1_rxBufferRead - used to calculate left bytes.
 682              *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 683              *
 684              * Reentrant:
 685              *  No.
 686              *
 687              * Theory:
 688              *  Allows the user to find out how full the RX Buffer is.
 689              *
 690              *******************************************************************************/
 691              uint8 UART_1_GetRxBufferSize(void)
 692                                                                      
 693              {
 694   1              uint8 size;
 695   1      
 696   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_DisableRxInt();
                          #endif /* UART_1_RX_INTERRUPT_ENABLED */
              
                          if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
                          {
                              if(UART_1_rxBufferLoopDetect > 0u)
                              {
                                  size = UART_1_RXBUFFERSIZE;
                              }
                              else
                              {
                                  size = 0u;
                              }
                          }
                          else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
                          {
                              size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
                          }
                          else
                          {
                              size = (UART_1_RXBUFFERSIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_EnableRxInt();
                          #endif /* End UART_1_RX_INTERRUPT_ENABLED */
              
                      #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 730   1      
 731   1                  /* We can only know if there is data in the fifo. */
 732   1                  size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 733   1      
 734   1              #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 735   1      
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 13  

 736   1              return(size);
 737   1          }
 738          
 739          
 740              /*******************************************************************************
 741              * Function Name: UART_1_ClearRxBuffer
 742              ********************************************************************************
 743              *
 744              * Summary:
 745              *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746              *  Clears hardware RX FIFO.
 747              *
 748              * Parameters:
 749              *  None.
 750              *
 751              * Return:
 752              *  None.
 753              *
 754              * Global Variables:
 755              *  UART_1_rxBufferWrite - cleared to zero.
 756              *  UART_1_rxBufferRead - cleared to zero.
 757              *  UART_1_rxBufferLoopDetect - cleared to zero.
 758              *  UART_1_rxBufferOverflow - cleared to zero.
 759              *
 760              * Reentrant:
 761              *  No.
 762              *
 763              * Theory:
 764              *  Setting the pointers to zero makes the system believe there is no data to
 765              *  read and writing will resume at address 0 overwriting any data that may
 766              *  have remained in the RAM.
 767              *
 768              * Side Effects:
 769              *  Any received data not read from the RAM or FIFO buffer will be lost.
 770              *******************************************************************************/
 771              void UART_1_ClearRxBuffer(void) 
 772              {
 773   1              uint8 enableInterrupts;
 774   1      
 775   1              /* clear the HW FIFO */
 776   1              /* Enter critical section */
 777   1              enableInterrupts = CyEnterCriticalSection();
 778   1              UART_1_RXDATA_AUX_CTL_REG |=  UART_1_RX_FIFO_CLR;
 779   1              UART_1_RXDATA_AUX_CTL_REG &= (uint8)~UART_1_RX_FIFO_CLR;
 780   1              /* Exit critical section */
 781   1              CyExitCriticalSection(enableInterrupts);
 782   1      
 783   1              #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_DisableRxInt();
                          #endif /* End UART_1_RX_INTERRUPT_ENABLED */
              
                          UART_1_rxBufferRead = 0u;
                          UART_1_rxBufferWrite = 0u;
                          UART_1_rxBufferLoopDetect = 0u;
                          UART_1_rxBufferOverflow = 0u;
              
                          /* Enable Rx interrupt. */
                          #if(UART_1_RX_INTERRUPT_ENABLED)
                              UART_1_EnableRxInt();
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 14  

                          #endif /* End UART_1_RX_INTERRUPT_ENABLED */
                      #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 800   1      
 801   1          }
 802          
 803          
 804              /*******************************************************************************
 805              * Function Name: UART_1_SetRxAddressMode
 806              ********************************************************************************
 807              *
 808              * Summary:
 809              *  Set the receive addressing mode
 810              *
 811              * Parameters:
 812              *  addressMode: Enumerated value indicating the mode of RX addressing
 813              *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814              *                                               detection
 815              *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816              *                                               address detection
 817              *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818              *                                               detection
 819              *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820              *                                               address detection
 821              *  UART_1__B_UART__AM_NONE - No address detection
 822              *
 823              * Return:
 824              *  None.
 825              *
 826              * Global Variables:
 827              *  UART_1_rxAddressMode - the parameter stored in this variable for
 828              *   the farther usage in RX ISR.
 829              *  UART_1_rxAddressDetected - set to initial state (0).
 830              *
 831              *******************************************************************************/
 832              void UART_1_SetRxAddressMode(uint8 addressMode)
 833                                                                  
 834              {
 835   1              #if(UART_1_RXHW_ADDRESS_ENABLED)
                          #if(UART_1_CONTROL_REG_REMOVED)
                              if(addressMode != 0u) { }     /* release compiler warning */
                          #else /* UART_1_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
                              UART_1_CONTROL_REG = tmpCtrl;
                              #if(UART_1_RX_INTERRUPT_ENABLED && \
                                 (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
                                  UART_1_rxAddressMode = addressMode;
                                  UART_1_rxAddressDetected = 0u;
                              #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
                          #endif /* End UART_1_CONTROL_REG_REMOVED */
                      #else /* UART_1_RXHW_ADDRESS_ENABLED */
 850   1                  if(addressMode != 0u) { }     /* release compiler warning */
 851   1              #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 852   1          }
 853          
 854          
 855              /*******************************************************************************
 856              * Function Name: UART_1_SetRxAddress1
 857              ********************************************************************************
 858              *
 859              * Summary:
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 15  

 860              *  Set the first hardware address compare value
 861              *
 862              * Parameters:
 863              *  address
 864              *
 865              * Return:
 866              *  None.
 867              *
 868              *******************************************************************************/
 869              void UART_1_SetRxAddress1(uint8 address) 
 870          
 871              {
 872   1              UART_1_RXADDRESS1_REG = address;
 873   1          }
 874          
 875          
 876              /*******************************************************************************
 877              * Function Name: UART_1_SetRxAddress2
 878              ********************************************************************************
 879              *
 880              * Summary:
 881              *  Set the second hardware address compare value
 882              *
 883              * Parameters:
 884              *  address
 885              *
 886              * Return:
 887              *  None.
 888              *
 889              *******************************************************************************/
 890              void UART_1_SetRxAddress2(uint8 address) 
 891              {
 892   1              UART_1_RXADDRESS2_REG = address;
 893   1          }
 894          
 895          #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 896          
 897          
 898          #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 899          
 900              #if(UART_1_TX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: UART_1_EnableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_1_EnableTxInt(void) 
                      {
                          CyIntEnable(UART_1_TX_VECT_NUM);
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 16  

                      }
              
              
                      /*******************************************************************************
                      * Function Name: UART_1_DisableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void UART_1_DisableTxInt(void) 
                      {
                          CyIntDisable(UART_1_TX_VECT_NUM);
                      }
              
                  #endif /* UART_1_TX_INTERRUPT_ENABLED */
 948          
 949          
 950              /*******************************************************************************
 951              * Function Name: UART_1_SetTxInterruptMode
 952              ********************************************************************************
 953              *
 954              * Summary:
 955              *  Configure which status bits trigger an interrupt event
 956              *
 957              * Parameters:
 958              *  intSrc: An or'd combination of the desired status bit masks (defined in
 959              *          the header file)
 960              *
 961              * Return:
 962              *  None.
 963              *
 964              * Theory:
 965              *  Enables the output of specific status bits to the interrupt controller
 966              *
 967              *******************************************************************************/
 968              void UART_1_SetTxInterruptMode(uint8 intSrc) 
 969              {
 970   1              UART_1_TXSTATUS_MASK_REG = intSrc;
 971   1          }
 972          
 973          
 974              /*******************************************************************************
 975              * Function Name: UART_1_WriteTxData
 976              ********************************************************************************
 977              *
 978              * Summary:
 979              *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980              *  bus is available. WriteTxData sends a byte without checking for buffer room
 981              *  or status. It is up to the user to separately check status.
 982              *
 983              * Parameters:
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 17  

 984              *  TXDataByte: byte of data to place in the transmit FIFO
 985              *
 986              * Return:
 987              * void
 988              *
 989              * Global Variables:
 990              *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 991              *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 992              *    incremented after each byte saved to buffer.
 993              *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 994              *    checked to identify the condition to write to FIFO directly or to TX buffer
 995              *  UART_1_initVar - checked to identify that the component has been
 996              *    initialized.
 997              *
 998              * Reentrant:
 999              *  No.
1000              *
1001              *******************************************************************************/
1002              void UART_1_WriteTxData(uint8 txDataByte) 
1003              {
1004   1              /* If not Initialized then skip this function*/
1005   1              if(UART_1_initVar != 0u)
1006   1              {
1007   2                  #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
              
                              /* Disable Tx interrupt. */
                              /* Protect variables that could change on interrupt. */
                              #if(UART_1_TX_INTERRUPT_ENABLED)
                                  UART_1_DisableTxInt();
                              #endif /* End UART_1_TX_INTERRUPT_ENABLED */
              
                              if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
                                  ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
                              {
                                  /* Add directly to the FIFO. */
                                  UART_1_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(UART_1_txBufferWrite >= UART_1_TXBUFFERSIZE)
                                  {
                                      UART_1_txBufferWrite = 0u;
                                  }
              
                                  UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
              
                                  /* Add to the software buffer. */
                                  UART_1_txBufferWrite++;
              
                              }
              
                              /* Enable Tx interrupt. */
                              #if(UART_1_TX_INTERRUPT_ENABLED)
                                  UART_1_EnableTxInt();
                              #endif /* End UART_1_TX_INTERRUPT_ENABLED */
              
                          #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1041   2      
1042   2                      /* Add directly to the FIFO. */
1043   2                      UART_1_TXDATA_REG = txDataByte;
1044   2      
1045   2                  #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 18  

1046   2              }
1047   1          }
1048          
1049          
1050              /*******************************************************************************
1051              * Function Name: UART_1_ReadTxStatus
1052              ********************************************************************************
1053              *
1054              * Summary:
1055              *  Read the status register for the component
1056              *
1057              * Parameters:
1058              *  None.
1059              *
1060              * Return:
1061              *  Contents of the status register
1062              *
1063              * Theory:
1064              *  This function reads the status register which is clear on read. It is up to
1065              *  the user to handle all bits in this return value accordingly, even if the bit
1066              *  was not enabled as an interrupt source the event happened and must be handled
1067              *  accordingly.
1068              *
1069              *******************************************************************************/
1070              uint8 UART_1_ReadTxStatus(void) 
1071              {
1072   1              return(UART_1_TXSTATUS_REG);
1073   1          }
1074          
1075          
1076              /*******************************************************************************
1077              * Function Name: UART_1_PutChar
1078              ********************************************************************************
1079              *
1080              * Summary:
1081              *  Wait to send byte until TX register or buffer has room.
1082              *
1083              * Parameters:
1084              *  txDataByte: The 8-bit data value to send across the UART.
1085              *
1086              * Return:
1087              *  None.
1088              *
1089              * Global Variables:
1090              *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1091              *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1092              *     checked to identify free space in txBuffer and incremented after each byte
1093              *     saved to buffer.
1094              *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1095              *     checked to identify free space in txBuffer.
1096              *  UART_1_initVar - checked to identify that the component has been
1097              *     initialized.
1098              *
1099              * Reentrant:
1100              *  No.
1101              *
1102              * Theory:
1103              *  Allows the user to transmit any byte of data in a single transfer
1104              *
1105              *******************************************************************************/
1106              void UART_1_PutChar(uint8 txDataByte) 
1107              {
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 19  

1108   1                  #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
                              /* The temporary output pointer is used since it takes two instructions
                              *  to increment with a wrap, and we can't risk doing that with the real
                              *  pointer and getting an interrupt in between instructions.
                              */
                              uint8 loc_txBufferWrite;
                              uint8 loc_txBufferRead;
              
                              do{
                                  /* Block if software buffer is full, so we don't overwrite. */
                                  #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Disable TX interrupt to protect variables that could change on interrupt */
                                      CyIntDisable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                                  loc_txBufferWrite = UART_1_txBufferWrite;
                                  loc_txBufferRead = UART_1_txBufferRead;
                                  #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Enable interrupt to continue transmission */
                                      CyIntEnable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                              }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBufferRead -
             - 1u)) :
                                                      ((loc_txBufferWrite - loc_txBufferRead) ==
                                                      (uint8)(UART_1_TXBUFFERSIZE - 1u)) );
              
                              if( (loc_txBufferRead == loc_txBufferWrite) &&
                                  ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
                              {
                                  /* Add directly to the FIFO. */
                                  UART_1_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(loc_txBufferWrite >= UART_1_TXBUFFERSIZE)
                                  {
                                      loc_txBufferWrite = 0u;
                                  }
                                  /* Add to the software buffer. */
                                  UART_1_txBuffer[loc_txBufferWrite] = txDataByte;
                                  loc_txBufferWrite++;
              
                                  /* Finally, update the real output pointer */
                                  #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntDisable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                                  UART_1_txBufferWrite = loc_txBufferWrite;
                                  #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntEnable(UART_1_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                              }
              
                          #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1159   1      
1160   1                      while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
1161   1                      {
1162   2                          ; /* Wait for room in the FIFO. */
1163   2                      }
1164   1      
1165   1                      /* Add directly to the FIFO. */
1166   1                      UART_1_TXDATA_REG = txDataByte;
1167   1      
1168   1                  #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 20  

1169   1          }
1170          
1171          
1172              /*******************************************************************************
1173              * Function Name: UART_1_PutString
1174              ********************************************************************************
1175              *
1176              * Summary:
1177              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178              *
1179              * Parameters:
1180              *  string: char pointer to character string of Data to Send.
1181              *
1182              * Return:
1183              *  None.
1184              *
1185              * Global Variables:
1186              *  UART_1_initVar - checked to identify that the component has been
1187              *     initialized.
1188              *
1189              * Reentrant:
1190              *  No.
1191              *
1192              * Theory:
1193              *  This function will block if there is not enough memory to place the whole
1194              *  string, it will block until the entire string has been written to the
1195              *  transmit buffer.
1196              *
1197              *******************************************************************************/
1198              void UART_1_PutString(const char8 string[]) 
1199              {
1200   1              uint16 buf_index = 0u;
1201   1              /* If not Initialized then skip this function*/
1202   1              if(UART_1_initVar != 0u)
1203   1              {
1204   2                  /* This is a blocking function, it will not exit until all data is sent*/
1205   2                  while(string[buf_index] != (char8)0)
1206   2                  {
1207   3                      UART_1_PutChar((uint8)string[buf_index]);
1208   3                      buf_index++;
1209   3                  }
1210   2              }
1211   1          }
1212          
1213          
1214              /*******************************************************************************
1215              * Function Name: UART_1_PutArray
1216              ********************************************************************************
1217              *
1218              * Summary:
1219              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220              *
1221              * Parameters:
1222              *  string: Address of the memory array residing in RAM or ROM.
1223              *  byteCount: Number of Bytes to be transmitted.
1224              *
1225              * Return:
1226              *  None.
1227              *
1228              * Global Variables:
1229              *  UART_1_initVar - checked to identify that the component has been
1230              *     initialized.
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 21  

1231              *
1232              * Reentrant:
1233              *  No.
1234              *
1235              *******************************************************************************/
1236              void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1237                                                                              
1238              {
1239   1              uint8 buf_index = 0u;
1240   1              /* If not Initialized then skip this function*/
1241   1              if(UART_1_initVar != 0u)
1242   1              {
1243   2                  do
1244   2                  {
1245   3                      UART_1_PutChar(string[buf_index]);
1246   3                      buf_index++;
1247   3                  }while(buf_index < byteCount);
1248   2              }
1249   1          }
1250          
1251          
1252              /*******************************************************************************
1253              * Function Name: UART_1_PutCRLF
1254              ********************************************************************************
1255              *
1256              * Summary:
1257              *  Write a character and then carriage return and line feed.
1258              *
1259              * Parameters:
1260              *  txDataByte: uint8 Character to send.
1261              *
1262              * Return:
1263              *  None.
1264              *
1265              * Global Variables:
1266              *  UART_1_initVar - checked to identify that the component has been
1267              *     initialized.
1268              *
1269              * Reentrant:
1270              *  No.
1271              *
1272              *******************************************************************************/
1273              void UART_1_PutCRLF(uint8 txDataByte) 
1274              {
1275   1              /* If not Initialized then skip this function*/
1276   1              if(UART_1_initVar != 0u)
1277   1              {
1278   2                  UART_1_PutChar(txDataByte);
1279   2                  UART_1_PutChar(0x0Du);
1280   2                  UART_1_PutChar(0x0Au);
1281   2              }
1282   1          }
1283          
1284          
1285              /*******************************************************************************
1286              * Function Name: UART_1_GetTxBufferSize
1287              ********************************************************************************
1288              *
1289              * Summary:
1290              *  Determine the amount of space left in the TX buffer and return the count in
1291              *  bytes
1292              *
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 22  

1293              * Parameters:
1294              *  None.
1295              *
1296              * Return:
1297              *  Integer count of the number of bytes left in the TX buffer
1298              *
1299              * Global Variables:
1300              *  UART_1_txBufferWrite - used to calculate left space.
1301              *  UART_1_txBufferRead - used to calculate left space.
1302              *
1303              * Reentrant:
1304              *  No.
1305              *
1306              * Theory:
1307              *  Allows the user to find out how full the TX Buffer is.
1308              *
1309              *******************************************************************************/
1310              uint8 UART_1_GetTxBufferSize(void)
1311                                                                      
1312              {
1313   1              uint8 size;
1314   1      
1315   1              #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_1_TX_INTERRUPT_ENABLED)
                              UART_1_DisableTxInt();
                          #endif /* End UART_1_TX_INTERRUPT_ENABLED */
              
                          if(UART_1_txBufferRead == UART_1_txBufferWrite)
                          {
                              size = 0u;
                          }
                          else if(UART_1_txBufferRead < UART_1_txBufferWrite)
                          {
                              size = (UART_1_txBufferWrite - UART_1_txBufferRead);
                          }
                          else
                          {
                              size = (UART_1_TXBUFFERSIZE - UART_1_txBufferRead) + UART_1_txBufferWrite;
                          }
              
                          /* Enable Tx interrupt. */
                          #if(UART_1_TX_INTERRUPT_ENABLED)
                              UART_1_EnableTxInt();
                          #endif /* End UART_1_TX_INTERRUPT_ENABLED */
              
                      #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1342   1      
1343   1                  size = UART_1_TXSTATUS_REG;
1344   1      
1345   1                  /* Is the fifo is full. */
1346   1                  if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
1347   1                  {
1348   2                      size = UART_1_FIFO_LENGTH;
1349   2                  }
1350   1                  else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
1351   1                  {
1352   2                      size = 0u;
1353   2                  }
1354   1                  else
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 23  

1355   1                  {
1356   2                      /* We only know there is data in the fifo. */
1357   2                      size = 1u;
1358   2                  }
1359   1      
1360   1              #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1361   1      
1362   1              return(size);
1363   1          }
1364          
1365          
1366              /*******************************************************************************
1367              * Function Name: UART_1_ClearTxBuffer
1368              ********************************************************************************
1369              *
1370              * Summary:
1371              *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372              *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373              *
1374              * Parameters:
1375              *  None.
1376              *
1377              * Return:
1378              *  None.
1379              *
1380              * Global Variables:
1381              *  UART_1_txBufferWrite - cleared to zero.
1382              *  UART_1_txBufferRead - cleared to zero.
1383              *
1384              * Reentrant:
1385              *  No.
1386              *
1387              * Theory:
1388              *  Setting the pointers to zero makes the system believe there is no data to
1389              *  read and writing will resume at address 0 overwriting any data that may have
1390              *  remained in the RAM.
1391              *
1392              * Side Effects:
1393              *  Any received data not read from the RAM buffer will be lost when overwritten.
1394              *
1395              *******************************************************************************/
1396              void UART_1_ClearTxBuffer(void) 
1397              {
1398   1              uint8 enableInterrupts;
1399   1      
1400   1              /* Enter critical section */
1401   1              enableInterrupts = CyEnterCriticalSection();
1402   1              /* clear the HW FIFO */
1403   1              UART_1_TXDATA_AUX_CTL_REG |=  UART_1_TX_FIFO_CLR;
1404   1              UART_1_TXDATA_AUX_CTL_REG &= (uint8)~UART_1_TX_FIFO_CLR;
1405   1              /* Exit critical section */
1406   1              CyExitCriticalSection(enableInterrupts);
1407   1      
1408   1              #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(UART_1_TX_INTERRUPT_ENABLED)
                              UART_1_DisableTxInt();
                          #endif /* End UART_1_TX_INTERRUPT_ENABLED */
              
                          UART_1_txBufferRead = 0u;
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 24  

                          UART_1_txBufferWrite = 0u;
              
                          /* Enable Tx interrupt. */
                          #if(UART_1_TX_INTERRUPT_ENABLED)
                              UART_1_EnableTxInt();
                          #endif /* End UART_1_TX_INTERRUPT_ENABLED */
              
                      #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1425   1          }
1426          
1427          
1428              /*******************************************************************************
1429              * Function Name: UART_1_SendBreak
1430              ********************************************************************************
1431              *
1432              * Summary:
1433              *  Write a Break command to the UART
1434              *
1435              * Parameters:
1436              *  uint8 retMode:  Wait mode,
1437              *   0 - Initialize registers for Break, sends the Break signal and return
1438              *       imediately.
1439              *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440              *       transmission mode then return.
1441              *   2 - Reinitialize registers to normal transmission mode then return.
1442              *   3 - both steps: 0 and 1
1443              *       init registers for Break, send Break signal
1444              *       wait until Break sending is complete, reinit registers to normal
1445              *       transmission mode then return.
1446              *
1447              * Return:
1448              *  None.
1449              *
1450              * Global Variables:
1451              *  UART_1_initVar - checked to identify that the component has been
1452              *     initialized.
1453              *  tx_period - static variable, used for keeping TX period configuration.
1454              *
1455              * Reentrant:
1456              *  No.
1457              *
1458              * Theory:
1459              *  SendBreak function initializes registers to send 13-bit break signal. It is
1460              *  important to return the registers configuration to normal for continue 8-bit
1461              *  operation.
1462              *  Trere are 3 variants for this API usage:
1463              *  1) SendBreak(3) - function will send the Break signal and take care on the
1464              *     configuration returning. Funcition will block CPU untill transmition
1465              *     complete.
1466              *  2) User may want to use bloking time if UART configured to the low speed
1467              *     operation
1468              *     Emample for this case:
1469              *     SendBreak(0);     - init Break signal transmition
1470              *         Add your code here to use CPU time
1471              *     SendBreak(1);     - complete Break operation
1472              *  3) Same to 2) but user may want to init and use the interrupt for complete
1473              *     break operation.
1474              *     Example for this case:
1475              *     Init TX interrupt whith "TX - On TX Complete" parameter
1476              *     SendBreak(0);     - init Break signal transmition
1477              *         Add your code here to use CPU time
1478              *     When interrupt appear with UART_TX_STS_COMPLETE status:
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 25  

1479              *     SendBreak(2);     - complete Break operation
1480              *
1481              * Side Effects:
1482              *   Uses static variable to keep registers configuration.
1483              *
1484              *******************************************************************************/
1485              void UART_1_SendBreak(uint8 retMode) 
1486              {
1487   1      
1488   1              /* If not Initialized then skip this function*/
1489   1              if(UART_1_initVar != 0u)
1490   1              {
1491   2                  /*Set the Counter to 13-bits and transmit a 00 byte*/
1492   2                  /*When that is done then reset the counter value back*/
1493   2                  uint8 tmpStat;
1494   2      
1495   2                  #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == UART_1_SEND_BREAK) ||
                                  (retMode == UART_1_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                        UART_1_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  UART_1_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = UART_1_TXSTATUS_REG;
                                  }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
                              }
              
                              if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_1_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = UART_1_TXSTATUS_REG;
                                  }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
                              }
              
                              if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_1_REINIT) ||
                                  (retMode == UART_1_SEND_WAIT_REINIT) )
                              {
                                  UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                (uint8)~UART_1_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* UART_1_HD_ENABLED Full Duplex mode */
1530   2      
1531   2                      static uint8 tx_period;
1532   2      
1533   2                      if( (retMode == UART_1_SEND_BREAK) ||
1534   2                          (retMode == UART_1_SEND_WAIT_REINIT) )
1535   2                      {
1536   3                          /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode*/
1537   3                          #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1538   3                                              (UART_1_PARITY_TYPE_SW != 0u) )
                                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                            UART_1_CTRL_HD_SEND_BREAK);
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 26  

                                  #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1542   3      
1543   3                          #if(UART_1_TXCLKGEN_DP)
1544   3                              tx_period = UART_1_TXBITCLKTX_COMPLETE_REG;
1545   3                              UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
1546   3                          #else
                                      tx_period = UART_1_TXBITCTR_PERIOD_REG;
                                      UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
                                  #endif /* End UART_1_TXCLKGEN_DP */
1550   3      
1551   3                          /* Send zeros*/
1552   3                          UART_1_TXDATA_REG = 0u;
1553   3      
1554   3                          do /* wait until transmit starts */
1555   3                          {
1556   4                              tmpStat = UART_1_TXSTATUS_REG;
1557   4                          }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1558   3                      }
1559   2      
1560   2                      if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1561   2                          (retMode == UART_1_SEND_WAIT_REINIT) )
1562   2                      {
1563   3                          do /*wait until transmit complete*/
1564   3                          {
1565   4                              tmpStat = UART_1_TXSTATUS_REG;
1566   4                          }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1567   3                      }
1568   2      
1569   2                      if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1570   2                          (retMode == UART_1_REINIT) ||
1571   2                          (retMode == UART_1_SEND_WAIT_REINIT) )
1572   2                      {
1573   3      
1574   3                          #if(UART_1_TXCLKGEN_DP)
1575   3                              UART_1_TXBITCLKTX_COMPLETE_REG = tx_period;
1576   3                          #else
                                      UART_1_TXBITCTR_PERIOD_REG = tx_period;
                                  #endif /* End UART_1_TXCLKGEN_DP */
1579   3      
1580   3                          #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1581   3                               (UART_1_PARITY_TYPE_SW != 0u) )
                                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                    (uint8)~UART_1_CTRL_HD_SEND_BREAK);
                                  #endif /* End UART_1_PARITY_TYPE != NONE */
1585   3                      }
1586   2                  #endif    /* End UART_1_HD_ENABLED */
1587   2              }
1588   1          }
1589          
1590          
1591              /*******************************************************************************
1592              * Function Name: UART_1_SetTxAddressMode
1593              ********************************************************************************
1594              *
1595              * Summary:
1596              *  Set the transmit addressing mode
1597              *
1598              * Parameters:
1599              *  addressMode: 0 -> Space
1600              *               1 -> Mark
1601              *
1602              * Return:
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 27  

1603              *  None.
1604              *
1605              *******************************************************************************/
1606              void UART_1_SetTxAddressMode(uint8 addressMode) 
1607              {
1608   1              /* Mark/Space sending enable*/
1609   1              if(addressMode != 0u)
1610   1              {
1611   2                  #if( UART_1_CONTROL_REG_REMOVED == 0u )
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
                                                                    UART_1_CTRL_MARK);
                          #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1615   2              }
1616   1              else
1617   1              {
1618   2                  #if( UART_1_CONTROL_REG_REMOVED == 0u )
                              UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                                  (uint8)~UART_1_CTRL_MARK);
                          #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1622   2              }
1623   1          }
1624          
1625          #endif  /* EndUART_1_TX_ENABLED */
1626          
1627          #if(UART_1_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART.
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void UART_1_LoadTxConfig(void) 
                  {
                      #if((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          UART_1_SetRxInterruptMode(0u);
                      #endif /* UART_1_RX_INTERRUPT_ENABLED */
              
                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() | UART_1_CTRL_HD_SEND);
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_HD_TXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_1_RXSTATUS_PTR);
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 28  

                      #endif /* CY_UDB_V0 */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_1_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer
                  *  has been used.
                  *
                  *******************************************************************************/
                  void UART_1_LoadRxConfig(void) 
                  {
                      UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
                                                              (uint8)~UART_1_CTRL_HD_SEND);
                      UART_1_RXBITCTR_PERIOD_REG = UART_1_HD_RXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(UART_1_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
              
                      #if((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
                          /* Enable RX interrupt after set RX configuration */
                          UART_1_SetRxInterruptMode(UART_1_INIT_RX_INTERRUPTS_MASK);
                      #endif /* UART_1_RX_INTERRUPT_ENABLED */
                  }
              
              #endif  /* UART_1_HD_ENABLED */
1710          
1711          
1712          /* [] END OF FILE */
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_1_Start (BEGIN)
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 76
0000 900000      R     MOV     DPTR,#UART_1_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 78
0008 120000      R     LCALL   UART_1_Init
                                           ; SOURCE LINE # 79
000B 900000      R     MOV     DPTR,#UART_1_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
0011         ?C0001:
                                           ; SOURCE LINE # 81
0011 120000      R     LCALL   UART_1_Enable
                                           ; SOURCE LINE # 82
0014 22                RET     
             ; FUNCTION UART_1_Start (END)

             ; FUNCTION UART_1_Init (BEGIN)
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 118
0000 906488            MOV     DPTR,#06488H
0003 7472              MOV     A,#072H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
0006 90648C            MOV     DPTR,#0648CH
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 132
000B 90642D            MOV     DPTR,#0642DH
000E 7407              MOV     A,#07H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
0011 90643D            MOV     DPTR,#0643DH
0014 7448              MOV     A,#048H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 144
0017 90648A            MOV     DPTR,#0648AH
001A E4                CLR     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
001C 22                RET     
             ; FUNCTION UART_1_Init (END)

             ; FUNCTION UART_1_Enable (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 30  

                                           ; SOURCE LINE # 181
0008 906498            MOV     DPTR,#06498H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
0013 90649C            MOV     DPTR,#0649CH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
001E 90649A            MOV     DPTR,#0649AH
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 4410              ORL     A,#010H
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0029 120000      E     LCALL   UART_1_IntClock_Start
                                           ; SOURCE LINE # 209
002C 900000      R     MOV     DPTR,#enableInterrupts
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 210
0034 22                RET     
             ; FUNCTION UART_1_Enable (END)

             ; FUNCTION UART_1_Stop (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 230
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
0008 906498            MOV     DPTR,#06498H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
0013 120000      E     LCALL   UART_1_IntClock_Stop
                                           ; SOURCE LINE # 250
0016 90649C            MOV     DPTR,#0649CH
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 31  

001C 54EF              ANL     A,#0EFH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0021 90649A            MOV     DPTR,#0649AH
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 54EF              ANL     A,#0EFH
0029 FF                MOV     R7,A
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
002C 900000      R     MOV     DPTR,#enableInterrupts
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 264
0034 22                RET     
             ; FUNCTION UART_1_Stop (END)

             ; FUNCTION UART_1_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 284
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 288
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_1_ReadControlRegister (END)

             ; FUNCTION _UART_1_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 305
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 312
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_1_WriteControlRegister (END)

             ; FUNCTION _UART_1_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 385
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648C            MOV     DPTR,#0648CH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
000F 22                RET     
             ; FUNCTION _UART_1_SetRxInterruptMode (END)

             ; FUNCTION UART_1_ReadRxData (BEGIN)
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 32  

                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 478
0000 90644C            MOV     DPTR,#0644CH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#rxData
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
000A 900000      R     MOV     DPTR,#rxData
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 483
000F         ?C0010:
000F 22                RET     
             ; FUNCTION UART_1_ReadRxData (END)

             ; FUNCTION UART_1_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
                                           ; SOURCE LINE # 513
0000 90646C            MOV     DPTR,#0646CH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#status
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
000E 900000      R     MOV     DPTR,#status
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
                                           ; SOURCE LINE # 524
0013         ?C0011:
0013 22                RET     
             ; FUNCTION UART_1_ReadRxStatus (END)

             ; FUNCTION UART_1_GetChar (BEGIN)
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 624
0005 90646C            MOV     DPTR,#0646CH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#rxStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 625
000F 900000      R     MOV     DPTR,#rxStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 30E51E            JNB     ACC.5,?C0012
                                           ; SOURCE LINE # 626
                                           ; SOURCE LINE # 627
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 33  

0018 90644C            MOV     DPTR,#0644CH
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#rxData
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
0022 900000      R     MOV     DPTR,#rxStatus
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 541E              ANL     A,#01EH
002A FF                MOV     R7,A
002B 7E00              MOV     R6,#00H
002D EF                MOV     A,R7
002E 4E                ORL     A,R6
002F 6005              JZ      ?C0012
                                           ; SOURCE LINE # 631
                                           ; SOURCE LINE # 632
0031 900000      R     MOV     DPTR,#rxData
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 633
                                           ; SOURCE LINE # 634
0036         ?C0012:
                                           ; SOURCE LINE # 637
0036 900000      R     MOV     DPTR,#rxData
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
                                           ; SOURCE LINE # 638
003B         ?C0014:
003B 22                RET     
             ; FUNCTION UART_1_GetChar (END)

             ; FUNCTION UART_1_GetByte (BEGIN)
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0000 120000      R     LCALL   UART_1_ReadRxStatus
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 7D00              MOV     R5,#00H
0008 FC                MOV     R4,A
0009 120000      R     LCALL   UART_1_ReadRxData
000C 7E00              MOV     R6,#00H
000E EC                MOV     A,R4
000F 4E                ORL     A,R6
0010 FE                MOV     R6,A
0011 ED                MOV     A,R5
0012 4F                ORL     A,R7
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 661
0014         ?C0015:
0014 22                RET     
             ; FUNCTION UART_1_GetByte (END)

             ; FUNCTION UART_1_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 732
0000 90646C            MOV     DPTR,#0646CH
0003 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 34  

0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E504            JNB     ACC.5,?C0016
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0017
000D         ?C0016:
000D 7F00              MOV     R7,#00H
000F         ?C0017:
000F 900000      R     MOV     DPTR,#size
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 736
0014 900000      R     MOV     DPTR,#size
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
                                           ; SOURCE LINE # 737
0019         ?C0018:
0019 22                RET     
             ; FUNCTION UART_1_GetRxBufferSize (END)

             ; FUNCTION UART_1_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 777
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0008 90649C            MOV     DPTR,#0649CH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0013 90649C            MOV     DPTR,#0649CH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 801
0026 22                RET     
             ; FUNCTION UART_1_ClearRxBuffer (END)

             ; FUNCTION _UART_1_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 832
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 850
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 35  

                                           ; SOURCE LINE # 852
0005         ?C0021:
0005 22                RET     
             ; FUNCTION _UART_1_SetRxAddressMode (END)

             ; FUNCTION _UART_1_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 869
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90642C            MOV     DPTR,#0642CH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 873
000F 22                RET     
             ; FUNCTION _UART_1_SetRxAddress1 (END)

             ; FUNCTION _UART_1_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 890
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 891
                                           ; SOURCE LINE # 892
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90643C            MOV     DPTR,#0643CH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 893
000F 22                RET     
             ; FUNCTION _UART_1_SetRxAddress2 (END)

             ; FUNCTION _UART_1_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 968
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648A            MOV     DPTR,#0648AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 971
000F 22                RET     
             ; FUNCTION _UART_1_SetTxInterruptMode (END)

             ; FUNCTION _UART_1_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 1002
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1003
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 36  

                                           ; SOURCE LINE # 1005
0005 900000      R     MOV     DPTR,#UART_1_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600A              JZ      ?C0026
                                           ; SOURCE LINE # 1006
                                           ; SOURCE LINE # 1043
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 90644A            MOV     DPTR,#0644AH
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1046
                                           ; SOURCE LINE # 1047
0017         ?C0026:
0017 22                RET     
             ; FUNCTION _UART_1_WriteTxData (END)

             ; FUNCTION UART_1_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1070
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
0000 90646A            MOV     DPTR,#0646AH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1073
0005         ?C0027:
0005 22                RET     
             ; FUNCTION UART_1_ReadTxStatus (END)

             ; FUNCTION _UART_1_PutChar (BEGIN)
                                           ; SOURCE LINE # 1106
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1107
0005         ?C0028:
                                           ; SOURCE LINE # 1160
0005 90646A            MOV     DPTR,#0646AH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 20E2F7            JB      ACC.2,?C0028
                                           ; SOURCE LINE # 1161
                                           ; SOURCE LINE # 1163
000E         ?C0029:
                                           ; SOURCE LINE # 1166
000E 900000      R     MOV     DPTR,#txDataByte
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 90644A            MOV     DPTR,#0644AH
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1169
0018 22                RET     
             ; FUNCTION _UART_1_PutChar (END)

             ; FUNCTION _UART_1_PutString (BEGIN)
                                           ; SOURCE LINE # 1198
0000 900000      R     MOV     DPTR,#string
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 37  

0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1199
                                           ; SOURCE LINE # 1200
0006 900000      R     MOV     DPTR,#buf_index
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1202
000E 900000      R     MOV     DPTR,#UART_1_initVar
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6042              JZ      ?C0034
                                           ; SOURCE LINE # 1203
0016         ?C0032:
                                           ; SOURCE LINE # 1205
0016 900000      R     MOV     DPTR,#string
0019 120000      E     LCALL   ?C?PLDXDATA
001C 900000      R     MOV     DPTR,#buf_index
001F E0                MOVX    A,@DPTR
0020 FE                MOV     R6,A
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E9                MOV     A,R1
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 EA                MOV     A,R2
0028 3E                ADDC    A,R6
0029 FA                MOV     R2,A
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 6027              JZ      ?C0034
                                           ; SOURCE LINE # 1206
                                           ; SOURCE LINE # 1207
0031 900000      R     MOV     DPTR,#string
0034 120000      E     LCALL   ?C?PLDXDATA
0037 900000      R     MOV     DPTR,#buf_index
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F E9                MOV     A,R1
0040 2F                ADD     A,R7
0041 F9                MOV     R1,A
0042 EA                MOV     A,R2
0043 3E                ADDC    A,R6
0044 FA                MOV     R2,A
0045 120000      E     LCALL   ?C?CLDPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1208
004C 900000      R     MOV     DPTR,#buf_index
004F E4                CLR     A
0050 75F001            MOV     B,#01H
0053 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1209
0056 80BE              SJMP    ?C0032
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 38  

                                           ; SOURCE LINE # 1210
                                           ; SOURCE LINE # 1211
0058         ?C0034:
0058 22                RET     
             ; FUNCTION _UART_1_PutString (END)

             ; FUNCTION _UART_1_PutArray (BEGIN)
                                           ; SOURCE LINE # 1236
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
000B 900000      R     MOV     DPTR,#buf_index
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1241
0010 900000      R     MOV     DPTR,#UART_1_initVar
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 602D              JZ      ?C0039
                                           ; SOURCE LINE # 1242
0018         ?C0038:
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
0018 900000      R     MOV     DPTR,#string
001B 120000      E     LCALL   ?C?PLDXDATA
001E 900000      R     MOV     DPTR,#buf_index
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 E9                MOV     A,R1
0024 2F                ADD     A,R7
0025 F9                MOV     R1,A
0026 E4                CLR     A
0027 3A                ADDC    A,R2
0028 FA                MOV     R2,A
0029 120000      E     LCALL   ?C?CLDPTR
002C FF                MOV     R7,A
002D 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1246
0030 900000      R     MOV     DPTR,#buf_index
0033 E0                MOVX    A,@DPTR
0034 04                INC     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1247
0036 900000      R     MOV     DPTR,#byteCount
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B 900000      R     MOV     DPTR,#buf_index
003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 EE                MOV     A,R6
0041 C3                CLR     C
0042 9F                SUBB    A,R7
0043 40D3              JC      ?C0038
                                           ; SOURCE LINE # 1248
                                           ; SOURCE LINE # 1249
0045         ?C0039:
0045 22                RET     
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 39  

             ; FUNCTION _UART_1_PutArray (END)

             ; FUNCTION _UART_1_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1273
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
                                           ; SOURCE LINE # 1276
0005 900000      R     MOV     DPTR,#UART_1_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0041
                                           ; SOURCE LINE # 1277
                                           ; SOURCE LINE # 1278
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1279
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1280
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_1_PutChar
                                           ; SOURCE LINE # 1281
                                           ; SOURCE LINE # 1282
001F         ?C0041:
001F 22                RET     
             ; FUNCTION _UART_1_PutCRLF (END)

             ; FUNCTION UART_1_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1310
                                           ; SOURCE LINE # 1312
                                           ; SOURCE LINE # 1343
0000 90646A            MOV     DPTR,#0646AH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#size
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1346
000A 900000      R     MOV     DPTR,#size
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 30E208            JNB     ACC.2,?C0042
                                           ; SOURCE LINE # 1347
                                           ; SOURCE LINE # 1348
0013 900000      R     MOV     DPTR,#size
0016 7404              MOV     A,#04H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1349
0019 8016              SJMP    ?C0043
001B         ?C0042:
                                           ; SOURCE LINE # 1350
001B 900000      R     MOV     DPTR,#size
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 30E107            JNB     ACC.1,?C0044
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 40  

                                           ; SOURCE LINE # 1351
                                           ; SOURCE LINE # 1352
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1353
0029 8006              SJMP    ?C0043
002B         ?C0044:
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1357
002B 900000      R     MOV     DPTR,#size
002E 7401              MOV     A,#01H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1358
0031         ?C0043:
                                           ; SOURCE LINE # 1362
0031 900000      R     MOV     DPTR,#size
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 1363
0036         ?C0046:
0036 22                RET     
             ; FUNCTION UART_1_GetTxBufferSize (END)

             ; FUNCTION UART_1_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1396
                                           ; SOURCE LINE # 1397
                                           ; SOURCE LINE # 1401
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
0008 90649A            MOV     DPTR,#0649AH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1404
0013 90649A            MOV     DPTR,#0649AH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1406
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1425
0026 22                RET     
             ; FUNCTION UART_1_ClearTxBuffer (END)

             ; FUNCTION _UART_1_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1485
0000 900000      R     MOV     DPTR,#retMode
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 41  

0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1486
                                           ; SOURCE LINE # 1489
0005 900000      R     MOV     DPTR,#UART_1_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0061
                                           ; SOURCE LINE # 1490
                                           ; SOURCE LINE # 1533
0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0050
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7028              JNZ     ?C0049
0022         ?C0050:
                                           ; SOURCE LINE # 1535
                                           ; SOURCE LINE # 1544
0022 90643D            MOV     DPTR,#0643DH
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#tx_period
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1545
002C 90643D            MOV     DPTR,#0643DH
002F 7467              MOV     A,#067H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1552
0032 90644A            MOV     DPTR,#0644AH
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
0037         ?C0053:
                                           ; SOURCE LINE # 1555
                                           ; SOURCE LINE # 1556
0037 90646A            MOV     DPTR,#0646AH
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#tmpStat
003F EF                MOV     A,R7
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1557
0041 900000      R     MOV     DPTR,#tmpStat
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 20E1ED            JB      ACC.1,?C0053
                                           ; SOURCE LINE # 1558
004A         ?C0049:
                                           ; SOURCE LINE # 1560
004A 900000      R     MOV     DPTR,#retMode
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 42  

0050 6401              XRL     A,#01H
0052 6009              JZ      ?C0058
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A B40316            CJNE    A,#03H,?C0054
                                           ; SOURCE LINE # 1562
005D         ?C0058:
                                           ; SOURCE LINE # 1564
                                           ; SOURCE LINE # 1565
005D 90646A            MOV     DPTR,#0646AH
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#tmpStat
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1566
0067 900000      R     MOV     DPTR,#tmpStat
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D F4                CPL     A
006E FF                MOV     R7,A
006F EF                MOV     A,R7
0070 20E0EA            JB      ACC.0,?C0058
                                           ; SOURCE LINE # 1567
0073         ?C0054:
                                           ; SOURCE LINE # 1569
0073 900000      R     MOV     DPTR,#retMode
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 6401              XRL     A,#01H
007B 6013              JZ      ?C0060
007D 900000      R     MOV     DPTR,#retMode
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 6402              XRL     A,#02H
0085 6009              JZ      ?C0060
0087 900000      R     MOV     DPTR,#retMode
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C EF                MOV     A,R7
008D B4030A            CJNE    A,#03H,?C0061
0090         ?C0060:
                                           ; SOURCE LINE # 1572
                                           ; SOURCE LINE # 1575
0090 900000      R     MOV     DPTR,#tx_period
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 90643D            MOV     DPTR,#0643DH
0098 EF                MOV     A,R7
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
                                           ; SOURCE LINE # 1587
                                           ; SOURCE LINE # 1588
009A         ?C0061:
009A 22                RET     
             ; FUNCTION _UART_1_SendBreak (END)

C51 COMPILER V9.51   UART_1                                                                12/07/2013 02:06:29 PAGE 43  

             ; FUNCTION _UART_1_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1606
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1607
                                           ; SOURCE LINE # 1609
                                           ; SOURCE LINE # 1610
                                           ; SOURCE LINE # 1615
0005         ?C0062:
                                           ; SOURCE LINE # 1617
                                           ; SOURCE LINE # 1622
                                           ; SOURCE LINE # 1623
0005         ?C0064:
0005 22                RET     
             ; FUNCTION _UART_1_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    918    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
