C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE PS2
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\PS2.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\PS2.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_951\Debug\PS2.lst) CD DB NOIP OT(2,S
                    -IZE) DF(DEBUG) INCDIR(.,.\Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_951\Debug\PS2.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: PS2.c
   3          * Version 2.30
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "PS2.h"
  18          #include "CyLib.h"
  19          #if(PS2_INTERNAL_CLOCK_USED)
  20              #include "PS2_IntClock.h"
  21          #endif /* End PS2_INTERNAL_CLOCK_USED */
  22          
  23          
  24          /***************************************
  25          * Global data allocation
  26          ***************************************/
  27          
  28          uint8 PS2_initVar = 0u;
  29          #if( PS2_TX_ENABLED && (PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH))
                  volatile uint8 PS2_txBuffer[PS2_TXBUFFERSIZE];
                  volatile uint8 PS2_txBufferRead = 0u;
                  uint8 PS2_txBufferWrite = 0u;
              #endif /* End PS2_TX_ENABLED */
  34          #if( ( PS2_RX_ENABLED || PS2_HD_ENABLED ) && \
  35               (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH) )
                  volatile uint8 PS2_rxBuffer[PS2_RXBUFFERSIZE];
                  volatile uint8 PS2_rxBufferRead = 0u;
                  volatile uint8 PS2_rxBufferWrite = 0u;
                  volatile uint8 PS2_rxBufferLoopDetect = 0u;
                  volatile uint8 PS2_rxBufferOverflow = 0u;
                  #if (PS2_RXHW_ADDRESS_ENABLED)
                      volatile uint8 PS2_rxAddressMode = PS2_RXADDRESSMODE;
                      volatile uint8 PS2_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */
              #endif /* End PS2_RX_ENABLED */
  46          
  47          
  48          /*******************************************************************************
  49          * Function Name: PS2_Start
  50          ********************************************************************************
  51          *
  52          * Summary:
  53          *  Initialize and Enable the UART component.
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 2   

  54          *  Enable the clock input to enable operation.
  55          *
  56          * Parameters:
  57          *  None.
  58          *
  59          * Return:
  60          *  None.
  61          *
  62          * Global variables:
  63          *  The PS2_intiVar variable is used to indicate initial
  64          *  configuration of this component. The variable is initialized to zero (0u)
  65          *  and set to one (1u) the first time UART_Start() is called. This allows for
  66          *  component initialization without re-initialization in all subsequent calls
  67          *  to the PS2_Start() routine.
  68          *
  69          * Reentrant:
  70          *  No.
  71          *
  72          *******************************************************************************/
  73          void PS2_Start(void) 
  74          {
  75   1          /* If not Initialized then initialize all required hardware and software */
  76   1          if(PS2_initVar == 0u)
  77   1          {
  78   2              PS2_Init();
  79   2              PS2_initVar = 1u;
  80   2          }
  81   1          PS2_Enable();
  82   1      }
  83          
  84          
  85          /*******************************************************************************
  86          * Function Name: PS2_Init
  87          ********************************************************************************
  88          *
  89          * Summary:
  90          *  Initialize component's parameters to the parameters set by user in the
  91          *  customizer of the component placed onto schematic. Usually called in
  92          *  PS2_Start().
  93          *
  94          * Parameters:
  95          *  None.
  96          *
  97          * Return:
  98          *  None.
  99          *
 100          *******************************************************************************/
 101          void PS2_Init(void) 
 102          {
 103   1          #if(PS2_RX_ENABLED || PS2_HD_ENABLED)
 104   1      
 105   1              #if(PS2_RX_INTERRUPT_ENABLED && (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH))
                          /* Set the RX Interrupt. */
                          (void)CyIntSetVector(PS2_RX_VECT_NUM, &PS2_RXISR);
                          CyIntSetPriority(PS2_RX_VECT_NUM, PS2_RX_PRIOR_NUM);
                      #endif /* End PS2_RX_INTERRUPT_ENABLED */
 110   1      
 111   1              #if (PS2_RXHW_ADDRESS_ENABLED)
                          PS2_SetRxAddressMode(PS2_RXAddressMode);
                          PS2_SetRxAddress1(PS2_RXHWADDRESS1);
                          PS2_SetRxAddress2(PS2_RXHWADDRESS2);
                      #endif /* End PS2_RXHW_ADDRESS_ENABLED */
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 3   

 116   1      
 117   1              /* Init Count7 period */
 118   1              PS2_RXBITCTR_PERIOD_REG = PS2_RXBITCTR_INIT;
 119   1              /* Configure the Initial RX interrupt mask */
 120   1              PS2_RXSTATUS_MASK_REG  = PS2_INIT_RX_INTERRUPTS_MASK;
 121   1          #endif /* End PS2_RX_ENABLED || PS2_HD_ENABLED*/
 122   1      
 123   1          #if(PS2_TX_ENABLED)
                      #if(PS2_TX_INTERRUPT_ENABLED && (PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH))
                          /* Set the TX Interrupt. */
                          (void)CyIntSetVector(PS2_TX_VECT_NUM, &PS2_TXISR);
                          CyIntSetPriority(PS2_TX_VECT_NUM, PS2_TX_PRIOR_NUM);
                      #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                      /* Write Counter Value for TX Bit Clk Generator*/
                      #if(PS2_TXCLKGEN_DP)
                          PS2_TXBITCLKGEN_CTR_REG = PS2_BIT_CENTER;
                          PS2_TXBITCLKTX_COMPLETE_REG = (PS2_NUMBER_OF_DATA_BITS +
                                      PS2_NUMBER_OF_START_BIT) * PS2_OVER_SAMPLE_COUNT;
                      #else
                          PS2_TXBITCTR_PERIOD_REG = ((PS2_NUMBER_OF_DATA_BITS +
                                      PS2_NUMBER_OF_START_BIT) * PS2_OVER_SAMPLE_8) - 1u;
                      #endif /* End PS2_TXCLKGEN_DP */
              
                      /* Configure the Initial TX interrupt mask */
                      #if(PS2_TX_INTERRUPT_ENABLED && (PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH))
                          PS2_TXSTATUS_MASK_REG = PS2_TX_STS_FIFO_EMPTY;
                      #else
                          PS2_TXSTATUS_MASK_REG = PS2_INIT_TX_INTERRUPTS_MASK;
                      #endif /*End PS2_TX_INTERRUPT_ENABLED*/
              
                  #endif /* End PS2_TX_ENABLED */
 148   1      
 149   1          #if(PS2_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      PS2_WriteControlRegister( \
                          (PS2_ReadControlRegister() & (uint8)~PS2_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(PS2_PARITY_TYPE << PS2_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End PS2_PARITY_TYPE_SW */
 154   1      }
 155          
 156          
 157          /*******************************************************************************
 158          * Function Name: PS2_Enable
 159          ********************************************************************************
 160          *
 161          * Summary:
 162          *  Enables the UART block operation
 163          *
 164          * Parameters:
 165          *  None.
 166          *
 167          * Return:
 168          *  None.
 169          *
 170          * Global Variables:
 171          *  PS2_rxAddressDetected - set to initial state (0).
 172          *
 173          *******************************************************************************/
 174          void PS2_Enable(void) 
 175          {
 176   1          uint8 enableInterrupts;
 177   1          enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 4   

 178   1      
 179   1          #if(PS2_RX_ENABLED || PS2_HD_ENABLED)
 180   1              /*RX Counter (Count7) Enable */
 181   1              PS2_RXBITCTR_CONTROL_REG |= PS2_CNTR_ENABLE;
 182   1              /* Enable the RX Interrupt. */
 183   1              PS2_RXSTATUS_ACTL_REG  |= PS2_INT_ENABLE;
 184   1              #if(PS2_RX_INTERRUPT_ENABLED && (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH))
                          CyIntEnable(PS2_RX_VECT_NUM);
                          #if (PS2_RXHW_ADDRESS_ENABLED)
                              PS2_rxAddressDetected = 0u;
                          #endif /* End PS2_RXHW_ADDRESS_ENABLED */
                      #endif /* End PS2_RX_INTERRUPT_ENABLED */
 190   1          #endif /* End PS2_RX_ENABLED || PS2_HD_ENABLED*/
 191   1      
 192   1          #if(PS2_TX_ENABLED)
                      /*TX Counter (DP/Count7) Enable */
                      #if(!PS2_TXCLKGEN_DP)
                          PS2_TXBITCTR_CONTROL_REG |= PS2_CNTR_ENABLE;
                      #endif /* End PS2_TXCLKGEN_DP */
                      /* Enable the TX Interrupt. */
                      PS2_TXSTATUS_ACTL_REG |= PS2_INT_ENABLE;
                      #if(PS2_TX_INTERRUPT_ENABLED && (PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH))
                          CyIntEnable(PS2_TX_VECT_NUM);
                      #endif /* End PS2_TX_INTERRUPT_ENABLED*/
                   #endif /* End PS2_TX_ENABLED */
 203   1      
 204   1          #if(PS2_INTERNAL_CLOCK_USED)
 205   1              /* Enable the clock. */
 206   1              PS2_IntClock_Start();
 207   1          #endif /* End PS2_INTERNAL_CLOCK_USED */
 208   1      
 209   1          CyExitCriticalSection(enableInterrupts);
 210   1      }
 211          
 212          
 213          /*******************************************************************************
 214          * Function Name: PS2_Stop
 215          ********************************************************************************
 216          *
 217          * Summary:
 218          *  Disable the UART component
 219          *
 220          * Parameters:
 221          *  None.
 222          *
 223          * Return:
 224          *  None.
 225          *
 226          *******************************************************************************/
 227          void PS2_Stop(void) 
 228          {
 229   1          uint8 enableInterrupts;
 230   1          enableInterrupts = CyEnterCriticalSection();
 231   1      
 232   1          /* Write Bit Counter Disable */
 233   1          #if(PS2_RX_ENABLED || PS2_HD_ENABLED)
 234   1              PS2_RXBITCTR_CONTROL_REG &= (uint8)~PS2_CNTR_ENABLE;
 235   1          #endif /* End PS2_RX_ENABLED */
 236   1      
 237   1          #if(PS2_TX_ENABLED)
                      #if(!PS2_TXCLKGEN_DP)
                          PS2_TXBITCTR_CONTROL_REG &= (uint8)~PS2_CNTR_ENABLE;
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 5   

                      #endif /* End PS2_TXCLKGEN_DP */
                  #endif /* PS2_TX_ENABLED */
 242   1      
 243   1          #if(PS2_INTERNAL_CLOCK_USED)
 244   1              /* Disable the clock. */
 245   1              PS2_IntClock_Stop();
 246   1          #endif /* End PS2_INTERNAL_CLOCK_USED */
 247   1      
 248   1          /* Disable internal interrupt component */
 249   1          #if(PS2_RX_ENABLED || PS2_HD_ENABLED)
 250   1              PS2_RXSTATUS_ACTL_REG  &= (uint8)~PS2_INT_ENABLE;
 251   1              #if(PS2_RX_INTERRUPT_ENABLED && (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH))
                          PS2_DisableRxInt();
                      #endif /* End PS2_RX_INTERRUPT_ENABLED */
 254   1          #endif /* End PS2_RX_ENABLED */
 255   1      
 256   1          #if(PS2_TX_ENABLED)
                      PS2_TXSTATUS_ACTL_REG &= (uint8)~PS2_INT_ENABLE;
                      #if(PS2_TX_INTERRUPT_ENABLED && (PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH))
                          PS2_DisableTxInt();
                      #endif /* End PS2_TX_INTERRUPT_ENABLED */
                  #endif /* End PS2_TX_ENABLED */
 262   1      
 263   1          CyExitCriticalSection(enableInterrupts);
 264   1      }
 265          
 266          
 267          /*******************************************************************************
 268          * Function Name: PS2_ReadControlRegister
 269          ********************************************************************************
 270          *
 271          * Summary:
 272          *  Read the current state of the control register
 273          *
 274          * Parameters:
 275          *  None.
 276          *
 277          * Return:
 278          *  Current state of the control register.
 279          *
 280          *******************************************************************************/
 281          uint8 PS2_ReadControlRegister(void) 
 282          {
 283   1          #if( PS2_CONTROL_REG_REMOVED )
 284   1              return(0u);
 285   1          #else
                      return(PS2_CONTROL_REG);
                  #endif /* End PS2_CONTROL_REG_REMOVED */
 288   1      }
 289          
 290          
 291          /*******************************************************************************
 292          * Function Name: PS2_WriteControlRegister
 293          ********************************************************************************
 294          *
 295          * Summary:
 296          *  Writes an 8-bit value into the control register
 297          *
 298          * Parameters:
 299          *  control:  control register value
 300          *
 301          * Return:
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 6   

 302          *  None.
 303          *
 304          *******************************************************************************/
 305          void  PS2_WriteControlRegister(uint8 control) 
 306          {
 307   1          #if( PS2_CONTROL_REG_REMOVED )
 308   1              if(control != 0u) { }      /* release compiler warning */
 309   1          #else
                     PS2_CONTROL_REG = control;
                  #endif /* End PS2_CONTROL_REG_REMOVED */
 312   1      }
 313          
 314          
 315          #if(PS2_RX_ENABLED || PS2_HD_ENABLED)
 316          
 317              #if(PS2_RX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: PS2_EnableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void PS2_EnableRxInt(void) 
                      {
                          CyIntEnable(PS2_RX_VECT_NUM);
                      }
              
              
                      /*******************************************************************************
                      * Function Name: PS2_DisableRxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable RX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void PS2_DisableRxInt(void) 
                      {
                          CyIntDisable(PS2_RX_VECT_NUM);
                      }
              
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 7   

                  #endif /* PS2_RX_INTERRUPT_ENABLED */
 365          
 366          
 367              /*******************************************************************************
 368              * Function Name: PS2_SetRxInterruptMode
 369              ********************************************************************************
 370              *
 371              * Summary:
 372              *  Configure which status bits trigger an interrupt event
 373              *
 374              * Parameters:
 375              *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376              *           the header file)
 377              *
 378              * Return:
 379              *  None.
 380              *
 381              * Theory:
 382              *  Enables the output of specific status bits to the interrupt controller
 383              *
 384              *******************************************************************************/
 385              void PS2_SetRxInterruptMode(uint8 intSrc) 
 386              {
 387   1              PS2_RXSTATUS_MASK_REG  = intSrc;
 388   1          }
 389          
 390          
 391              /*******************************************************************************
 392              * Function Name: PS2_ReadRxData
 393              ********************************************************************************
 394              *
 395              * Summary:
 396              *  Returns data in RX Data register without checking status register to
 397              *  determine if data is valid
 398              *
 399              * Parameters:
 400              *  None.
 401              *
 402              * Return:
 403              *  Received data from RX register
 404              *
 405              * Global Variables:
 406              *  PS2_rxBuffer - RAM buffer pointer for save received data.
 407              *  PS2_rxBufferWrite - cyclic index for write to rxBuffer,
 408              *     checked to identify new data.
 409              *  PS2_rxBufferRead - cyclic index for read from rxBuffer,
 410              *     incremented after each byte has been read from buffer.
 411              *  PS2_rxBufferLoopDetect - creared if loop condition was detected
 412              *     in RX ISR.
 413              *
 414              * Reentrant:
 415              *  No.
 416              *
 417              *******************************************************************************/
 418              uint8 PS2_ReadRxData(void) 
 419              {
 420   1              uint8 rxData;
 421   1      
 422   1              #if(PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 8   

                          /* Disable Rx interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_DisableRxInt();
                          #endif /* PS2_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = PS2_rxBufferRead;
                          loc_rxBufferWrite = PS2_rxBufferWrite;
              
                          if( (PS2_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = PS2_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
              
                              if(loc_rxBufferRead >= PS2_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              PS2_rxBufferRead = loc_rxBufferRead;
              
                              if(PS2_rxBufferLoopDetect != 0u )
                              {
                                  PS2_rxBufferLoopDetect = 0u;
                                  #if( (PS2_RX_INTERRUPT_ENABLED) && (PS2_FLOW_CONTROL != 0u) && \
                                       (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( PS2_HD_ENABLED )
                                          if((PS2_CONTROL_REG & PS2_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only in RX
                                              *  configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              PS2_RXSTATUS_MASK_REG  |= PS2_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          PS2_RXSTATUS_MASK_REG  |= PS2_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end PS2_HD_ENABLED */
                                  #endif /* PS2_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
                          }
                          else
                          {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                              rxData = PS2_RXDATA_REG;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_EnableRxInt();
                          #endif /* End PS2_RX_INTERRUPT_ENABLED */
              
                      #else /* PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 476   1      
 477   1                  /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478   1                  rxData = PS2_RXDATA_REG;
 479   1      
 480   1              #endif /* PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 481   1      
 482   1              return(rxData);
 483   1          }
 484          
 485          
 486              /*******************************************************************************
 487              * Function Name: PS2_ReadRxStatus
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 9   

 488              ********************************************************************************
 489              *
 490              * Summary:
 491              *  Read the current state of the status register
 492              *  And detect software buffer overflow.
 493              *
 494              * Parameters:
 495              *  None.
 496              *
 497              * Return:
 498              *  Current state of the status register.
 499              *
 500              * Global Variables:
 501              *  PS2_rxBufferOverflow - used to indicate overload condition.
 502              *   It set to one in RX interrupt when there isn?t free space in
 503              *   PS2_rxBufferRead to write new data. This condition returned
 504              *   and cleared to zero by this API as an
 505              *   PS2_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506              *   bits.
 507              *
 508              *******************************************************************************/
 509              uint8 PS2_ReadRxStatus(void) 
 510              {
 511   1              uint8 status;
 512   1      
 513   1              status = PS2_RXSTATUS_REG & PS2_RX_HW_MASK;
 514   1      
 515   1              #if(PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH)
                          if( PS2_rxBufferOverflow != 0u )
                          {
                              status |= PS2_RX_STS_SOFT_BUFF_OVER;
                              PS2_rxBufferOverflow = 0u;
                          }
                      #endif /* PS2_RXBUFFERSIZE */
 522   1      
 523   1              return(status);
 524   1          }
 525          
 526          
 527              /*******************************************************************************
 528              * Function Name: PS2_GetChar
 529              ********************************************************************************
 530              *
 531              * Summary:
 532              *  Reads UART RX buffer immediately, if data is not available or an error
 533              *  condition exists, zero is returned; otherwise, character is read and
 534              *  returned.
 535              *
 536              * Parameters:
 537              *  None.
 538              *
 539              * Return:
 540              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541              *  A returned zero signifies an error condition or no data available.
 542              *
 543              * Global Variables:
 544              *  PS2_rxBuffer - RAM buffer pointer for save received data.
 545              *  PS2_rxBufferWrite - cyclic index for write to rxBuffer,
 546              *     checked to identify new data.
 547              *  PS2_rxBufferRead - cyclic index for read from rxBuffer,
 548              *     incremented after each byte has been read from buffer.
 549              *  PS2_rxBufferLoopDetect - creared if loop condition was detected
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 10  

 550              *     in RX ISR.
 551              *
 552              * Reentrant:
 553              *  No.
 554              *
 555              *******************************************************************************/
 556              uint8 PS2_GetChar(void) 
 557              {
 558   1              uint8 rxData = 0u;
 559   1              uint8 rxStatus;
 560   1      
 561   1              #if(PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH)
                          uint8 loc_rxBufferRead;
                          uint8 loc_rxBufferWrite;
                          /* Protect variables that could change on interrupt. */
                          /* Disable Rx interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_DisableRxInt();
                          #endif /* PS2_RX_INTERRUPT_ENABLED */
                          loc_rxBufferRead = PS2_rxBufferRead;
                          loc_rxBufferWrite = PS2_rxBufferWrite;
              
                          if( (PS2_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
                          {
                              rxData = PS2_rxBuffer[loc_rxBufferRead];
                              loc_rxBufferRead++;
                              if(loc_rxBufferRead >= PS2_RXBUFFERSIZE)
                              {
                                  loc_rxBufferRead = 0u;
                              }
                              /* Update the real pointer */
                              PS2_rxBufferRead = loc_rxBufferRead;
              
                              if(PS2_rxBufferLoopDetect > 0u )
                              {
                                  PS2_rxBufferLoopDetect = 0u;
                                  #if( (PS2_RX_INTERRUPT_ENABLED) && (PS2_FLOW_CONTROL != 0u) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( PS2_HD_ENABLED )
                                          if((PS2_CONTROL_REG & PS2_CTRL_HD_SEND) == 0u)
                                          {   /* In Half duplex mode return RX mask only if
                                              *  RX configuration set, otherwise
                                              *  mask will be returned in LoadRxConfig() API.
                                              */
                                              PS2_RXSTATUS_MASK_REG  |= PS2_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          PS2_RXSTATUS_MASK_REG  |= PS2_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end PS2_HD_ENABLED */
                                  #endif /* PS2_RX_INTERRUPT_ENABLED and Hardware flow control*/
                              }
              
                          }
                          else
                          {   rxStatus = PS2_RXSTATUS_REG;
                              if((rxStatus & PS2_RX_STS_FIFO_NOTEMPTY) != 0u)
                              {   /* Read received data from FIFO*/
                                  rxData = PS2_RXDATA_REG;
                                  /*Check status on error*/
                                  if((rxStatus & (PS2_RX_STS_BREAK | PS2_RX_STS_PAR_ERROR |
                                                 PS2_RX_STS_STOP_ERROR | PS2_RX_STS_OVERRUN)) != 0u)
                                  {
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 11  

                                      rxData = 0u;
                                  }
                              }
                          }
              
                          /* Enable Rx interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_EnableRxInt();
                          #endif /* PS2_RX_INTERRUPT_ENABLED */
              
                      #else /* PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 623   1      
 624   1                  rxStatus =PS2_RXSTATUS_REG;
 625   1                  if((rxStatus & PS2_RX_STS_FIFO_NOTEMPTY) != 0u)
 626   1                  {   /* Read received data from FIFO*/
 627   2                      rxData = PS2_RXDATA_REG;
 628   2                      /*Check status on error*/
 629   2                      if((rxStatus & (PS2_RX_STS_BREAK | PS2_RX_STS_PAR_ERROR |
 630   2                                     PS2_RX_STS_STOP_ERROR | PS2_RX_STS_OVERRUN)) != 0u)
 631   2                      {
 632   3                          rxData = 0u;
 633   3                      }
 634   2                  }
 635   1              #endif /* PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 636   1      
 637   1              return(rxData);
 638   1          }
 639          
 640          
 641              /*******************************************************************************
 642              * Function Name: PS2_GetByte
 643              ********************************************************************************
 644              *
 645              * Summary:
 646              *  Grab the next available byte of data from the recieve FIFO
 647              *
 648              * Parameters:
 649              *  None.
 650              *
 651              * Return:
 652              *  MSB contains Status Register and LSB contains UART RX data
 653              *
 654              * Reentrant:
 655              *  No.
 656              *
 657              *******************************************************************************/
 658              uint16 PS2_GetByte(void) 
 659              {
 660   1              return ( ((uint16)PS2_ReadRxStatus() << 8u) | PS2_ReadRxData() );
 661   1          }
 662          
 663          
 664              /*******************************************************************************
 665              * Function Name: PS2_GetRxBufferSize
 666              ********************************************************************************
 667              *
 668              * Summary:
 669              *  Determine the amount of bytes left in the RX buffer and return the count in
 670              *  bytes
 671              *
 672              * Parameters:
 673              *  None.
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 12  

 674              *
 675              * Return:
 676              *  uint8: Integer count of the number of bytes left
 677              *  in the RX buffer
 678              *
 679              * Global Variables:
 680              *  PS2_rxBufferWrite - used to calculate left bytes.
 681              *  PS2_rxBufferRead - used to calculate left bytes.
 682              *  PS2_rxBufferLoopDetect - checked to decide left bytes amount.
 683              *
 684              * Reentrant:
 685              *  No.
 686              *
 687              * Theory:
 688              *  Allows the user to find out how full the RX Buffer is.
 689              *
 690              *******************************************************************************/
 691              uint8 PS2_GetRxBufferSize(void)
 692                                                                      
 693              {
 694   1              uint8 size;
 695   1      
 696   1              #if(PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH)
              
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_DisableRxInt();
                          #endif /* PS2_RX_INTERRUPT_ENABLED */
              
                          if(PS2_rxBufferRead == PS2_rxBufferWrite)
                          {
                              if(PS2_rxBufferLoopDetect > 0u)
                              {
                                  size = PS2_RXBUFFERSIZE;
                              }
                              else
                              {
                                  size = 0u;
                              }
                          }
                          else if(PS2_rxBufferRead < PS2_rxBufferWrite)
                          {
                              size = (PS2_rxBufferWrite - PS2_rxBufferRead);
                          }
                          else
                          {
                              size = (PS2_RXBUFFERSIZE - PS2_rxBufferRead) + PS2_rxBufferWrite;
                          }
              
                          /* Enable Rx interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_EnableRxInt();
                          #endif /* End PS2_RX_INTERRUPT_ENABLED */
              
                      #else /* PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 730   1      
 731   1                  /* We can only know if there is data in the fifo. */
 732   1                  size = ((PS2_RXSTATUS_REG & PS2_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 733   1      
 734   1              #endif /* End PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 735   1      
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 13  

 736   1              return(size);
 737   1          }
 738          
 739          
 740              /*******************************************************************************
 741              * Function Name: PS2_ClearRxBuffer
 742              ********************************************************************************
 743              *
 744              * Summary:
 745              *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746              *  Clears hardware RX FIFO.
 747              *
 748              * Parameters:
 749              *  None.
 750              *
 751              * Return:
 752              *  None.
 753              *
 754              * Global Variables:
 755              *  PS2_rxBufferWrite - cleared to zero.
 756              *  PS2_rxBufferRead - cleared to zero.
 757              *  PS2_rxBufferLoopDetect - cleared to zero.
 758              *  PS2_rxBufferOverflow - cleared to zero.
 759              *
 760              * Reentrant:
 761              *  No.
 762              *
 763              * Theory:
 764              *  Setting the pointers to zero makes the system believe there is no data to
 765              *  read and writing will resume at address 0 overwriting any data that may
 766              *  have remained in the RAM.
 767              *
 768              * Side Effects:
 769              *  Any received data not read from the RAM or FIFO buffer will be lost.
 770              *******************************************************************************/
 771              void PS2_ClearRxBuffer(void) 
 772              {
 773   1              uint8 enableInterrupts;
 774   1      
 775   1              /* clear the HW FIFO */
 776   1              /* Enter critical section */
 777   1              enableInterrupts = CyEnterCriticalSection();
 778   1              PS2_RXDATA_AUX_CTL_REG |=  PS2_RX_FIFO_CLR;
 779   1              PS2_RXDATA_AUX_CTL_REG &= (uint8)~PS2_RX_FIFO_CLR;
 780   1              /* Exit critical section */
 781   1              CyExitCriticalSection(enableInterrupts);
 782   1      
 783   1              #if(PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH)
                          /* Disable Rx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_DisableRxInt();
                          #endif /* End PS2_RX_INTERRUPT_ENABLED */
              
                          PS2_rxBufferRead = 0u;
                          PS2_rxBufferWrite = 0u;
                          PS2_rxBufferLoopDetect = 0u;
                          PS2_rxBufferOverflow = 0u;
              
                          /* Enable Rx interrupt. */
                          #if(PS2_RX_INTERRUPT_ENABLED)
                              PS2_EnableRxInt();
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 14  

                          #endif /* End PS2_RX_INTERRUPT_ENABLED */
                      #endif /* End PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH */
 800   1      
 801   1          }
 802          
 803          
 804              /*******************************************************************************
 805              * Function Name: PS2_SetRxAddressMode
 806              ********************************************************************************
 807              *
 808              * Summary:
 809              *  Set the receive addressing mode
 810              *
 811              * Parameters:
 812              *  addressMode: Enumerated value indicating the mode of RX addressing
 813              *  PS2__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814              *                                               detection
 815              *  PS2__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816              *                                               address detection
 817              *  PS2__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818              *                                               detection
 819              *  PS2__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820              *                                               address detection
 821              *  PS2__B_UART__AM_NONE - No address detection
 822              *
 823              * Return:
 824              *  None.
 825              *
 826              * Global Variables:
 827              *  PS2_rxAddressMode - the parameter stored in this variable for
 828              *   the farther usage in RX ISR.
 829              *  PS2_rxAddressDetected - set to initial state (0).
 830              *
 831              *******************************************************************************/
 832              void PS2_SetRxAddressMode(uint8 addressMode)
 833                                                                  
 834              {
 835   1              #if(PS2_RXHW_ADDRESS_ENABLED)
                          #if(PS2_CONTROL_REG_REMOVED)
                              if(addressMode != 0u) { }     /* release compiler warning */
                          #else /* PS2_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = PS2_CONTROL_REG & (uint8)~PS2_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << PS2_CTRL_RXADDR_MODE0_SHIFT);
                              PS2_CONTROL_REG = tmpCtrl;
                              #if(PS2_RX_INTERRUPT_ENABLED && \
                                 (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH) )
                                  PS2_rxAddressMode = addressMode;
                                  PS2_rxAddressDetected = 0u;
                              #endif /* End PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH*/
                          #endif /* End PS2_CONTROL_REG_REMOVED */
                      #else /* PS2_RXHW_ADDRESS_ENABLED */
 850   1                  if(addressMode != 0u) { }     /* release compiler warning */
 851   1              #endif /* End PS2_RXHW_ADDRESS_ENABLED */
 852   1          }
 853          
 854          
 855              /*******************************************************************************
 856              * Function Name: PS2_SetRxAddress1
 857              ********************************************************************************
 858              *
 859              * Summary:
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 15  

 860              *  Set the first hardware address compare value
 861              *
 862              * Parameters:
 863              *  address
 864              *
 865              * Return:
 866              *  None.
 867              *
 868              *******************************************************************************/
 869              void PS2_SetRxAddress1(uint8 address) 
 870          
 871              {
 872   1              PS2_RXADDRESS1_REG = address;
 873   1          }
 874          
 875          
 876              /*******************************************************************************
 877              * Function Name: PS2_SetRxAddress2
 878              ********************************************************************************
 879              *
 880              * Summary:
 881              *  Set the second hardware address compare value
 882              *
 883              * Parameters:
 884              *  address
 885              *
 886              * Return:
 887              *  None.
 888              *
 889              *******************************************************************************/
 890              void PS2_SetRxAddress2(uint8 address) 
 891              {
 892   1              PS2_RXADDRESS2_REG = address;
 893   1          }
 894          
 895          #endif  /* PS2_RX_ENABLED || PS2_HD_ENABLED*/
 896          
 897          
 898          #if( (PS2_TX_ENABLED) || (PS2_HD_ENABLED) )
              
                  #if(PS2_TX_INTERRUPT_ENABLED)
              
                      /*******************************************************************************
                      * Function Name: PS2_EnableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Enable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Enable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void PS2_EnableTxInt(void) 
                      {
                          CyIntEnable(PS2_TX_VECT_NUM);
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 16  

                      }
              
              
                      /*******************************************************************************
                      * Function Name: PS2_DisableTxInt
                      ********************************************************************************
                      *
                      * Summary:
                      *  Disable TX interrupt generation
                      *
                      * Parameters:
                      *  None.
                      *
                      * Return:
                      *  None.
                      *
                      * Theory:
                      *  Disable the interrupt output -or- the interrupt component itself
                      *
                      *******************************************************************************/
                      void PS2_DisableTxInt(void) 
                      {
                          CyIntDisable(PS2_TX_VECT_NUM);
                      }
              
                  #endif /* PS2_TX_INTERRUPT_ENABLED */
              
              
                  /*******************************************************************************
                  * Function Name: PS2_SetTxInterruptMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configure which status bits trigger an interrupt event
                  *
                  * Parameters:
                  *  intSrc: An or'd combination of the desired status bit masks (defined in
                  *          the header file)
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Enables the output of specific status bits to the interrupt controller
                  *
                  *******************************************************************************/
                  void PS2_SetTxInterruptMode(uint8 intSrc) 
                  {
                      PS2_TXSTATUS_MASK_REG = intSrc;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_WriteTxData
                  ********************************************************************************
                  *
                  * Summary:
                  *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
                  *  bus is available. WriteTxData sends a byte without checking for buffer room
                  *  or status. It is up to the user to separately check status.
                  *
                  * Parameters:
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 17  

                  *  TXDataByte: byte of data to place in the transmit FIFO
                  *
                  * Return:
                  * void
                  *
                  * Global Variables:
                  *  PS2_txBuffer - RAM buffer pointer for save data for transmission
                  *  PS2_txBufferWrite - cyclic index for write to txBuffer,
                  *    incremented after each byte saved to buffer.
                  *  PS2_txBufferRead - cyclic index for read from txBuffer,
                  *    checked to identify the condition to write to FIFO directly or to TX buffer
                  *  PS2_initVar - checked to identify that the component has been
                  *    initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void PS2_WriteTxData(uint8 txDataByte) 
                  {
                      /* If not Initialized then skip this function*/
                      if(PS2_initVar != 0u)
                      {
                          #if(PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH)
              
                              /* Disable Tx interrupt. */
                              /* Protect variables that could change on interrupt. */
                              #if(PS2_TX_INTERRUPT_ENABLED)
                                  PS2_DisableTxInt();
                              #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                              if( (PS2_txBufferRead == PS2_txBufferWrite) &&
                                  ((PS2_TXSTATUS_REG & PS2_TX_STS_FIFO_FULL) == 0u) )
                              {
                                  /* Add directly to the FIFO. */
                                  PS2_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(PS2_txBufferWrite >= PS2_TXBUFFERSIZE)
                                  {
                                      PS2_txBufferWrite = 0u;
                                  }
              
                                  PS2_txBuffer[PS2_txBufferWrite] = txDataByte;
              
                                  /* Add to the software buffer. */
                                  PS2_txBufferWrite++;
              
                              }
              
                              /* Enable Tx interrupt. */
                              #if(PS2_TX_INTERRUPT_ENABLED)
                                  PS2_EnableTxInt();
                              #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                          #else /* PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
              
                              /* Add directly to the FIFO. */
                              PS2_TXDATA_REG = txDataByte;
              
                          #endif /* End PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 18  

                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_ReadTxStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Read the status register for the component
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Contents of the status register
                  *
                  * Theory:
                  *  This function reads the status register which is clear on read. It is up to
                  *  the user to handle all bits in this return value accordingly, even if the bit
                  *  was not enabled as an interrupt source the event happened and must be handled
                  *  accordingly.
                  *
                  *******************************************************************************/
                  uint8 PS2_ReadTxStatus(void) 
                  {
                      return(PS2_TXSTATUS_REG);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_PutChar
                  ********************************************************************************
                  *
                  * Summary:
                  *  Wait to send byte until TX register or buffer has room.
                  *
                  * Parameters:
                  *  txDataByte: The 8-bit data value to send across the UART.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  PS2_txBuffer - RAM buffer pointer for save data for transmission
                  *  PS2_txBufferWrite - cyclic index for write to txBuffer,
                  *     checked to identify free space in txBuffer and incremented after each byte
                  *     saved to buffer.
                  *  PS2_txBufferRead - cyclic index for read from txBuffer,
                  *     checked to identify free space in txBuffer.
                  *  PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to transmit any byte of data in a single transfer
                  *
                  *******************************************************************************/
                  void PS2_PutChar(uint8 txDataByte) 
                  {
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 19  

                          #if(PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH)
                              /* The temporary output pointer is used since it takes two instructions
                              *  to increment with a wrap, and we can't risk doing that with the real
                              *  pointer and getting an interrupt in between instructions.
                              */
                              uint8 loc_txBufferWrite;
                              uint8 loc_txBufferRead;
              
                              do{
                                  /* Block if software buffer is full, so we don't overwrite. */
                                  #if ((PS2_TXBUFFERSIZE > PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Disable TX interrupt to protect variables that could change on interrupt */
                                      CyIntDisable(PS2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                                  loc_txBufferWrite = PS2_txBufferWrite;
                                  loc_txBufferRead = PS2_txBufferRead;
                                  #if ((PS2_TXBUFFERSIZE > PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      /* Enable interrupt to continue transmission */
                                      CyIntEnable(PS2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                              }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBufferRead -
             - 1u)) :
                                                      ((loc_txBufferWrite - loc_txBufferRead) ==
                                                      (uint8)(PS2_TXBUFFERSIZE - 1u)) );
              
                              if( (loc_txBufferRead == loc_txBufferWrite) &&
                                  ((PS2_TXSTATUS_REG & PS2_TX_STS_FIFO_FULL) == 0u) )
                              {
                                  /* Add directly to the FIFO. */
                                  PS2_TXDATA_REG = txDataByte;
                              }
                              else
                              {
                                  if(loc_txBufferWrite >= PS2_TXBUFFERSIZE)
                                  {
                                      loc_txBufferWrite = 0u;
                                  }
                                  /* Add to the software buffer. */
                                  PS2_txBuffer[loc_txBufferWrite] = txDataByte;
                                  loc_txBufferWrite++;
              
                                  /* Finally, update the real output pointer */
                                  #if ((PS2_TXBUFFERSIZE > PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntDisable(PS2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                                  PS2_txBufferWrite = loc_txBufferWrite;
                                  #if ((PS2_TXBUFFERSIZE > PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                                      CyIntEnable(PS2_TX_VECT_NUM);
                                  #endif /* End TXBUFFERSIZE > 255 */
                              }
              
                          #else /* PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
              
                              while((PS2_TXSTATUS_REG & PS2_TX_STS_FIFO_FULL) != 0u)
                              {
                                  ; /* Wait for room in the FIFO. */
                              }
              
                              /* Add directly to the FIFO. */
                              PS2_TXDATA_REG = txDataByte;
              
                          #endif /* End PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 20  

                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_PutString
                  ********************************************************************************
                  *
                  * Summary:
                  *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
                  *
                  * Parameters:
                  *  string: char pointer to character string of Data to Send.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  This function will block if there is not enough memory to place the whole
                  *  string, it will block until the entire string has been written to the
                  *  transmit buffer.
                  *
                  *******************************************************************************/
                  void PS2_PutString(const char8 string[]) 
                  {
                      uint16 buf_index = 0u;
                      /* If not Initialized then skip this function*/
                      if(PS2_initVar != 0u)
                      {
                          /* This is a blocking function, it will not exit until all data is sent*/
                          while(string[buf_index] != (char8)0)
                          {
                              PS2_PutChar((uint8)string[buf_index]);
                              buf_index++;
                          }
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_PutArray
                  ********************************************************************************
                  *
                  * Summary:
                  *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
                  *
                  * Parameters:
                  *  string: Address of the memory array residing in RAM or ROM.
                  *  byteCount: Number of Bytes to be transmitted.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  PS2_initVar - checked to identify that the component has been
                  *     initialized.
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 21  

                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void PS2_PutArray(const uint8 string[], uint8 byteCount)
                                                                                  
                  {
                      uint8 buf_index = 0u;
                      /* If not Initialized then skip this function*/
                      if(PS2_initVar != 0u)
                      {
                          do
                          {
                              PS2_PutChar(string[buf_index]);
                              buf_index++;
                          }while(buf_index < byteCount);
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_PutCRLF
                  ********************************************************************************
                  *
                  * Summary:
                  *  Write a character and then carriage return and line feed.
                  *
                  * Parameters:
                  *  txDataByte: uint8 Character to send.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void PS2_PutCRLF(uint8 txDataByte) 
                  {
                      /* If not Initialized then skip this function*/
                      if(PS2_initVar != 0u)
                      {
                          PS2_PutChar(txDataByte);
                          PS2_PutChar(0x0Du);
                          PS2_PutChar(0x0Au);
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_GetTxBufferSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Determine the amount of space left in the TX buffer and return the count in
                  *  bytes
                  *
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 22  

                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Integer count of the number of bytes left in the TX buffer
                  *
                  * Global Variables:
                  *  PS2_txBufferWrite - used to calculate left space.
                  *  PS2_txBufferRead - used to calculate left space.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to find out how full the TX Buffer is.
                  *
                  *******************************************************************************/
                  uint8 PS2_GetTxBufferSize(void)
                                                                          
                  {
                      uint8 size;
              
                      #if(PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(PS2_TX_INTERRUPT_ENABLED)
                              PS2_DisableTxInt();
                          #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                          if(PS2_txBufferRead == PS2_txBufferWrite)
                          {
                              size = 0u;
                          }
                          else if(PS2_txBufferRead < PS2_txBufferWrite)
                          {
                              size = (PS2_txBufferWrite - PS2_txBufferRead);
                          }
                          else
                          {
                              size = (PS2_TXBUFFERSIZE - PS2_txBufferRead) + PS2_txBufferWrite;
                          }
              
                          /* Enable Tx interrupt. */
                          #if(PS2_TX_INTERRUPT_ENABLED)
                              PS2_EnableTxInt();
                          #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                      #else /* PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
              
                          size = PS2_TXSTATUS_REG;
              
                          /* Is the fifo is full. */
                          if((size & PS2_TX_STS_FIFO_FULL) != 0u)
                          {
                              size = PS2_FIFO_LENGTH;
                          }
                          else if((size & PS2_TX_STS_FIFO_EMPTY) != 0u)
                          {
                              size = 0u;
                          }
                          else
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 23  

                          {
                              /* We only know there is data in the fifo. */
                              size = 1u;
                          }
              
                      #endif /* End PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
              
                      return(size);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_ClearTxBuffer
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
                  *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  PS2_txBufferWrite - cleared to zero.
                  *  PS2_txBufferRead - cleared to zero.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Setting the pointers to zero makes the system believe there is no data to
                  *  read and writing will resume at address 0 overwriting any data that may have
                  *  remained in the RAM.
                  *
                  * Side Effects:
                  *  Any received data not read from the RAM buffer will be lost when overwritten.
                  *
                  *******************************************************************************/
                  void PS2_ClearTxBuffer(void) 
                  {
                      uint8 enableInterrupts;
              
                      /* Enter critical section */
                      enableInterrupts = CyEnterCriticalSection();
                      /* clear the HW FIFO */
                      PS2_TXDATA_AUX_CTL_REG |=  PS2_TX_FIFO_CLR;
                      PS2_TXDATA_AUX_CTL_REG &= (uint8)~PS2_TX_FIFO_CLR;
                      /* Exit critical section */
                      CyExitCriticalSection(enableInterrupts);
              
                      #if(PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH)
              
                          /* Disable Tx interrupt. */
                          /* Protect variables that could change on interrupt. */
                          #if(PS2_TX_INTERRUPT_ENABLED)
                              PS2_DisableTxInt();
                          #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                          PS2_txBufferRead = 0u;
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 24  

                          PS2_txBufferWrite = 0u;
              
                          /* Enable Tx interrupt. */
                          #if(PS2_TX_INTERRUPT_ENABLED)
                              PS2_EnableTxInt();
                          #endif /* End PS2_TX_INTERRUPT_ENABLED */
              
                      #endif /* End PS2_TXBUFFERSIZE > PS2_FIFO_LENGTH */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_SendBreak
                  ********************************************************************************
                  *
                  * Summary:
                  *  Write a Break command to the UART
                  *
                  * Parameters:
                  *  uint8 retMode:  Wait mode,
                  *   0 - Initialize registers for Break, sends the Break signal and return
                  *       imediately.
                  *   1 - Wait until Break sending is complete, reinitialize registers to normal
                  *       transmission mode then return.
                  *   2 - Reinitialize registers to normal transmission mode then return.
                  *   3 - both steps: 0 and 1
                  *       init registers for Break, send Break signal
                  *       wait until Break sending is complete, reinit registers to normal
                  *       transmission mode then return.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *  tx_period - static variable, used for keeping TX period configuration.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  SendBreak function initializes registers to send 13-bit break signal. It is
                  *  important to return the registers configuration to normal for continue 8-bit
                  *  operation.
                  *  Trere are 3 variants for this API usage:
                  *  1) SendBreak(3) - function will send the Break signal and take care on the
                  *     configuration returning. Funcition will block CPU untill transmition
                  *     complete.
                  *  2) User may want to use bloking time if UART configured to the low speed
                  *     operation
                  *     Emample for this case:
                  *     SendBreak(0);     - init Break signal transmition
                  *         Add your code here to use CPU time
                  *     SendBreak(1);     - complete Break operation
                  *  3) Same to 2) but user may want to init and use the interrupt for complete
                  *     break operation.
                  *     Example for this case:
                  *     Init TX interrupt whith "TX - On TX Complete" parameter
                  *     SendBreak(0);     - init Break signal transmition
                  *         Add your code here to use CPU time
                  *     When interrupt appear with UART_TX_STS_COMPLETE status:
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 25  

                  *     SendBreak(2);     - complete Break operation
                  *
                  * Side Effects:
                  *   Uses static variable to keep registers configuration.
                  *
                  *******************************************************************************/
                  void PS2_SendBreak(uint8 retMode) 
                  {
              
                      /* If not Initialized then skip this function*/
                      if(PS2_initVar != 0u)
                      {
                          /*Set the Counter to 13-bits and transmit a 00 byte*/
                          /*When that is done then reset the counter value back*/
                          uint8 tmpStat;
              
                          #if(PS2_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == PS2_SEND_BREAK) ||
                                  (retMode == PS2_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  PS2_WriteControlRegister(PS2_ReadControlRegister() |
                                                                        PS2_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  PS2_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = PS2_TXSTATUS_REG;
                                  }while((tmpStat & PS2_TX_STS_FIFO_EMPTY) != 0u);
                              }
              
                              if( (retMode == PS2_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == PS2_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = PS2_TXSTATUS_REG;
                                  }while(((uint8)~tmpStat & PS2_TX_STS_COMPLETE) != 0u);
                              }
              
                              if( (retMode == PS2_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == PS2_REINIT) ||
                                  (retMode == PS2_SEND_WAIT_REINIT) )
                              {
                                  PS2_WriteControlRegister(PS2_ReadControlRegister() &
                                                                (uint8)~PS2_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* PS2_HD_ENABLED Full Duplex mode */
              
                              static uint8 tx_period;
              
                              if( (retMode == PS2_SEND_BREAK) ||
                                  (retMode == PS2_SEND_WAIT_REINIT) )
                              {
                                  /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode*/
                                  #if( (PS2_PARITY_TYPE != PS2__B_UART__NONE_REVB) || \
                                                      (PS2_PARITY_TYPE_SW != 0u) )
                                      PS2_WriteControlRegister(PS2_ReadControlRegister() |
                                                                            PS2_CTRL_HD_SEND_BREAK);
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 26  

                                  #endif /* End PS2_PARITY_TYPE != PS2__B_UART__NONE_REVB  */
              
                                  #if(PS2_TXCLKGEN_DP)
                                      tx_period = PS2_TXBITCLKTX_COMPLETE_REG;
                                      PS2_TXBITCLKTX_COMPLETE_REG = PS2_TXBITCTR_BREAKBITS;
                                  #else
                                      tx_period = PS2_TXBITCTR_PERIOD_REG;
                                      PS2_TXBITCTR_PERIOD_REG = PS2_TXBITCTR_BREAKBITS8X;
                                  #endif /* End PS2_TXCLKGEN_DP */
              
                                  /* Send zeros*/
                                  PS2_TXDATA_REG = 0u;
              
                                  do /* wait until transmit starts */
                                  {
                                      tmpStat = PS2_TXSTATUS_REG;
                                  }while((tmpStat & PS2_TX_STS_FIFO_EMPTY) != 0u);
                              }
              
                              if( (retMode == PS2_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == PS2_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = PS2_TXSTATUS_REG;
                                  }while(((uint8)~tmpStat & PS2_TX_STS_COMPLETE) != 0u);
                              }
              
                              if( (retMode == PS2_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == PS2_REINIT) ||
                                  (retMode == PS2_SEND_WAIT_REINIT) )
                              {
              
                                  #if(PS2_TXCLKGEN_DP)
                                      PS2_TXBITCLKTX_COMPLETE_REG = tx_period;
                                  #else
                                      PS2_TXBITCTR_PERIOD_REG = tx_period;
                                  #endif /* End PS2_TXCLKGEN_DP */
              
                                  #if( (PS2_PARITY_TYPE != PS2__B_UART__NONE_REVB) || \
                                       (PS2_PARITY_TYPE_SW != 0u) )
                                      PS2_WriteControlRegister(PS2_ReadControlRegister() &
                                                                    (uint8)~PS2_CTRL_HD_SEND_BREAK);
                                  #endif /* End PS2_PARITY_TYPE != NONE */
                              }
                          #endif    /* End PS2_HD_ENABLED */
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_SetTxAddressMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Set the transmit addressing mode
                  *
                  * Parameters:
                  *  addressMode: 0 -> Space
                  *               1 -> Mark
                  *
                  * Return:
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 27  

                  *  None.
                  *
                  *******************************************************************************/
                  void PS2_SetTxAddressMode(uint8 addressMode) 
                  {
                      /* Mark/Space sending enable*/
                      if(addressMode != 0u)
                      {
                          #if( PS2_CONTROL_REG_REMOVED == 0u )
                              PS2_WriteControlRegister(PS2_ReadControlRegister() |
                                                                    PS2_CTRL_MARK);
                          #endif /* End PS2_CONTROL_REG_REMOVED == 0u */
                      }
                      else
                      {
                          #if( PS2_CONTROL_REG_REMOVED == 0u )
                              PS2_WriteControlRegister(PS2_ReadControlRegister() &
                                                                  (uint8)~PS2_CTRL_MARK);
                          #endif /* End PS2_CONTROL_REG_REMOVED == 0u */
                      }
                  }
              
              #endif  /* EndPS2_TX_ENABLED */
1626          
1627          #if(PS2_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: PS2_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART.
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void PS2_LoadTxConfig(void) 
                  {
                      #if((PS2_RX_INTERRUPT_ENABLED) && (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          PS2_SetRxInterruptMode(0u);
                      #endif /* PS2_RX_INTERRUPT_ENABLED */
              
                      PS2_WriteControlRegister(PS2_ReadControlRegister() | PS2_CTRL_HD_SEND);
                      PS2_RXBITCTR_PERIOD_REG = PS2_HD_TXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(PS2_RXSTATUS_PTR);
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 28  

                      #endif /* CY_UDB_V0 */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: PS2_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer
                  *  has been used.
                  *
                  *******************************************************************************/
                  void PS2_LoadRxConfig(void) 
                  {
                      PS2_WriteControlRegister(PS2_ReadControlRegister() &
                                                              (uint8)~PS2_CTRL_HD_SEND);
                      PS2_RXBITCTR_PERIOD_REG = PS2_HD_RXBITCTR_INIT;
                      #if(CY_UDB_V0) /* Manually clear status register when mode has been changed */
                          /* Clear status register */
                          CY_GET_REG8(PS2_RXSTATUS_PTR);
                      #endif /* CY_UDB_V0 */
              
                      #if((PS2_RX_INTERRUPT_ENABLED) && (PS2_RXBUFFERSIZE > PS2_FIFO_LENGTH))
                          /* Enable RX interrupt after set RX configuration */
                          PS2_SetRxInterruptMode(PS2_INIT_RX_INTERRUPTS_MASK);
                      #endif /* PS2_RX_INTERRUPT_ENABLED */
                  }
              
              #endif  /* PS2_HD_ENABLED */
1710          
1711          
1712          /* [] END OF FILE */
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION PS2_Start (BEGIN)
                                           ; SOURCE LINE # 73
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 76
0000 900000      R     MOV     DPTR,#PS2_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 78
0008 120000      R     LCALL   PS2_Init
                                           ; SOURCE LINE # 79
000B 900000      R     MOV     DPTR,#PS2_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
0011         ?C0001:
                                           ; SOURCE LINE # 81
0011 120000      R     LCALL   PS2_Enable
                                           ; SOURCE LINE # 82
0014 22                RET     
             ; FUNCTION PS2_Start (END)

             ; FUNCTION PS2_Init (BEGIN)
                                           ; SOURCE LINE # 101
                                           ; SOURCE LINE # 102
                                           ; SOURCE LINE # 118
0000 906484            MOV     DPTR,#06484H
0003 7472              MOV     A,#072H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
0006 906487            MOV     DPTR,#06487H
0009 7420              MOV     A,#020H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
000C 22                RET     
             ; FUNCTION PS2_Init (END)

             ; FUNCTION PS2_Enable (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 181
0008 906494            MOV     DPTR,#06494H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 183
0013 906497            MOV     DPTR,#06497H
0016 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 30  

0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
001E 120000      E     LCALL   PS2_IntClock_Start
                                           ; SOURCE LINE # 209
0021 900000      R     MOV     DPTR,#enableInterrupts
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 210
0029 22                RET     
             ; FUNCTION PS2_Enable (END)

             ; FUNCTION PS2_Stop (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 230
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
0008 906494            MOV     DPTR,#06494H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
0013 120000      E     LCALL   PS2_IntClock_Stop
                                           ; SOURCE LINE # 250
0016 906497            MOV     DPTR,#06497H
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 54EF              ANL     A,#0EFH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
0021 900000      R     MOV     DPTR,#enableInterrupts
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 264
0029 22                RET     
             ; FUNCTION PS2_Stop (END)

             ; FUNCTION PS2_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 284
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 288
0002         ?C0006:
0002 22                RET     
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 31  

             ; FUNCTION PS2_ReadControlRegister (END)

             ; FUNCTION _PS2_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 305
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 308
                                           ; SOURCE LINE # 312
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _PS2_WriteControlRegister (END)

             ; FUNCTION _PS2_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 385
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906487            MOV     DPTR,#06487H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
000F 22                RET     
             ; FUNCTION _PS2_SetRxInterruptMode (END)

             ; FUNCTION PS2_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 478
0000 906443            MOV     DPTR,#06443H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#rxData
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
000A 900000      R     MOV     DPTR,#rxData
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 483
000F         ?C0010:
000F 22                RET     
             ; FUNCTION PS2_ReadRxData (END)

             ; FUNCTION PS2_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 509
                                           ; SOURCE LINE # 510
                                           ; SOURCE LINE # 513
0000 906467            MOV     DPTR,#06467H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#status
000C EF                MOV     A,R7
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 32  

000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
000E 900000      R     MOV     DPTR,#status
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
                                           ; SOURCE LINE # 524
0013         ?C0011:
0013 22                RET     
             ; FUNCTION PS2_ReadRxStatus (END)

             ; FUNCTION PS2_GetChar (BEGIN)
                                           ; SOURCE LINE # 556
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 624
0005 906467            MOV     DPTR,#06467H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#rxStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 625
000F 900000      R     MOV     DPTR,#rxStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 30E51E            JNB     ACC.5,?C0012
                                           ; SOURCE LINE # 626
                                           ; SOURCE LINE # 627
0018 906443            MOV     DPTR,#06443H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#rxData
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
0022 900000      R     MOV     DPTR,#rxStatus
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 541E              ANL     A,#01EH
002A FF                MOV     R7,A
002B 7E00              MOV     R6,#00H
002D EF                MOV     A,R7
002E 4E                ORL     A,R6
002F 6005              JZ      ?C0012
                                           ; SOURCE LINE # 631
                                           ; SOURCE LINE # 632
0031 900000      R     MOV     DPTR,#rxData
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 633
                                           ; SOURCE LINE # 634
0036         ?C0012:
                                           ; SOURCE LINE # 637
0036 900000      R     MOV     DPTR,#rxData
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
                                           ; SOURCE LINE # 638
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 33  

003B         ?C0014:
003B 22                RET     
             ; FUNCTION PS2_GetChar (END)

             ; FUNCTION PS2_GetByte (BEGIN)
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0000 120000      R     LCALL   PS2_ReadRxStatus
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 7D00              MOV     R5,#00H
0008 FC                MOV     R4,A
0009 120000      R     LCALL   PS2_ReadRxData
000C 7E00              MOV     R6,#00H
000E EC                MOV     A,R4
000F 4E                ORL     A,R6
0010 FE                MOV     R6,A
0011 ED                MOV     A,R5
0012 4F                ORL     A,R7
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 661
0014         ?C0015:
0014 22                RET     
             ; FUNCTION PS2_GetByte (END)

             ; FUNCTION PS2_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 732
0000 906467            MOV     DPTR,#06467H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E504            JNB     ACC.5,?C0016
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0017
000D         ?C0016:
000D 7F00              MOV     R7,#00H
000F         ?C0017:
000F 900000      R     MOV     DPTR,#size
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 736
0014 900000      R     MOV     DPTR,#size
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
                                           ; SOURCE LINE # 737
0019         ?C0018:
0019 22                RET     
             ; FUNCTION PS2_GetRxBufferSize (END)

             ; FUNCTION PS2_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 777
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0008 906493            MOV     DPTR,#06493H
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 34  

000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0013 906493            MOV     DPTR,#06493H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 801
0026 22                RET     
             ; FUNCTION PS2_ClearRxBuffer (END)

             ; FUNCTION _PS2_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 832
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 850
                                           ; SOURCE LINE # 852
0005         ?C0021:
0005 22                RET     
             ; FUNCTION _PS2_SetRxAddressMode (END)

             ; FUNCTION _PS2_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 869
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906423            MOV     DPTR,#06423H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 873
000F 22                RET     
             ; FUNCTION _PS2_SetRxAddress1 (END)

             ; FUNCTION _PS2_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 890
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 891
                                           ; SOURCE LINE # 892
0005 900000      R     MOV     DPTR,#address
C51 COMPILER V9.51   PS2                                                                   02/17/2014 11:55:08 PAGE 35  

0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906433            MOV     DPTR,#06433H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 893
000F 22                RET     
             ; FUNCTION _PS2_SetRxAddress2 (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    363    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
