FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0117)     ;---------------------------------------------------
                                        (0118)     ; Insert your custom code below this banner
                                        (0119)     ;---------------------------------------------------
                                        (0120) 
                                        (0121)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0122)     halt                           ;Stop execution if power falls too low
                                        (0123) 
                                        (0124)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0125)     // call	void_handler
0008: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0129)     // call	void_handler
000C: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0133)     // call	void_handler
0010: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0137)     // call	void_handler
0014: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   18h                      ;VC3 Interrupt Vector
                                        (0141)     // call	void_handler
0018: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0145)     // call	void_handler
001C: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 05 E2 LJMP  _Timer8_1_ISR      (0149)     ljmp	_Timer8_1_ISR
0023: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0153)     // call	void_handler
0024: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0157)     // call	void_handler
0028: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0161)     // call	void_handler
002C: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                        (0165)     // call	void_handler
0030: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                        (0169)     // call	void_handler
0034: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                        (0173)     // call	void_handler
0038: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                        (0177)     // call	void_handler
003C: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                        (0181)     // call	void_handler
0040: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                        (0185)     // call	void_handler
0044: 7E       RETI                     (0186)     reti
                                        (0187) 
                                        (0188)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                        (0189)     // call	void_handler
0048: 7E       RETI                     (0190)     reti
                                        (0191) 
                                        (0192)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                        (0193)     // call	void_handler
004C: 7E       RETI                     (0194)     reti
                                        (0195) 
                                        (0196)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                        (0197)     // call	void_handler
0050: 7E       RETI                     (0198)     reti
                                        (0199) 
                                        (0200)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                        (0201)     // call	void_handler
0054: 7E       RETI                     (0202)     reti
                                        (0203) 
                                        (0204)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                        (0205)     // call	void_handler
0058: 7E       RETI                     (0206)     reti
                                        (0207) 
                                        (0208)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                        (0209)     // call	void_handler
005C: 7E       RETI                     (0210)     reti
                                        (0211) 
                                        (0212)     org   60h                      ;PSoC I2C Interrupt Vector
0060: 7D 09 1B LJMP  _EzI2Cs_1_ISR      (0213)     ljmp	_EzI2Cs_1_ISR
0063: 7E       RETI                     (0214)     reti
                                        (0215) 
                                        (0216)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0217)     // call	void_handler
0064: 7E       RETI                     (0218)     reti
0068: 71 10    OR    F,0x10             
                                        (0219)     ;---------------------------------------------------
                                        (0220)     ; Insert your custom code above this banner
                                        (0221)     ;---------------------------------------------------
                                        (0222)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0223) 
                                        (0224) ;-----------------------------------------------------------------------------
                                        (0225) ;  Start of Execution.
                                        (0226) ;-----------------------------------------------------------------------------
                                        (0227) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0228) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0229) ;
                                        (0230) 
                                        (0231) IF	(TOOLCHAIN & HITECH)
                                        (0232)  	AREA PD_startup(CODE, REL, CON)
                                        (0233) ELSE
                                        (0234)     org 68h
                                        (0235) ENDIF
                                        (0236) __Start:
                                        (0237) 
                                        (0238)     ; initialize SMP values for voltage stabilization, if required,
                                        (0239)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0240)     ; least for now. 
                                        (0241)     ;
                                        (0242)     M8C_SetBank1
006A: 62 FA 00 MOV   REG[0xFA],0x0      (0243)     mov reg[0FAh], 0				;Reset flash location
006D: 62 E3 87 MOV   REG[0xE3],0x87     (0244)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
0070: 70 EF    AND   F,0xEF             
                                        (0245)     M8C_SetBank0
                                        (0246) 
                                        (0247)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
0072: 50 20    MOV   A,0x20             (0248)     mov   A, 20h
0074: 28       ROMX                     (0249)     romx
0075: 50 40    MOV   A,0x40             (0250)     mov   A, 40h
0077: 28       ROMX                     (0251)     romx
0078: 50 60    MOV   A,0x60             (0252)     mov   A, 60h
007A: 28       ROMX                     (0253)     romx
007B: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0254)     ; %45%20%46%46% End workaround
                                        (0255) 
                                        (0256) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0257) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0258)     M8C_EnableWatchDog
                                        (0259) ENDIF
                                        (0260) 
                                        (0261) IF ( SELECT_32K )
                                        (0262)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0263) ELSE
007E: 41 FE FB AND   REG[0xFE],0xFB     (0264)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0265) ENDIF
                                        (0266) 
                                        (0267)     ;---------------------------
                                        (0268)     ; Set up the Temporary stack
                                        (0269)     ;---------------------------
                                        (0270)     ; A temporary stack is set up for the SSC instructions.
                                        (0271)     ; The real stack start will be assigned later.
                                        (0272)     ;
                                        (0273) _stack_start:          equ 80h
0081: 50 80    MOV   A,0x80             (0274)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0083: 4E       SWAP  SP,A               (0275)     swap  SP, A                    ; This is only temporary if going to LMM
0084: 62 E3 38 MOV   REG[0xE3],0x38     
0087: 5D D0    MOV   A,REG[0xD0]        
0089: 08       PUSH  A                  
008A: 62 D0 00 MOV   REG[0xD0],0x0      
008D: 55 FA 01 MOV   [sw_Y+98],0x1      
0090: 4F       MOV   X,SP               
0091: 5B       MOV   A,X                
0092: 01 03    ADD   A,0x3              
0094: 53 F9    MOV   [sw_Y+97],A        
0096: 55 F8 3A MOV   [sw_Y+96],0x3A     
0099: 50 06    MOV   A,0x6              
009B: 00       SWI                      
009C: 71 10    OR    F,0x10             
009E: 51 FC    MOV   A,[sw_Y+100]       
00A0: 29 40    OR    A,0x40             
00A2: 60 EA    MOV   REG[0xEA],A        
00A4: 70 EF    AND   F,0xEF             
00A6: 18       POP   A                  
00A7: 60 D0    MOV   REG[0xD0],A        
                                        (0276) 
                                        (0277)     ;-----------------------------------------------
                                        (0278)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0279)     ;-----------------------------------------------
                                        (0280) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0281) 
                                        (0282) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0283)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0284)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0285)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0286)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0287)   IF ( AGND_BYPASS )
                                        (0288)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0289)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0290)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0291)     ; value using the proper trim values.
                                        (0292)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0293)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0294)   ENDIF
                                        (0295)  ENDIF
                                        (0296) ENDIF ; 5.0 V Operation
                                        (0297) 
                                        (0298) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0299)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0300)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0301)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0302)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0303)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0304)  ENDIF
                                        (0305) ENDIF ; 3.3 Volt Operation
                                        (0306) 
00A9: 55 F8 00 MOV   [sw_Y+96],0x0      (0307)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00AC: 55 F9 00 MOV   [sw_Y+97],0x0      (0308)     mov  [bSSC_KEYSP], 0
00AF: 71 10    OR    F,0x10             
                                        (0309) 
                                        (0310)     ;---------------------------------------
                                        (0311)     ; Initialize Crystal Oscillator and PLL
                                        (0312)     ;---------------------------------------
                                        (0313) 
                                        (0314) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0315)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0316)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0317)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0318)     ; the ECO to stabilize.
                                        (0319)     ;
                                        (0320)     M8C_SetBank1
                                        (0321)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0322)     M8C_SetBank0
                                        (0323)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0324)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0325)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0326) .WaitFor1s:
                                        (0327)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0328)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0329)                                           ;   since interrupts are not globally enabled
                                        (0330) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0331)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0332)     M8C_SetBank1
00B1: 62 E0 02 MOV   REG[0xE0],0x2      (0333)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00B4: 70 EF    AND   F,0xEF             
00B6: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0334)     M8C_SetBank0
                                        (0335)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0336) 
                                        (0337) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0338) 
                                        (0339) IF ( PLL_MODE )
                                        (0340)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0341)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0342)     ;
                                        (0343)     M8C_SetBank1
                                        (0344)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0345)     M8C_SetBank0
                                        (0346)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0347)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0348) 
                                        (0349) .WaitFor16ms:
                                        (0350)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0351)     jz   .WaitFor16ms
                                        (0352)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0353)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0354)     M8C_SetBank0
                                        (0355) 
                                        (0356) IF      ( WAIT_FOR_32K )
                                        (0357) ELSE ; !( WAIT_FOR_32K )
                                        (0358)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0359)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0360) ENDIF ;(WAIT_FOR_32K)
                                        (0361) ENDIF ;(PLL_MODE)
                                        (0362) 
                                        (0363) 	;-------------------------------------------------------
                                        (0364)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0365)     ;-------------------------------------------------------
                                        (0366) 
                                        (0367)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0368) 
                                        (0369) IF (SYSCLK_SOURCE)
                                        (0370)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0371) ENDIF
                                        (0372)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0373) 
                                        (0374)     ;------------------------
                                        (0375)     ; Close CT leakage path.
                                        (0376)     ;------------------------
00B9: 62 71 05 MOV   REG[0x71],0x5      (0377)     mov   reg[ACB00CR0], 05h
00BC: 62 75 05 MOV   REG[0x75],0x5      (0378)     mov   reg[ACB01CR0], 05h
00BF: 62 79 05 MOV   REG[0x79],0x5      (0379)     mov   reg[ACB02CR0], 05h
00C2: 62 7D 05 MOV   REG[0x7D],0x5      (0380)     mov   reg[ACB03CR0], 05h
00C5: 62 D1 07 MOV   REG[0xD1],0x7      
                                        (0381) 
                                        (0382) 
                                        (0383) IF	(TOOLCHAIN & HITECH)
                                        (0384)     ;---------------------------------------------
                                        (0385)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0386)     ;---------------------------------------------
                                        (0387) 	global		__Lstackps
                                        (0388) 	mov     a,low __Lstackps
                                        (0389) 	swap    a,sp
                                        (0390) 
                                        (0391) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0392)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0393)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0394)     RAM_SETPAGE_CUR 0
                                        (0395)     RAM_SETPAGE_MVW 0
                                        (0396)     RAM_SETPAGE_MVR 0
                                        (0397)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0398)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0399)     ELSE
                                        (0400)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0401)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0402) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0403) ELSE
                                        (0404)     ;---------------------------------------------
                                        (0405)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0406)     ;---------------------------------------------
                                        (0407) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0408)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00C8: 50 00    MOV   A,0x0              (0409)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00CA: 4E       SWAP  SP,A               (0410)     swap  A, SP
00CB: 62 D3 07 MOV   REG[0xD3],0x7      
00CE: 62 D0 00 MOV   REG[0xD0],0x0      
00D1: 62 D5 00 MOV   REG[0xD5],0x0      
00D4: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0411)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0412)     RAM_SETPAGE_CUR 0
                                        (0413)     RAM_SETPAGE_MVW 0
                                        (0414)     RAM_SETPAGE_MVR 0
                                        (0415) 
                                        (0416)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00D7: 71 C0    OR    F,0xC0             (0417)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0418)   ELSE
                                        (0419)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0420)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0421) ELSE
                                        (0422)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0423)     swap  SP, A
                                        (0424) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0425) ENDIF ;	TOOLCHAIN
                                        (0426) 
                                        (0427)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0428)     ;---------------------------------------------------
                                        (0429)     ; Insert your custom code below this banner
                                        (0430)     ;---------------------------------------------------
                                        (0431) 
                                        (0432)     ;---------------------------------------------------
                                        (0433)     ; Insert your custom code above this banner
                                        (0434)     ;---------------------------------------------------
                                        (0435)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0436) 
                                        (0437)     ;-------------------------
                                        (0438)     ; Load Base Configuration
                                        (0439)     ;-------------------------
                                        (0440)     ; Load global parameter settings and load the user modules in the
                                        (0441)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0442)     ; to minimize start up time; (2) We may still need to play with the
                                        (0443)     ; Sleep Timer.
                                        (0444)     ;
00D9: 7C 05 71 LCALL 0x0571             (0445)     lcall LoadConfigInit
                                        (0446) 
                                        (0447)     ;-----------------------------------
                                        (0448)     ; Initialize C Run-Time Environment
                                        (0449)     ;-----------------------------------
                                        (0450) IF ( C_LANGUAGE_SUPPORT )
                                        (0451) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0452)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0453)     mov  [__r0],<__bss_start
                                        (0454) BssLoop:
                                        (0455)     cmp  [__r0],<__bss_end
                                        (0456)     jz   BssDone
                                        (0457)     mvi  [__r0],A
                                        (0458)     jmp  BssLoop
                                        (0459) BssDone:
                                        (0460)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0461)     mov  X,<__idata_start
                                        (0462)     mov  [__r0],<__data_start
                                        (0463) IDataLoop:
                                        (0464)     cmp  [__r0],<__data_end
                                        (0465)     jz   C_RTE_Done
                                        (0466)     push A
                                        (0467)     romx
                                        (0468)     mvi  [__r0],A
                                        (0469)     pop  A
                                        (0470)     inc  X
                                        (0471)     adc  A,0
                                        (0472)     jmp  IDataLoop
                                        (0473) 
                                        (0474) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0475) 
                                        (0476) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00DC: 62 D0 00 MOV   REG[0xD0],0x0      (0477)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0478)                                        ; to use the Virtual Register page.
                                        (0479) 
                                        (0480)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0481)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0482)     ; text segment and may have been relocated by the Code Compressor.
                                        (0483)     ;
00DF: 50 04    MOV   A,0x4              (0484)     mov   A, >__pXIData                ; Get the address of the flash
00E1: 57 68    MOV   X,0x68             (0485)     mov   X, <__pXIData                ;   pointer to the xidata area.
00E3: 08       PUSH  A                  (0486)     push  A
00E4: 28       ROMX                     (0487)     romx                               ; get the MSB of xidata's address
00E5: 53 49    MOV   [__r0],A           (0488)     mov   [__r0], A
00E7: 18       POP   A                  (0489)     pop   A
00E8: 75       INC   X                  (0490)     inc   X
00E9: 09 00    ADC   A,0x0              (0491)     adc   A, 0
00EB: 28       ROMX                     (0492)     romx                               ; get the LSB of xidata's address
00EC: 4B       SWAP  A,X                (0493)     swap  A, X
00ED: 51 49    MOV   A,[__r0]           (0494)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0495)                                        ;   XIData structure list in flash
00EF: 80 04    JMP   0x00F4             (0496)     jmp   .AccessStruct
                                        (0497) 
                                        (0498)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0499)     ; values of C variables. Each structure contains 3 member elements.
                                        (0500)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0501)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0502)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0503)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0504)     ; value in the second member element, an unsigned byte:
                                        (0505)     ; (1) If the value of the second element is non-zero, it represents
                                        (0506)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0507)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0508)     ; the bytes are copied to the block of RAM.
                                        (0509)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0510)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0511)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0512) 
                                        (0513) .AccessNextStructLoop:
00F1: 75       INC   X                  (0514)     inc   X                            ; pXIData++
00F2: 09 00    ADC   A,0x0              (0515)     adc   A, 0
00F4: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0516) .AccessStruct:                         ; Entry point for first block
                                        (0517)     ;
                                        (0518)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0519)     ;
                                        (0520)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00F7: 08       PUSH  A                  (0521)     push  A
00F8: 28       ROMX                     (0522)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00F9: 60 D5    MOV   REG[0xD5],A        (0523)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00FB: 74       INC   A                  (0524)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00FC: A0 4B    JZ    0x0148             (0525)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00FE: 18       POP   A                  (0526)     pop   A                            ; restore pXIData to [A,X]
00FF: 75       INC   X                  (0527)     inc   X                            ; pXIData++
0100: 09 00    ADC   A,0x0              (0528)     adc   A, 0
0102: 08       PUSH  A                  (0529)     push  A
0103: 28       ROMX                     (0530)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
0104: 53 49    MOV   [__r0],A           (0531)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
0106: 18       POP   A                  (0532)     pop   A                            ; restore pXIData to [A,X]
0107: 75       INC   X                  (0533)     inc   X                            ; pXIData++ (point to size)
0108: 09 00    ADC   A,0x0              (0534)     adc   A, 0
010A: 08       PUSH  A                  (0535)     push  A
010B: 28       ROMX                     (0536)     romx                               ; Get the size (CPU.A <- *pXIData)
010C: A0 1C    JZ    0x0129             (0537)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
010E: 53 48    MOV   [__r1],A           (0538)     mov   [__r1], A                    ;             else downcount in __r1
0110: 18       POP   A                  (0539)     pop   A                            ; restore pXIData to [A,X]
                                        (0540) 
                                        (0541) .CopyNextByteLoop:
                                        (0542)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0543)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0544)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0545)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0546)     ;
0111: 75       INC   X                  (0547)     inc   X                            ; pXIData++ (point to next data byte)
0112: 09 00    ADC   A,0x0              (0548)     adc   A, 0
0114: 08       PUSH  A                  (0549)     push  A
0115: 28       ROMX                     (0550)     romx                               ; Get the data value (CPU.A <- *pXIData)
0116: 3F 49    MVI   [__r0],A           (0551)     mvi   [__r0], A                    ; Transfer the data to RAM
0118: 47 49 FF TST   [__r0],0xFF        (0552)     tst   [__r0], 0xff                 ; Check for page crossing
011B: B0 06    JNZ   0x0122             (0553)     jnz   .CopyLoopTail                ;   No crossing, keep going
011D: 5D D5    MOV   A,REG[0xD5]        (0554)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
011F: 74       INC   A                  (0555)     inc   A
0120: 60 D5    MOV   REG[0xD5],A        (0556)     mov   reg[ MVW_PP], A
                                        (0557) .CopyLoopTail:
0122: 18       POP   A                  (0558)     pop   A                            ; restore pXIData to [A,X]
0123: 7A 48    DEC   [__r1]             (0559)     dec   [__r1]                       ; End of this array in flash?
0125: BF EB    JNZ   0x0111             (0560)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
0127: 8F C9    JMP   0x00F1             (0561)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0562) 
                                        (0563) .ClearRAMBlockToZero:
0129: 18       POP   A                  (0564)     pop   A                            ; restore pXIData to [A,X]
012A: 75       INC   X                  (0565)     inc   X                            ; pXIData++ (point to next data byte)
012B: 09 00    ADC   A,0x0              (0566)     adc   A, 0
012D: 08       PUSH  A                  (0567)     push  A
012E: 28       ROMX                     (0568)     romx                               ; Get the run length (CPU.A <- *pXIData)
012F: 53 48    MOV   [__r1],A           (0569)     mov   [__r1], A                    ; Initialize downcounter
0131: 50 00    MOV   A,0x0              (0570)     mov   A, 0                         ; Initialize source data
                                        (0571) 
                                        (0572) .ClearRAMBlockLoop:
                                        (0573)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0574)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0575)     ;
0133: 3F 49    MVI   [__r0],A           (0576)     mvi   [__r0], A                    ; Clear a byte
0135: 47 49 FF TST   [__r0],0xFF        (0577)     tst   [__r0], 0xff                 ; Check for page crossing
0138: B0 08    JNZ   0x0141             (0578)     jnz   .ClearLoopTail               ;   No crossing, keep going
013A: 5D D5    MOV   A,REG[0xD5]        (0579)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
013C: 74       INC   A                  (0580)     inc   A
013D: 60 D5    MOV   REG[0xD5],A        (0581)     mov   reg[ MVW_PP], A
013F: 50 00    MOV   A,0x0              (0582)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0583) .ClearLoopTail:
0141: 7A 48    DEC   [__r1]             (0584)     dec   [__r1]                       ; Was this the last byte?
0143: BF EF    JNZ   0x0133             (0585)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0145: 18       POP   A                  (0586)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0146: 8F AA    JMP   0x00F1             (0587)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0588) 
                                        (0589) .C_RTE_WrapUp:
0148: 18       POP   A                  (0590)     pop   A                            ; balance stack
0149: 71 10    OR    F,0x10             
                                        (0591) 
                                        (0592) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0593) 
                                        (0594) C_RTE_Done:
                                        (0595) 
                                        (0596) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0597) 
                                        (0598)     ;-------------------------------
                                        (0599)     ; Voltage Stabilization for SMP
                                        (0600)     ;-------------------------------
                                        (0601) 
                                        (0602) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0603) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0604)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0605)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0606)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0607)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0608)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0609)     M8C_SetBank1
                                        (0610)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0611)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0612)     M8C_SetBank0
                                        (0613)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0614)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0615) .WaitFor2ms:
                                        (0616)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0617)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0618) ENDIF ; SMP is operational
                                        (0619) ENDIF ; 5.0V Operation
                                        (0620) 
                                        (0621)     ;-------------------------------
                                        (0622)     ; Set Power-On Reset (POR) Level
                                        (0623)     ;-------------------------------
                                        (0624)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH, 
                                        (0625)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper 
                                        (0626)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0627)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0628)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0629) 
                                        (0630)     M8C_SetBank1
                                        (0631) 
                                        (0632) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
                                        (0633)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
                                        (0634)  ELSE                                       ;    No, fast mode
                                        (0635)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
                                        (0636)                                             ;       no, set midpoint POR in user code, if desired
                                        (0637)   ELSE ; 24HMz                              ;
014B: 43 E3 20 OR    REG[0xE3],0x20     (0638)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
014E: 70 EF    AND   F,0xEF             
                                        (0639)   ENDIF ; 24MHz
                                        (0640)  ENDIF ; Slow Mode
                                        (0641) ENDIF ; 5.0V Operation
                                        (0642) 
                                        (0643)     M8C_SetBank0
                                        (0644) 
                                        (0645)     ;----------------------------
                                        (0646)     ; Wrap up and invoke "main"
                                        (0647)     ;----------------------------
                                        (0648) 
                                        (0649)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0650)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0651)     ;
0150: 62 E0 00 MOV   REG[0xE0],0x0      (0652)     mov  reg[INT_MSK0],0
0153: 71 10    OR    F,0x10             
                                        (0653) 
                                        (0654)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0655)     ; And put decimator in full mode so it does not consume too much current.
                                        (0656)     ;
                                        (0657)     M8C_SetBank1
0155: 62 E0 03 MOV   REG[0xE0],0x3      (0658)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0158: 43 E7 80 OR    REG[0xE7],0x80     (0659)     or   reg[DEC_CR2],80h                    ; Put decimator in full mode
015B: 70 EF    AND   F,0xEF             
                                        (0660)     M8C_SetBank0
                                        (0661) 
                                        (0662)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0663)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0664)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0665)     ;
015D: 62 E2 00 MOV   REG[0xE2],0x0      (0666)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0667)                                    ; have been set during the boot process.
                                        (0668) IF	(TOOLCHAIN & HITECH)
                                        (0669) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0670) ELSE
                                        (0671) IF ENABLE_LJMP_TO_MAIN
                                        (0672)     ljmp  _main                    ; goto main (no return)
                                        (0673) ELSE
0160: 7C 0A 72 LCALL __UserModules_end|_main|__text_start|_main(0674)     lcall _main                    ; call main
                                        (0675) .Exit:
0163: 8F FF    JMP   0x0163             (0676)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0677) ENDIF
                                        (0678) ENDIF ; TOOLCHAIN
                                        (0679) 
                                        (0680)     ;---------------------------------
                                        (0681)     ; Library Access to Global Parms
                                        (0682)     ;---------------------------------
                                        (0683)     ;
                                        (0684)  bGetPowerSetting:
                                        (0685) _bGetPowerSetting:
                                        (0686)     ; Returns value of POWER_SETTING in the A register.
                                        (0687)     ; No inputs. No Side Effects.
                                        (0688)     ;
0165: 50 10    MOV   A,0x10             (0689)     mov   A, POWER_SETTING
0167: 7F       RET                      (0690)     ret
                                        (0691) 
                                        (0692) IF	(TOOLCHAIN & HITECH)
                                        (0693) ELSE
                                        (0694)     ;---------------------------------
                                        (0695)     ; Order Critical RAM & ROM AREAs
                                        (0696)     ;---------------------------------
                                        (0697)     ;  'TOP' is all that has been defined so far...
                                        (0698) 
                                        (0699)     ;  ROM AREAs for C CONST, static & global items
                                        (0700)     ;
                                        (0701)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0702)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0703) __idata_start:
                                        (0704) 
                                        (0705)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0706) __func_lit_start:
                                        (0707) 
                                        (0708) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0709)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0710)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0711)     ; relocated by the code compressor, but the text area may shrink and
                                        (0712)     ; that moves xidata around.
                                        (0713)     ;
                                        (0714) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0715) ENDIF
                                        (0716) 
                                        (0717)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0718)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0719) 
                                        (0720)     ; CODE segment for general use
                                        (0721)     ;
                                        (0722)     AREA text (ROM, REL, CON)
                                        (0723) __text_start:
                                        (0724) 
                                        (0725)     ; RAM area usage
                                        (0726)     ;
                                        (0727)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0728) __data_start:
                                        (0729) 
                                        (0730)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0731)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0732)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0733) __bss_start:
                                        (0734) 
                                        (0735) ENDIF ; TOOLCHAIN
                                        (0736) 
                                        (0737) ; end of file boot.asm
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.2946
046C: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_catchrobo_dcm2_Bank1
                                        (0019) export LoadConfigTBL_catchrobo_dcm2_Bank0
                                        (0020) export LoadConfigTBL_catchrobo_dcm2_Ordered
                                        (0021) AREA lit(rom, rel)
                                        (0022) LoadConfigTBL_catchrobo_dcm2_Bank0:
                                        (0023) ;  Instance name EzI2Cs_1, User Module EzI2Cs
                                        (0024) ;  Instance name LCD_1, User Module LCD
                                        (0025) ;  Instance name MBM_1, User Module MBM
                                        (0026) ;  Instance name PRS32_X, User Module PRS32
                                        (0027) ;       Instance name PRS32_X, Block Name PRS32_ISB1(DBB11)
                                        (0028) 	db		37h, 00h		;PRS32_X_CONTROL_REG_ISB1(DBB11CR0)
                                        (0029) 	db		35h, 00h		;PRS32_X_POLY_REG_ISB1   (DBB11DR1)
                                        (0030) 	db		36h, 00h		;PRS32_X_SEED_REG_ISB1   (DBB11DR2)
                                        (0031) ;       Instance name PRS32_X, Block Name PRS32_ISB2(DCB12)
                                        (0032) 	db		3bh, 00h		;PRS32_X_CONTROL_REG_ISB2(DCB12CR0)
                                        (0033) 	db		39h, 00h		;PRS32_X_POLY_REG_ISB2   (DCB12DR1)
                                        (0034) 	db		3ah, 00h		;PRS32_X_SEED_REG_ISB2   (DCB12DR2)
                                        (0035) ;       Instance name PRS32_X, Block Name PRS32_LSB(DBB10)
                                        (0036) 	db		33h, 00h		;PRS32_X_CONTROL_REG_LSB (DBB10CR0)
                                        (0037) 	db		31h, 00h		;PRS32_X_POLY_REG_LSB    (DBB10DR1)
                                        (0038) 	db		32h, 00h		;PRS32_X_SEED_REG_LSB    (DBB10DR2)
                                        (0039) ;       Instance name PRS32_X, Block Name PRS32_MSB(DCB13)
                                        (0040) 	db		3fh, 00h		;PRS32_X_CONTROL_REG_MSB (DCB13CR0)
                                        (0041) 	db		3dh, 00h		;PRS32_X_POLY_REG_MSB    (DCB13DR1)
                                        (0042) 	db		3eh, 00h		;PRS32_X_SEED_REG_MSB    (DCB13DR2)
                                        (0043) ;  Instance name PRS32_Y, User Module PRS32
                                        (0044) ;       Instance name PRS32_Y, Block Name PRS32_ISB1(DBB21)
                                        (0045) 	db		47h, 00h		;PRS32_Y_CONTROL_REG_ISB1(DBB21CR0)
                                        (0046) 	db		45h, 00h		;PRS32_Y_POLY_REG_ISB1   (DBB21DR1)
                                        (0047) 	db		46h, 00h		;PRS32_Y_SEED_REG_ISB1   (DBB21DR2)
                                        (0048) ;       Instance name PRS32_Y, Block Name PRS32_ISB2(DCB22)
                                        (0049) 	db		4bh, 00h		;PRS32_Y_CONTROL_REG_ISB2(DCB22CR0)
                                        (0050) 	db		49h, 00h		;PRS32_Y_POLY_REG_ISB2   (DCB22DR1)
                                        (0051) 	db		4ah, 00h		;PRS32_Y_SEED_REG_ISB2   (DCB22DR2)
                                        (0052) ;       Instance name PRS32_Y, Block Name PRS32_LSB(DBB20)
                                        (0053) 	db		43h, 00h		;PRS32_Y_CONTROL_REG_LSB (DBB20CR0)
                                        (0054) 	db		41h, 00h		;PRS32_Y_POLY_REG_LSB    (DBB20DR1)
                                        (0055) 	db		42h, 00h		;PRS32_Y_SEED_REG_LSB    (DBB20DR2)
                                        (0056) ;       Instance name PRS32_Y, Block Name PRS32_MSB(DCB23)
                                        (0057) 	db		4fh, 00h		;PRS32_Y_CONTROL_REG_MSB (DCB23CR0)
                                        (0058) 	db		4dh, 00h		;PRS32_Y_POLY_REG_MSB    (DCB23DR1)
                                        (0059) 	db		4eh, 00h		;PRS32_Y_SEED_REG_MSB    (DCB23DR2)
                                        (0060) ;  Instance name PRS32_Z, User Module PRS32
                                        (0061) ;       Instance name PRS32_Z, Block Name PRS32_ISB1(DBB31)
                                        (0062) 	db		57h, 00h		;PRS32_Z_CONTROL_REG_ISB1(DBB31CR0)
                                        (0063) 	db		55h, 00h		;PRS32_Z_POLY_REG_ISB1   (DBB31DR1)
                                        (0064) 	db		56h, 00h		;PRS32_Z_SEED_REG_ISB1   (DBB31DR2)
                                        (0065) ;       Instance name PRS32_Z, Block Name PRS32_ISB2(DCB32)
                                        (0066) 	db		5bh, 00h		;PRS32_Z_CONTROL_REG_ISB2(DCB32CR0)
                                        (0067) 	db		59h, 00h		;PRS32_Z_POLY_REG_ISB2   (DCB32DR1)
                                        (0068) 	db		5ah, 00h		;PRS32_Z_SEED_REG_ISB2   (DCB32DR2)
                                        (0069) ;       Instance name PRS32_Z, Block Name PRS32_LSB(DBB30)
                                        (0070) 	db		53h, 00h		;PRS32_Z_CONTROL_REG_LSB (DBB30CR0)
                                        (0071) 	db		51h, 00h		;PRS32_Z_POLY_REG_LSB    (DBB30DR1)
                                        (0072) 	db		52h, 00h		;PRS32_Z_SEED_REG_LSB    (DBB30DR2)
                                        (0073) ;       Instance name PRS32_Z, Block Name PRS32_MSB(DCB33)
                                        (0074) 	db		5fh, 00h		;PRS32_Z_CONTROL_REG_MSB (DCB33CR0)
                                        (0075) 	db		5dh, 00h		;PRS32_Z_POLY_REG_MSB    (DCB33DR1)
                                        (0076) 	db		5eh, 00h		;PRS32_Z_SEED_REG_MSB    (DCB33DR2)
                                        (0077) ;  Instance name SHADOWREGS_1, User Module SHADOWREGS
                                        (0078) ;  Instance name SHADOWREGS_2, User Module SHADOWREGS
                                        (0079) ;  Instance name SHADOWREGS_3, User Module SHADOWREGS
                                        (0080) ;  Instance name Timer8_1, User Module Timer8
                                        (0081) ;       Instance name Timer8_1, Block Name TIMER8(DBB00)
                                        (0082) 	db		23h, 04h		;Timer8_1_CONTROL_REG(DBB00CR0)
                                        (0083) 	db		21h, f9h		;Timer8_1_PERIOD_REG(DBB00DR1)
                                        (0084) 	db		22h, 00h		;Timer8_1_COMPARE_REG(DBB00DR2)
                                        (0085) ;  Global Register values Bank 0
                                        (0086) 	db		60h, 28h		; AnalogColumnInputSelect register (AMX_IN)
                                        (0087) 	db		66h, 00h		; AnalogComparatorControl1 register (CMP_CR1)
                                        (0088) 	db		63h, 10h		; AnalogReferenceControl register (ARF_CR)
                                        (0089) 	db		65h, 00h		; AnalogSyncControl register (ASY_CR)
                                        (0090) 	db		e6h, 00h		; DecimatorControl_0 register (DEC_CR0)
                                        (0091) 	db		e7h, 00h		; DecimatorControl_1 register (DEC_CR1)
                                        (0092) 	db		d6h, 08h		; I2CConfig register (I2C_CFG)
                                        (0093) 	db		b0h, 00h		; Row_0_InputMux register (RDI0RI)
                                        (0094) 	db		b1h, 00h		; Row_0_InputSync register (RDI0SYN)
                                        (0095) 	db		b2h, 00h		; Row_0_LogicInputAMux register (RDI0IS)
                                        (0096) 	db		b3h, 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
                                        (0097) 	db		b4h, 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
                                        (0098) 	db		b5h, 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
                                        (0099) 	db		b6h, 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
                                        (0100) 	db		b8h, 55h		; Row_1_InputMux register (RDI1RI)
                                        (0101) 	db		b9h, 00h		; Row_1_InputSync register (RDI1SYN)
                                        (0102) 	db		bah, 10h		; Row_1_LogicInputAMux register (RDI1IS)
                                        (0103) 	db		bbh, 33h		; Row_1_LogicSelect_0 register (RDI1LT0)
                                        (0104) 	db		bch, 33h		; Row_1_LogicSelect_1 register (RDI1LT1)
                                        (0105) 	db		bdh, 00h		; Row_1_OutputDrive_0 register (RDI1SRO0)
                                        (0106) 	db		beh, 0ch		; Row_1_OutputDrive_1 register (RDI1SRO1)
                                        (0107) 	db		c0h, 00h		; Row_2_InputMux register (RDI2RI)
                                        (0108) 	db		c1h, 00h		; Row_2_InputSync register (RDI2SYN)
                                        (0109) 	db		c2h, 20h		; Row_2_LogicInputAMux register (RDI2IS)
                                        (0110) 	db		c3h, 33h		; Row_2_LogicSelect_0 register (RDI2LT0)
                                        (0111) 	db		c4h, 33h		; Row_2_LogicSelect_1 register (RDI3LT1)
                                        (0112) 	db		c5h, 30h		; Row_2_OutputDrive_0 register (RDI2SRO0)
                                        (0113) 	db		c6h, 00h		; Row_2_OutputDrive_1 register (RDI2SRO1)
                                        (0114) 	db		c8h, 55h		; Row_3_InputMux register (RDI3RI)
                                        (0115) 	db		c9h, 00h		; Row_3_InputSync register (RDI3SYN)
                                        (0116) 	db		cah, 30h		; Row_3_LogicInputAMux register (RDI3IS)
                                        (0117) 	db		cbh, 33h		; Row_3_LogicSelect_0 register (RDI3LT0)
                                        (0118) 	db		cch, 33h		; Row_3_LogicSelect_1 register (RDI3LT1)
                                        (0119) 	db		cdh, 00h		; Row_3_OutputDrive_0 register (RDI3SRO0)
                                        (0120) 	db		ceh, 20h		; Row_3_OutputDrive_1 register (RDI3SRO1)
                                        (0121) 	db		6ch, 00h		; TMP_DR0 register (TMP_DR0)
                                        (0122) 	db		6dh, 00h		; TMP_DR1 register (TMP_DR1)
                                        (0123) 	db		6eh, 00h		; TMP_DR2 register (TMP_DR2)
                                        (0124) 	db		6fh, 00h		; TMP_DR3 register (TMP_DR3)
                                        (0125) 	db		ffh
                                        (0126) LoadConfigTBL_catchrobo_dcm2_Bank1:
                                        (0127) ;  Instance name EzI2Cs_1, User Module EzI2Cs
                                        (0128) ;  Instance name LCD_1, User Module LCD
                                        (0129) ;  Instance name MBM_1, User Module MBM
                                        (0130) ;  Instance name PRS32_X, User Module PRS32
                                        (0131) ;       Instance name PRS32_X, Block Name PRS32_ISB1(DBB11)
                                        (0132) 	db		34h, 0ah		;PRS32_X_FUNC_REG_ISB1   (DBB11FN)
                                        (0133) 	db		35h, 36h		;PRS32_X_INPUT_REG_ISB1  (DBB11IN)
                                        (0134) 	db		36h, 40h		;PRS32_X_OUTPUT_REG_ISB1 (DBB11OU)
                                        (0135) ;       Instance name PRS32_X, Block Name PRS32_ISB2(DCB12)
                                        (0136) 	db		38h, 0ah		;PRS32_X_FUNC_REG_ISB2   (DCB12FN)
                                        (0137) 	db		39h, 36h		;PRS32_X_INPUT_REG_ISB2  (DCB12IN)
                                        (0138) 	db		3ah, 40h		;PRS32_X_OUTPUT_REG_ISB2 (DCB12OU)
                                        (0139) ;       Instance name PRS32_X, Block Name PRS32_LSB(DBB10)
                                        (0140) 	db		30h, 0ah		;PRS32_X_FUNC_REG_LSB    (DBB10FN)
                                        (0141) 	db		31h, 06h		;PRS32_X_INPUT_REG_LSB   (DBB10IN)
                                        (0142) 	db		32h, 40h		;PRS32_X_OUTPUT_REG_LSB  (DBB10OU)
                                        (0143) ;       Instance name PRS32_X, Block Name PRS32_MSB(DCB13)
                                        (0144) 	db		3ch, 2ah		;PRS32_X_FUNC_REG_MSB    (DCB13FN)
                                        (0145) 	db		3dh, 36h		;PRS32_X_INPUT_REG_MSB   (DCB13IN)
                                        (0146) 	db		3eh, 70h		;PRS32_X_OUTPUT_REG_MSB  (DCB13OU)
                                        (0147) ;  Instance name PRS32_Y, User Module PRS32
                                        (0148) ;       Instance name PRS32_Y, Block Name PRS32_ISB1(DBB21)
                                        (0149) 	db		44h, 0ah		;PRS32_Y_FUNC_REG_ISB1   (DBB21FN)
                                        (0150) 	db		45h, 36h		;PRS32_Y_INPUT_REG_ISB1  (DBB21IN)
                                        (0151) 	db		46h, 40h		;PRS32_Y_OUTPUT_REG_ISB1 (DBB21OU)
                                        (0152) ;       Instance name PRS32_Y, Block Name PRS32_ISB2(DCB22)
                                        (0153) 	db		48h, 0ah		;PRS32_Y_FUNC_REG_ISB2   (DCB22FN)
                                        (0154) 	db		49h, 36h		;PRS32_Y_INPUT_REG_ISB2  (DCB22IN)
                                        (0155) 	db		4ah, 40h		;PRS32_Y_OUTPUT_REG_ISB2 (DCB22OU)
                                        (0156) ;       Instance name PRS32_Y, Block Name PRS32_LSB(DBB20)
                                        (0157) 	db		40h, 0ah		;PRS32_Y_FUNC_REG_LSB    (DBB20FN)
                                        (0158) 	db		41h, 06h		;PRS32_Y_INPUT_REG_LSB   (DBA20IN)
                                        (0159) 	db		42h, 40h		;PRS32_Y_OUTPUT_REG_LSB  (DBA20OU)
                                        (0160) ;       Instance name PRS32_Y, Block Name PRS32_MSB(DCB23)
                                        (0161) 	db		4ch, 2ah		;PRS32_Y_FUNC_REG_MSB    (DCB23FN)
                                        (0162) 	db		4dh, 36h		;PRS32_Y_INPUT_REG_MSB   (DCB23IN)
                                        (0163) 	db		4eh, 68h		;PRS32_Y_OUTPUT_REG_MSB  (DCB23OU)
                                        (0164) ;  Instance name PRS32_Z, User Module PRS32
                                        (0165) ;       Instance name PRS32_Z, Block Name PRS32_ISB1(DBB31)
                                        (0166) 	db		54h, 0ah		;PRS32_Z_FUNC_REG_ISB1   (DBB31FN)
                                        (0167) 	db		55h, 36h		;PRS32_Z_INPUT_REG_ISB1  (DBB31IN)
                                        (0168) 	db		56h, 40h		;PRS32_Z_OUTPUT_REG_ISB1 (DBB31OU)
                                        (0169) ;       Instance name PRS32_Z, Block Name PRS32_ISB2(DCB32)
                                        (0170) 	db		58h, 0ah		;PRS32_Z_FUNC_REG_ISB2   (DCB32FN)
                                        (0171) 	db		59h, 36h		;PRS32_Z_INPUT_REG_ISB2  (DCB32IN)
                                        (0172) 	db		5ah, 40h		;PRS32_Z_OUTPUT_REG_ISB2 (DCB32OU)
                                        (0173) ;       Instance name PRS32_Z, Block Name PRS32_LSB(DBB30)
                                        (0174) 	db		50h, 0ah		;PRS32_Z_FUNC_REG_LSB    (DBB30FN)
                                        (0175) 	db		51h, 06h		;PRS32_Z_INPUT_REG_LSB   (DBB30IN)
                                        (0176) 	db		52h, 40h		;PRS32_Z_OUTPUT_REG_LSB  (DBB30OU)
                                        (0177) ;       Instance name PRS32_Z, Block Name PRS32_MSB(DCB33)
                                        (0178) 	db		5ch, 2ah		;PRS32_Z_FUNC_REG_MSB    (DCB33FN)
                                        (0179) 	db		5dh, 36h		;PRS32_Z_INPUT_REG_MSB   (DCB33IN)
                                        (0180) 	db		5eh, 78h		;PRS32_Z_OUTPUT_REG_MSB  (DCB33OU)
                                        (0181) ;  Instance name SHADOWREGS_1, User Module SHADOWREGS
                                        (0182) ;  Instance name SHADOWREGS_2, User Module SHADOWREGS
                                        (0183) ;  Instance name SHADOWREGS_3, User Module SHADOWREGS
                                        (0184) ;  Instance name Timer8_1, User Module Timer8
                                        (0185) ;       Instance name Timer8_1, Block Name TIMER8(DBB00)
                                        (0186) 	db		20h, 20h		;Timer8_1_FUNC_REG(DBB00FN)
                                        (0187) 	db		21h, 01h		;Timer8_1_INPUT_REG(DBB00IN)
                                        (0188) 	db		22h, 40h		;Timer8_1_OUTPUT_REG(DBB00OU)
                                        (0189) ;  Global Register values Bank 1
                                        (0190) 	db		61h, 00h		; AnalogClockSelect1 register (CLK_CR1)
                                        (0191) 	db		69h, 00h		; AnalogClockSelect2 register (CLK_CR2)
                                        (0192) 	db		60h, 00h		; AnalogColumnClockSelect register (CLK_CR0)
                                        (0193) 	db		62h, 00h		; AnalogIOControl_0 register (ABF_CR0)
                                        (0194) 	db		67h, 33h		; AnalogLUTControl0 register (ALT_CR0)
                                        (0195) 	db		68h, 33h		; AnalogLUTControl1 register (ALT_CR1)
                                        (0196) 	db		63h, 00h		; AnalogModulatorControl_0 register (AMD_CR0)
                                        (0197) 	db		66h, 00h		; AnalogModulatorControl_1 register (AMD_CR1)
                                        (0198) 	db		d1h, 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
                                        (0199) 	db		d3h, 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
                                        (0200) 	db		d0h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
                                        (0201) 	db		d2h, 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
                                        (0202) 	db		e1h, bfh		; OscillatorControl_1 register (OSC_CR1)
                                        (0203) 	db		e2h, 00h		; OscillatorControl_2 register (OSC_CR2)
                                        (0204) 	db		dfh, ffh		; OscillatorControl_3 register (OSC_CR3)
                                        (0205) 	db		deh, 00h		; OscillatorControl_4 register (OSC_CR4)
                                        (0206) 	db		ddh, 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
                                        (0207) 	db		e7h, 00h		; Type2Decimator_Control register (DEC_CR2)
                                        (0208) 	db		ffh
                                        (0209) AREA psoc_config(rom, rel)
                                        (0210) LoadConfigTBL_catchrobo_dcm2_Ordered:
                                        (0211) ;  Ordered Global Register values
                                        (0212) 	M8C_SetBank0
046E: 62 00 00 MOV   REG[0x0],0x0       (0213) 	mov	reg[00h], 00h		; Port_0_Data register (PRT0DR)
0471: 71 10    OR    F,0x10             
                                        (0214) 	M8C_SetBank1
0473: 62 00 FF MOV   REG[0x0],0xFF      (0215) 	mov	reg[00h], ffh		; Port_0_DriveMode_0 register (PRT0DM0)
0476: 62 01 00 MOV   REG[0x1],0x0       (0216) 	mov	reg[01h], 00h		; Port_0_DriveMode_1 register (PRT0DM1)
0479: 70 EF    AND   F,0xEF             
                                        (0217) 	M8C_SetBank0
047B: 62 03 00 MOV   REG[0x3],0x0       (0218) 	mov	reg[03h], 00h		; Port_0_DriveMode_2 register (PRT0DM2)
047E: 62 02 80 MOV   REG[0x2],0x80      (0219) 	mov	reg[02h], 80h		; Port_0_GlobalSelect register (PRT0GS)
0481: 71 10    OR    F,0x10             
                                        (0220) 	M8C_SetBank1
0483: 62 02 00 MOV   REG[0x2],0x0       (0221) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
0486: 62 03 00 MOV   REG[0x3],0x0       (0222) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
0489: 70 EF    AND   F,0xEF             
                                        (0223) 	M8C_SetBank0
048B: 62 01 00 MOV   REG[0x1],0x0       (0224) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
048E: 62 04 A0 MOV   REG[0x4],0xA0      (0225) 	mov	reg[04h], a0h		; Port_1_Data register (PRT1DR)
0491: 71 10    OR    F,0x10             
                                        (0226) 	M8C_SetBank1
0493: 62 04 FC MOV   REG[0x4],0xFC      (0227) 	mov	reg[04h], fch		; Port_1_DriveMode_0 register (PRT1DM0)
0496: 62 05 A3 MOV   REG[0x5],0xA3      (0228) 	mov	reg[05h], a3h		; Port_1_DriveMode_1 register (PRT1DM1)
0499: 70 EF    AND   F,0xEF             
                                        (0229) 	M8C_SetBank0
049B: 62 07 A3 MOV   REG[0x7],0xA3      (0230) 	mov	reg[07h], a3h		; Port_1_DriveMode_2 register (PRT1DM2)
049E: 62 06 44 MOV   REG[0x6],0x44      (0231) 	mov	reg[06h], 44h		; Port_1_GlobalSelect register (PRT1GS)
04A1: 71 10    OR    F,0x10             
                                        (0232) 	M8C_SetBank1
04A3: 62 06 00 MOV   REG[0x6],0x0       (0233) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
04A6: 62 07 00 MOV   REG[0x7],0x0       (0234) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
04A9: 70 EF    AND   F,0xEF             
                                        (0235) 	M8C_SetBank0
04AB: 62 05 00 MOV   REG[0x5],0x0       (0236) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
04AE: 62 08 00 MOV   REG[0x8],0x0       (0237) 	mov	reg[08h], 00h		; Port_2_Data register (PRT2DR)
04B1: 71 10    OR    F,0x10             
                                        (0238) 	M8C_SetBank1
04B3: 62 08 EF MOV   REG[0x8],0xEF      (0239) 	mov	reg[08h], efh		; Port_2_DriveMode_0 register (PRT2DM0)
04B6: 62 09 10 MOV   REG[0x9],0x10      (0240) 	mov	reg[09h], 10h		; Port_2_DriveMode_1 register (PRT2DM1)
04B9: 70 EF    AND   F,0xEF             
                                        (0241) 	M8C_SetBank0
04BB: 62 0B 10 MOV   REG[0xB],0x10      (0242) 	mov	reg[0bh], 10h		; Port_2_DriveMode_2 register (PRT2DM2)
04BE: 62 0A A2 MOV   REG[0xA],0xA2      (0243) 	mov	reg[0ah], a2h		; Port_2_GlobalSelect register (PRT2GS)
04C1: 71 10    OR    F,0x10             
                                        (0244) 	M8C_SetBank1
04C3: 62 0A 00 MOV   REG[0xA],0x0       (0245) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
04C6: 62 0B 00 MOV   REG[0xB],0x0       (0246) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
04C9: 70 EF    AND   F,0xEF             
                                        (0247) 	M8C_SetBank0
04CB: 62 09 00 MOV   REG[0x9],0x0       (0248) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
04CE: 62 0C 00 MOV   REG[0xC],0x0       (0249) 	mov	reg[0ch], 00h		; Port_3_Data register (PRT3DR)
04D1: 71 10    OR    F,0x10             
                                        (0250) 	M8C_SetBank1
04D3: 62 0C 00 MOV   REG[0xC],0x0       (0251) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
04D6: 62 0D 00 MOV   REG[0xD],0x0       (0252) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
04D9: 70 EF    AND   F,0xEF             
                                        (0253) 	M8C_SetBank0
04DB: 62 0F 00 MOV   REG[0xF],0x0       (0254) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
04DE: 62 0E 00 MOV   REG[0xE],0x0       (0255) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
04E1: 71 10    OR    F,0x10             
                                        (0256) 	M8C_SetBank1
04E3: 62 0E 00 MOV   REG[0xE],0x0       (0257) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
04E6: 62 0F 00 MOV   REG[0xF],0x0       (0258) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
04E9: 70 EF    AND   F,0xEF             
                                        (0259) 	M8C_SetBank0
04EB: 62 0D 00 MOV   REG[0xD],0x0       (0260) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
04EE: 62 10 00 MOV   REG[0x10],0x0      (0261) 	mov	reg[10h], 00h		; Port_4_Data register (PRT4DR)
04F1: 71 10    OR    F,0x10             
                                        (0262) 	M8C_SetBank1
04F3: 62 10 00 MOV   REG[0x10],0x0      (0263) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
04F6: 62 11 00 MOV   REG[0x11],0x0      (0264) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
04F9: 70 EF    AND   F,0xEF             
                                        (0265) 	M8C_SetBank0
04FB: 62 13 00 MOV   REG[0x13],0x0      (0266) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
04FE: 62 12 00 MOV   REG[0x12],0x0      (0267) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0501: 71 10    OR    F,0x10             
                                        (0268) 	M8C_SetBank1
0503: 62 12 00 MOV   REG[0x12],0x0      (0269) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
0506: 62 13 00 MOV   REG[0x13],0x0      (0270) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
0509: 70 EF    AND   F,0xEF             
                                        (0271) 	M8C_SetBank0
050B: 62 11 00 MOV   REG[0x11],0x0      (0272) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
050E: 62 14 00 MOV   REG[0x14],0x0      (0273) 	mov	reg[14h], 00h		; Port_5_Data register (PRT5DR)
0511: 71 10    OR    F,0x10             
                                        (0274) 	M8C_SetBank1
0513: 62 14 00 MOV   REG[0x14],0x0      (0275) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
0516: 62 15 00 MOV   REG[0x15],0x0      (0276) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
0519: 70 EF    AND   F,0xEF             
                                        (0277) 	M8C_SetBank0
051B: 62 17 00 MOV   REG[0x17],0x0      (0278) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
051E: 62 16 00 MOV   REG[0x16],0x0      (0279) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0521: 71 10    OR    F,0x10             
                                        (0280) 	M8C_SetBank1
0523: 62 16 00 MOV   REG[0x16],0x0      (0281) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0526: 62 17 00 MOV   REG[0x17],0x0      (0282) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
0529: 70 EF    AND   F,0xEF             
                                        (0283) 	M8C_SetBank0
052B: 62 15 00 MOV   REG[0x15],0x0      (0284) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
052E: 62 18 00 MOV   REG[0x18],0x0      (0285) 	mov	reg[18h], 00h		; Port_6_Data register (PRT6DR)
0531: 71 10    OR    F,0x10             
                                        (0286) 	M8C_SetBank1
0533: 62 18 00 MOV   REG[0x18],0x0      (0287) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
0536: 62 19 00 MOV   REG[0x19],0x0      (0288) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
0539: 70 EF    AND   F,0xEF             
                                        (0289) 	M8C_SetBank0
053B: 62 1B 00 MOV   REG[0x1B],0x0      (0290) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
053E: 62 1A 00 MOV   REG[0x1A],0x0      (0291) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
0541: 71 10    OR    F,0x10             
                                        (0292) 	M8C_SetBank1
0543: 62 1A 00 MOV   REG[0x1A],0x0      (0293) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
0546: 62 1B 00 MOV   REG[0x1B],0x0      (0294) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
0549: 70 EF    AND   F,0xEF             
                                        (0295) 	M8C_SetBank0
054B: 62 19 00 MOV   REG[0x19],0x0      (0296) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
054E: 62 1C 00 MOV   REG[0x1C],0x0      (0297) 	mov	reg[1ch], 00h		; Port_7_Data register (PRT7DR)
0551: 71 10    OR    F,0x10             
                                        (0298) 	M8C_SetBank1
0553: 62 1C 00 MOV   REG[0x1C],0x0      (0299) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0556: 62 1D 00 MOV   REG[0x1D],0x0      (0300) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
0559: 70 EF    AND   F,0xEF             
                                        (0301) 	M8C_SetBank0
055B: 62 1F 00 MOV   REG[0x1F],0x0      (0302) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
055E: 62 1E 00 MOV   REG[0x1E],0x0      (0303) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0561: 71 10    OR    F,0x10             
                                        (0304) 	M8C_SetBank1
0563: 62 1E 00 MOV   REG[0x1E],0x0      (0305) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0566: 62 1F 00 MOV   REG[0x1F],0x0      (0306) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0569: 70 EF    AND   F,0xEF             
                                        (0307) 	M8C_SetBank0
056B: 62 1D 00 MOV   REG[0x1D],0x0      (0308) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
056E: 70 EF    AND   F,0xEF             
                                        (0309) 	M8C_SetBank0
0570: 7F       RET                      (0310) 	ret
                                        (0311) 
                                        (0312) 
                                        (0313) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.2946
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_catchrobo_dcm2
                                        (0026) export _LoadConfig_catchrobo_dcm2
                                        (0027) export Port_0_Data_SHADE
                                        (0028) export _Port_0_Data_SHADE
                                        (0029) export Port_0_DriveMode_0_SHADE
                                        (0030) export _Port_0_DriveMode_0_SHADE
                                        (0031) export Port_0_DriveMode_1_SHADE
                                        (0032) export _Port_0_DriveMode_1_SHADE
                                        (0033) export Port_1_Data_SHADE
                                        (0034) export _Port_1_Data_SHADE
                                        (0035) export Port_2_Data_SHADE
                                        (0036) export _Port_2_Data_SHADE
                                        (0037) 
                                        (0038) 
                                        (0039) export NO_SHADOW
                                        (0040) export _NO_SHADOW
                                        (0041) 
                                        (0042) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0043) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0044) 
                                        (0045) AREA psoc_config(rom, rel)
                                        (0046) 
                                        (0047) ;---------------------------------------------------------------------------
                                        (0048) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0049) ;                  parameters handled by boot code, like CPU speed). This
                                        (0050) ;                  function can be called from user code, but typically it
                                        (0051) ;                  is only called from boot.
                                        (0052) ;
                                        (0053) ;       INPUTS: None.
                                        (0054) ;      RETURNS: Nothing.
                                        (0055) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0056) ;               In the large memory model currently only the page
                                        (0057) ;               pointer registers listed below are modified.  This does
                                        (0058) ;               not guarantee that in future implementations of this
                                        (0059) ;               function other page pointer registers will not be
                                        (0060) ;               modified.
                                        (0061) ;          
                                        (0062) ;               Page Pointer Registers Modified: 
                                        (0063) ;               CUR_PP
                                        (0064) ;
                                        (0065) _LoadConfigInit:
                                        (0066)  LoadConfigInit:
                                        (0067)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0068)     
0571: 55 00 00 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x0(0069) 	mov		[Port_0_Data_SHADE], 0h
0574: 55 03 FF MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3],0xFF(0070) 	mov		[Port_0_DriveMode_0_SHADE], ffh
0577: 55 04 00 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+4],0x0(0071) 	mov		[Port_0_DriveMode_1_SHADE], 0h
057A: 55 01 A0 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],0xA0(0072) 	mov		[Port_1_Data_SHADE], a0h
057D: 55 02 00 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],0x0(0073) 	mov		[Port_2_Data_SHADE], 0h
                                        (0074) 
0580: 7C 05 87 LCALL 0x0587             (0075) 	lcall	LoadConfig_catchrobo_dcm2
0583: 7C 04 6C LCALL 0x046C             (0076) 	lcall	LoadConfigTBL_catchrobo_dcm2_Ordered
                                        (0077) 
                                        (0078) 
                                        (0079)     RAM_EPILOGUE RAM_USE_CLASS_4
0586: 7F       RET                      (0080)     ret
                                        (0081) 
                                        (0082) ;---------------------------------------------------------------------------
                                        (0083) ; Load Configuration catchrobo_dcm2
                                        (0084) ;
                                        (0085) ;    Load configuration registers for catchrobo_dcm2.
                                        (0086) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0087) ;
                                        (0088) ;       INPUTS: None.
                                        (0089) ;      RETURNS: Nothing.
                                        (0090) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0091) ;               modified as may the Page Pointer registers!
                                        (0092) ;               In the large memory model currently only the page
                                        (0093) ;               pointer registers listed below are modified.  This does
                                        (0094) ;               not guarantee that in future implementations of this
                                        (0095) ;               function other page pointer registers will not be
                                        (0096) ;               modified.
                                        (0097) ;          
                                        (0098) ;               Page Pointer Registers Modified: 
                                        (0099) ;               CUR_PP
                                        (0100) ;
                                        (0101) _LoadConfig_catchrobo_dcm2:
                                        (0102)  LoadConfig_catchrobo_dcm2:
                                        (0103)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0104) 
0587: 10       PUSH  X                  (0105) 	push	x
0588: 70 EF    AND   F,0xEF             
                                        (0106)     M8C_SetBank0                    ; Force bank 0
058A: 50 00    MOV   A,0x0              (0107)     mov     a, 0                    ; Specify bank 0
058C: 67       ASR   A                  (0108)     asr     a                       ; Store in carry flag
                                        (0109)                                     ; Load bank 0 table:
058D: 50 02    MOV   A,0x2              (0110)     mov     A, >LoadConfigTBL_catchrobo_dcm2_Bank0
058F: 57 02    MOV   X,0x2              (0111)     mov     X, <LoadConfigTBL_catchrobo_dcm2_Bank0
0591: 7C 05 A2 LCALL 0x05A2             (0112)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0113) 
0594: 50 01    MOV   A,0x1              (0114)     mov     a, 1                    ; Specify bank 1
0596: 67       ASR   A                  (0115)     asr     a                       ; Store in carry flag
                                        (0116)                                     ; Load bank 1 table:
0597: 50 02    MOV   A,0x2              (0117)     mov     A, >LoadConfigTBL_catchrobo_dcm2_Bank1
0599: 57 9F    MOV   X,0x9F             (0118)     mov     X, <LoadConfigTBL_catchrobo_dcm2_Bank1
059B: 7C 05 A2 LCALL 0x05A2             (0119)     lcall   LoadConfig              ; Load the bank 1 values
059E: 70 EF    AND   F,0xEF             
                                        (0120) 
                                        (0121)     M8C_SetBank0                    ; Force return to bank 0
05A0: 20       POP   X                  (0122) 	pop		x
                                        (0123) 
                                        (0124)     RAM_EPILOGUE RAM_USE_CLASS_4
05A1: 7F       RET                      (0125)     ret
                                        (0126) 
                                        (0127) 
                                        (0128) 
                                        (0129) 
                                        (0130) ;---------------------------------------------------------------------------
                                        (0131) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0132) ;              pairs. Terminate on address=0xFF.
                                        (0133) ;
                                        (0134) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0135) ;           Flag Register Carry bit encodes the Register Bank
                                        (0136) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0137) ;
                                        (0138) ;  RETURNS: nothing.
                                        (0139) ;
                                        (0140) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0141) ;                X-3 Temporary store for register address
                                        (0142) ;                X-2 LSB of config table address
                                        (0143) ;                X-1 MSB of config table address
                                        (0144) ;
                                        (0145) LoadConfig:
                                        (0146)     RAM_PROLOGUE RAM_USE_CLASS_2
05A2: 38 02    ADD   SP,0x2             (0147)     add     SP, 2                   ; Set up local vars
05A4: 10       PUSH  X                  (0148)     push    X                       ; Save config table address on stack
05A5: 08       PUSH  A                  (0149)     push    A
05A6: 4F       MOV   X,SP               (0150)     mov     X, SP
05A7: 56 FC 00 MOV   [X-4],0x0          (0151)     mov     [X-4], 0                ; Set default Destination to Bank 0
05AA: D0 04    JNC   0x05AF             (0152)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
05AC: 56 FC 01 MOV   [X-4],0x1          (0153)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0154) .BankSelectSaved:
05AF: 18       POP   A                  (0155)     pop     A
05B0: 20       POP   X                  (0156)     pop     X
05B1: 70 EF    AND   F,0xEF             
05B3: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0157) 
                                        (0158) LoadConfigLp:
                                        (0159)     M8C_SetBank0                    ; Switch to bank 0
                                        (0160)     M8C_ClearWDT                    ; Clear the watchdog for long inits
05B6: 10       PUSH  X                  (0161)     push    X                       ; Preserve the config table address
05B7: 08       PUSH  A                  (0162)     push    A
05B8: 28       ROMX                     (0163)     romx                            ; Load register address from table
05B9: 39 FF    CMP   A,0xFF             (0164)     cmp     A, END_CONFIG_TABLE     ; End of table?
05BB: A0 1F    JZ    0x05DB             (0165)     jz      EndLoadConfig           ;   Yes, go wrap it up
05BD: 4F       MOV   X,SP               (0166)     mov     X, SP                   ;
05BE: 48 FC 01 TST   [X-4],0x1          (0167)     tst     [X-4], 1                ; Loading IO Bank 1?
05C1: A0 03    JZ    0x05C5             (0168)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
05C3: 71 10    OR    F,0x10             
                                        (0169)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0170) .IOBankNowSet:
05C5: 54 FD    MOV   [X-3],A            (0171)     mov     [X-3], A                ; Stash the register address
05C7: 18       POP   A                  (0172)     pop     A                       ; Retrieve the table address
05C8: 20       POP   X                  (0173)     pop     X
05C9: 75       INC   X                  (0174)     inc     X                       ; Advance to the data byte
05CA: 09 00    ADC   A,0x0              (0175)     adc     A, 0
05CC: 10       PUSH  X                  (0176)     push    X                       ; Save the config table address again
05CD: 08       PUSH  A                  (0177)     push    A
05CE: 28       ROMX                     (0178)     romx                            ; load config data from the table
05CF: 4F       MOV   X,SP               (0179)     mov     X, SP                   ; retrieve the register address
05D0: 59 FD    MOV   X,[X-3]            (0180)     mov     X, [X-3]
05D2: 61 00    MOV   REG[X+0x0],A       (0181)     mov     reg[X], A               ; Configure the register
05D4: 18       POP   A                  (0182)     pop     A                       ; retrieve the table address
05D5: 20       POP   X                  (0183)     pop     X
05D6: 75       INC   X                  (0184)     inc     X                       ; advance to next table entry
05D7: 09 00    ADC   A,0x0              (0185)     adc     A, 0
05D9: 8F D7    JMP   0x05B1             (0186)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0187) EndLoadConfig:
05DB: 38 FC    ADD   SP,0xFC            (0188)     add     SP, -4
05DD: 70 3F    AND   F,0x3F             
05DF: 71 C0    OR    F,0xC0             
                                        (0189)     RAM_EPILOGUE RAM_USE_CLASS_2
05E1: 7F       RET                      (0190)     ret
                                        (0191) 
                                        (0192) AREA InterruptRAM(ram, rel)
                                        (0193) 
                                        (0194) NO_SHADOW:
                                        (0195) _NO_SHADOW:
                                        (0196) ; write only register shadows
                                        (0197) _Port_0_Data_SHADE:
                                        (0198) Port_0_Data_SHADE:	BLK	1
                                        (0199) _Port_1_Data_SHADE:
                                        (0200) Port_1_Data_SHADE:	BLK	1
                                        (0201) _Port_2_Data_SHADE:
                                        (0202) Port_2_Data_SHADE:	BLK	1
                                        (0203) _Port_0_DriveMode_0_SHADE:
                                        (0204) Port_0_DriveMode_0_SHADE:	BLK	1
                                        (0205) _Port_0_DriveMode_1_SHADE:
                                        (0206) Port_0_DriveMode_1_SHADE:	BLK	1
                                        (0207) 
FILE: lib\timer8_1int.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer8_1INT.asm
                                        (0004) ;;   Version: 2.70, Updated on 2013/5/19 at 10:44:42
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer8 Interrupt Service Routine
                                        (0008) ;;-----------------------------------------------------------------------------
                                        (0009) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0010) ;;*****************************************************************************
                                        (0011) ;;*****************************************************************************
                                        (0012) 
                                        (0013) include "m8c.inc"
                                        (0014) include "memory.inc"
                                        (0015) include "Timer8_1.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) ;-----------------------------------------------
                                        (0019) ;  Global Symbols
                                        (0020) ;-----------------------------------------------
                                        (0021) export  _Timer8_1_ISR
                                        (0022) 
                                        (0023) 
                                        (0024) AREA InterruptRAM (RAM,REL,CON)
                                        (0025) 
                                        (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0027) ;---------------------------------------------------
                                        (0028) ; Insert your custom declarations below this banner
                                        (0029) ;---------------------------------------------------
                                        (0030) 
                                        (0031) ;------------------------
                                        (0032) ; Includes
                                        (0033) ;------------------------
                                        (0034) 
                                        (0035) 	
                                        (0036) ;------------------------
                                        (0037) ;  Constant Definitions
                                        (0038) ;------------------------
                                        (0039) 
                                        (0040) 
                                        (0041) ;------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;------------------------
                                        (0044) 
                                        (0045) 
                                        (0046) ;---------------------------------------------------
                                        (0047) ; Insert your custom declarations above this banner
                                        (0048) ;---------------------------------------------------
                                        (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0050) 
                                        (0051) 
                                        (0052) AREA UserModules (ROM, REL)
                                        (0053) 
                                        (0054) ;-----------------------------------------------------------------------------
                                        (0055) ;  FUNCTION NAME: _Timer8_1_ISR
                                        (0056) ;
                                        (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                        (0058) ;
                                        (0059) ;-----------------------------------------------------------------------------
                                        (0060) ;
                                        (0061) 
                                        (0062) _Timer8_1_ISR:
                                        (0063) 
                                        (0064)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                        (0065)    ;---------------------------------------------------
                                        (0066)    ; Insert your custom assembly code below this banner
                                        (0067)    ;---------------------------------------------------
                                        (0068)    ;   NOTE: interrupt service routines must preserve
                                        (0069)    ;   the values of the A and X CPU registers.
                                        (0070)    
                                        (0071)    ;---------------------------------------------------
                                        (0072)    ; Insert your custom assembly code above this banner
                                        (0073)    ;---------------------------------------------------
                                        (0074)    
05E2: 7D 19 BA LJMP  __Timer8_1_ISR     (0075)    ljmp __Timer8_1_ISR
                                        (0076)    
                                        (0077)    ;---------------------------------------------------
                                        (0078)    ; Insert a lcall to a C function below this banner
                                        (0079)    ; and un-comment the lines between these banners
                                        (0080)    ;---------------------------------------------------
                                        (0081)    
                                        (0082)    ;PRESERVE_CPU_CONTEXT
                                        (0083)    ;lcall _My_C_Function
                                        (0084)    ;RESTORE_CPU_CONTEXT
                                        (0085)    
                                        (0086)    ;---------------------------------------------------
                                        (0087)    ; Insert a lcall to a C function above this banner
                                        (0088)    ; and un-comment the lines between these banners
                                        (0089)    ;---------------------------------------------------
                                        (0090)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0091) 
05E5: 7E       RETI                     (0092)    reti
                                        (0093) 
                                        (0094) 
                                        (0095) ; end of file Timer8_1INT.asm
FILE: lib\timer8_1.asm                  (0001) ;;*****************************************************************************
05E6: 43 E1 01 OR    REG[0xE1],0x1      (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: Timer8_1.asm
                                        (0004) ;;   Version: 2.70, Updated on 2013/5/19 at 10:44:42
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: Timer8 User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "Timer8_1.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export  Timer8_1_EnableInt
                                        (0030) export _Timer8_1_EnableInt
                                        (0031) export  Timer8_1_DisableInt
                                        (0032) export _Timer8_1_DisableInt
                                        (0033) export  Timer8_1_Start
                                        (0034) export _Timer8_1_Start
                                        (0035) export  Timer8_1_Stop
                                        (0036) export _Timer8_1_Stop
                                        (0037) export  Timer8_1_WritePeriod
                                        (0038) export _Timer8_1_WritePeriod
                                        (0039) export  Timer8_1_WriteCompareValue
                                        (0040) export _Timer8_1_WriteCompareValue
                                        (0041) export  Timer8_1_bReadCompareValue
                                        (0042) export _Timer8_1_bReadCompareValue
                                        (0043) export  Timer8_1_bReadTimer
                                        (0044) export _Timer8_1_bReadTimer
                                        (0045) export  Timer8_1_bReadTimerSaveCV
                                        (0046) export _Timer8_1_bReadTimerSaveCV
                                        (0047) 
                                        (0048) ; The following functions are deprecated and subject to omission in future releases
                                        (0049) ;
                                        (0050) export  bTimer8_1_ReadCompareValue  ; deprecated
                                        (0051) export _bTimer8_1_ReadCompareValue  ; deprecated
                                        (0052) export  bTimer8_1_ReadTimer         ; deprecated
                                        (0053) export _bTimer8_1_ReadTimer         ; deprecated
                                        (0054) export  bTimer8_1_ReadTimerSaveCV   ; deprecated
                                        (0055) export _bTimer8_1_ReadTimerSaveCV   ; deprecated
                                        (0056) 
                                        (0057) export  bTimer8_1_ReadCounter       ; obsolete
                                        (0058) export _bTimer8_1_ReadCounter       ; obsolete
                                        (0059) export  bTimer8_1_CaptureCounter    ; obsolete
                                        (0060) export _bTimer8_1_CaptureCounter    ; obsolete
                                        (0061) 
                                        (0062) 
                                        (0063) AREA catchrobo_dcm2_RAM (RAM,REL)
                                        (0064) 
                                        (0065) ;-----------------------------------------------
                                        (0066) ;  Constant Definitions
                                        (0067) ;-----------------------------------------------
                                        (0068) 
                                        (0069) 
                                        (0070) ;-----------------------------------------------
                                        (0071) ; Variable Allocation
                                        (0072) ;-----------------------------------------------
                                        (0073) 
                                        (0074) 
                                        (0075) AREA UserModules (ROM, REL)
                                        (0076) 
                                        (0077) .SECTION
                                        (0078) ;-----------------------------------------------------------------------------
                                        (0079) ;  FUNCTION NAME: Timer8_1_EnableInt
                                        (0080) ;
                                        (0081) ;  DESCRIPTION:
                                        (0082) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
                                        (0083) ;     associated with this User Module. This function has no effect until and
                                        (0084) ;     unless the global interrupts are enabled (for example by using the
                                        (0085) ;     macro M8C_EnableGInt).
                                        (0086) ;-----------------------------------------------------------------------------
                                        (0087) ;
                                        (0088) ;  ARGUMENTS:    None.
                                        (0089) ;  RETURNS:      Nothing.
                                        (0090) ;  SIDE EFFECTS: 
                                        (0091) ;    The A and X registers may be modified by this or future implementations
                                        (0092) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0093) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0094) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0095) ;    functions.
                                        (0096) ;
                                        (0097)  Timer8_1_EnableInt:
                                        (0098) _Timer8_1_EnableInt:
                                        (0099)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0100)    Timer8_1_EnableInt_M
                                        (0101)    RAM_EPILOGUE RAM_USE_CLASS_1
05E9: 7F       RET                      (0102)    ret
05EA: 41 E1 FE AND   REG[0xE1],0xFE     
                                        (0103) 
                                        (0104) .ENDSECTION
                                        (0105) 
                                        (0106) 
                                        (0107) .SECTION
                                        (0108) ;-----------------------------------------------------------------------------
                                        (0109) ;  FUNCTION NAME: Timer8_1_DisableInt
                                        (0110) ;
                                        (0111) ;  DESCRIPTION:
                                        (0112) ;     Disables this timer's interrupt by clearing the interrupt enable
                                        (0113) ;     mask bit associated with this User Module.
                                        (0114) ;-----------------------------------------------------------------------------
                                        (0115) ;
                                        (0116) ;  ARGUMENTS:    None
                                        (0117) ;  RETURNS:      Nothing
                                        (0118) ;  SIDE EFFECTS: 
                                        (0119) ;    The A and X registers may be modified by this or future implementations
                                        (0120) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0121) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0122) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0123) ;    functions.
                                        (0124) ;
                                        (0125)  Timer8_1_DisableInt:
                                        (0126) _Timer8_1_DisableInt:
                                        (0127)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0128)    Timer8_1_DisableInt_M
                                        (0129)    RAM_EPILOGUE RAM_USE_CLASS_1
05ED: 7F       RET                      (0130)    ret
05EE: 43 23 01 OR    REG[0x23],0x1      
                                        (0131) 
                                        (0132) .ENDSECTION
                                        (0133) 
                                        (0134) 
                                        (0135) .SECTION
                                        (0136) ;-----------------------------------------------------------------------------
                                        (0137) ;  FUNCTION NAME: Timer8_1_Start
                                        (0138) ;
                                        (0139) ;  DESCRIPTION:
                                        (0140) ;     Sets the start bit in the Control register of this user module.  The
                                        (0141) ;     timer will begin counting on the next input clock.
                                        (0142) ;-----------------------------------------------------------------------------
                                        (0143) ;
                                        (0144) ;  ARGUMENTS:    None
                                        (0145) ;  RETURNS:      Nothing
                                        (0146) ;  SIDE EFFECTS: 
                                        (0147) ;    The A and X registers may be modified by this or future implementations
                                        (0148) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0149) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0150) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0151) ;    functions.
                                        (0152) ;
                                        (0153)  Timer8_1_Start:
                                        (0154) _Timer8_1_Start:
                                        (0155)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0156)    Timer8_1_Start_M
                                        (0157)    RAM_EPILOGUE RAM_USE_CLASS_1
05F1: 7F       RET                      (0158)    ret
05F2: 41 23 FE AND   REG[0x23],0xFE     
                                        (0159) 
                                        (0160) .ENDSECTION
                                        (0161) 
                                        (0162) 
                                        (0163) .SECTION
                                        (0164) ;-----------------------------------------------------------------------------
                                        (0165) ;  FUNCTION NAME: Timer8_1_Stop
                                        (0166) ;
                                        (0167) ;  DESCRIPTION:
                                        (0168) ;     Disables timer operation by clearing the start bit in the Control
                                        (0169) ;     register.
                                        (0170) ;-----------------------------------------------------------------------------
                                        (0171) ;
                                        (0172) ;  ARGUMENTS:    None
                                        (0173) ;  RETURNS:      Nothing
                                        (0174) ;  SIDE EFFECTS: 
                                        (0175) ;    The A and X registers may be modified by this or future implementations
                                        (0176) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0177) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0178) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0179) ;    functions.
                                        (0180) ;
                                        (0181)  Timer8_1_Stop:
                                        (0182) _Timer8_1_Stop:
                                        (0183)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0184)    Timer8_1_Stop_M
                                        (0185)    RAM_EPILOGUE RAM_USE_CLASS_1
05F5: 7F       RET                      (0186)    ret
                                        (0187) 
                                        (0188) .ENDSECTION
                                        (0189) 
                                        (0190) 
                                        (0191) .SECTION
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  FUNCTION NAME: Timer8_1_WritePeriod
                                        (0194) ;
                                        (0195) ;  DESCRIPTION:
                                        (0196) ;     Write the 8-bit period value into the Period register (DR1). If the
                                        (0197) ;     Timer user module is stopped, then this value will also be latched
                                        (0198) ;     into the Count register (DR0).
                                        (0199) ;-----------------------------------------------------------------------------
                                        (0200) ;
                                        (0201) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                        (0202) ;  RETURNS:   Nothing
                                        (0203) ;  SIDE EFFECTS: 
                                        (0204) ;    The A and X registers may be modified by this or future implementations
                                        (0205) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0207) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0208) ;    functions.
                                        (0209) ;
                                        (0210)  Timer8_1_WritePeriod:
                                        (0211) _Timer8_1_WritePeriod:
                                        (0212)    RAM_PROLOGUE RAM_USE_CLASS_1
05F6: 60 21    MOV   REG[0x21],A        (0213)    mov   reg[Timer8_1_PERIOD_REG], A
                                        (0214)    RAM_EPILOGUE RAM_USE_CLASS_1
05F8: 7F       RET                      (0215)    ret
                                        (0216) 
                                        (0217) .ENDSECTION
                                        (0218) 
                                        (0219) 
                                        (0220) .SECTION
                                        (0221) ;-----------------------------------------------------------------------------
                                        (0222) ;  FUNCTION NAME: Timer8_1_WriteCompareValue
                                        (0223) ;
                                        (0224) ;  DESCRIPTION:
                                        (0225) ;     Writes compare value into the Compare register (DR2).
                                        (0226) ;
                                        (0227) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                        (0228) ;           Compare register. (Call Timer8_1_Stop to disable).
                                        (0229) ;-----------------------------------------------------------------------------
                                        (0230) ;
                                        (0231) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                        (0232) ;  RETURNS:      Nothing
                                        (0233) ;  SIDE EFFECTS: 
                                        (0234) ;    The A and X registers may be modified by this or future implementations
                                        (0235) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0236) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0237) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0238) ;    functions.
                                        (0239) ;
                                        (0240)  Timer8_1_WriteCompareValue:
                                        (0241) _Timer8_1_WriteCompareValue:
                                        (0242)    RAM_PROLOGUE RAM_USE_CLASS_1
05F9: 60 22    MOV   REG[0x22],A        (0243)    mov   reg[Timer8_1_COMPARE_REG], A
                                        (0244)    RAM_EPILOGUE RAM_USE_CLASS_1
05FB: 7F       RET                      (0245)    ret
                                        (0246) 
                                        (0247) .ENDSECTION
                                        (0248) 
                                        (0249) 
                                        (0250) .SECTION
                                        (0251) ;-----------------------------------------------------------------------------
                                        (0252) ;  FUNCTION NAME: Timer8_1_bReadCompareValue
                                        (0253) ;
                                        (0254) ;  DESCRIPTION:
                                        (0255) ;     Reads the Compare register.
                                        (0256) ;-----------------------------------------------------------------------------
                                        (0257) ;
                                        (0258) ;  ARGUMENTS:    None
                                        (0259) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                        (0260) ;  SIDE EFFECTS: 
                                        (0261) ;    The A and X registers may be modified by this or future implementations
                                        (0262) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0263) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0264) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0265) ;    functions.
                                        (0266) ;
                                        (0267)  Timer8_1_bReadCompareValue:
                                        (0268) _Timer8_1_bReadCompareValue:
                                        (0269)  bTimer8_1_ReadCompareValue:                     ; this name deprecated
                                        (0270) _bTimer8_1_ReadCompareValue:                     ; this name deprecated
                                        (0271)    RAM_PROLOGUE RAM_USE_CLASS_1
05FC: 5D 22    MOV   A,REG[0x22]        (0272)    mov   A, reg[Timer8_1_COMPARE_REG]
                                        (0273)    RAM_EPILOGUE RAM_USE_CLASS_1
05FE: 7F       RET                      (0274)    ret
                                        (0275) 
                                        (0276) .ENDSECTION
                                        (0277) 
                                        (0278) 
                                        (0279) .SECTION
                                        (0280) ;-----------------------------------------------------------------------------
                                        (0281) ;  FUNCTION NAME: Timer8_1_bReadTimerSaveCV
                                        (0282) ;
                                        (0283) ;  DESCRIPTION:
                                        (0284) ;     Returns the value in the Count register (DR0), preserving the
                                        (0285) ;     value in the compare register (DR2).
                                        (0286) ;-----------------------------------------------------------------------------
                                        (0287) ;
                                        (0288) ;  ARGUMENTS: None
                                        (0289) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                        (0290) ;  SIDE EFFECTS:
                                        (0291) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                        (0292) ;     2) If enabled, Global interrupts are momentarily disabled.
                                        (0293) ;     3) The user module is stopped momentarily while the compare value is
                                        (0294) ;        restored.  This may cause the Count register to miss one or more
                                        (0295) ;        counts depending on the input clock speed.
                                        (0296) ;     4) The A and X registers may be modified by this or future implementations
                                        (0297) ;        of this function.  The same is true for all RAM page pointer registers in
                                        (0298) ;        the Large Memory Model.  When necessary, it is the calling function's
                                        (0299) ;        responsibility to perserve their values across calls to fastcall16 
                                        (0300) ;        functions.
                                        (0301) ;
                                        (0302) ;  THEORY of OPERATION:
                                        (0303) ;     1) Read and save the Compare register.
                                        (0304) ;     2) Read the Count register, causing its data to be latched into
                                        (0305) ;        the Compare register.
                                        (0306) ;     3) Read and save the Counter value, now in the Compare register,
                                        (0307) ;        to the buffer.
                                        (0308) ;     4) Disable global interrupts
                                        (0309) ;     5) Halt the timer
                                        (0310) ;     6) Restore the Compare register values
                                        (0311) ;     7) Start the Timer again
                                        (0312) ;     8) Restore global interrupt state
                                        (0313) ;
                                        (0314)  Timer8_1_bReadTimerSaveCV:
                                        (0315) _Timer8_1_bReadTimerSaveCV:
                                        (0316)  bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
                                        (0317) _bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
                                        (0318)  bTimer8_1_ReadCounter:                          ; this name deprecated
                                        (0319) _bTimer8_1_ReadCounter:                          ; this name deprecated
                                        (0320) 
                                        (0321) CpuFlags:      equ   0
                                        (0322) bCount:        equ   1
                                        (0323) 
                                        (0324)    RAM_PROLOGUE RAM_USE_CLASS_2
05FF: 4F       MOV   X,SP               (0325)    mov   X, SP                                   ; X <- stack frame pointer
0600: 38 02    ADD   SP,0x2             (0326)    add   SP, 2                                   ; Reserve space for flags, count
0602: 5D 23    MOV   A,REG[0x23]        (0327)    mov   A, reg[Timer8_1_CONTROL_REG]            ; save the Control register
0604: 08       PUSH  A                  (0328)    push  A
0605: 5D 22    MOV   A,REG[0x22]        (0329)    mov   A, reg[Timer8_1_COMPARE_REG]            ; save the Compare register
0607: 08       PUSH  A                  (0330)    push  A
0608: 5D 20    MOV   A,REG[0x20]        (0331)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
                                        (0332)                                                  ; This may cause an interrupt!
060A: 5D 22    MOV   A,REG[0x22]        (0333)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Now grab DR2 (DR0) and save
060C: 54 01    MOV   [X+1],A            (0334)    mov   [X+bCount], A
060E: 50 00    MOV   A,0x0              (0335)    mov   A, 0                                    ; Guess the global interrupt state
0610: 49 F7 01 TST   REG[0xF7],0x1      (0336)    tst   reg[CPU_F], FLAG_GLOBAL_IE              ; Currently Disabled?
0613: A0 03    JZ    0x0617             (0337)    jz    .SetupStatusFlag                        ;   Yes, guess was correct
0615: 50 01    MOV   A,0x1              (0338)    mov   A, FLAG_GLOBAL_IE                       ;    No, modify our guess
                                        (0339) .SetupStatusFlag:                                ; and ...
0617: 54 00    MOV   [X+0],A            (0340)    mov   [X+CpuFlags], A                         ;   StackFrame[0] <- Flag Reg image
0619: 70 FE    AND   F,0xFE             
061B: 41 23 FE AND   REG[0x23],0xFE     
                                        (0341)    M8C_DisableGInt                               ; Disable interrupts globally
                                        (0342)    Timer8_1_Stop_M                               ; Stop the timer
061E: 18       POP   A                  (0343)    pop   A                                       ; Restore the Compare register
061F: 60 22    MOV   REG[0x22],A        (0344)    mov   reg[Timer8_1_COMPARE_REG], A
0621: 18       POP   A                  (0345)    pop   A                                       ; restore start state of the timer
0622: 60 23    MOV   REG[0x23],A        (0346)    mov   reg[Timer8_1_CONTROL_REG], A
0624: 18       POP   A                  (0347)    pop   A                                       ; Return result stored in stack frame
0625: 70 3F    AND   F,0x3F             
0627: 71 C0    OR    F,0xC0             
                                        (0348)    RAM_EPILOGUE RAM_USE_CLASS_2
0629: 7E       RETI                     (0349)    reti                                          ; Flag Reg <- StackFrame[0]
                                        (0350) 
                                        (0351) .ENDSECTION
                                        (0352) 
                                        (0353) 
                                        (0354) .SECTION
                                        (0355) ;-----------------------------------------------------------------------------
                                        (0356) ;  FUNCTION NAME: Timer8_1_bReadTimer
                                        (0357) ;
                                        (0358) ;  DESCRIPTION:
                                        (0359) ;     Performs a software capture of the Count register.  A synchronous
                                        (0360) ;     read of the Count register is performed.  The timer is NOT stopped.
                                        (0361) ;
                                        (0362) ;     WARNING - this will cause loss of data in the Compare register.
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;
                                        (0365) ;  ARGUMENTS:    None
                                        (0366) ;  RETURNS:      fastcall16 BYTE bCount, (value of DR0 in the A register)
                                        (0367) ;  SIDE EFFECTS:
                                        (0368) ;    May cause an interrupt.
                                        (0369) ;
                                        (0370) ;    The A and X registers may be modified by this or future implementations
                                        (0371) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0372) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0373) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0374) ;    functions.
                                        (0375) ;
                                        (0376) ;  THEORY of OPERATION:
                                        (0377) ;     1) Read the Count register - this causes the count value to be
                                        (0378) ;        latched into the Compare register.
                                        (0379) ;     2) Read and return the Count register values from the Compare
                                        (0380) ;        registers into the return buffer.
                                        (0381) ;
                                        (0382)  Timer8_1_bReadTimer:
                                        (0383) _Timer8_1_bReadTimer:
                                        (0384)  bTimer8_1_ReadTimer:                            ; this name deprecated
                                        (0385) _bTimer8_1_ReadTimer:                            ; this name deprecated
                                        (0386)  bTimer8_1_CaptureCounter:                       ; this name deprecated
                                        (0387) _bTimer8_1_CaptureCounter:                       ; this name deprecated
                                        (0388) 
                                        (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
062A: 5D 20    MOV   A,REG[0x20]        (0390)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
                                        (0391)                                                  ; This may cause an interrupt!
062C: 5D 22    MOV   A,REG[0x22]        (0392)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Return DR2 (actually DR0)
                                        (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
062E: 7F       RET                      (0394)    ret
                                        (0395) 
                                        (0396) .ENDSECTION
                                        (0397) 
                                        (0398) ; End of File Timer8_1.asm
FILE: lib\prs32_z.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PRS32_Z.asm
                                        (0004) ;;   Version: 3.4, Updated on 2013/5/19 at 10:44:2
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PRS32 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "PRS32_Z.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export    PRS32_Z_Start
                                        (0030) export   _PRS32_Z_Start
                                        (0031) export    PRS32_Z_Stop
                                        (0032) export   _PRS32_Z_Stop
                                        (0033) export    PRS32_Z_WriteSeed
                                        (0034) export   _PRS32_Z_WriteSeed
                                        (0035) export    PRS32_Z_WritePolynomial
                                        (0036) export   _PRS32_Z_WritePolynomial
                                        (0037) export    PRS32_Z_ReadPRS
                                        (0038) export   _PRS32_Z_ReadPRS
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) bfCONTROL_REG_START_BIT:   equ   1        ; Control register start bit
                                        (0044) 
                                        (0045) AREA UserModules (ROM, REL)
                                        (0046) 
                                        (0047) .SECTION
                                        (0048) ;-----------------------------------------------------------------------------
                                        (0049) ;  FUNCTION NAME: PRS32_Z_Start
                                        (0050) ;
                                        (0051) ;  DESCRIPTION:
                                        (0052) ;     Starts the PRS32 user module.  The PRS will begin computing the PRS
                                        (0053) ;     POLYNOMIAL when data is clocked in.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: None
                                        (0058) ;
                                        (0059) ;  RETURNS:   None
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  PRS32_Z_Start:
                                        (0069) _PRS32_Z_Start:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
062F: 43 53 01 OR    REG[0x53],0x1      (0071)    or    REG[PRS32_Z_CONTROL_REG_LSB], bfCONTROL_REG_START_BIT
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0632: 7F       RET                      (0073)    ret
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: PRS32_Z_Stop
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables PRS32 operation.
                                        (0082) ;
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS: None
                                        (0086) ;
                                        (0087) ;  RETURNS:   None
                                        (0088) ;
                                        (0089) ;  SIDE EFFECTS:
                                        (0090) ;    The A and X registers may be modified by this or future implementations
                                        (0091) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0092) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0093) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0094) ;    functions.
                                        (0095) ;
                                        (0096) ;    Writing to the Seed register will cause the seed value to be latched into
                                        (0097) ;    the Shift register.
                                        (0098) ;
                                        (0099) ;  THEORY of OPERATION or PROCEDURE:
                                        (0100) ;     Clear the start bit in the Control register of the LSB block.
                                        (0101) ;
                                        (0102) ;-----------------------------------------------------------------------------
                                        (0103)  PRS32_Z_Stop:
                                        (0104) _PRS32_Z_Stop:
                                        (0105)    RAM_PROLOGUE RAM_USE_CLASS_1
0633: 41 53 FE AND   REG[0x53],0xFE     (0106)    and   REG[PRS32_Z_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0107)    RAM_EPILOGUE RAM_USE_CLASS_1
0636: 7F       RET                      (0108)    ret
                                        (0109) .ENDSECTION
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: PRS32_Z_WriteSeed
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Initializes the PRS polynomial function with a starting seed value.
                                        (0117) ;     The PRS32 User module is stopped while the Seed value is updated and
                                        (0118) ;     upon exit, its previous start state is restored.
                                        (0119) ;
                                        (0120) ;-----------------------------------------------------------------------------
                                        (0121) ;
                                        (0122) ;  ARGUMENTS:
                                        (0123) ;     DWORD dwSeedValue - the seed value to initialize the polynomial function.
                                        (0124) ;        X register points to 4 byte dword value.
                                        (0125) ;        Note that X points to MSB.
                                        (0126) ;
                                        (0127) ;  RETURNS: None
                                        (0128) ;
                                        (0129) ;  SIDE EFFECTS:
                                        (0130) ;    The A and X registers may be modified by this or future implementations
                                        (0131) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0132) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0133) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0134) ;    functions.
                                        (0135) ;
                                        (0136) ;    PRS32 user module is stopped while the seed is updated.
                                        (0137) ;
                                        (0138) ;  THEORY of OPERATION or PROCEDURE:
                                        (0139) ;     Set the seed value in the Seed register.
                                        (0140) ;
                                        (0141) ;-----------------------------------------------------------------------------
                                        (0142) _PRS32_Z_WriteSeed:
                                        (0143)  PRS32_Z_WriteSeed:
                                        (0144)    RAM_PROLOGUE RAM_USE_CLASS_2
0637: 4F       MOV   X,SP               (0145)    mov   X, SP
                                        (0146)    ;get and save the current start state
0638: 5D 53    MOV   A,REG[0x53]        (0147)    mov   A, REG[PRS32_Z_CONTROL_REG_LSB]
063A: 08       PUSH  A                  (0148)    push  A
                                        (0149) 
                                        (0150)    ;stop the PRS32
063B: 41 53 FE AND   REG[0x53],0xFE     (0151)    and   REG[PRS32_Z_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0152) 
                                        (0153)    ; Load the Seed value into the Seed register
063E: 52 FA    MOV   A,[X-6]            (0154)    mov   A, [X-6]
0640: 60 5E    MOV   REG[0x5E],A        (0155)    mov   reg[PRS32_Z_SEED_REG_MSB], A
0642: 52 FB    MOV   A,[X-5]            (0156)    mov   A, [X-5]
0644: 60 5A    MOV   REG[0x5A],A        (0157)    mov   reg[PRS32_Z_SEED_REG_ISB2], A
0646: 52 FC    MOV   A,[X-4]            (0158)    mov   A, [X-4]
0648: 60 56    MOV   REG[0x56],A        (0159)    mov   reg[PRS32_Z_SEED_REG_ISB1], A
064A: 52 FD    MOV   A,[X-3]            (0160)    mov   A, [X-3]
064C: 60 52    MOV   REG[0x52],A        (0161)    mov   reg[PRS32_Z_SEED_REG_LSB], A
                                        (0162) 
                                        (0163)    ; restore the start state
064E: 18       POP   A                  (0164)    pop   A
064F: 60 53    MOV   REG[0x53],A        (0165)    mov   REG[PRS32_Z_CONTROL_REG_LSB], A
0651: 70 3F    AND   F,0x3F             
0653: 71 C0    OR    F,0xC0             
                                        (0166)    RAM_EPILOGUE RAM_USE_CLASS_2
0655: 7F       RET                      (0167)    ret
                                        (0168) .ENDSECTION
                                        (0169) 
                                        (0170) .SECTION
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;  FUNCTION NAME: PRS32_Z_WritePolynomial
                                        (0173) ;
                                        (0174) ;  DESCRIPTION:
                                        (0175) ;     Initializes the PRS polynomial value.
                                        (0176) ;     The PRS32 User module is stopped while the polynomial value is updated and
                                        (0177) ;     upon exit, its previous start state is restored.
                                        (0178) ;
                                        (0179) ;-----------------------------------------------------------------------------
                                        (0180) ;
                                        (0181) ;  ARGUMENTS:
                                        (0182) ;     dwPolynomial - the polynomial to load into the polynomial register
                                        (0183) ;        X register points to 4 byte dword value - MSB byte is zero.
                                        (0184) ;        Note that X points to MSB.
                                        (0185) ;
                                        (0186) ;  RETURNS: None
                                        (0187) ;
                                        (0188) ;  SIDE EFFECTS:
                                        (0189) ;    The A and X registers may be modified by this or future implementations
                                        (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0193) ;    functions.
                                        (0194) ;
                                        (0195) ;    PRS32 user module is stopped while the polynomial is updated.
                                        (0196) ;
                                        (0197) ;  THEORY of OPERATION or PROCEDURE:
                                        (0198) ;     Set the polynomial value in the Polynomial register
                                        (0199) ;
                                        (0200) ;-----------------------------------------------------------------------------
                                        (0201) _PRS32_Z_WritePolynomial:
                                        (0202)  PRS32_Z_WritePolynomial:
                                        (0203)    RAM_PROLOGUE RAM_USE_CLASS_2
0656: 4F       MOV   X,SP               (0204)    mov   X, SP
                                        (0205) 
                                        (0206)    ;get and save the current start state
0657: 5D 53    MOV   A,REG[0x53]        (0207)    mov   A, REG[PRS32_Z_CONTROL_REG_LSB]
0659: 08       PUSH  A                  (0208)    push  A
                                        (0209) 
                                        (0210)    ;stop the PRS32
065A: 41 53 FE AND   REG[0x53],0xFE     (0211)    and   REG[PRS32_Z_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0212) 
                                        (0213)    ; Load the polynomial into the PRS32 Polynomial register
065D: 52 FA    MOV   A,[X-6]            (0214)    mov   A, [X-6]
065F: 60 5D    MOV   REG[0x5D],A        (0215)    mov   reg[PRS32_Z_POLY_REG_MSB], A
0661: 52 FB    MOV   A,[X-5]            (0216)    mov   A, [X-5]
0663: 60 59    MOV   REG[0x59],A        (0217)    mov   reg[PRS32_Z_POLY_REG_ISB2], A
0665: 52 FC    MOV   A,[X-4]            (0218)    mov   A, [X-4]
0667: 60 55    MOV   REG[0x55],A        (0219)    mov   reg[PRS32_Z_POLY_REG_ISB1], A
0669: 52 FD    MOV   A,[X-3]            (0220)    mov   A, [X-3]
066B: 60 51    MOV   REG[0x51],A        (0221)    mov   reg[PRS32_Z_POLY_REG_LSB], A
                                        (0222) 
                                        (0223)    ; restore the start state
066D: 18       POP   A                  (0224)    pop   A
066E: 60 53    MOV   REG[0x53],A        (0225)    mov   REG[PRS32_Z_CONTROL_REG_LSB], A
0670: 70 3F    AND   F,0x3F             
0672: 71 C0    OR    F,0xC0             
                                        (0226) 
                                        (0227)    RAM_EPILOGUE RAM_USE_CLASS_2
0674: 7F       RET                      (0228)    ret
0675: 70 BF    AND   F,0xBF             
0677: 60 D3    MOV   REG[0xD3],A        
                                        (0229) .ENDSECTION
                                        (0230) 
                                        (0231) .SECTION
                                        (0232) ;-----------------------------------------------------------------------------
                                        (0233) ;  FUNCTION NAME: PRS32_Z_ReadPRS
                                        (0234) ;
                                        (0235) ;  DESCRIPTION:
                                        (0236) ;     Reads the currently computed PRS polynomial function value.
                                        (0237) ;
                                        (0238) ;-----------------------------------------------------------------------------
                                        (0239) ;
                                        (0240) ;  ARGUMENTS:
                                        (0241) ;     DWORD * pdwPRSNumber - a pointer to a DWORD buffer to put the PRS computed
                                        (0242) ;        value.
                                        (0243) ;        The pointer is passed in the X register.
                                        (0244) ;        X points to the MSB of the DWORD
                                        (0245) ;
                                        (0246) ;  RETURNS:
                                        (0247) ;     The read value is placed in the data buffer pointed to by pdwPRSNumber as
                                        (0248) ;     passed in the X register.
                                        (0249) ;
                                        (0250) ;  SIDE EFFECTS:
                                        (0251) ;    The A and X registers may be modified by this or future implementations
                                        (0252) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0253) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0254) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0255) ;    functions.
                                        (0256) ;          
                                        (0257) ;    Currently only the page pointer registers listed below are modified:
                                        (0258) ;          IDX_PP
                                        (0259) ;
                                        (0260) ;     The seed value is lost.
                                        (0261) ;
                                        (0262) ;  THEORY of OPERATION or PROCEDURE:
                                        (0263) ;     1) Read the Shift register - PRS value is transferred to Seed register
                                        (0264) ;     2) Read the Seed register.
                                        (0265) ;
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267)  PRS32_Z_ReadPRS:
                                        (0268) _PRS32_Z_ReadPRS:
                                        (0269)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0270)    RAM_SETPAGE_IDX A 
                                        (0271) 
                                        (0272)    ;-------------
                                        (0273)    ;  MSB BYTE
                                        (0274)    ;-------------
                                        (0275)    ; Read the Shift register.  This causes the current
                                        (0276)    ;  PRS computed number to be transferred to the Seed register.
0679: 5D 5C    MOV   A,REG[0x5C]        (0277)    mov   A, reg[PRS32_Z_SHIFT_REG_MSB]
                                        (0278) 
                                        (0279)    ; Read the PRS computed value
067B: 5D 5E    MOV   A,REG[0x5E]        (0280)    mov   A, reg[PRS32_Z_SEED_REG_MSB]
067D: 54 00    MOV   [X+0],A            (0281)    mov   [X+0], A
                                        (0282) 
                                        (0283)    ;-------------
                                        (0284)    ;  ISB2 BYTE
                                        (0285)    ;-------------
                                        (0286)    ; Read the Shift register.  This causes the current
                                        (0287)    ;  PRS computed number to be transferred to the Seed register.
067F: 5D 58    MOV   A,REG[0x58]        (0288)    mov   A, reg[PRS32_Z_SHIFT_REG_ISB2]
                                        (0289) 
                                        (0290)    ; Read the PRS computed value
0681: 5D 5A    MOV   A,REG[0x5A]        (0291)    mov   A, reg[PRS32_Z_SEED_REG_ISB2]
0683: 54 01    MOV   [X+1],A            (0292)    mov   [X+1], A
                                        (0293) 
                                        (0294)    ;-------------
                                        (0295)    ;  ISB1 BYTE
                                        (0296)    ;-------------
                                        (0297)    ; Read the Shift register.  This causes the current
                                        (0298)    ;  PRS computed number to be transferred to the Seed register.
0685: 5D 54    MOV   A,REG[0x54]        (0299)    mov   A, reg[PRS32_Z_SHIFT_REG_ISB1]
                                        (0300) 
                                        (0301)    ; Read the PRS computed value
0687: 5D 56    MOV   A,REG[0x56]        (0302)    mov   A, reg[PRS32_Z_SEED_REG_ISB1]
0689: 54 02    MOV   [X+2],A            (0303)    mov   [X+2], A
                                        (0304) 
                                        (0305)    ;-------------
                                        (0306)    ;  LSB BYTE
                                        (0307)    ;-------------
                                        (0308)    ; Read the Shift register.  This causes the current
                                        (0309)    ;  PRS computed number to be transferred to the Seed register.
068B: 5D 50    MOV   A,REG[0x50]        (0310)    mov   A, reg[PRS32_Z_SHIFT_REG_LSB]
                                        (0311) 
                                        (0312)    ; Read the PRS computed value
068D: 5D 52    MOV   A,REG[0x52]        (0313)    mov   A, reg[PRS32_Z_SEED_REG_LSB]
068F: 54 03    MOV   [X+3],A            (0314)    mov   [X+3], A
0691: 70 3F    AND   F,0x3F             
0693: 71 C0    OR    F,0xC0             
                                        (0315) 
                                        (0316)    RAM_EPILOGUE RAM_USE_CLASS_3
0695: 7F       RET                      (0317)    ret
                                        (0318) .ENDSECTION
                                        (0319) 
                                        (0320) ; End of File PRS32_Z.asm
FILE: lib\prs32_y.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PRS32_Y.asm
                                        (0004) ;;   Version: 3.4, Updated on 2013/5/19 at 10:44:2
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PRS32 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "PRS32_Y.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export    PRS32_Y_Start
                                        (0030) export   _PRS32_Y_Start
                                        (0031) export    PRS32_Y_Stop
                                        (0032) export   _PRS32_Y_Stop
                                        (0033) export    PRS32_Y_WriteSeed
                                        (0034) export   _PRS32_Y_WriteSeed
                                        (0035) export    PRS32_Y_WritePolynomial
                                        (0036) export   _PRS32_Y_WritePolynomial
                                        (0037) export    PRS32_Y_ReadPRS
                                        (0038) export   _PRS32_Y_ReadPRS
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) bfCONTROL_REG_START_BIT:   equ   1        ; Control register start bit
                                        (0044) 
                                        (0045) AREA UserModules (ROM, REL)
                                        (0046) 
                                        (0047) .SECTION
                                        (0048) ;-----------------------------------------------------------------------------
                                        (0049) ;  FUNCTION NAME: PRS32_Y_Start
                                        (0050) ;
                                        (0051) ;  DESCRIPTION:
                                        (0052) ;     Starts the PRS32 user module.  The PRS will begin computing the PRS
                                        (0053) ;     POLYNOMIAL when data is clocked in.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: None
                                        (0058) ;
                                        (0059) ;  RETURNS:   None
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  PRS32_Y_Start:
                                        (0069) _PRS32_Y_Start:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
0696: 43 43 01 OR    REG[0x43],0x1      (0071)    or    REG[PRS32_Y_CONTROL_REG_LSB], bfCONTROL_REG_START_BIT
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0699: 7F       RET                      (0073)    ret
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: PRS32_Y_Stop
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables PRS32 operation.
                                        (0082) ;
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS: None
                                        (0086) ;
                                        (0087) ;  RETURNS:   None
                                        (0088) ;
                                        (0089) ;  SIDE EFFECTS:
                                        (0090) ;    The A and X registers may be modified by this or future implementations
                                        (0091) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0092) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0093) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0094) ;    functions.
                                        (0095) ;
                                        (0096) ;    Writing to the Seed register will cause the seed value to be latched into
                                        (0097) ;    the Shift register.
                                        (0098) ;
                                        (0099) ;  THEORY of OPERATION or PROCEDURE:
                                        (0100) ;     Clear the start bit in the Control register of the LSB block.
                                        (0101) ;
                                        (0102) ;-----------------------------------------------------------------------------
                                        (0103)  PRS32_Y_Stop:
                                        (0104) _PRS32_Y_Stop:
                                        (0105)    RAM_PROLOGUE RAM_USE_CLASS_1
069A: 41 43 FE AND   REG[0x43],0xFE     (0106)    and   REG[PRS32_Y_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0107)    RAM_EPILOGUE RAM_USE_CLASS_1
069D: 7F       RET                      (0108)    ret
                                        (0109) .ENDSECTION
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: PRS32_Y_WriteSeed
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Initializes the PRS polynomial function with a starting seed value.
                                        (0117) ;     The PRS32 User module is stopped while the Seed value is updated and
                                        (0118) ;     upon exit, its previous start state is restored.
                                        (0119) ;
                                        (0120) ;-----------------------------------------------------------------------------
                                        (0121) ;
                                        (0122) ;  ARGUMENTS:
                                        (0123) ;     DWORD dwSeedValue - the seed value to initialize the polynomial function.
                                        (0124) ;        X register points to 4 byte dword value.
                                        (0125) ;        Note that X points to MSB.
                                        (0126) ;
                                        (0127) ;  RETURNS: None
                                        (0128) ;
                                        (0129) ;  SIDE EFFECTS:
                                        (0130) ;    The A and X registers may be modified by this or future implementations
                                        (0131) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0132) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0133) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0134) ;    functions.
                                        (0135) ;
                                        (0136) ;    PRS32 user module is stopped while the seed is updated.
                                        (0137) ;
                                        (0138) ;  THEORY of OPERATION or PROCEDURE:
                                        (0139) ;     Set the seed value in the Seed register.
                                        (0140) ;
                                        (0141) ;-----------------------------------------------------------------------------
                                        (0142) _PRS32_Y_WriteSeed:
                                        (0143)  PRS32_Y_WriteSeed:
                                        (0144)    RAM_PROLOGUE RAM_USE_CLASS_2
069E: 4F       MOV   X,SP               (0145)    mov   X, SP
                                        (0146)    ;get and save the current start state
069F: 5D 43    MOV   A,REG[0x43]        (0147)    mov   A, REG[PRS32_Y_CONTROL_REG_LSB]
06A1: 08       PUSH  A                  (0148)    push  A
                                        (0149) 
                                        (0150)    ;stop the PRS32
06A2: 41 43 FE AND   REG[0x43],0xFE     (0151)    and   REG[PRS32_Y_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0152) 
                                        (0153)    ; Load the Seed value into the Seed register
06A5: 52 FA    MOV   A,[X-6]            (0154)    mov   A, [X-6]
06A7: 60 4E    MOV   REG[0x4E],A        (0155)    mov   reg[PRS32_Y_SEED_REG_MSB], A
06A9: 52 FB    MOV   A,[X-5]            (0156)    mov   A, [X-5]
06AB: 60 4A    MOV   REG[0x4A],A        (0157)    mov   reg[PRS32_Y_SEED_REG_ISB2], A
06AD: 52 FC    MOV   A,[X-4]            (0158)    mov   A, [X-4]
06AF: 60 46    MOV   REG[0x46],A        (0159)    mov   reg[PRS32_Y_SEED_REG_ISB1], A
06B1: 52 FD    MOV   A,[X-3]            (0160)    mov   A, [X-3]
06B3: 60 42    MOV   REG[0x42],A        (0161)    mov   reg[PRS32_Y_SEED_REG_LSB], A
                                        (0162) 
                                        (0163)    ; restore the start state
06B5: 18       POP   A                  (0164)    pop   A
06B6: 60 43    MOV   REG[0x43],A        (0165)    mov   REG[PRS32_Y_CONTROL_REG_LSB], A
06B8: 70 3F    AND   F,0x3F             
06BA: 71 C0    OR    F,0xC0             
                                        (0166)    RAM_EPILOGUE RAM_USE_CLASS_2
06BC: 7F       RET                      (0167)    ret
                                        (0168) .ENDSECTION
                                        (0169) 
                                        (0170) .SECTION
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;  FUNCTION NAME: PRS32_Y_WritePolynomial
                                        (0173) ;
                                        (0174) ;  DESCRIPTION:
                                        (0175) ;     Initializes the PRS polynomial value.
                                        (0176) ;     The PRS32 User module is stopped while the polynomial value is updated and
                                        (0177) ;     upon exit, its previous start state is restored.
                                        (0178) ;
                                        (0179) ;-----------------------------------------------------------------------------
                                        (0180) ;
                                        (0181) ;  ARGUMENTS:
                                        (0182) ;     dwPolynomial - the polynomial to load into the polynomial register
                                        (0183) ;        X register points to 4 byte dword value - MSB byte is zero.
                                        (0184) ;        Note that X points to MSB.
                                        (0185) ;
                                        (0186) ;  RETURNS: None
                                        (0187) ;
                                        (0188) ;  SIDE EFFECTS:
                                        (0189) ;    The A and X registers may be modified by this or future implementations
                                        (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0193) ;    functions.
                                        (0194) ;
                                        (0195) ;    PRS32 user module is stopped while the polynomial is updated.
                                        (0196) ;
                                        (0197) ;  THEORY of OPERATION or PROCEDURE:
                                        (0198) ;     Set the polynomial value in the Polynomial register
                                        (0199) ;
                                        (0200) ;-----------------------------------------------------------------------------
                                        (0201) _PRS32_Y_WritePolynomial:
                                        (0202)  PRS32_Y_WritePolynomial:
                                        (0203)    RAM_PROLOGUE RAM_USE_CLASS_2
06BD: 4F       MOV   X,SP               (0204)    mov   X, SP
                                        (0205) 
                                        (0206)    ;get and save the current start state
06BE: 5D 43    MOV   A,REG[0x43]        (0207)    mov   A, REG[PRS32_Y_CONTROL_REG_LSB]
06C0: 08       PUSH  A                  (0208)    push  A
                                        (0209) 
                                        (0210)    ;stop the PRS32
06C1: 41 43 FE AND   REG[0x43],0xFE     (0211)    and   REG[PRS32_Y_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0212) 
                                        (0213)    ; Load the polynomial into the PRS32 Polynomial register
06C4: 52 FA    MOV   A,[X-6]            (0214)    mov   A, [X-6]
06C6: 60 4D    MOV   REG[0x4D],A        (0215)    mov   reg[PRS32_Y_POLY_REG_MSB], A
06C8: 52 FB    MOV   A,[X-5]            (0216)    mov   A, [X-5]
06CA: 60 49    MOV   REG[0x49],A        (0217)    mov   reg[PRS32_Y_POLY_REG_ISB2], A
06CC: 52 FC    MOV   A,[X-4]            (0218)    mov   A, [X-4]
06CE: 60 45    MOV   REG[0x45],A        (0219)    mov   reg[PRS32_Y_POLY_REG_ISB1], A
06D0: 52 FD    MOV   A,[X-3]            (0220)    mov   A, [X-3]
06D2: 60 41    MOV   REG[0x41],A        (0221)    mov   reg[PRS32_Y_POLY_REG_LSB], A
                                        (0222) 
                                        (0223)    ; restore the start state
06D4: 18       POP   A                  (0224)    pop   A
06D5: 60 43    MOV   REG[0x43],A        (0225)    mov   REG[PRS32_Y_CONTROL_REG_LSB], A
06D7: 70 3F    AND   F,0x3F             
06D9: 71 C0    OR    F,0xC0             
                                        (0226) 
                                        (0227)    RAM_EPILOGUE RAM_USE_CLASS_2
06DB: 7F       RET                      (0228)    ret
06DC: 70 BF    AND   F,0xBF             
06DE: 60 D3    MOV   REG[0xD3],A        
                                        (0229) .ENDSECTION
                                        (0230) 
                                        (0231) .SECTION
                                        (0232) ;-----------------------------------------------------------------------------
                                        (0233) ;  FUNCTION NAME: PRS32_Y_ReadPRS
                                        (0234) ;
                                        (0235) ;  DESCRIPTION:
                                        (0236) ;     Reads the currently computed PRS polynomial function value.
                                        (0237) ;
                                        (0238) ;-----------------------------------------------------------------------------
                                        (0239) ;
                                        (0240) ;  ARGUMENTS:
                                        (0241) ;     DWORD * pdwPRSNumber - a pointer to a DWORD buffer to put the PRS computed
                                        (0242) ;        value.
                                        (0243) ;        The pointer is passed in the X register.
                                        (0244) ;        X points to the MSB of the DWORD
                                        (0245) ;
                                        (0246) ;  RETURNS:
                                        (0247) ;     The read value is placed in the data buffer pointed to by pdwPRSNumber as
                                        (0248) ;     passed in the X register.
                                        (0249) ;
                                        (0250) ;  SIDE EFFECTS:
                                        (0251) ;    The A and X registers may be modified by this or future implementations
                                        (0252) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0253) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0254) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0255) ;    functions.
                                        (0256) ;          
                                        (0257) ;    Currently only the page pointer registers listed below are modified:
                                        (0258) ;          IDX_PP
                                        (0259) ;
                                        (0260) ;     The seed value is lost.
                                        (0261) ;
                                        (0262) ;  THEORY of OPERATION or PROCEDURE:
                                        (0263) ;     1) Read the Shift register - PRS value is transferred to Seed register
                                        (0264) ;     2) Read the Seed register.
                                        (0265) ;
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267)  PRS32_Y_ReadPRS:
                                        (0268) _PRS32_Y_ReadPRS:
                                        (0269)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0270)    RAM_SETPAGE_IDX A 
                                        (0271) 
                                        (0272)    ;-------------
                                        (0273)    ;  MSB BYTE
                                        (0274)    ;-------------
                                        (0275)    ; Read the Shift register.  This causes the current
                                        (0276)    ;  PRS computed number to be transferred to the Seed register.
06E0: 5D 4C    MOV   A,REG[0x4C]        (0277)    mov   A, reg[PRS32_Y_SHIFT_REG_MSB]
                                        (0278) 
                                        (0279)    ; Read the PRS computed value
06E2: 5D 4E    MOV   A,REG[0x4E]        (0280)    mov   A, reg[PRS32_Y_SEED_REG_MSB]
06E4: 54 00    MOV   [X+0],A            (0281)    mov   [X+0], A
                                        (0282) 
                                        (0283)    ;-------------
                                        (0284)    ;  ISB2 BYTE
                                        (0285)    ;-------------
                                        (0286)    ; Read the Shift register.  This causes the current
                                        (0287)    ;  PRS computed number to be transferred to the Seed register.
06E6: 5D 48    MOV   A,REG[0x48]        (0288)    mov   A, reg[PRS32_Y_SHIFT_REG_ISB2]
                                        (0289) 
                                        (0290)    ; Read the PRS computed value
06E8: 5D 4A    MOV   A,REG[0x4A]        (0291)    mov   A, reg[PRS32_Y_SEED_REG_ISB2]
06EA: 54 01    MOV   [X+1],A            (0292)    mov   [X+1], A
                                        (0293) 
                                        (0294)    ;-------------
                                        (0295)    ;  ISB1 BYTE
                                        (0296)    ;-------------
                                        (0297)    ; Read the Shift register.  This causes the current
                                        (0298)    ;  PRS computed number to be transferred to the Seed register.
06EC: 5D 44    MOV   A,REG[0x44]        (0299)    mov   A, reg[PRS32_Y_SHIFT_REG_ISB1]
                                        (0300) 
                                        (0301)    ; Read the PRS computed value
06EE: 5D 46    MOV   A,REG[0x46]        (0302)    mov   A, reg[PRS32_Y_SEED_REG_ISB1]
06F0: 54 02    MOV   [X+2],A            (0303)    mov   [X+2], A
                                        (0304) 
                                        (0305)    ;-------------
                                        (0306)    ;  LSB BYTE
                                        (0307)    ;-------------
                                        (0308)    ; Read the Shift register.  This causes the current
                                        (0309)    ;  PRS computed number to be transferred to the Seed register.
06F2: 5D 40    MOV   A,REG[0x40]        (0310)    mov   A, reg[PRS32_Y_SHIFT_REG_LSB]
                                        (0311) 
                                        (0312)    ; Read the PRS computed value
06F4: 5D 42    MOV   A,REG[0x42]        (0313)    mov   A, reg[PRS32_Y_SEED_REG_LSB]
06F6: 54 03    MOV   [X+3],A            (0314)    mov   [X+3], A
06F8: 70 3F    AND   F,0x3F             
06FA: 71 C0    OR    F,0xC0             
                                        (0315) 
                                        (0316)    RAM_EPILOGUE RAM_USE_CLASS_3
06FC: 7F       RET                      (0317)    ret
                                        (0318) .ENDSECTION
                                        (0319) 
                                        (0320) ; End of File PRS32_Y.asm
FILE: lib\prs32_x.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: PRS32_X.asm
                                        (0004) ;;   Version: 3.4, Updated on 2013/5/19 at 10:44:2
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: PRS32 User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "PRS32_X.inc"
                                        (0025) 
                                        (0026) ;-----------------------------------------------
                                        (0027) ;  Global Symbols
                                        (0028) ;-----------------------------------------------
                                        (0029) export    PRS32_X_Start
                                        (0030) export   _PRS32_X_Start
                                        (0031) export    PRS32_X_Stop
                                        (0032) export   _PRS32_X_Stop
                                        (0033) export    PRS32_X_WriteSeed
                                        (0034) export   _PRS32_X_WriteSeed
                                        (0035) export    PRS32_X_WritePolynomial
                                        (0036) export   _PRS32_X_WritePolynomial
                                        (0037) export    PRS32_X_ReadPRS
                                        (0038) export   _PRS32_X_ReadPRS
                                        (0039) 
                                        (0040) ;-----------------------------------------------
                                        (0041) ;  Constant Definitions
                                        (0042) ;-----------------------------------------------
                                        (0043) bfCONTROL_REG_START_BIT:   equ   1        ; Control register start bit
                                        (0044) 
                                        (0045) AREA UserModules (ROM, REL)
                                        (0046) 
                                        (0047) .SECTION
                                        (0048) ;-----------------------------------------------------------------------------
                                        (0049) ;  FUNCTION NAME: PRS32_X_Start
                                        (0050) ;
                                        (0051) ;  DESCRIPTION:
                                        (0052) ;     Starts the PRS32 user module.  The PRS will begin computing the PRS
                                        (0053) ;     POLYNOMIAL when data is clocked in.
                                        (0054) ;
                                        (0055) ;-----------------------------------------------------------------------------
                                        (0056) ;
                                        (0057) ;  ARGUMENTS: None
                                        (0058) ;
                                        (0059) ;  RETURNS:   None
                                        (0060) ;
                                        (0061) ;  SIDE EFFECTS:
                                        (0062) ;    The A and X registers may be modified by this or future implementations
                                        (0063) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0064) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0065) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0066) ;    functions.
                                        (0067) ;
                                        (0068)  PRS32_X_Start:
                                        (0069) _PRS32_X_Start:
                                        (0070)    RAM_PROLOGUE RAM_USE_CLASS_1
06FD: 43 33 01 OR    REG[0x33],0x1      (0071)    or    REG[PRS32_X_CONTROL_REG_LSB], bfCONTROL_REG_START_BIT
                                        (0072)    RAM_EPILOGUE RAM_USE_CLASS_1
0700: 7F       RET                      (0073)    ret
                                        (0074) .ENDSECTION
                                        (0075) 
                                        (0076) .SECTION
                                        (0077) ;-----------------------------------------------------------------------------
                                        (0078) ;  FUNCTION NAME: PRS32_X_Stop
                                        (0079) ;
                                        (0080) ;  DESCRIPTION:
                                        (0081) ;     Disables PRS32 operation.
                                        (0082) ;
                                        (0083) ;-----------------------------------------------------------------------------
                                        (0084) ;
                                        (0085) ;  ARGUMENTS: None
                                        (0086) ;
                                        (0087) ;  RETURNS:   None
                                        (0088) ;
                                        (0089) ;  SIDE EFFECTS:
                                        (0090) ;    The A and X registers may be modified by this or future implementations
                                        (0091) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0092) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0093) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0094) ;    functions.
                                        (0095) ;
                                        (0096) ;    Writing to the Seed register will cause the seed value to be latched into
                                        (0097) ;    the Shift register.
                                        (0098) ;
                                        (0099) ;  THEORY of OPERATION or PROCEDURE:
                                        (0100) ;     Clear the start bit in the Control register of the LSB block.
                                        (0101) ;
                                        (0102) ;-----------------------------------------------------------------------------
                                        (0103)  PRS32_X_Stop:
                                        (0104) _PRS32_X_Stop:
                                        (0105)    RAM_PROLOGUE RAM_USE_CLASS_1
0701: 41 33 FE AND   REG[0x33],0xFE     (0106)    and   REG[PRS32_X_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0107)    RAM_EPILOGUE RAM_USE_CLASS_1
0704: 7F       RET                      (0108)    ret
                                        (0109) .ENDSECTION
                                        (0110) 
                                        (0111) .SECTION
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;  FUNCTION NAME: PRS32_X_WriteSeed
                                        (0114) ;
                                        (0115) ;  DESCRIPTION:
                                        (0116) ;     Initializes the PRS polynomial function with a starting seed value.
                                        (0117) ;     The PRS32 User module is stopped while the Seed value is updated and
                                        (0118) ;     upon exit, its previous start state is restored.
                                        (0119) ;
                                        (0120) ;-----------------------------------------------------------------------------
                                        (0121) ;
                                        (0122) ;  ARGUMENTS:
                                        (0123) ;     DWORD dwSeedValue - the seed value to initialize the polynomial function.
                                        (0124) ;        X register points to 4 byte dword value.
                                        (0125) ;        Note that X points to MSB.
                                        (0126) ;
                                        (0127) ;  RETURNS: None
                                        (0128) ;
                                        (0129) ;  SIDE EFFECTS:
                                        (0130) ;    The A and X registers may be modified by this or future implementations
                                        (0131) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0132) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0133) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0134) ;    functions.
                                        (0135) ;
                                        (0136) ;    PRS32 user module is stopped while the seed is updated.
                                        (0137) ;
                                        (0138) ;  THEORY of OPERATION or PROCEDURE:
                                        (0139) ;     Set the seed value in the Seed register.
                                        (0140) ;
                                        (0141) ;-----------------------------------------------------------------------------
                                        (0142) _PRS32_X_WriteSeed:
                                        (0143)  PRS32_X_WriteSeed:
                                        (0144)    RAM_PROLOGUE RAM_USE_CLASS_2
0705: 4F       MOV   X,SP               (0145)    mov   X, SP
                                        (0146)    ;get and save the current start state
0706: 5D 33    MOV   A,REG[0x33]        (0147)    mov   A, REG[PRS32_X_CONTROL_REG_LSB]
0708: 08       PUSH  A                  (0148)    push  A
                                        (0149) 
                                        (0150)    ;stop the PRS32
0709: 41 33 FE AND   REG[0x33],0xFE     (0151)    and   REG[PRS32_X_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0152) 
                                        (0153)    ; Load the Seed value into the Seed register
070C: 52 FA    MOV   A,[X-6]            (0154)    mov   A, [X-6]
070E: 60 3E    MOV   REG[0x3E],A        (0155)    mov   reg[PRS32_X_SEED_REG_MSB], A
0710: 52 FB    MOV   A,[X-5]            (0156)    mov   A, [X-5]
0712: 60 3A    MOV   REG[0x3A],A        (0157)    mov   reg[PRS32_X_SEED_REG_ISB2], A
0714: 52 FC    MOV   A,[X-4]            (0158)    mov   A, [X-4]
0716: 60 36    MOV   REG[0x36],A        (0159)    mov   reg[PRS32_X_SEED_REG_ISB1], A
0718: 52 FD    MOV   A,[X-3]            (0160)    mov   A, [X-3]
071A: 60 32    MOV   REG[0x32],A        (0161)    mov   reg[PRS32_X_SEED_REG_LSB], A
                                        (0162) 
                                        (0163)    ; restore the start state
071C: 18       POP   A                  (0164)    pop   A
071D: 60 33    MOV   REG[0x33],A        (0165)    mov   REG[PRS32_X_CONTROL_REG_LSB], A
071F: 70 3F    AND   F,0x3F             
0721: 71 C0    OR    F,0xC0             
                                        (0166)    RAM_EPILOGUE RAM_USE_CLASS_2
0723: 7F       RET                      (0167)    ret
                                        (0168) .ENDSECTION
                                        (0169) 
                                        (0170) .SECTION
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;  FUNCTION NAME: PRS32_X_WritePolynomial
                                        (0173) ;
                                        (0174) ;  DESCRIPTION:
                                        (0175) ;     Initializes the PRS polynomial value.
                                        (0176) ;     The PRS32 User module is stopped while the polynomial value is updated and
                                        (0177) ;     upon exit, its previous start state is restored.
                                        (0178) ;
                                        (0179) ;-----------------------------------------------------------------------------
                                        (0180) ;
                                        (0181) ;  ARGUMENTS:
                                        (0182) ;     dwPolynomial - the polynomial to load into the polynomial register
                                        (0183) ;        X register points to 4 byte dword value - MSB byte is zero.
                                        (0184) ;        Note that X points to MSB.
                                        (0185) ;
                                        (0186) ;  RETURNS: None
                                        (0187) ;
                                        (0188) ;  SIDE EFFECTS:
                                        (0189) ;    The A and X registers may be modified by this or future implementations
                                        (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0193) ;    functions.
                                        (0194) ;
                                        (0195) ;    PRS32 user module is stopped while the polynomial is updated.
                                        (0196) ;
                                        (0197) ;  THEORY of OPERATION or PROCEDURE:
                                        (0198) ;     Set the polynomial value in the Polynomial register
                                        (0199) ;
                                        (0200) ;-----------------------------------------------------------------------------
                                        (0201) _PRS32_X_WritePolynomial:
                                        (0202)  PRS32_X_WritePolynomial:
                                        (0203)    RAM_PROLOGUE RAM_USE_CLASS_2
0724: 4F       MOV   X,SP               (0204)    mov   X, SP
                                        (0205) 
                                        (0206)    ;get and save the current start state
0725: 5D 33    MOV   A,REG[0x33]        (0207)    mov   A, REG[PRS32_X_CONTROL_REG_LSB]
0727: 08       PUSH  A                  (0208)    push  A
                                        (0209) 
                                        (0210)    ;stop the PRS32
0728: 41 33 FE AND   REG[0x33],0xFE     (0211)    and   REG[PRS32_X_CONTROL_REG_LSB], ~bfCONTROL_REG_START_BIT
                                        (0212) 
                                        (0213)    ; Load the polynomial into the PRS32 Polynomial register
072B: 52 FA    MOV   A,[X-6]            (0214)    mov   A, [X-6]
072D: 60 3D    MOV   REG[0x3D],A        (0215)    mov   reg[PRS32_X_POLY_REG_MSB], A
072F: 52 FB    MOV   A,[X-5]            (0216)    mov   A, [X-5]
0731: 60 39    MOV   REG[0x39],A        (0217)    mov   reg[PRS32_X_POLY_REG_ISB2], A
0733: 52 FC    MOV   A,[X-4]            (0218)    mov   A, [X-4]
0735: 60 35    MOV   REG[0x35],A        (0219)    mov   reg[PRS32_X_POLY_REG_ISB1], A
0737: 52 FD    MOV   A,[X-3]            (0220)    mov   A, [X-3]
0739: 60 31    MOV   REG[0x31],A        (0221)    mov   reg[PRS32_X_POLY_REG_LSB], A
                                        (0222) 
                                        (0223)    ; restore the start state
073B: 18       POP   A                  (0224)    pop   A
073C: 60 33    MOV   REG[0x33],A        (0225)    mov   REG[PRS32_X_CONTROL_REG_LSB], A
073E: 70 3F    AND   F,0x3F             
0740: 71 C0    OR    F,0xC0             
                                        (0226) 
                                        (0227)    RAM_EPILOGUE RAM_USE_CLASS_2
0742: 7F       RET                      (0228)    ret
0743: 70 BF    AND   F,0xBF             
0745: 60 D3    MOV   REG[0xD3],A        
                                        (0229) .ENDSECTION
                                        (0230) 
                                        (0231) .SECTION
                                        (0232) ;-----------------------------------------------------------------------------
                                        (0233) ;  FUNCTION NAME: PRS32_X_ReadPRS
                                        (0234) ;
                                        (0235) ;  DESCRIPTION:
                                        (0236) ;     Reads the currently computed PRS polynomial function value.
                                        (0237) ;
                                        (0238) ;-----------------------------------------------------------------------------
                                        (0239) ;
                                        (0240) ;  ARGUMENTS:
                                        (0241) ;     DWORD * pdwPRSNumber - a pointer to a DWORD buffer to put the PRS computed
                                        (0242) ;        value.
                                        (0243) ;        The pointer is passed in the X register.
                                        (0244) ;        X points to the MSB of the DWORD
                                        (0245) ;
                                        (0246) ;  RETURNS:
                                        (0247) ;     The read value is placed in the data buffer pointed to by pdwPRSNumber as
                                        (0248) ;     passed in the X register.
                                        (0249) ;
                                        (0250) ;  SIDE EFFECTS:
                                        (0251) ;    The A and X registers may be modified by this or future implementations
                                        (0252) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0253) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0254) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0255) ;    functions.
                                        (0256) ;          
                                        (0257) ;    Currently only the page pointer registers listed below are modified:
                                        (0258) ;          IDX_PP
                                        (0259) ;
                                        (0260) ;     The seed value is lost.
                                        (0261) ;
                                        (0262) ;  THEORY of OPERATION or PROCEDURE:
                                        (0263) ;     1) Read the Shift register - PRS value is transferred to Seed register
                                        (0264) ;     2) Read the Seed register.
                                        (0265) ;
                                        (0266) ;-----------------------------------------------------------------------------
                                        (0267)  PRS32_X_ReadPRS:
                                        (0268) _PRS32_X_ReadPRS:
                                        (0269)    RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0270)    RAM_SETPAGE_IDX A 
                                        (0271) 
                                        (0272)    ;-------------
                                        (0273)    ;  MSB BYTE
                                        (0274)    ;-------------
                                        (0275)    ; Read the Shift register.  This causes the current
                                        (0276)    ;  PRS computed number to be transferred to the Seed register.
0747: 5D 3C    MOV   A,REG[0x3C]        (0277)    mov   A, reg[PRS32_X_SHIFT_REG_MSB]
                                        (0278) 
                                        (0279)    ; Read the PRS computed value
0749: 5D 3E    MOV   A,REG[0x3E]        (0280)    mov   A, reg[PRS32_X_SEED_REG_MSB]
074B: 54 00    MOV   [X+0],A            (0281)    mov   [X+0], A
                                        (0282) 
                                        (0283)    ;-------------
                                        (0284)    ;  ISB2 BYTE
                                        (0285)    ;-------------
                                        (0286)    ; Read the Shift register.  This causes the current
                                        (0287)    ;  PRS computed number to be transferred to the Seed register.
074D: 5D 38    MOV   A,REG[0x38]        (0288)    mov   A, reg[PRS32_X_SHIFT_REG_ISB2]
                                        (0289) 
                                        (0290)    ; Read the PRS computed value
074F: 5D 3A    MOV   A,REG[0x3A]        (0291)    mov   A, reg[PRS32_X_SEED_REG_ISB2]
0751: 54 01    MOV   [X+1],A            (0292)    mov   [X+1], A
                                        (0293) 
                                        (0294)    ;-------------
                                        (0295)    ;  ISB1 BYTE
                                        (0296)    ;-------------
                                        (0297)    ; Read the Shift register.  This causes the current
                                        (0298)    ;  PRS computed number to be transferred to the Seed register.
0753: 5D 34    MOV   A,REG[0x34]        (0299)    mov   A, reg[PRS32_X_SHIFT_REG_ISB1]
                                        (0300) 
                                        (0301)    ; Read the PRS computed value
0755: 5D 36    MOV   A,REG[0x36]        (0302)    mov   A, reg[PRS32_X_SEED_REG_ISB1]
0757: 54 02    MOV   [X+2],A            (0303)    mov   [X+2], A
                                        (0304) 
                                        (0305)    ;-------------
                                        (0306)    ;  LSB BYTE
                                        (0307)    ;-------------
                                        (0308)    ; Read the Shift register.  This causes the current
                                        (0309)    ;  PRS computed number to be transferred to the Seed register.
0759: 5D 30    MOV   A,REG[0x30]        (0310)    mov   A, reg[PRS32_X_SHIFT_REG_LSB]
                                        (0311) 
                                        (0312)    ; Read the PRS computed value
075B: 5D 32    MOV   A,REG[0x32]        (0313)    mov   A, reg[PRS32_X_SEED_REG_LSB]
075D: 54 03    MOV   [X+3],A            (0314)    mov   [X+3], A
075F: 70 3F    AND   F,0x3F             
0761: 71 C0    OR    F,0xC0             
                                        (0315) 
                                        (0316)    RAM_EPILOGUE RAM_USE_CLASS_3
0763: 7F       RET                      (0317)    ret
                                        (0318) .ENDSECTION
                                        (0319) 
                                        (0320) ; End of File PRS32_X.asm
FILE: lib\lcd_1.asm                     (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME:   LCD_1.asm
                                        (0004) ;;  Version: 1.60, Updated on 2013/5/19 at 10:43:48
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: LCD User Module software implementation file.
                                        (0008) ;;
                                        (0009) ;; This set of functions is written for the common 2 and 4 line
                                        (0010) ;; LCDs that use the Hitachi HD44780A controller.
                                        (0011) ;;
                                        (0012) ;;  LCD connections to PSoC port
                                        (0013) ;;
                                        (0014) ;;    PX.0 ==> LCD D4
                                        (0015) ;;    PX.1 ==> LCD D5
                                        (0016) ;;    PX.2 ==> LCD D6
                                        (0017) ;;    PX.3 ==> LCD D7
                                        (0018) ;;    PX.4 ==> LCD E
                                        (0019) ;;    PX.5 ==> LCD RS
                                        (0020) ;;    PX.6 ==> LCD R/W
                                        (0021) ;;
                                        (0022) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0023) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0024) ;;        This means it is the caller's responsibility to preserve any values
                                        (0025) ;;        in the X and A registers that are still needed after the API functions
                                        (0026) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0027) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0028) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0029) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0030) ;;-----------------------------------------------------------------------------
                                        (0031) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0032) ;;*****************************************************************************
                                        (0033) ;;*****************************************************************************
                                        (0034) 
                                        (0035) include "m8c.inc"
                                        (0036) include "memory.inc"
                                        (0037) include "LCD_1.inc"
                                        (0038) 
                                        (0039) ;-----------------------------------------------
                                        (0040) ;  Global Symbols
                                        (0041) ;-----------------------------------------------
                                        (0042) 
                                        (0043) export   LCD_1_Start
                                        (0044) export  _LCD_1_Start
                                        (0045) export   LCD_1_Init
                                        (0046) export  _LCD_1_Init
                                        (0047) 
                                        (0048) export   LCD_1_WriteData
                                        (0049) export  _LCD_1_WriteData
                                        (0050) 
                                        (0051) export   LCD_1_Control
                                        (0052) export  _LCD_1_Control
                                        (0053) 
                                        (0054) export  LCD_1_PrString
                                        (0055) export _LCD_1_PrString
                                        (0056) 
                                        (0057) export  LCD_1_PrCString
                                        (0058) export _LCD_1_PrCString
                                        (0059) 
                                        (0060) export  LCD_1_Position
                                        (0061) export _LCD_1_Position
                                        (0062) 
                                        (0063) export  LCD_1_PrHexByte
                                        (0064) export _LCD_1_PrHexByte
                                        (0065) 
                                        (0066) export  LCD_1_PrHexInt
                                        (0067) export _LCD_1_PrHexInt
                                        (0068) 
                                        (0069) export  LCD_1_Delay50uTimes
                                        (0070) export _LCD_1_Delay50uTimes
                                        (0071) 
                                        (0072) export  LCD_1_Delay50u
                                        (0073) export _LCD_1_Delay50u
                                        (0074) 
                                        (0075) ;-----------------------------------------------
                                        (0076) ; If bargraph functions not required, don't
                                        (0077) ; export the function names.
                                        (0078) ;-----------------------------------------------
                                        (0079) 
                                        (0080) IF (LCD_1_BARGRAPH_ENABLE)
                                        (0081) export  LCD_1_InitBG
                                        (0082) export _LCD_1_InitBG
                                        (0083) 
                                        (0084) export  LCD_1_InitVBG
                                        (0085) export _LCD_1_InitVBG
                                        (0086) 
                                        (0087) ; NOTE: The two functions,
                                        (0088) ;
                                        (0089) ;    LCD_1_DrawVBG and
                                        (0090) ;    LCD_1_DrawBG
                                        (0091) ;
                                        (0092) ; are implemented using both fastcall16 and legacy fastcall16 because they
                                        (0093) ; fall into a special and rare case where the calling sequences specified
                                        (0094) ; by the two disciplines are incompatible. The fastcall16 versions are
                                        (0095) ; provided for both C and Assembly users in all memory models. The legacy
                                        (0096) ; fastcall16 versions are provided only to support existing small memory
                                        (0097) ; model assembly language code---they do not work in the large memory
                                        (0098) ; model.
                                        (0099) ;
                                        (0100) ; ** The legacy fastcall16 versions are provided on a temporary basis to
                                        (0101) ; ** ease the transition to the 4.2 release of PSoC Designer. Their use is
                                        (0102) ; ** deprecated and their status is "No Further Maintenance".
                                        (0103) ;
                                        (0104) ; The fastcall16 versions of these functions are distinguished by a
                                        (0105) ; leading underscore in the name. The legacy fastcall16 names (which appear
                                        (0106) ; in this comment) do not have the leading underscore. Details on the
                                        (0107) ; calling sequence to be used for fastcall16 are given in the user module
                                        (0108) ; datasheet.
                                        (0109) ;
                                        (0110) ; Fastcall16 versions:
                                        (0111) export _LCD_1_DrawVBG
                                        (0112) export _LCD_1_DrawBG
                                        (0113) 
                                        (0114) IF SYSTEM_SMALL_MEMORY_MODEL
                                        (0115) ; Legacy Fastcall versions:
                                        (0116) export  LCD_1_DrawVBG
                                        (0117) export  LCD_1_DrawBG
                                        (0118) ENDIF  ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0119) 
                                        (0120) ENDIF  ; BARGRAPH_ENABLE
                                        (0121) 
                                        (0122) ;
                                        (0123) ; The following functions are deprecated and will be eliminated in a future
                                        (0124) ; version of PSoC Designer.
                                        (0125) ;
                                        (0126) export   LCD_1_Write_Data
                                        (0127) export  _LCD_1_Write_Data
                                        (0128) 
                                        (0129) 
                                        (0130) ;-----------------------------------------------
                                        (0131) ;  EQUATES
                                        (0132) ;-----------------------------------------------
                                        (0133) 
                                        (0134) LCD_1_Port:           equ    PRT0DR
                                        (0135) LCD_1_PortMode0:      equ    PRT0DM0
                                        (0136) LCD_1_PortMode1:      equ    PRT0DM1
                                        (0137) 
                                        (0138) LCD_1_E:              equ    10h
                                        (0139) LCD_1_RW:             equ    40h
                                        (0140) LCD_1_RS:             equ    20h
                                        (0141) 
                                        (0142) LCD_1_DATA_MASK:      equ    0Fh
                                        (0143) LCD_1_READY_BIT:      equ    08h
                                        (0144) 
                                        (0145) LCD_1_DATA_READ:      equ    ( LCD_1_E | LCD_1_RW | LCD_1_RS )
                                        (0146) LCD_1_CNTL_READ:      equ    ( LCD_1_E | LCD_1_RW )
                                        (0147) LCD_1_PORT_WRITE:     equ    7Fh
                                        (0148) LCD_1_PORT_MASK:      equ    7Fh
                                        (0149) 
                                        (0150) LCD_1_DISP_INC:       equ    03h
                                        (0151) LCD_1_DISP_OFF:       equ    08h
                                        (0152) LCD_1_DISP_ON:        equ    0Ch
                                        (0153) LCD_1_4BIT_2LINE:     equ    2Ch
                                        (0154) 
                                        (0155) 
                                        (0156) ;-----------------------------------------------
                                        (0157) ;      Bargraph definitions
                                        (0158) ;-----------------------------------------------
                                        (0159) 
                                        (0160) LCD_1_BG_CHAR_WIDTH:  equ    16     ; 16 characters in width
                                        (0161) LCD_1_BG_SEG_WIDTH:   equ    80     ; 16 * 5 = 80
                                        (0162) LCD_1_BG_COL_START:   equ     0     ; Always start in the left most column
                                        (0163) 
                                        (0164)                                   ; Offsets for 2x16, 2x20, 4x20
                                        (0165)                                   ; Change these values for a custom LCD
                                        (0166) 
                                        (0167) LCD_1_ROW1_OFFSET:    equ    80h    ; Address/command offset for row 1
                                        (0168) LCD_1_ROW2_OFFSET:    equ    C0h    ; Address/command offset for row 2
                                        (0169) LCD_1_ROW3_OFFSET:    equ    94h    ; Address/command offset for row 1
                                        (0170) LCD_1_ROW4_OFFSET:    equ    D4h    ; Address/command offset for row 2
                                        (0171) 
                                        (0172) LCD_1_BG_ROW1_OFFSET: equ    80h    ; Address/command offset for row 1
                                        (0173) LCD_1_BG_ROW2_OFFSET: equ    C0h    ; Address/command offset for row 2
                                        (0174) 
                                        (0175) LCD_1_CG_RAM_OFFSET:  equ    40h    ; Offset to character RAM
                                        (0176) 
                                        (0177) AREA UserModules (ROM, REL)
                                        (0178) 
                                        (0179) .SECTION
                                        (0180) ;-----------------------------------------------------------------------------
                                        (0181) ;  FUNCTION NAME: LCD_1_PrCString
                                        (0182) ;
                                        (0183) ;  DESCRIPTION:
                                        (0184) ;    Print constant (ROM) string to LCD
                                        (0185) ;-----------------------------------------------------------------------------
                                        (0186) ;
                                        (0187) ;  ARGUMENTS:
                                        (0188) ;     A:X  Pointer to String
                                        (0189) ;          A contains MSB of string address
                                        (0190) ;          X contains LSB of string address
                                        (0191) ;
                                        (0192) ;  RETURNS:  none
                                        (0193) ;
                                        (0194) ;  SIDE EFFECTS:
                                        (0195) ;    The A and X registers may be modified by this or future implementations
                                        (0196) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0197) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0198) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0199) ;    functions.
                                        (0200) ;          
                                        (0201) ;    Currently only the page pointer registers listed below are modified: 
                                        (0202) ;          CUR_PP
                                        (0203) ;
                                        (0204)  LCD_1_PrCString:
                                        (0205) _LCD_1_PrCString:
                                        (0206)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0207)  .Loop_PrCString:
0764: 08       PUSH  A                  (0208)     push  A                            ; Store ROM pointer
0765: 10       PUSH  X                  (0209)     push  X
0766: 28       ROMX                     (0210)     romx                               ; Get character from ROM
0767: B0 04    JNZ   0x076C             (0211)     jnz   .LCD_PrCString_WR            ; print character and advance pointer
0769: 20       POP   X                  (0212)     pop   X                            ; Restore the stack
076A: 18       POP   A                  (0213)     pop   A
                                        (0214)     RAM_EPILOGUE RAM_USE_CLASS_1
076B: 7F       RET                      (0215)     ret                                ; Return
                                        (0216) 
                                        (0217) .LCD_PrCString_WR:
076C: 90 44    CALL  LCD_1_WriteData|_LCD_1_Write_Data|_LCD_1_WriteData|LCD_1_Write_Data(0218)     call  LCD_1_WriteData              ; Write data to LCD
076E: 20       POP   X                  (0219)     pop   X                            ; Get ROM pointer
076F: 18       POP   A                  (0220)     pop   A
0770: 75       INC   X                  (0221)     inc   X                            ; Inc LSB of pointer
0771: DF F2    JNC   _LCD_1_PrCString   (0222)     jnc   .Loop_PrCString
0773: 74       INC   A                  (0223)     inc   A                            ; Inc MSB of pointer if LSB overflow
0774: 8F EF    JMP   _LCD_1_PrCString   (0224)     jmp   .Loop_PrCString
                                        (0225) 
                                        (0226) .ENDSECTION
                                        (0227) 
                                        (0228) ;-----------------------------------------------------------------------------
                                        (0229) ;  FUNCTION NAME: LCD_1_PrHexByte
                                        (0230) ;
                                        (0231) ;  DESCRIPTION:
                                        (0232) ;     Print a byte in Hex (two characters) to current LCD position
                                        (0233) ;
                                        (0234) ;-----------------------------------------------------------------------------
                                        (0235) ;
                                        (0236) ;  ARGUMENTS:
                                        (0237) ;     A  => (BYTE) Data/char to be printed
                                        (0238) ;
                                        (0239) ;  RETURNS: none
                                        (0240) ;
                                        (0241) ;  SIDE EFFECTS:
                                        (0242) ;    The A and X registers may be modified by this or future implementations
                                        (0243) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0244) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0245) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0246) ;    functions.
                                        (0247) ;          
                                        (0248) ;    Currently only the page pointer registers listed below are modified: 
                                        (0249) ;          CUR_PP
                                        (0250) ;
                                        (0251) .LITERAL
                                        (0252) LCD_1_HEX_STR::
                                        (0253)      DS    "0123456789ABCDEF"
                                        (0254) .ENDLITERAL
                                        (0255) .SECTION
                                        (0256) 
                                        (0257)  LCD_1_PrHexByte:
                                        (0258) _LCD_1_PrHexByte:
                                        (0259)     RAM_PROLOGUE RAM_USE_CLASS_1
0786: 08       PUSH  A                  (0260)     push  A                            ; Save lower nibble
0787: 67       ASR   A                  (0261)     asr   A                            ; Shift high nibble to right
0788: 67       ASR   A                  (0262)     asr   A
0789: 67       ASR   A                  (0263)     asr   A
078A: 67       ASR   A                  (0264)     asr   A
078B: 21 0F    AND   A,0xF              (0265)     and   A,0Fh                        ; Mask off nibble
078D: FF E7    INDEX LCD_1_HEX_STR      (0266)     index LCD_1_HEX_STR                  ; Get Hex value
078F: 90 21    CALL  LCD_1_WriteData|_LCD_1_Write_Data|_LCD_1_WriteData|LCD_1_Write_Data(0267)     call  LCD_1_WriteData              ; Write data to screen
0791: 18       POP   A                  (0268)     pop   A                            ; Restore value
0792: 21 0F    AND   A,0xF              (0269)     and   A,0Fh                        ; Mask off lower nibble
0794: FF E0    INDEX LCD_1_HEX_STR      (0270)     index LCD_1_HEX_STR                  ; Get Hex value
0796: 90 1A    CALL  LCD_1_WriteData|_LCD_1_Write_Data|_LCD_1_WriteData|LCD_1_Write_Data(0271)     call  LCD_1_WriteData              ; Write data to screen
                                        (0272)     RAM_EPILOGUE RAM_USE_CLASS_1
0798: 7F       RET                      (0273)     ret
                                        (0274) .ENDSECTION
                                        (0275) 
                                        (0276) .SECTION
                                        (0277) ;-----------------------------------------------------------------------------
                                        (0278) ;  FUNCTION NAME: LCD_1_PrHexInt
                                        (0279) ;
                                        (0280) ;  DESCRIPTION:
                                        (0281) ;     Print an Int in Hex (four characters) to current LCD position
                                        (0282) ;
                                        (0283) ;-----------------------------------------------------------------------------
                                        (0284) ;
                                        (0285) ;  ARGUMENTS:
                                        (0286) ;     A:X Integer value
                                        (0287) ;         A  contains LSB of Int
                                        (0288) ;         X  contains MSB of Int
                                        (0289) ;
                                        (0290) ;  RETURNS: none
                                        (0291) ;
                                        (0292) ;  SIDE EFFECTS:
                                        (0293) ;    The A and X registers may be modified by this or future implementations
                                        (0294) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0295) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0296) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0297) ;    functions.
                                        (0298) ;          
                                        (0299) ;    Currently only the page pointer registers listed below are modified: 
                                        (0300) ;          CUR_PP
                                        (0301) ;
                                        (0302)  LCD_1_PrHexInt:
                                        (0303) _LCD_1_PrHexInt:
                                        (0304)     RAM_PROLOGUE RAM_USE_CLASS_1
0799: 4B       SWAP  A,X                (0305)     swap  A,X
079A: 9F EA    CALL  _LCD_1_PrHexByte   (0306)     call  LCD_1_PrHexByte              ; Print MSB
079C: 5B       MOV   A,X                (0307)     mov   A,X                          ; Move LSB into position
079D: 9F E7    CALL  _LCD_1_PrHexByte   (0308)     call  LCD_1_PrHexByte              ; Print LSB
                                        (0309)     RAM_EPILOGUE RAM_USE_CLASS_1
079F: 7F       RET                      (0310)     ret
07A0: 70 BF    AND   F,0xBF             
07A2: 60 D3    MOV   REG[0xD3],A        
                                        (0311) .ENDSECTION
                                        (0312) 
                                        (0313) .SECTION
                                        (0314) ;-----------------------------------------------------------------------------
                                        (0315) ;  FUNCTION NAME: LCD_1_PrString
                                        (0316) ;
                                        (0317) ;  DESCRIPTION:
                                        (0318) ;     Print (RAM) ASCII string to LCD
                                        (0319) ;
                                        (0320) ;-----------------------------------------------------------------------------
                                        (0321) ;
                                        (0322) ;  ARGUMENTS:
                                        (0323) ;     A:X contains pointer to string
                                        (0324) ;         X  contains LSB of string pointer
                                        (0325) ;         A  contains MSB or page of string pointer (not used at this time)
                                        (0326) ;
                                        (0327) ;  RETURNS:
                                        (0328) ;
                                        (0329) ;  SIDE EFFECTS:
                                        (0330) ;    The A and X registers may be modified by this or future implementations
                                        (0331) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0332) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0333) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0334) ;    functions.
                                        (0335) ;          
                                        (0336) ;    Currently only the page pointer registers listed below are modified: 
                                        (0337) ;          CUR_PP
                                        (0338) ;          IDX_PP
                                        (0339) ;
                                        (0340) ;
                                        (0341)  LCD_1_PrString:
                                        (0342) _LCD_1_PrString:
                                        (0343)     RAM_PROLOGUE RAM_USE_CLASS_3
                                        (0344)     RAM_SETPAGE_IDX A
                                        (0345)  .Loop_PrString:
07A4: 52 00    MOV   A,[X+0]            (0346)     mov   A,[X]                        ; Get value pointed to by X
07A6: A0 06    JZ    0x07AD             (0347)     jz    .End_LCD_PrString            ; Check for end of string
                                        (0348)     ;LCD_1_writeData is known not to modify X so no need to preserve
07A8: 90 08    CALL  LCD_1_WriteData|_LCD_1_Write_Data|_LCD_1_WriteData|LCD_1_Write_Data(0349)     call  LCD_1_WriteData              ; Write data to screen
07AA: 75       INC   X                  (0350)     inc   X                            ; Advance pointer to next character
07AB: 8F F8    JMP   0x07A4             (0351)     jmp   .Loop_PrString               ; Go get next character
07AD: 70 3F    AND   F,0x3F             
07AF: 71 C0    OR    F,0xC0             
                                        (0352) .End_LCD_PrString:
                                        (0353)     RAM_EPILOGUE RAM_USE_CLASS_3
07B1: 7F       RET                      (0354)     ret
                                        (0355) .ENDSECTION
                                        (0356) 
                                        (0357) .SECTION
                                        (0358) ;-----------------------------------------------------------------------------
                                        (0359) ;  FUNCTION NAME: LCD_1_WriteData
                                        (0360) ;
                                        (0361) ;  DESCRIPTION:
                                        (0362) ;     Write a byte to the LCD's data register.
                                        (0363) ;
                                        (0364) ;-----------------------------------------------------------------------------
                                        (0365) ;
                                        (0366) ;  ARGUMENTS:
                                        (0367) ;    A contains byte to be written to LCD data register
                                        (0368) ;
                                        (0369) ;  RETURNS: none
                                        (0370) ;
                                        (0371) ;  SIDE EFFECTS:
                                        (0372) ;    The A and X registers may be modified by this or future implementations
                                        (0373) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0374) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0375) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0376) ;    functions.
                                        (0377) ;          
                                        (0378) ;    Currently only the page pointer registers listed below are modified: 
                                        (0379) ;          CUR_PP
                                        (0380) ;
                                        (0381)  LCD_1_WriteData:
                                        (0382) _LCD_1_WriteData:
                                        (0383)  LCD_1_Write_Data:   ; Do not use
                                        (0384) _LCD_1_Write_Data:   ; Do not use
                                        (0385)     RAM_PROLOGUE RAM_USE_CLASS_1
07B2: 90 65    CALL  0x0819             (0386)     call  LCD_1_Check_Ready            ; Make sure controller is ready
                                        (0387)                                        ; A is preserved in LCD_1_Check_Ready
07B4: 08       PUSH  A                  (0388)     push  A                            ; Save copy of character
07B5: 67       ASR   A                  (0389)     asr   A                            ; Shift high nibble to right
07B6: 67       ASR   A                  (0390)     asr   A
07B7: 67       ASR   A                  (0391)     asr   A
07B8: 67       ASR   A                  (0392)     asr   A
07B9: 21 0F    AND   A,0xF              (0393)     and   A,0Fh                        ; Mask off high nibble
07BB: 90 3B    CALL  0x07F8             (0394)     call  LCD_1_WDATA_Nibble           ; Write Upper nibble
07BD: 18       POP   A                  (0395)     pop   A                            ; Retrieve copy of character
07BE: 21 0F    AND   A,0xF              (0396)     and   A,0Fh                        ; Mask off high nibble
07C0: 40       NOP                      (0397)     nop
07C1: 40       NOP                      (0398)     nop
07C2: 40       NOP                      (0399)     nop
07C3: 90 33    CALL  0x07F8             (0400)     call  LCD_1_WDATA_Nibble   ; Write Lower nibble
                                        (0401)     RAM_EPILOGUE RAM_USE_CLASS_1
07C5: 7F       RET                      (0402)     ret
                                        (0403) .ENDSECTION
                                        (0404) 
                                        (0405) .SECTION
                                        (0406) ;-----------------------------------------------------------------------------
                                        (0407) ;  FUNCTION NAME: LCD_1_Control
                                        (0408) ;
                                        (0409) ;  DESCRIPTION:
                                        (0410) ;     Write a byte to the LCD's control register.
                                        (0411) ;
                                        (0412) ;-----------------------------------------------------------------------------
                                        (0413) ;
                                        (0414) ;  ARGUMENTS:
                                        (0415) ;     A contains data to be written to LCD control register.
                                        (0416) ;
                                        (0417) ;  RETURNS: none
                                        (0418) ;
                                        (0419) ;  SIDE EFFECTS:
                                        (0420) ;    The A and X registers may be modified by this or future implementations
                                        (0421) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0422) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0423) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0424) ;    functions.
                                        (0425) ;          
                                        (0426) ;    Currently only the page pointer registers listed below are modified: 
                                        (0427) ;          CUR_PP
                                        (0428) ;
                                        (0429)  LCD_1_Control:
                                        (0430) _LCD_1_Control:
                                        (0431)     RAM_PROLOGUE RAM_USE_CLASS_1
07C6: 90 51    CALL  0x0819             (0432)     call  LCD_1_Check_Ready            ; Make sure controller is ready
                                        (0433)                                        ; A is preserved in LCD_1_Check_Ready
07C8: 08       PUSH  A                  (0434)     push  A                            ; Save copy of byte
07C9: 67       ASR   A                  (0435)     asr   A                            ; Shift Upper Nibble to right
07CA: 67       ASR   A                  (0436)     asr   A
07CB: 67       ASR   A                  (0437)     asr   A
07CC: 67       ASR   A                  (0438)     asr   A
07CD: 21 0F    AND   A,0xF              (0439)     and   A,0Fh                        ; Mask off, just in case
07CF: 90 09    CALL  0x07DA             (0440)     call  LCD_1_WCNTL_Nibble           ; Write high nibble
07D1: 18       POP   A                  (0441)     pop   A                            ; Restore copy of byte
07D2: 21 0F    AND   A,0xF              (0442)     and   A,0Fh                        ; Mask off high nibble
07D4: 40       NOP                      (0443)     nop
07D5: 40       NOP                      (0444)     nop
07D6: 40       NOP                      (0445)     nop
07D7: 90 01    CALL  0x07DA             (0446)     call  LCD_1_WCNTL_Nibble             ; Write Lower nibble
                                        (0447)     RAM_EPILOGUE RAM_USE_CLASS_1
07D9: 7F       RET                      (0448)     ret
                                        (0449) .ENDSECTION
                                        (0450) 
                                        (0451) .SECTION
                                        (0452) ;-----------------------------------------------------------------------------
                                        (0453) ;  FUNCTION NAME: LCD_1_WCNTL_Nibble
                                        (0454) ;
                                        (0455) ;  DESCRIPTION:
                                        (0456) ;     Write a single nibble to the LCD's command register
                                        (0457) ;
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;
                                        (0460) ;  ARGUMENTS:
                                        (0461) ;     A[3:0]   Contains Nibble to be written to command register
                                        (0462) ;
                                        (0463) ;  RETURNS: none
                                        (0464) ;
                                        (0465) ;  SIDE EFFECTS:
                                        (0466) ;    The A and X registers may be modified by this or future implementations
                                        (0467) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0468) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0469) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0470) ;    functions.
                                        (0471) ;          
                                        (0472) ;    Currently only the page pointer registers listed below are modified: 
                                        (0473) ;          CUR_PP
                                        (0474) ;
                                        (0475)  LCD_1_WCNTL_Nibble:
                                        (0476)     RAM_PROLOGUE RAM_USE_CLASS_4
07DA: 08       PUSH  A                  (0477)     push  A
07DB: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0478)     RAM_SETPAGE_CUR >Port_0_Data_SHADE           ; Set CUR_PP to LCD variable address
07DE: 26 00 80 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x80(0479)     and   [Port_0_Data_SHADE],~LCD_1_PORT_MASK
07E1: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0480)     mov   A,[Port_0_Data_SHADE]
07E3: 60 00    MOV   REG[0x0],A         (0481)     mov   reg[LCD_1_Port],A                      ; Reset control lines
                                        (0482) 
07E5: 18       POP   A                  (0483)     pop   A
07E6: 21 0F    AND   A,0xF              (0484)     and   A,LCD_1_DATA_MASK                      ; Make sure no bogus data in MSN
07E8: 29 10    OR    A,0x10             (0485)     or    A,LCD_1_E                              ; Bring "E" Enable line high
07EA: 2A 00    OR    A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0486)     or    A,[Port_0_Data_SHADE]                  ; OR in bit 7 just
07EC: 60 00    MOV   REG[0x0],A         (0487)     mov   reg[LCD_1_Port], A                     ; Write data
07EE: 53 00    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],A(0488)     mov   [Port_0_Data_SHADE],A                  ; Keep shadow register in sync
07F0: 40       NOP                      (0489)     nop
07F1: 21 8F    AND   A,0x8F             (0490)     and   A,(~LCD_1_PORT_MASK|LCD_1_DATA_MASK)   ; Disable E signal and leave data on bus.
07F3: 53 00    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],A(0491)     mov   [Port_0_Data_SHADE],A                  ; Keep shadow register in sync
07F5: 60 00    MOV   REG[0x0],A         (0492)     mov   reg[LCD_1_Port],A
                                        (0493)     RAM_EPILOGUE RAM_USE_CLASS_4
07F7: 7F       RET                      (0494)     ret
                                        (0495) .ENDSECTION
                                        (0496) 
                                        (0497) .SECTION
                                        (0498) ;-----------------------------------------------------------------------------
                                        (0499) ;  FUNCTION NAME: LCD_1_WDATA_Nibble
                                        (0500) ;
                                        (0501) ;  DESCRIPTION:
                                        (0502) ;     Write a single nibble to the LCD's DATA register
                                        (0503) ;
                                        (0504) ;-----------------------------------------------------------------------------
                                        (0505) ;
                                        (0506) ;  ARGUMENTS:
                                        (0507) ;     A[3:0]   Contains Nibble to be written to data register
                                        (0508) ;
                                        (0509) ;  RETURNS: none
                                        (0510) ;
                                        (0511) ;  SIDE EFFECTS:
                                        (0512) ;    The A and X registers may be modified by this or future implementations
                                        (0513) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0514) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0515) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0516) ;    functions.
                                        (0517) ;          
                                        (0518) ;    Currently only the page pointer registers listed below are modified: 
                                        (0519) ;          CUR_PP
                                        (0520) ;
                                        (0521) LCD_1_WDATA_Nibble:
                                        (0522)     RAM_PROLOGUE RAM_USE_CLASS_4
07F8: 08       PUSH  A                  (0523)     push  A
07F9: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0524)     RAM_SETPAGE_CUR >Port_0_Data_SHADE          ; Set CUR_PP to LCD variable address
07FC: 26 00 80 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x80(0525)     and   [Port_0_Data_SHADE],~LCD_1_PORT_MASK
07FF: 2E 00 20 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x20(0526)     or    [Port_0_Data_SHADE],LCD_1_RS                ; Raise RS to signify a Data Write
0802: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0527)     mov   A,[Port_0_Data_SHADE]
0804: 60 00    MOV   REG[0x0],A         (0528)     mov   reg[LCD_1_Port],A
                                        (0529) 
0806: 18       POP   A                  (0530)     pop   A
0807: 21 0F    AND   A,0xF              (0531)     and   A,LCD_1_DATA_MASK                           ; Make sure no bogus data in A[7:4]
0809: 29 30    OR    A,0x30             (0532)     or    A,(LCD_1_E | LCD_1_RS)                      ; Bring "E" Enable line high
080B: 2A 00    OR    A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0533)     or    A,[Port_0_Data_SHADE]                       ; Keep shadow in sync
080D: 60 00    MOV   REG[0x0],A         (0534)     mov   reg[LCD_1_Port], A                            ; Write data
080F: 53 00    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],A(0535)     mov   [Port_0_Data_SHADE],A                       ; Keep shadow in sync
0811: 40       NOP                      (0536)     NOP
0812: 21 AF    AND   A,0xAF             (0537)     and   A,(~LCD_1_PORT_MASK|LCD_1_DATA_MASK|LCD_1_RS)  ; Disable E signal and leave Data on bus
0814: 53 00    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],A(0538)     mov   [Port_0_Data_SHADE],A                       ; keep shadow in sync
0816: 60 00    MOV   REG[0x0],A         (0539)     mov   reg[LCD_1_Port],A
                                        (0540)     RAM_EPILOGUE RAM_USE_CLASS_4
0818: 7F       RET                      (0541)     ret
                                        (0542) .ENDSECTION
                                        (0543) 
                                        (0544) .SECTION
                                        (0545) ;-----------------------------------------------------------------------------
                                        (0546) ;  FUNCTION NAME: LCD_1_Check_Ready
                                        (0547) ;
                                        (0548) ;  DESCRIPTION:
                                        (0549) ;     Wait until LCD has completed last command.
                                        (0550) ;
                                        (0551) ;-----------------------------------------------------------------------------
                                        (0552) ;
                                        (0553) ;  ARGUMENTS: none
                                        (0554) ;
                                        (0555) ;  RETURNS: none
                                        (0556) ;
                                        (0557) ;  SIDE EFFECTS:
                                        (0558) ;    The A and X registers may be modified by this or future implementations
                                        (0559) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0560) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0561) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0562) ;    functions.
                                        (0563) ;          
                                        (0564) ;    Currently only the page pointer registers listed below are modified: 
                                        (0565) ;          CUR_PP
                                        (0566) ;
                                        (0567) ;     If LCD is not present, this routine may never return.
                                        (0568) ;
                                        (0569) LCD_1_Check_Ready:
                                        (0570)     RAM_PROLOGUE RAM_USE_CLASS_4
0819: 08       PUSH  A                  (0571)     push  A                                           ; Save Accumulator
081A: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0572)     RAM_SETPAGE_CUR >Port_0_Data_SHADE                ; Set CUR_PP to LCD variable address
081D: 26 00 80 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x80(0573)     and   [Port_0_Data_SHADE],~LCD_1_PORT_MASK        ; Mask of all LCD bits
0820: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0574)     mov   A,[Port_0_Data_SHADE]
0822: 60 00    MOV   REG[0x0],A         (0575)     mov   reg[LCD_1_Port],A                           ; Zero LCD port bits
                                        (0576) 
0824: 26 03 F0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3],0xF0(0577)     and   [Port_0_DriveMode_0_SHADE],~LCD_1_DATA_MASK ; Clear out LCD mode bits.
0827: 51 03    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3](0578)     mov   A,[Port_0_DriveMode_0_SHADE]
0829: 71 10    OR    F,0x10             
                                        (0579)     M8C_SetBank1                                      ; Change port mode to read status
082B: 60 00    MOV   REG[0x0],A         (0580)     mov   reg[LCD_1_PortMode0],A                      ; Setup LCD Port for reading
082D: 70 EF    AND   F,0xEF             
                                        (0581)     M8C_SetBank0
                                        (0582) 
082F: 2E 00 40 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x40(0583)     or    [Port_0_Data_SHADE],LCD_1_RW                ; Raise RW to signify Read operation
0832: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0584)     mov   A,[Port_0_Data_SHADE]
0834: 60 00    MOV   REG[0x0],A         (0585)     mov   reg[LCD_1_Port],A
0836: 40       NOP                      (0586)     NOP
                                        (0587) 
0837: 10       PUSH  X                  (0588)     push  X							                            ; Save 'X' register
0838: 57 FF    MOV   X,0xFF             (0589)     mov   X,255                         			            ; 255 Attempts
                                        (0590) 
                                        (0591) .LCD_RDY_LOOP:
083A: 2E 00 50 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x50(0592)     or    [Port_0_Data_SHADE], LCD_1_CNTL_READ                  ; Raise E to start cycle
083D: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0593)     mov   A,[Port_0_Data_SHADE]
083F: 60 00    MOV   REG[0x0],A         (0594)     mov   reg[LCD_1_Port],A
                                        (0595) 
0841: 40       NOP                      (0596)     nop                                               ; Wait 2 nops to make sure data is ready
0842: 40       NOP                      (0597)     nop
0843: 5D 00    MOV   A,REG[0x0]         (0598)     mov   A,reg[LCD_1_Port]
                                        (0599) 
                                        (0600) ; The code below is used to work around the async read issue with the ICE with the 
                                        (0601) ; 25/26xxx family of devices.  It will help to eliminate "Invalid memory reference" 
                                        (0602) ; errors.  It is not required when running without the ICE or when using any other 
                                        (0603) ; family besides the 25/26xxx family. If not using the ICE or with any other family
                                        (0604) ; the ICE_PORT_SYNC flag should be set to 0.
                                        (0605) IF(ICE_PORT_SYNC)                          
                                        (0606)     mov   reg[ 0xfa], A                    
                                        (0607)     mov   A, reg[0xfa]                     
                                        (0608) ENDIF   
                                        (0609)                                    
0845: 08       PUSH  A                  (0610)     push  A
0846: 26 00 C0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0xC0(0611)     and   [Port_0_Data_SHADE],(~LCD_1_PORT_MASK | LCD_1_RW)     ; Lower E signal
0849: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0612)     mov   A,[Port_0_Data_SHADE]
084B: 60 00    MOV   REG[0x0],A         (0613)     mov   reg[LCD_1_Port],A
                                        (0614) 
084D: 40       NOP                      (0615)     nop                                    ; Add delay for the slowest part and the
084E: 40       NOP                      (0616)     nop                                    ; fastest PSoC
084F: 40       NOP                      (0617)     nop
                                        (0618)                                                                 ; Get the LSBs
0850: 2E 00 50 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0x50(0619)     or    [Port_0_Data_SHADE],LCD_1_CNTL_READ                   ; Raise E to start cycle
0853: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0620)     mov   A,[Port_0_Data_SHADE]
0855: 60 00    MOV   REG[0x0],A         (0621)     mov   reg[LCD_1_Port],A
                                        (0622) 
0857: 40       NOP                      (0623)     nop
0858: 40       NOP                      (0624)     nop
                                        (0625) 
0859: 26 00 C0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],0xC0(0626)     and   [Port_0_Data_SHADE],(~LCD_1_PORT_MASK | LCD_1_RW)     ; Lower E signal
085C: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw](0627)     mov   A,[Port_0_Data_SHADE]
085E: 60 00    MOV   REG[0x0],A         (0628)     mov   reg[LCD_1_Port],A
                                        (0629) 
0860: 18       POP   A                  (0630)     pop   A
0861: 21 08    AND   A,0x8              (0631)     and   A,LCD_1_READY_BIT                                       ; Check busy
                                        (0632) 
0863: A0 04    JZ    0x0868             (0633)     jz    .UNLOCK
0865: 79       DEC   X                  (0634)     dec   X
0866: BF D3    JNZ   0x083A             (0635)     jnz   .LCD_RDY_LOOP                                         ; If LCD still busy, read again for 255 times
                                        (0636) .UNLOCK:
0868: 20       POP   X                  (0637)     pop   X							                            ; Restore 'X' register
                                        (0638) 
0869: 2E 03 7F OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3],0x7F(0639)     or    [Port_0_DriveMode_0_SHADE],LCD_1_PORT_WRITE ; Revert Data bit to Write mode
086C: 51 03    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3](0640)     mov   A,[Port_0_DriveMode_0_SHADE]
086E: 71 10    OR    F,0x10             
                                        (0641)     M8C_SetBank1
0870: 60 00    MOV   REG[0x0],A         (0642)     mov   reg[LCD_1_PortMode0],A                      ; Setup LCD Port for writing
0872: 70 EF    AND   F,0xEF             
                                        (0643)     M8C_SetBank0
0874: 18       POP   A                  (0644)     pop   A
                                        (0645)     RAM_EPILOGUE RAM_USE_CLASS_4                                ; Restore Accumulator
0875: 7F       RET                      (0646)     ret
0876: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0647) .ENDSECTION
                                        (0648) 
                                        (0649) .SECTION
                                        (0650) ;-----------------------------------------------------------------------------
                                        (0651) ;  FUNCTION NAME: LCD_1_Start
                                        (0652) ;  FUNCTION NAME: LCD_1_Init
                                        (0653) ;
                                        (0654) ;  DESCRIPTION:
                                        (0655) ;     Initialize LCD
                                        (0656) ;
                                        (0657) ;-----------------------------------------------------------------------------
                                        (0658) ;
                                        (0659) ;  ARGUMENTS: none
                                        (0660) ;
                                        (0661) ;  RETURNS: none
                                        (0662) ;
                                        (0663) ;  SIDE EFFECTS:
                                        (0664) ;    The A and X registers may be modified by this or future implementations
                                        (0665) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0666) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0667) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0668) ;    functions.
                                        (0669) ;          
                                        (0670) ;    Currently only the page pointer registers listed below are modified: 
                                        (0671) ;          CUR_PP
                                        (0672) ;
                                        (0673) ;  THEORY of OPERATION or PROCEDURE:
                                        (0674) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0675) ;    This initialization is a bit long, but it should work for
                                        (0676) ;    most 2 and 4 line LCDs.
                                        (0677) ;
                                        (0678)  LCD_1_Start:
                                        (0679) _LCD_1_Start:
                                        (0680)  LCD_1_Init:
                                        (0681) _LCD_1_Init:
                                        (0682)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0683)     RAM_SETPAGE_CUR >Port_0_Data_SHADE                          ; Set CUR_PP to LCD variable address
                                        (0684) 
0879: 26 03 80 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3],0x80(0685)     and   [Port_0_DriveMode_0_SHADE],~LCD_1_PORT_MASK           ; Mask off LCD bits
087C: 2E 03 7F OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3],0x7F(0686)     or    [Port_0_DriveMode_0_SHADE],LCD_1_PORT_WRITE           ; Set LCD port for writing
087F: 26 04 80 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+4],0x80(0687)     and   [Port_0_DriveMode_1_SHADE],~LCD_1_PORT_MASK           ; Mask off LCD bits
                                        (0688) 
0882: 51 03    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+3](0689)     mov   A,[Port_0_DriveMode_0_SHADE]
0884: 71 10    OR    F,0x10             
                                        (0690)     M8C_SetBank1
0886: 60 00    MOV   REG[0x0],A         (0691)     mov   reg[LCD_1_PortMode0],A                                ; Setup LCD Port for writing
0888: 51 04    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+4](0692)     mov   A,[Port_0_DriveMode_1_SHADE]
088A: 60 01    MOV   REG[0x1],A         (0693)     mov   reg[LCD_1_PortMode1],A
088C: 70 EF    AND   F,0xEF             
                                        (0694)     M8C_SetBank0
                                        (0695) 
088E: 50 FA    MOV   A,0xFA             (0696)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
0890: 90 67    CALL  _LCD_1_Delay50uTimes(0697)     call  LCD_1_Delay50uTimes
0892: 50 FA    MOV   A,0xFA             (0698)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
0894: 90 63    CALL  _LCD_1_Delay50uTimes(0699)     call  LCD_1_Delay50uTimes
                                        (0700) 
0896: 50 03    MOV   A,0x3              (0701)     mov   A,03h
0898: 9F 40    CALL  0x07DA             (0702)     call  LCD_1_WCNTL_Nibble
                                        (0703) 
089A: 50 52    MOV   A,0x52             (0704)     mov   A,82                              ; Delay for 4.1 mSec (82 * 50uSec)
089C: 90 5B    CALL  _LCD_1_Delay50uTimes(0705)     call  LCD_1_Delay50uTimes
                                        (0706) 
089E: 50 03    MOV   A,0x3              (0707)     mov   A,03h
08A0: 9F 38    CALL  0x07DA             (0708)     call  LCD_1_WCNTL_Nibble
                                        (0709) 
08A2: 90 63    CALL  _LCD_1_Delay50u    (0710)     call  LCD_1_Delay50u
08A4: 90 61    CALL  _LCD_1_Delay50u    (0711)     call  LCD_1_Delay50u
08A6: 90 5F    CALL  _LCD_1_Delay50u    (0712)     call  LCD_1_Delay50u
                                        (0713) 
08A8: 50 03    MOV   A,0x3              (0714)     mov   A,03h
08AA: 9F 2E    CALL  0x07DA             (0715)     call  LCD_1_WCNTL_Nibble
                                        (0716) 
08AC: 50 5A    MOV   A,0x5A             (0717)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
08AE: 90 49    CALL  _LCD_1_Delay50uTimes(0718)     call  LCD_1_Delay50uTimes
                                        (0719) 
08B0: 50 02    MOV   A,0x2              (0720)     mov   A,02h
08B2: 9F 26    CALL  0x07DA             (0721)     call  LCD_1_WCNTL_Nibble
                                        (0722) 
08B4: 50 5A    MOV   A,0x5A             (0723)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
08B6: 90 41    CALL  _LCD_1_Delay50uTimes(0724)     call  LCD_1_Delay50uTimes
                                        (0725) 
08B8: 50 08    MOV   A,0x8              (0726)     mov   A,08h
08BA: 9F 0A    CALL  _LCD_1_Control     (0727)     call  LCD_1_Control
08BC: 50 5A    MOV   A,0x5A             (0728)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
08BE: 90 39    CALL  _LCD_1_Delay50uTimes(0729)     call  LCD_1_Delay50uTimes
                                        (0730) 
08C0: 50 01    MOV   A,0x1              (0731)     mov   A,01h
08C2: 9F 02    CALL  _LCD_1_Control     (0732)     call  LCD_1_Control
08C4: 50 5A    MOV   A,0x5A             (0733)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
08C6: 90 31    CALL  _LCD_1_Delay50uTimes(0734)     call  LCD_1_Delay50uTimes
                                        (0735) 
08C8: 50 06    MOV   A,0x6              (0736)     mov   A,06h
08CA: 9E FA    CALL  _LCD_1_Control     (0737)     call  LCD_1_Control
                                        (0738) 
08CC: 50 0E    MOV   A,0xE              (0739)     mov   A,0Eh
08CE: 9E F6    CALL  _LCD_1_Control     (0740)     call  LCD_1_Control
                                        (0741) 
08D0: 50 2C    MOV   A,0x2C             (0742)     mov   A,LCD_1_4BIT_2LINE                  ; Setup for 4 bit interface, 2 line
08D2: 9E F2    CALL  _LCD_1_Control     (0743)     call  LCD_1_Control
                                        (0744) 
08D4: 50 08    MOV   A,0x8              (0745)     mov   A,LCD_1_DISP_OFF
08D6: 9E EE    CALL  _LCD_1_Control     (0746)     call  LCD_1_Control
                                        (0747) 
08D8: 50 0C    MOV   A,0xC              (0748)     mov   A,LCD_1_DISP_ON
08DA: 9E EA    CALL  _LCD_1_Control     (0749)     call  LCD_1_Control
                                        (0750) 
08DC: 50 03    MOV   A,0x3              (0751)     mov   A,LCD_1_DISP_INC
08DE: 9E E6    CALL  _LCD_1_Control     (0752)     call  LCD_1_Control
                                        (0753) 
08E0: 50 5A    MOV   A,0x5A             (0754)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
08E2: 90 15    CALL  _LCD_1_Delay50uTimes(0755)     call  LCD_1_Delay50uTimes
                                        (0756)     RAM_EPILOGUE RAM_USE_CLASS_4
08E4: 7F       RET                      (0757)     ret
                                        (0758) .ENDSECTION
                                        (0759) 
                                        (0760) ;-----------------------------------------------------------------------------
                                        (0761) ;  FUNCTION NAME: LCD_1_Position
                                        (0762) ;
                                        (0763) ;  DESCRIPTION:
                                        (0764) ;     Position Cursor at Row and Col location
                                        (0765) ;
                                        (0766) ;-----------------------------------------------------------------------------
                                        (0767) ;
                                        (0768) ;  ARGUMENTS:
                                        (0769) ;     A => Row  0 to 3
                                        (0770) ;     X => Col  0 to 39+
                                        (0771) ;
                                        (0772) ;  RETURNS:  none
                                        (0773) ;
                                        (0774) ;  SIDE EFFECTS:
                                        (0775) ;    The A and X registers may be modified by this or future implementations
                                        (0776) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0777) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0778) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0779) ;    functions.
                                        (0780) ;
                                        (0781) .LITERAL
                                        (0782) LCD_1_ROW_OFFSET::
                                        (0783)      DB    LCD_1_ROW1_OFFSET, LCD_1_ROW2_OFFSET, LCD_1_ROW3_OFFSET, LCD_1_ROW4_OFFSET
                                        (0784) .ENDLITERAL
                                        (0785) 
                                        (0786) .SECTION
                                        (0787)  LCD_1_Position:
                                        (0788) _LCD_1_Position:
                                        (0789)     RAM_PROLOGUE RAM_USE_CLASS_2
08E9: 21 03    AND   A,0x3              (0790)     and   A,03h                        ; Mask off 2 bits for row address 0 to 3
08EB: 10       PUSH  X                  (0791)     push  X                            ; Store COL
08EC: FF F7    INDEX LCD_1_ROW_OFFSET   (0792)     index LCD_1_ROW_OFFSET ; Get ROW memory offset from table
08EE: 4F       MOV   X,SP               (0793)     mov   X,SP                         ; Get Stack pointer
08EF: 03 FF    ADD   A,[X-1]            (0794)     add   A,[X+(-1)]                   ; Add the COL to the display pointer
08F1: 20       POP   X                  (0795)     pop   X
                                        (0796) 
08F2: 9E D2    CALL  _LCD_1_Control     (0797)     call  LCD_1_Control                ; Write control byte
08F4: 70 3F    AND   F,0x3F             
08F6: 71 C0    OR    F,0xC0             
                                        (0798)     RAM_EPILOGUE RAM_USE_CLASS_2
08F8: 7F       RET                      (0799)     ret
                                        (0800) .ENDSECTION
                                        (0801) 
                                        (0802) .SECTION
                                        (0803) ;-----------------------------------------------------------------------------
                                        (0804) ;  FUNCTION NAME: LCD_1_Delay50uTimes
                                        (0805) ;
                                        (0806) ;  DESCRIPTION:
                                        (0807) ;     Delay increments of 50uSeconds
                                        (0808) ;
                                        (0809) ;-----------------------------------------------------------------------------
                                        (0810) ;
                                        (0811) ;  ARGUMENTS:
                                        (0812) ;     A contains the delay multiplier
                                        (0813) ;
                                        (0814) ;  RETURNS:
                                        (0815) ;
                                        (0816) ;  SIDE EFFECTS:
                                        (0817) ;    The A and X registers may be modified by this or future implementations
                                        (0818) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0819) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0820) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0821) ;    functions.
                                        (0822) ;
                                        (0823) ;
                                        (0824)  LCD_1_Delay50uTimes:
                                        (0825) _LCD_1_Delay50uTimes:
                                        (0826)     RAM_PROLOGUE RAM_USE_CLASS_1
08F9: 90 0C    CALL  _LCD_1_Delay50u    (0827)     call  LCD_1_Delay50u
08FB: 78       DEC   A                  (0828)     dec   A
08FC: BF FC    JNZ   _LCD_1_Delay50uTimes(0829)     jnz   LCD_1_Delay50uTimes
                                        (0830)     RAM_EPILOGUE RAM_USE_CLASS_1
08FE: 7F       RET                      (0831)     ret
                                        (0832) 
                                        (0833) .ENDSECTION
                                        (0834) 
                                        (0835) ;-----------------------------------------------------------------------------
                                        (0836) ;  FUNCTION NAME: LCD_1_Delay50u
                                        (0837) ;
                                        (0838) ;  DESCRIPTION:
                                        (0839) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                        (0840) ;     Slower clock frequencies the delay will be;
                                        (0841) ;           1.5
                                        (0842) ;        -------------- * 50uSec
                                        (0843) ;        clock_freq(MHz)
                                        (0844) ;
                                        (0845) ;
                                        (0846) ;-----------------------------------------------------------------------------
                                        (0847) ;
                                        (0848) ;  ARGUMENTS: none
                                        (0849) ;
                                        (0850) ;  RETURNS: none
                                        (0851) ;
                                        (0852) ;  SIDE EFFECTS:
                                        (0853) ;    The A and X registers may be modified by this or future implementations
                                        (0854) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0855) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0856) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0857) ;    functions.
                                        (0858) ;
                                        (0859) ;  THEORY of OPERATION or PROCEDURE:
                                        (0860) ;
                                        (0861) .LITERAL
                                        (0862)  LCD_1_Delay50u_Table::
                                        (0863)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                        (0864) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                        (0865) .ENDLITERAL
                                        (0866) .SECTION
                                        (0867) 
                                        (0868)   LCD_1_Delay50u:
                                        (0869)  _LCD_1_Delay50u:                      ; [11]  Call
                                        (0870)     RAM_PROLOGUE RAM_USE_CLASS_1
0907: 08       PUSH  A                  (0871)     push  A
0908: 71 10    OR    F,0x10             
                                        (0872)     M8C_SetBank1                         ; [4]
090A: 5D E0    MOV   A,REG[0xE0]        (0873)     mov   A, reg[OSC_CR0]                ; [6] Get delay value
090C: 70 EF    AND   F,0xEF             
                                        (0874)     M8C_SetBank0                         ; [4]
090E: 21 07    AND   A,0x7              (0875)     and   A,07h                          ; [4] Mask off only the clock bits
0910: 39 05    CMP   A,0x5              (0876)     cmp   A,05h
0912: D0 06    JNC   0x0919             (0877)     jnc   .Delay50u_End
0914: FF E9    INDEX LCD_1_Delay50u_Table(0878)     index LCD_1_Delay50u_Table ; [13] Get delay value
                                        (0879) .Delay50u_Loop:                          ;
0916: 78       DEC   A                  (0880)     dec   A                              ; [4]
0917: BF FE    JNZ   0x0916             (0881)     jnz   .Delay50u_Loop                 ; [5]
                                        (0882) .Delay50u_End:
0919: 18       POP   A                  (0883)     pop   A
                                        (0884)     RAM_EPILOGUE RAM_USE_CLASS_1
091A: 7F       RET                      (0885)     ret
                                        (0886) .ENDSECTION
                                        (0887) 
                                        (0888) 
                                        (0889) ;-----------------------------------------------------------------------------
                                        (0890) ;      If bargraph is not enabled, the following functions are not required.
                                        (0891) ;-----------------------------------------------------------------------------
                                        (0892) 
                                        (0893) IF (LCD_1_BARGRAPH_ENABLE)
                                        (0894) 
                                        (0895) IF SYSTEM_SMALL_MEMORY_MODEL
                                        (0896) .SECTION
                                        (0897) ;-----------------------------------------------------------------------------
                                        (0898) ;  FUNCTION NAME: LCD_1_DrawBG
                                        (0899) ;
                                        (0900) ;  DESCRIPTION:
                                        (0901) ;  This legacy fastcall version are provided only to support existing small
                                        (0902) ;  memory model assembly language code---it does not work in the large memory
                                        (0903) ;  model.
                                        (0904) ;
                                        (0905) ;  ** This legacy fastcall version is provided on a temporary basis to
                                        (0906) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                        (0907) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                        (0908) ;  ** function in assembly you should convert to _LCD_1_DrawVBG
                                        (0909) ;  ** (with a leading underscore) and the fastcall16 interface
                                        (0910) ;
                                        (0911) ;  Draw a horizontal bargraph on the LCD with the given parameters.  This
                                        (0912) ;  is a legacy function that is intended to support existing Assembly
                                        (0913) ;  language programs that call this function.  This should not be used for
                                        (0914) ;  new code or with Large Memory Model programs.
                                        (0915) ;-----------------------------------------------------------------------------
                                        (0916) ;
                                        (0917) ;  LEGACY FASTCALL ARGUMENTS:
                                        (0918) ;    A    => Starting row for bargraph 0 to 3
                                        (0919) ;   [X]   => Starting Column for bargraph 0 to 39+
                                        (0920) ;   [x-1] => Length of bargraph in chars 1 to 40+
                                        (0921) ;   [X-2] => Position of pointer in segments 5 times Length
                                        (0922) ;
                                        (0923) ;
                                        (0924) ;  RETURNS:  none
                                        (0925) ;
                                        (0926) ;  SIDE EFFECTS:
                                        (0927) ;    The A and X registers may be modified by this or future implementations
                                        (0928) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0929) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0930) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0931) ;    functions.
                                        (0932) ;
                                        (0933) ;    If LCD_1_Init is not called before this function, the
                                        (0934) ;    bargraph will not be drawn properly.
                                        (0935) ;
                                        (0936) ; Stack offset constants
                                        (0937) BG_COLX:       equ  0                   ; Stack position of Column
                                        (0938) BG_CHAR_LENX:  equ -1                   ; Stack position of Length
                                        (0939) BG_LENGTHX:    equ -2                   ; Stack position of bargraph pointer position
                                        (0940) 
                                        (0941) 
                                        (0942) LCD_1_DrawBG:
                                        (0943)     push  X
                                        (0944)     mov   X,[X+BG_COLX]                 ; Row in A, Col in X
                                        (0945)     call  LCD_1_Position               ; Set cursor position
                                        (0946)     pop   X                             ; Restore pointer
                                        (0947) 
                                        (0948) .LCD_BG_LOOP1X:
                                        (0949)     cmp   [X+BG_LENGTHX],00h            ; Check for past end of BG
                                        (0950)     jnz   .LCD_CHECK1X
                                        (0951)     mov   A,00h                         ; Load empty character
                                        (0952)     jmp   .LCD_BG_DOITX                 ;
                                        (0953) 
                                        (0954) .LCD_CHECK1X:
                                        (0955)     cmp   [X+BG_LENGTHX],06h            ; Check if BG pointer is at this character
                                        (0956)     jnc   .LCD_CHECK2X                  ; Note yet, use full character
                                        (0957)     mov   A,[X+BG_LENGTHX]
                                        (0958)     sub   [X+BG_LENGTHX],A
                                        (0959)     jmp   .LCD_BG_DOITX
                                        (0960) 
                                        (0961) .LCD_CHECK2X:                           ; Put index to full character
                                        (0962)     mov   A, 06h
                                        (0963)     sub   [X+BG_LENGTHX],05h            ; Subtract another 5 positions
                                        (0964) 
                                        (0965) .LCD_BG_DOITX:
                                        (0966)     call  LCD_1_WriteData              ; Display BG character
                                        (0967) 
                                        (0968)     dec   [X+BG_CHAR_LENX]              ; Dec Char count
                                        (0969)     jnz   .LCD_BG_LOOP1X                ; Do it all over again
                                        (0970)     ret
                                        (0971) .ENDSECTION
                                        (0972) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0973) 
                                        (0974) .SECTION
                                        (0975) ;-----------------------------------------------------------------------------
                                        (0976) ;  FUNCTION NAME: LCD_1_DrawBG
                                        (0977) ;
                                        (0978) ;  DESCRIPTION:
                                        (0979) ;     Draw a horizontal bargraph on the LCD with the given parameters.
                                        (0980) ;
                                        (0981) ;
                                        (0982) ;-----------------------------------------------------------------------------
                                        (0983) ;
                                        (0984) ;  FASTCALL16 ARGUMENTS:
                                        (0985) ;   [SP-3] => Starting row for bargraph 0 to 3
                                        (0986) ;   [SP-4] => Starting Column for bargraph 0 to 39+
                                        (0987) ;   [SP-5] => Length of bargraph in chars 1 to 40+
                                        (0988) ;   [SP-6] => Position of pointer in segments 5 times Length
                                        (0989) ;
                                        (0990) ;
                                        (0991) ;  RETURNS:  none
                                        (0992) ;
                                        (0993) ;  SIDE EFFECTS:
                                        (0994) ;    The A and X registers may be modified by this or future implementations
                                        (0995) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0996) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0997) ;    responsibility to preserve their values across calls to fastcall16 
                                        (0998) ;    functions.
                                        (0999) ;          
                                        (1000) ;    Currently only the page pointer registers listed below are modified: 
                                        (1001) ;          CUR_PP
                                        (1002) ;
                                        (1003) ;    If LCD_1_Init is not called before this function, the
                                        (1004) ;    bargraph will not be drawn properly.
                                        (1005) ;
                                        (1006) ; Stack offset constants
                                        (1007) BG_ROW:       equ -3
                                        (1008) BG_COL:       equ -4                   ; Stack position of Column
                                        (1009) BG_CHAR_LEN:  equ -5                   ; Stack position of Length
                                        (1010) BG_LENGTH:    equ -6                   ; Stack position of bargraph pointer position
                                        (1011) 
                                        (1012) 
                                        (1013) _LCD_1_DrawBG:
                                        (1014)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (1015)     mov   X, SP
                                        (1016)     push  X
                                        (1017)     mov   A,[X+BG_ROW]                 ; Row in A
                                        (1018)     mov   X,[X+BG_COL]                 ; Col in X
                                        (1019)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (1020)     call  LCD_1_Position               ; Set cursor position
                                        (1021)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (1022)     pop  X
                                        (1023) 
                                        (1024) .LCD_BG_LOOP1:
                                        (1025)     cmp   [X+BG_LENGTH],00h            ; Check for past end of BG
                                        (1026)     jnz   .LCD_CHECK1
                                        (1027)     mov   A,00h                        ; Load empty character
                                        (1028)     jmp   .LCD_BG_DOIT                  ;
                                        (1029) 
                                        (1030) .LCD_CHECK1:
                                        (1031)     cmp   [X+BG_LENGTH],06h            ; Check if BG pointer is at this character
                                        (1032)     jnc   .LCD_CHECK2                   ; Note yet, use full character
                                        (1033)     mov   A,[X+BG_LENGTH]
                                        (1034)     sub   [X+BG_LENGTH],A
                                        (1035)     jmp   .LCD_BG_DOIT
                                        (1036) 
                                        (1037) .LCD_CHECK2:                            ; Put index to full character
                                        (1038)     mov   A, 06h
                                        (1039)     sub   [X+BG_LENGTH],05h            ; Subtract another 5 positions
                                        (1040) 
                                        (1041) .LCD_BG_DOIT:
                                        (1042)     call  LCD_1_WriteData              ; Display BG character
                                        (1043) 
                                        (1044)     dec   [X+BG_CHAR_LEN]              ; Dec Char count
                                        (1045)     jnz   .LCD_BG_LOOP1                 ; Do it all over again
                                        (1046)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (1047)     ret
                                        (1048) .ENDSECTION
                                        (1049) 
                                        (1050) IF SYSTEM_SMALL_MEMORY_MODEL
                                        (1051) .SECTION
                                        (1052) ;-----------------------------------------------------------------------------
                                        (1053) ;  FUNCTION NAME: LCD_1_DrawVBG
                                        (1054) ;
                                        (1055) ;  DESCRIPTION:
                                        (1056) ;  This legacy fastcall version are provided only to support existing small
                                        (1057) ;  memory model assembly language code---it does not work in the large memory
                                        (1058) ;  model.
                                        (1059) ;
                                        (1060) ;  ** This legacy fastcall version is provided on a temporary basis to
                                        (1061) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                        (1062) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                        (1063) ;  ** function in assembly you should convert to _LCD_1_DrawVBG
                                        (1064) ;  ** (with a leading underscore) and the fastcall16 interface
                                        (1065) ;
                                        (1066) ;  Draw a vertical bargraph on the LCD with the given parameters. This
                                        (1067) ;  is a legacy function that is intended to support existing Assembly
                                        (1068) ;  language programs that call this function.  This should not be used for
                                        (1069) ;  new code or with Large Memory Model programs.
                                        (1070) ;-----------------------------------------------------------------------------
                                        (1071) ;
                                        (1072) ;  LEGACY FASTCALL ARGUMENTS:
                                        (1073) ;    A    => Starting row for bargraph 0 to 3
                                        (1074) ;   [X]   => Starting Column for bargraph 0 to 40+
                                        (1075) ;   [x-1] => Height of bargraph in chars 1 - 4
                                        (1076) ;   [X-2] => Position of pointer in segments 8 times height
                                        (1077) ;  RETURNS:
                                        (1078) ;
                                        (1079) ;  SIDE EFFECTS:
                                        (1080) ;    The A and X registers may be modified by this or future implementations
                                        (1081) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1082) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1083) ;    responsibility to preserve their values across calls to fastcall16 
                                        (1084) ;    functions.
                                        (1085) ;    
                                        (1086) ;    If LCD_1_Init is not called before this function, the
                                        (1087) ;    bargraph will not be drawn properly.
                                        (1088) ;
                                        (1089) ; Stack offset constants
                                        (1090) VBG_COLX:            equ  0
                                        (1091) VBG_CHAR_HEIGHTX:    equ -1
                                        (1092) VBG_SEG_HEIGHTX:     equ -2
                                        (1093) 
                                        (1094) LCD_1_DrawVBG:
                                        (1095) 
                                        (1096)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
                                        (1097) .VBG_LOOPX:
                                        (1098)     push  A
                                        (1099)     index LCD_1_ROW_OFFSET  ; Get row offset
                                        (1100)     add   A,[X+VBG_COLX]                ; Add column offset to position
                                        (1101)     call  LCD_1_Control                ; Position Cursor
                                        (1102)     cmp   [X+VBG_SEG_HEIGHTX],00h       ; Check for zero segs
                                        (1103)     jnz   .VBG_NZ_SEGX
                                        (1104)     mov   A,' '                        ; Load space character
                                        (1105)     jmp   .VBG_WRITE_CHARX
                                        (1106) .VBG_NZ_SEGX:
                                        (1107)     cmp   [X+VBG_SEG_HEIGHTX],09h       ; Check for full segment
                                        (1108)     jnc   .VBG_FULL_SEGX
                                        (1109)                                         ; Partial segment between 1 and 8
                                        (1110)     mov   A,[X+VBG_SEG_HEIGHTX]
                                        (1111)     dec   A
                                        (1112)     mov   [X+VBG_SEG_HEIGHTX],00h       ; Zero segment height
                                        (1113)     jmp   .VBG_WRITE_CHARX
                                        (1114) 
                                        (1115) .VBG_FULL_SEGX:                          ; Bargaph
                                        (1116)     sub   [X+VBG_SEG_HEIGHTX],08h       ; Subtract full segment
                                        (1117)     mov   A,07h                        ; Load full segment
                                        (1118) 
                                        (1119) .VBG_WRITE_CHARX:                        ; Write character to display
                                        (1120)     call  LCD_1_WriteData              ; Write value
                                        (1121)     pop   A
                                        (1122)     dec   A
                                        (1123)     dec   [X+VBG_CHAR_HEIGHTX]
                                        (1124)     jnz   .VBG_LOOPX
                                        (1125)     ret
                                        (1126) .ENDSECTION
                                        (1127) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (1128) 
                                        (1129) .SECTION
                                        (1130) ;-----------------------------------------------------------------------------
                                        (1131) ;  FUNCTION NAME: LCD_1_DrawVBG
                                        (1132) ;
                                        (1133) ;  DESCRIPTION:
                                        (1134) ;     Draw a vertical bargraph on the LCD with the given parameters.
                                        (1135) ;
                                        (1136) ;
                                        (1137) ;-----------------------------------------------------------------------------
                                        (1138) ;
                                        (1139) ;  FASTCALL16 ARGUMENTS:
                                        (1140) ;
                                        (1141) ;   [SP-3] => Starting row for bargraph 0 to 3
                                        (1142) ;   [SP-4] => Starting Column for bargraph 0 to 40+
                                        (1143) ;   [SP-5] => Height of bargraph in chars 1 - 4
                                        (1144) ;   [SP-6] => Position of pointer in segments 8 times height
                                        (1145) ;  RETURNS:
                                        (1146) ;
                                        (1147) ;  SIDE EFFECTS:
                                        (1148) ;    The A and X registers may be modified by this or future implementations
                                        (1149) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1150) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1151) ;    responsibility to preserve their values across calls to fastcall16 
                                        (1152) ;    functions.
                                        (1153) ;          
                                        (1154) ;    Currently only the page pointer registers listed below are modified: 
                                        (1155) ;          CUR_PP
                                        (1156) ;
                                        (1157) ;    If LCD_1_Init is not called before this function, the
                                        (1158) ;    bargraph will not be drawn properly.
                                        (1159) ;
                                        (1160) ; Stack offset constants
                                        (1161) VBG_ROW:        equ -3
                                        (1162) VBG_COL:            equ -4
                                        (1163) VBG_CHAR_HEIGHT:    equ -5
                                        (1164) VBG_SEG_HEIGHT:     equ -6
                                        (1165) 
                                        (1166) _LCD_1_DrawVBG:
                                        (1167)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (1168)     mov   X, SP
                                        (1169)     mov   A, [X+VBG_ROW]
                                        (1170)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
                                        (1171) .VBG_LOOP:
                                        (1172)     push  A
                                        (1173)     index LCD_1_ROW_OFFSET  ; Get row offset
                                        (1174)     add   A,[X+VBG_COL]                ; Add column offset to position
                                        (1175)     call  LCD_1_Control                ; Position Cursor
                                        (1176)     cmp   [X+VBG_SEG_HEIGHT],00h       ; Check for zero segs
                                        (1177)     jnz   .VBG_NZ_SEG
                                        (1178)     mov   A,' '                        ; Load space character
                                        (1179)     jmp   .VBG_WRITE_CHAR
                                        (1180) .VBG_NZ_SEG:
                                        (1181)     cmp   [X+VBG_SEG_HEIGHT],09h       ; Check for full segment
                                        (1182)     jnc   .VBG_FULL_SEG
                                        (1183)                                        ; Partial segment between 1 and 8
                                        (1184)     mov   A,[X+VBG_SEG_HEIGHT]
                                        (1185)     dec   A
                                        (1186)     mov   [X+VBG_SEG_HEIGHT],00h       ; Zero segment height
                                        (1187)     jmp   .VBG_WRITE_CHAR
                                        (1188) 
                                        (1189) .VBG_FULL_SEG:                          ; Bargaph
                                        (1190)     sub   [X+VBG_SEG_HEIGHT],08h       ; Subtract full segment
                                        (1191)     mov   A,07h                        ; Load full segment
                                        (1192) 
                                        (1193) .VBG_WRITE_CHAR:                        ; Write character to display
                                        (1194)     call  LCD_1_WriteData              ; Write value
                                        (1195)     pop   A
                                        (1196)     dec   A
                                        (1197)     dec   [X+VBG_CHAR_HEIGHT]
                                        (1198)     jnz   .VBG_LOOP
                                        (1199)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (1200)     ret
                                        (1201) .ENDSECTION
                                        (1202) 
                                        (1203) .SECTION
                                        (1204) ;-----------------------------------------------------------------------------
                                        (1205) ;  FUNCTION NAME: LCD_1_InitVBG
                                        (1206) ;
                                        (1207) ;  DESCRIPTION:
                                        (1208) ;     Initialize the vertical bargraph characters.
                                        (1209) ;
                                        (1210) ;-----------------------------------------------------------------------------
                                        (1211) ;
                                        (1212) ;  ARGUMENTS:  none
                                        (1213) ;
                                        (1214) ;  RETURNS:  none
                                        (1215) ;
                                        (1216) ;  SIDE EFFECTS:
                                        (1217) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1218) ;    Only one type of bargraph (horizontal or vertical) may be used
                                        (1219) ;    at a time since they each require their own set of characters.
                                        (1220) ;
                                        (1221) ;  SIDE EFFECTS:
                                        (1222) ;    The A and X registers may be modified by this or future implementations
                                        (1223) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1224) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1225) ;    responsibility to preserve their values across calls to fastcall16 
                                        (1226) ;    functions.
                                        (1227) ;          
                                        (1228) ;    Currently only the page pointer registers listed below are modified: 
                                        (1229) ;          CUR_PP
                                        (1230) ;
                                        (1231) ; Stack offset constants
                                        (1232) VBGDATA_CTR:      equ    00h           ; Char data count stack offset
                                        (1233) VBG_BYTES:        equ    01h           ; Byte counter stack offset
                                        (1234) 
                                        (1235)  LCD_1_InitVBG:
                                        (1236) _LCD_1_InitVBG:
                                        (1237)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (1238)     mov   X,SP                         ; Get location of stack
                                        (1239)     push  A                            ; Create 2 locations
                                        (1240)     push  A
                                        (1241) 
                                        (1242)     mov   A,LCD_1_CG_RAM_OFFSET              ; Setup pointer
                                        (1243)     call  LCD_1_Control                ; Position the CG pointer
                                        (1244)     mov   [X+VBGDATA_CTR],01h          ; Reset data counter
                                        (1245) 
                                        (1246)  .VBG_Loop1:                            ; loop once for each 8 characters
                                        (1247)     mov   [X+VBG_BYTES],08h            ; Load cycle pointer
                                        (1248)  .VBG_Loop2:                            ; Loop once for each line in character (8 times)
                                        (1249)     mov   A,[X+VBGDATA_CTR]
                                        (1250)     cmp   A,[X+VBG_BYTES]
                                        (1251)     jnc   .VBG_SOLID
                                        (1252)     mov   A,00h                        ; Empty line
                                        (1253)     jmp   .VBG_Load                     ; Jump to load the bargraph
                                        (1254) .VBG_SOLID:
                                        (1255)     mov   A,FFh                        ; Load solid line
                                        (1256) .VBG_Load:
                                        (1257)     call  LCD_1_WriteData              ; character data
                                        (1258)     dec   [X+VBG_BYTES]                ; Dec byte counter
                                        (1259)     jnz   .VBG_Loop2                    ; End Loop 2
                                        (1260)     inc   [X+VBGDATA_CTR]
                                        (1261)     cmp   [X+VBGDATA_CTR],09h
                                        (1262)     jnz   .VBG_Loop1                    ; End Loop1
                                        (1263) 
                                        (1264)     pop  A
                                        (1265)     pop  A
                                        (1266)     mov  A,LCD_1_DISP_ON                    ; Turn on display, don't really
                                        (1267)     call LCD_1_Control                 ; need this.
                                        (1268)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (1269)     ret
                                        (1270) .ENDSECTION
                                        (1271) 
                                        (1272) ;-----------------------------------------------------------------------------
                                        (1273) ;  FUNCTION NAME: LCD_1_InitBG
                                        (1274) ;
                                        (1275) ;  DESCRIPTION:
                                        (1276) ;     Initialize horizontal bargraph characters
                                        (1277) ;
                                        (1278) ;-----------------------------------------------------------------------------
                                        (1279) ;
                                        (1280) ;  ARGUMENTS:
                                        (1281) ;     A = type  0 = full                   |||||||||........
                                        (1282) ;               1 = single vertical line   ..........|......
                                        (1283) ;
                                        (1284) ;  RETURNS:
                                        (1285) ;
                                        (1286) ;  SIDE EFFECTS:
                                        (1287) ;    The A and X registers may be modified by this or future implementations
                                        (1288) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (1289) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (1290) ;    responsibility to preserve their values across calls to fastcall16 
                                        (1291) ;    functions.
                                        (1292) ;          
                                        (1293) ;    Currently only the page pointer registers listed below are modified: 
                                        (1294) ;          CUR_PP
                                        (1295) ;
                                        (1296) ;    Only one type of bargraph (horizontal or vertical) may be used
                                        (1297) ;    at a time since they each require their own set of characters.
                                        (1298) ;
                                        (1299) ;  THEORY of OPERATION or PROCEDURE:
                                        (1300) ;    This function writes to the LCD character RAM to generate 8 custom
                                        (1301) ;    characters used to generated one of two horizontal bargraphs.
                                        (1302) ;
                                        (1303) .LITERAL
                                        (1304)  LCD_1_BG_TYPE1:: ; ....., |...., ||..., |||.., ||||., |||||, |||||
                                        (1305)      DB    00h, 10h, 18h, 1Ch, 1Eh, 1Fh, 1Fh
                                        (1306)  LCD_1_BG_TYPE2:: ; ....., |...., .|..., ..|.., ...|., ....|, .....
                                        (1307)     DB  00h, 10h, 08h, 04h, 02h, 01h, 00h
                                        (1308) .ENDLITERAL
                                        (1309) 
                                        (1310) .SECTION
                                        (1311) ; Stack offset constants
                                        (1312) BGDATA_PTR:   equ    00h               ; Stack offsets
                                        (1313) BGCHARS:      equ    01h
                                        (1314) BGTYPE:       equ    02h
                                        (1315) 
                                        (1316)  LCD_1_InitBG:
                                        (1317) _LCD_1_InitBG:
                                        (1318)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (1319)     mov   X,SP                         ; Get location of stack
                                        (1320)     add   SP,3
                                        (1321)     mov   [X+BGTYPE],A                 ; Store the bargraph type
                                        (1322) 
                                        (1323)     mov   A,LCD_1_CG_RAM_OFFSET              ; Setup pointer
                                        (1324)     call  LCD_1_Control                ; Position the CG pointer
                                        (1325)     mov   [X+BGDATA_PTR],00h           ; Reset pointer to BG data
                                        (1326) 
                                        (1327)  .BG_Loop1:
                                        (1328)     mov   [X+BGCHARS],08h              ; Load cycle pointer
                                        (1329)  .BG_Loop2:
                                        (1330)     mov   A,[X+BGDATA_PTR]
                                        (1331)     cmp   [X+BGTYPE],00h               ; Check which bargraph
                                        (1332)     jnz   .BG_OTHER
                                        (1333)     index LCD_1_BG_TYPE1
                                        (1334)     jmp   .BG_Load
                                        (1335)  .BG_OTHER:
                                        (1336)     index LCD_1_BG_TYPE2
                                        (1337)  .BG_Load:
                                        (1338)     call  LCD_1_WriteData
                                        (1339)     dec   [X+BGCHARS]                  ; Character builder counter
                                        (1340)     jnz   .BG_Loop2
                                        (1341)     inc   [X+BGDATA_PTR]               ; Advance to next character
                                        (1342)     cmp   [X+BGDATA_PTR],07h
                                        (1343)     jnz   .BG_Loop1
                                        (1344) 
                                        (1345)     add   SP,-3
                                        (1346)     mov   A,LCD_1_DISP_ON
                                        (1347)     call  LCD_1_Control
                                        (1348)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (1349)     ret
                                        (1350) .ENDSECTION
                                        (1351) 
                                        (1352) ENDIF
                                        (1353) 
                                        (1354) ; End of File LCD_1.asm
FILE: lib\ezi2cs_1int.asm               (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: EzI2Cs_1INT.asm
                                        (0004) ;;  Version: 2.00, Updated on 2013/5/19 at 10:43:36
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: I2CFXM (Slave) Interrupt Service Routine
                                        (0008) ;;  
                                        (0009) ;;-----------------------------------------------------------------------------
                                        (0010) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0011) ;;*****************************************************************************
                                        (0012) ;;*****************************************************************************
                                        (0013) include "EzI2Cs_1.inc"
                                        (0014) include "m8c.inc"
                                        (0015) include "memory.inc"
                                        (0016) 
                                        (0017) 
                                        (0018) 
                                        (0019) 
                                        (0020) ;-----------------------------------------------
                                        (0021) ;  Global Symbols
                                        (0022) ;-----------------------------------------------
                                        (0023) 
                                        (0024) export    EzI2Cs_1_varPage      
                                        (0025) export   _EzI2Cs_1_varPage      
                                        (0026) 
                                        (0027) export    EzI2Cs_1_bState  
                                        (0028) export   _EzI2Cs_1_bState
                                        (0029) 
                                        (0030) export    EzI2Cs_1_bRAM_RWoffset
                                        (0031) export   _EzI2Cs_1_bRAM_RWoffset
                                        (0032) 
                                        (0033) export    EzI2Cs_1_bRAM_RWcntr
                                        (0034) export   _EzI2Cs_1_bRAM_RWcntr
                                        (0035) 
                                        (0036) export   _EzI2Cs_1_pRAM_Buf_Addr_LSB
                                        (0037) export    EzI2Cs_1_pRAM_Buf_Addr_LSB
                                        (0038) 
                                        (0039) IF (SYSTEM_LARGE_MEMORY_MODEL)
                                        (0040) export   _EzI2Cs_1_pRAM_Buf_Addr_MSB
                                        (0041) export    EzI2Cs_1_pRAM_Buf_Addr_MSB
                                        (0042) ENDIF
                                        (0043) 
                                        (0044) export   _EzI2Cs_1_bRAM_Buf_Size                                
                                        (0045) export    EzI2Cs_1_bRAM_Buf_Size    
                                        (0046) 
                                        (0047) export   _EzI2Cs_1_bRAM_Buf_WSize               
                                        (0048) export    EzI2Cs_1_bRAM_Buf_WSize  
                                        (0049) 
                                        (0050) IF (EzI2Cs_1_ROM_ENABLE)
                                        (0051) export    EzI2Cs_1_bROM_RWoffset
                                        (0052) export   _EzI2Cs_1_bROM_RWoffset
                                        (0053) 
                                        (0054) export    EzI2Cs_1_bROM_RWcntr   
                                        (0055) export   _EzI2Cs_1_bROM_RWcntr   
                                        (0056) 
                                        (0057) export   _EzI2Cs_1_pROM_Buf_Addr_LSB
                                        (0058) export    EzI2Cs_1_pROM_Buf_Addr_LSB
                                        (0059) export   _EzI2Cs_1_pROM_Buf_Addr_MSB
                                        (0060) export    EzI2Cs_1_pROM_Buf_Addr_MSB
                                        (0061) 
                                        (0062) export   _EzI2Cs_1_bROM_Buf_Size                           
                                        (0063) export    EzI2Cs_1_bROM_Buf_Size
                                        (0064) 
                                        (0065) ENDIF
                                        (0066) 
                                        (0067) export    EzI2Cs_1_bBusy_Flag  
                                        (0068) export   _EzI2Cs_1_bBusy_Flag
                                        (0069) 
                                        (0070) AREA InterruptRAM (RAM, REL, CON)
                                        (0071) 
                                        (0072) ;-----------------------------------------------
                                        (0073) ; Variable Allocation
                                        (0074) ;-----------------------------------------------
                                        (0075) 
                                        (0076) 
                                        (0077) ;; Exported variables
                                        (0078)  _EzI2Cs_1_varPage:                                ; This points to the variable page
                                        (0079)   EzI2Cs_1_varPage:          
                                        (0080) 
                                        (0081)  _EzI2Cs_1_bState:
                                        (0082)   EzI2Cs_1_bState:                           blk 1
                                        (0083) 
                                        (0084) ;; RAM space variables
                                        (0085)  _EzI2Cs_1_bRAM_RWoffset:                          ; RAM address counter.  This is reset each time
                                        (0086)   EzI2Cs_1_bRAM_RWoffset:                    blk 1 ; a read or write is initiated.
                                        (0087) 
                                        (0088)  _EzI2Cs_1_bRAM_RWcntr:                            ; RAM Read/Write counter.  Keeps track of offset 
                                        (0089)   EzI2Cs_1_bRAM_RWcntr:                      blk 1 ; during a read or write operation.  Reset to
                                        (0090)                                                       ; _bRAM_RWoffset at start of R/W command.
                                        (0091) 
                                        (0092) IF (SYSTEM_LARGE_MEMORY_MODEL)
                                        (0093)  _EzI2Cs_1_pRAM_Buf_Addr_MSB:                      ; Base address (MSB) to RAM buffer.  
                                        (0094)   EzI2Cs_1_pRAM_Buf_Addr_MSB:                blk 1 ; 
                                        (0095) ENDIF
                                        (0096) 
                                        (0097)  _EzI2Cs_1_pRAM_Buf_Addr_LSB:                      ; Base address (LSB) to RAM buffer.  
                                        (0098)   EzI2Cs_1_pRAM_Buf_Addr_LSB:                blk 1 ; 
                                        (0099) 
                                        (0100)  _EzI2Cs_1_bRAM_Buf_Size:                          ; Size of RAM buffer.   
                                        (0101)   EzI2Cs_1_bRAM_Buf_Size:                    blk 1 ; 
                                        (0102) 
                                        (0103)  _EzI2Cs_1_bRAM_Buf_WSize:                         ; Portion of the RAM buffer size that is writable.
                                        (0104)   EzI2Cs_1_bRAM_Buf_WSize:                   blk 1 ; 
                                        (0105) 
                                        (0106) ;; ROM space variables
                                        (0107) IF (EzI2Cs_1_ROM_ENABLE)
                                        (0108)  _EzI2Cs_1_bROM_RWoffset:                          ; ROM address counter.  This is reset each time
                                        (0109)   EzI2Cs_1_bROM_RWoffset:                    blk 1 ; a read is initiated
                                        (0110) 
                                        (0111)  _EzI2Cs_1_bROM_RWcntr:                            ; ROM read counter. Keeps track of offset 
                                        (0112)   EzI2Cs_1_bROM_RWcntr:                      blk 1 ; during a read operation.  Reset to
                                        (0113)                                                       ; _bRAM_RWoffset at start of command.
                                        (0114) 
                                        (0115)  _EzI2Cs_1_pROM_Buf_Addr_MSB:                      ; ROM address (MSB) counter. (Relative to buffer)  This
                                        (0116)   EzI2Cs_1_pROM_Buf_Addr_MSB:                blk 1 ; counter is reset each time a read is initiated.
                                        (0117) 
                                        (0118)  _EzI2Cs_1_pROM_Buf_Addr_LSB:                      ; ROM address (MSB) counter. (Relative to buffer)  This
                                        (0119)   EzI2Cs_1_pROM_Buf_Addr_LSB:                blk 1 ; counter is reset each time a read is initiated.
                                        (0120) 
                                        (0121)  _EzI2Cs_1_bROM_Buf_Size:                          ; Size of RAM buffer.                            
                                        (0122)   EzI2Cs_1_bROM_Buf_Size:                    blk 1 ; 
                                        (0123) 
                                        (0124) ENDIF
                                        (0125) 
                                        (0126) IF (EzI2Cs_1_AUTO_ADDR_CHECK^1)
                                        (0127) IF (EzI2Cs_1_DYNAMIC_ADDR) 
                                        (0128) 
                                        (0129) export    EzI2Cs_1_bAddr
                                        (0130) export   _EzI2Cs_1_bAddr 
                                        (0131) 
                                        (0132)  _EzI2Cs_1_bAddr:
                                        (0133)   EzI2Cs_1_bAddr:                            blk 1
                                        (0134) ENDIF
                                        (0135) ENDIF
                                        (0136) 
                                        (0137)  _EzI2Cs_1_bBusy_Flag:
                                        (0138)   EzI2Cs_1_bBusy_Flag:                       blk 1
                                        (0139) 
                                        (0140) ;-----------------------------------------------
                                        (0141) ;  EQUATES and TABLES
                                        (0142) ;-----------------------------------------------
                                        (0143) 
                                        (0144) ;; Bit definitions for EzI2Cs_1_bState
                                        (0145) STATE_IDLE:         equ  0x00      ; Wait for Correct Address
                                        (0146) STATE_WR_RAM_ADDR:  equ  0x02      ; Wait for Secondary address on write
                                        (0147) STATE_WR_RAM:       equ  0x04      ; Write RAM Data
                                        (0148) STATE_RD_RAM:       equ  0x06      ; Read RAM Data
                                        (0149) 
                                        (0150) STATE_WR_ROM_ADDR:  equ  0x08      ; Wait for Secondary address on write
                                        (0151) STATE_RD_ROM:       equ  0x0A      ; Read ROM Data
                                        (0152) 
                                        (0153) STATE_WR_ROM:       equ  0x0C      ; Write ROM (Not supported at this time)
                                        (0154) STATE_RESET:        equ  0x0E      ; Reset state machine
                                        (0155) 
                                        (0156) STATE_MASK:         equ  0x0E
                                        (0157) STATE_MASK2:        equ  0x0F      ; State Mask
                                        (0158) 
                                        (0159) ALT_MODE_FLAG:      equ  0x40      ; Reserved
                                        (0160) 
                                        (0161) 
                                        (0162) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                        (0163) ;---------------------------------------------------
                                        (0164) ; Insert your custom declarations below this banner
                                        (0165) ;---------------------------------------------------
                                        (0166) 
                                        (0167) ;------------------------
                                        (0168) ;  Constant Definitions
                                        (0169) ;------------------------
                                        (0170) 
                                        (0171) 
                                        (0172) ;------------------------
                                        (0173) ; Variable Allocation
                                        (0174) ;------------------------
                                        (0175) 
                                        (0176) 
                                        (0177) ;---------------------------------------------------
                                        (0178) ; Insert your custom declarations above this banner
                                        (0179) ;---------------------------------------------------
                                        (0180) ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0181) 
                                        (0182) 
                                        (0183) 
                                        (0184) 
                                        (0185) AREA UserModules (ROM, REL, CON)
                                        (0186) 
                                        (0187) export _EzI2Cs_1_ISR
                                        (0188) ;;****************************************************
                                        (0189) ;; I2C_ISR  main entry point from vector 60h
                                        (0190) ;;
                                        (0191) ;;****************************************************
                                        (0192) 
                                        (0193)  EzI2Cs_1_ISR:
                                        (0194) _EzI2Cs_1_ISR:
                                        (0195) 
091B: 08       PUSH  A                  (0196)     push A
091C: 10       PUSH  X                  (0197)     push X
091D: 70 3F    AND   F,0x3F             
091F: 71 80    OR    F,0x80             
0921: 5D D3    MOV   A,REG[0xD3]        
0923: 08       PUSH  A                  
0924: 5D D0    MOV   A,REG[0xD0]        
0926: 08       PUSH  A                  
0927: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0198)     
                                        (0199)     ;@PSoC_UserCode_ISR_START@ (Do not change this line.)
                                        (0200)     ;---------------------------------------------------
                                        (0201)     ; Insert your custom code below this banner
                                        (0202)     ;---------------------------------------------------
                                        (0203) 
                                        (0204)     ;---------------------------------------------------
                                        (0205)     ; Insert your custom code above this banner
                                        (0206)     ;---------------------------------------------------
                                        (0207)     ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0208) 
                                        (0209) ;; The folling conditional code is only valid when using the
                                        (0210) ;; large memory model.
                                        (0211) IF (SYSTEM_LARGE_MEMORY_MODEL)
                                        (0212)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_2              ; Set Page Mode
                                        (0213)    REG_PRESERVE IDX_PP                             ; Save Index Page Pointer
                                        (0214)    REG_PRESERVE CUR_PP                             ; Save Current Page Pointer
                                        (0215)    RAM_SETPAGE_CUR  >EzI2Cs_1_varPage      ; Set the current page mode Pointer
092A: 51 08    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+8](0216)    mov   A, [EzI2Cs_1_pRAM_Buf_Addr_MSB]   ; Set Index page mode pointer
092C: 60 D3    MOV   REG[0xD3],A        
                                        (0217)    RAM_SETPAGE_IDX A
                                        (0218) ENDIF
                                        (0219) 
092E: 2E 05 80 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x80(0220)     or   [EzI2Cs_1_bState],EzI2Cs_1_ANY_ACTIVITY                     ; Set Activity flag
0931: 49 D7 08 TST   REG[0xD7],0x8      (0221)     tst  reg[EzI2Cs_1_SCR_REG],EzI2Cs_1_SCR_ADDRESS                  ; Check for address
0934: A0 09    JZ    0x093E             (0222)     jz   .I2C_CHECK_STOP                                             ; Go to check for Stop condition if no Address
0936: 26 05 F0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0xF0(0223)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bits.                       
0939: 2E 05 00 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x0(0224)     or   [EzI2Cs_1_bState],STATE_IDLE                                ; Address flag set, change to IDLE state
093C: 80 08    JMP   0x0945             (0225)     jmp  .I2C_DO_STATE_MACHINE
                                        (0226) .I2C_CHECK_STOP:
                                        (0227)     ; Check for Stop condition here.  If a stop condition
                                        (0228)     ; exists, reset state machine to idle.
093E: 49 D7 20 TST   REG[0xD7],0x20     (0229)     tst reg[EzI2Cs_1_SCR_REG],EzI2Cs_1_SCR_STOP_STATUS               ; Check for Stop condition
0941: A0 03    JZ    0x0945             (0230)     jz .I2C_DO_STATE_MACHINE                                            ; No Stop condition - do I2C state mashine
                                        (0231)     ; Following line was commented due to CDT#60202.
                                        (0232)     ; The stop bit is cleared by SetEzI2Cs_1_SCR macro, so the functionality related to EzI2Cs_1_bBusy_Flag is preserved.
                                        (0233)     ; and reg[EzI2Cs_1_SCR_REG],~EzI2Cs_1_SCR_STOP_STATUS            ; Clear Stop bit
0943: 80 A8    JMP   0x09EC             (0234)     jmp  I2C_STATE_RESET
                                        (0235) .I2C_DO_STATE_MACHINE:
0945: 51 05    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5](0236)     mov  A,[EzI2Cs_1_bState]    ; Get State
0947: 21 0E    AND   A,0xE              (0237)     and  A,STATE_MASK                   ; Mask off invalid states
0949: E0 01    JACC  0x094B             (0238)     jacc I2C_STATE_JUMP_TABLE
                                        (0239) 
                                        (0240) I2C_STATE_JUMP_TABLE:
094B: 80 11    JMP   0x095D             (0241)     jmp  I2C_STATE_IDLE                 ; Idle state
094D: 80 67    JMP   0x09B5             (0242)     jmp  I2C_STATE_WR_RAM_ADDR              ; Wait for Address write state
094F: 80 79    JMP   0x09C9             (0243)     jmp  I2C_STATE_WR_RAM               ; 
0951: 80 47    JMP   0x0999             (0244)     jmp  I2C_STATE_RD_RAM
                                        (0245) IF (EzI2Cs_1_ROM_ENABLE)        ; Only valid if ROM enabled
                                        (0246)     jmp  I2C_STATE_WR_ROM_ADDR
                                        (0247)     jmp  I2C_STATE_RD_ROM
                                        (0248)     jmp  I2C_STATE_WR_ROM
                                        (0249) ELSE
0953: 80 98    JMP   0x09EC             (0250)     jmp  I2C_STATE_RESET
0955: 80 96    JMP   0x09EC             (0251)     jmp  I2C_STATE_RESET
0957: 80 94    JMP   0x09EC             (0252)     jmp  I2C_STATE_RESET
                                        (0253) ENDIF
0959: 80 92    JMP   0x09EC             (0254)     jmp  I2C_STATE_RESET
                                        (0255) 
095B: 80 99    JMP   0x09F5             (0256)     jmp  EzI2Cs_1_ISR_END
                                        (0257) 
                                        (0258) 
                                        (0259)     ;            *** I2C Idle state ***
                                        (0260)     ;
                                        (0261)     ;   Sit idle until a start with address is issued.
                                        (0262)     ;   Check to see if there is an address match
                                        (0263)     ;     If address match, ACK the bus and determine next state
                                        (0264)     ;     Else NAK the transfer and return to idle state.
                                        (0265)     ;   Also check stop for condition.IF (EzI2Cs_1_ROM_ENABLE)  ;; Enable only if alternate ROM Address is Enabled
                                        (0266)     ;
                                        (0267) I2C_STATE_IDLE:                 ; Idle state
                                        (0268) 
                                        (0269) IF (EzI2Cs_1_AUTO_ADDR_CHECK^1)   ;; for CY8C28X45 chip: skip address comparison and NACK sending stage-hardware will do this for us  if AutoAddressCompare feature is enabled.
                                        (0270)                                           ;; The code in this pre-compiler directive will be executed for all chips except CY8C28X45.
                                        (0271)  IF (EzI2Cs_1_CY8C22x45)
                                        (0272)    M8C_SetBank1
                                        (0273)    tst   reg[EzI2Cs_1_ADDR_REG], EzI2Cs_1_HW_ADDR_EN
                                        (0274)    jnz   .HwAddrRecEnabled
                                        (0275)    M8C_SetBank0
                                        (0276)  ENDIF										  
                                        (0277) IF (EzI2Cs_1_DYNAMIC_ADDR)  ;; DYNAMIC ADDRESS
                                        (0278)     mov  A,reg[EzI2Cs_1_DR_REG]                                      ; Get transmitted address
                                        (0279)     and  A,EzI2Cs_1_ADDR_MASK                                        ; Mask off alt address bit and R/W bit
                                        (0280)     cmp  A,[EzI2Cs_1_bAddr]                                          ; Check for proper Address
                                        (0281)     jz   .CHK_ADDR_MODE 
                                        (0282)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_NAK )                             ; NAK Address 
                                        (0283)     jmp  EzI2Cs_1_ISR_END                                            ; Not valid Address, leave
                                        (0284) 
                                        (0285) ELSE    ;; STATIC ADDRESS
095D: 5D D8    MOV   A,REG[0xD8]        (0286)     mov  A,reg[EzI2Cs_1_DR_REG]                                      ; Get transmitted address
095F: 21 FE    AND   A,0xFE             (0287)     and  A,EzI2Cs_1_ADDR_MASK                                        ; Mask off alt address bit and R/W bit
0961: 39 3C    CMP   A,0x3C             (0288)     cmp  A,EzI2Cs_1_SLAVE_ADDR                                       ; Check for proper Address
0963: A0 06    JZ    0x096A             (0289)     jz   .CHK_ADDR_MODE 
0965: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0290)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_NAK )                             ; NAK Address 
0968: 80 8C    JMP   0x09F5             (0291)     jmp  EzI2Cs_1_ISR_END                                            ; Not valid Address, leave
                                        (0292) ENDIF
                                        (0293)  IF (EzI2Cs_1_CY8C22x45)
                                        (0294) .HwAddrRecEnabled:
                                        (0295)    M8C_SetBank0
                                        (0296)  ENDIF
                                        (0297) ENDIF
                                        (0298) 
                                        (0299) .CHK_ADDR_MODE:   ; A proper address has been detected, now determine what mode, R/W alt_addr?? 
                                        (0300) IF (EzI2Cs_1_ROM_ENABLE)  ;; Enable only if alternate ROM Address is Enabled
                                        (0301)     tst  reg[EzI2Cs_1_DR_REG],EzI2Cs_1_ALT_ADDR_BIT                  ; Check for Alt address
                                        (0302)     jnz  SERVICE_ROM_ADDR
                                        (0303) ENDIF
                                        (0304) 
                                        (0305) .STANDARD_ADDR:
096A: 49 D8 01 TST   REG[0xD8],0x1      (0306)     tst  reg[EzI2Cs_1_DR_REG],EzI2Cs_1_RD_FLAG                       ; Check for a Read operation
096D: B0 0F    JNZ   0x097D             (0307)     jnz  .PREPARE_FOR_RAM_READ
                                        (0308) 
096F: 55 0C 02 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+12],0x2(0309)     mov [EzI2Cs_1_bBusy_Flag], EzI2Cs_1_I2C_BUSY_RAM_WRITE           ; Write transaction in process - set Busy flag to WRITE
                                        (0310) 
                                        (0311)     ; Prepare for RAM Write Address operation
0972: 26 05 F0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0xF0(0312)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
0975: 2E 05 02 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x2(0313)     or   [EzI2Cs_1_bState],STATE_WR_RAM_ADDR                         ; Set state machine to do RAM Write
0978: 62 D7 10 MOV   REG[0xD7],0x10     
                                        (0314)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_ACK )                             ; ACK Address 
097B: 80 79    JMP   0x09F5             (0315)     jmp  EzI2Cs_1_ISR_END                                     ; Base address to RAM buffer.  
                                        (0316) 
                                        (0317) .PREPARE_FOR_RAM_READ:
097D: 55 0C 01 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+12],0x1(0318)     mov [EzI2Cs_1_bBusy_Flag], EzI2Cs_1_I2C_BUSY_RAM_READ            ; Possible read transaction in process - set Busy flag to READ
                                        (0319) 
0980: 26 05 F0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0xF0(0320)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
0983: 2E 05 06 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x6(0321)     or   [EzI2Cs_1_bState],STATE_RD_RAM                              ; Set state machine to do RAM Read 
0986: 5F 07 06 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7],[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+6](0322)     mov  [EzI2Cs_1_bRAM_RWcntr],[EzI2Cs_1_bRAM_RWoffset]             ; Reset address counter to start of Offset
0989: 51 09    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+9](0323)     mov  A,[EzI2Cs_1_pRAM_Buf_Addr_LSB]                              ; Get base address
098B: 02 07    ADD   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0324)     add  A,[EzI2Cs_1_bRAM_RWcntr]                                    ; Set Offset and add to base address      
098D: 5C       MOV   X,A                (0325)     mov  X,A                                                         ; Put offset in X
098E: 52 00    MOV   A,[X+0]            (0326)     mov  A,[X]                                                       ; Get first byte to transmit
0990: 60 D8    MOV   REG[0xD8],A        (0327)     mov  reg[EzI2Cs_1_DR_REG],A                               ; Base address to RAM buffer.  
0992: 76 07    INC   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0328)     inc  [EzI2Cs_1_bRAM_RWcntr]                                      ; Increment RAM buffer counter to next location.
0994: 62 D7 14 MOV   REG[0xD7],0x14     
                                        (0329) 
                                        (0330)                                                                      ; ACK command and transmit first byte.
                                        (0331)     SetEzI2Cs_1_SCR (EzI2Cs_1_SCR_ACK|EzI2Cs_1_SCR_TRANSMIT)   
0997: 80 5D    JMP   0x09F5             (0332)     jmp  EzI2Cs_1_ISR_END
                                        (0333) 
                                        (0334)     ;            *** I2C Read RAM state ***
                                        (0335)     ;
                                        (0336) I2C_STATE_RD_RAM:
                                        (0337)     ;@PSoC_UserCode_RAM_RD@ (Do not change this line.)
                                        (0338)     ;---------------------------------------------------
                                        (0339)     ; Insert your custom code below this banner
                                        (0340)     ;---------------------------------------------------
                                        (0341)     
                                        (0342)     ;---------------------------------------------------
                                        (0343)     ; Insert your custom code above this banner
                                        (0344)     ;---------------------------------------------------
                                        (0345)     ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0346)     
0999: 51 0A    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+10](0347)     mov  A,[EzI2Cs_1_bRAM_Buf_Size]
099B: 78       DEC   A                  (0348)     dec  A
099C: 3A 07    CMP   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0349)     cmp  A,[EzI2Cs_1_bRAM_RWcntr]                                    ; Check to see if out of range.
099E: C0 0F    JC    0x09AE             (0350)     jc   .I2C_TRANSMIT_DATA  ; WARNING!! Bogas data will be transmitted if out of range.   
                                        (0351) 
09A0: 51 09    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+9](0352)     mov  A,[EzI2Cs_1_pRAM_Buf_Addr_LSB]                              ; Get base address
09A2: 02 07    ADD   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0353)     add  A,[EzI2Cs_1_bRAM_RWcntr]                                    ; Set Offset and add to base address      
09A4: 5C       MOV   X,A                (0354)     mov  X,A                                                         ; Put offset in X
09A5: 52 00    MOV   A,[X+0]            (0355)     mov  A,[X]                                                       ; Get first byte to transmit
09A7: 60 D8    MOV   REG[0xD8],A        (0356)     mov  reg[EzI2Cs_1_DR_REG],A                                      ; Write data to transmit register
09A9: 76 07    INC   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0357)     inc  [EzI2Cs_1_bRAM_RWcntr]                                      ; Increment RAM buffer counter to next location.
09AB: 2E 05 20 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x20(0358)     or   [EzI2Cs_1_bState],EzI2Cs_1_READ_ACTIVITY                    ; Set Read Activity flag
                                        (0359) 
                                        (0360) 
                                        (0361) .I2C_TRANSMIT_DATA:     
09AE: 60 D8    MOV   REG[0xD8],A        (0362)     mov  reg[EzI2Cs_1_DR_REG],A                                      ; Write data to transmit register
09B0: 62 D7 04 MOV   REG[0xD7],0x4      
                                        (0363)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_TRANSMIT )                        ; ACK command and transmit first byte. 
09B3: 80 41    JMP   0x09F5             (0364)     jmp  EzI2Cs_1_ISR_END
                                        (0365) 
                                        (0366) 
                                        (0367)     ;            *** I2C Write RAM Address state ***
                                        (0368)     ;
                                        (0369)     ;  During this state, the RAM address offset is set.
                                        (0370) I2C_STATE_WR_RAM_ADDR:              ; Wait for Address write state
09B5: 5D D8    MOV   A,REG[0xD8]        (0371)     mov  A,reg[EzI2Cs_1_DR_REG]                                      ; Get transmitted Address offset
09B7: 3A 0A    CMP   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+10](0372)     cmp  A,[EzI2Cs_1_bRAM_Buf_Size]                                  ; Check if out of range.
09B9: D0 2D    JNC   0x09E7             (0373)     jnc  I2C_NAK_DATA                                                ; If out of range NAK address
09BB: A0 2B    JZ    0x09E7             (0374)     jz   I2C_NAK_DATA
                                        (0375) 
                                        (0376)     ; Address in range
09BD: 53 07    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7],A(0377)     mov  [EzI2Cs_1_bRAM_RWcntr],A                                    ; Reset address counter with new value
09BF: 53 06    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+6],A(0378)     mov  [EzI2Cs_1_bRAM_RWoffset],A                                  ; Set offset with new value.
09C1: 26 05 F0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0xF0(0379)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
09C4: 2E 05 04 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x4(0380)     or   [EzI2Cs_1_bState],STATE_WR_RAM                              ; Set state machine to do RAM Write
09C7: 80 1A    JMP   0x09E2             (0381)     jmp  I2C_ACK_DATA                         ; ACK the data
                                        (0382) 
                                        (0383) 
                                        (0384)     ;            *** I2C Write RAM state
                                        (0385) I2C_STATE_WR_RAM:  
                                        (0386)     ;@PSoC_UserCode_RAM_WR@ (Do not change this line.)
                                        (0387)     ;---------------------------------------------------
                                        (0388)     ; Insert your custom code below this banner
                                        (0389)     ;---------------------------------------------------
                                        (0390)     
                                        (0391)     ;---------------------------------------------------
                                        (0392)     ; Insert your custom code above this banner
                                        (0393)     ;---------------------------------------------------
                                        (0394)     ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0395)     
09C9: 51 0B    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+11](0396)     mov  A,[EzI2Cs_1_bRAM_Buf_WSize]                                 ; Get buffer size to make sure we
09CB: A0 1B    JZ    0x09E7             (0397)     jz   I2C_NAK_DATA                                                ; If RAM WSize is zero, do not allow write.
09CD: 78       DEC   A                  (0398)     dec  A                                                           ; are in a valid area.
09CE: 3A 07    CMP   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0399)     cmp  A,[EzI2Cs_1_bRAM_RWcntr]                                    ; Check to see if out of range.
09D0: C0 16    JC    0x09E7             (0400)     jc   I2C_NAK_DATA                                                ; If out of range NAK address
                                        (0401) 
09D2: 51 09    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+9](0402)     mov  A,[EzI2Cs_1_pRAM_Buf_Addr_LSB]                              ; Get base address
09D4: 02 07    ADD   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0403)     add  A,[EzI2Cs_1_bRAM_RWcntr]                                    ; Set Offset and add to base address      
09D6: 5C       MOV   X,A                (0404)     mov  X,A                                                         ; Put offset in X
                                        (0405) 
09D7: 5D D8    MOV   A,REG[0xD8]        (0406)     mov  A,reg[EzI2Cs_1_DR_REG]                                      ; Read data to be written
09D9: 54 00    MOV   [X+0],A            (0407)     mov  [X],A                                                       ; Store data in Buffer
09DB: 2E 05 10 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x10(0408)     or   [EzI2Cs_1_bState],EzI2Cs_1_WRITE_ACTIVITY                   ; Set Write Activity flag
09DE: 76 07    INC   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+7](0409)     inc  [EzI2Cs_1_bRAM_RWcntr]                                      ; Advance pointer to next location
09E0: 80 01    JMP   0x09E2             (0410)     jmp  I2C_ACK_DATA                         ; ACK the data
09E2: 62 D7 10 MOV   REG[0xD7],0x10     
                                        (0411) 
                                        (0412)     
                                        (0413)     
                                        (0414) IF (EzI2Cs_1_ROM_ENABLE)  ;; Enable only if alternate ROM Address is Enabled
                                        (0415) 
                                        (0416) SERVICE_ROM_ADDR:  ; At this time only ROM Read is supported.  
                                        (0417)     tst  reg[EzI2Cs_1_DR_REG],EzI2Cs_1_RD_FLAG                       ; Check for a Read operation
                                        (0418)     jnz  PREPARE_FOR_ROM_READ
                                        (0419) 
                                        (0420)     mov [EzI2Cs_1_bBusy_Flag], EzI2Cs_1_I2C_BUSY_ROM_WRITE           ; Write transaction in process - set Busy flag to WRITE
                                        (0421)     
                                        (0422)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
                                        (0423)     or   [EzI2Cs_1_bState],STATE_WR_ROM_ADDR                         ; Set state machine to do ROM ADDR Write
                                        (0424)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_ACK )                             ; ACK Address 
                                        (0425)     jmp  EzI2Cs_1_ISR_END                                    ; Base address to RAM buffer.  
                                        (0426) 
                                        (0427)     ; Prepare for Write ROM Address.              
                                        (0428) I2C_STATE_WR_ROM_ADDR:
                                        (0429)     mov  A,reg[EzI2Cs_1_DR_REG]                                      ; Get transmitted Address offset
                                        (0430)     cmp  A,[EzI2Cs_1_bROM_Buf_Size]                                  ; Check if out of range.
                                        (0431)     jnc  I2C_NAK_DATA                                                ; If out of range NAK address
                                        (0432)     jz   I2C_NAK_DATA
                                        (0433) 
                                        (0434)     mov  [EzI2Cs_1_bROM_RWcntr],A                                    ; Reset address counter with new value
                                        (0435)     mov  [EzI2Cs_1_bROM_RWoffset],A                                  ; Set offset with new value.
                                        (0436)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
                                        (0437)     or   [EzI2Cs_1_bState],STATE_WR_ROM                              ; Set state machine to do ROM Write
                                        (0438)     jmp  I2C_ACK_DATA
                                        (0439) 
                                        (0440) I2C_STATE_WR_ROM:  // Flash command interpreter
                                        (0441)    ;@PSoC_UserCode_ROM_WR@ (Do not change this line.)
                                        (0442)    ;---------------------------------------------------
                                        (0443)    ; Insert your custom code below this banner
                                        (0444)    ;---------------------------------------------------
                                        (0445) 
                                        (0446)    ;---------------------------------------------------
                                        (0447)    ; Insert your custom code above this banner
                                        (0448)    ;---------------------------------------------------
                                        (0449)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0450) 
                                        (0451)     jnc  I2C_NAK_DATA                                                ; Write to ROM not supported.
                                        (0452) 
                                        (0453) PREPARE_FOR_ROM_READ:
                                        (0454)     mov [EzI2Cs_1_bBusy_Flag], EzI2Cs_1_I2C_BUSY_ROM_READ            ; Possible read transaction in process - set Busy flag to READ
                                        (0455)     
                                        (0456)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
                                        (0457)     or   [EzI2Cs_1_bState],STATE_RD_ROM                              ; Set state machine to do ROM Read 
                                        (0458)     mov  [EzI2Cs_1_bROM_RWcntr],[EzI2Cs_1_bROM_RWoffset]             ; Reset address counter to start of Offset
                                        (0459)     mov  X,[EzI2Cs_1_pROM_Buf_Addr_MSB]                              ; Get MSB of ROM address in X
                                        (0460)     mov  A,[EzI2Cs_1_pROM_Buf_Addr_LSB]                              ; Get LSB of ROM base address
                                        (0461)     add  A,[EzI2Cs_1_bROM_RWcntr]                                    ; Set Offset and add to base address      
                                        (0462)     jnc  .GET_ROM_VALUE
                                        (0463)     inc  X    ; Inc the MSB
                                        (0464) .GET_ROM_VALUE:
                                        (0465)     swap A,X  ; Place MSB of ROM address in A, and LSB in X for ROMX
                                        (0466)     romx      ; Get Rom value in A
                                        (0467) 
                                        (0468)     mov  reg[EzI2Cs_1_DR_REG],A                              ; Base address to RAM buffer.  
                                        (0469)     inc  [EzI2Cs_1_bROM_RWcntr]                                      ; Increment RAM buffer counter to next location.
                                        (0470) 
                                        (0471)                                                                      ; ACK command and transmit first byte.
                                        (0472)     SetEzI2Cs_1_SCR  (EzI2Cs_1_SCR_ACK|EzI2Cs_1_SCR_TRANSMIT)   
                                        (0473)     jmp  EzI2Cs_1_ISR_END
                                        (0474) 
                                        (0475) 
                                        (0476) I2C_STATE_RD_ROM:
                                        (0477)     ;@PSoC_UserCode_ROM_RD@ (Do not change this line.)
                                        (0478)     ;---------------------------------------------------
                                        (0479)     ; Insert your custom code below this banner
                                        (0480)     ;---------------------------------------------------
                                        (0481) 
                                        (0482)     ;---------------------------------------------------
                                        (0483)     ; Insert your custom code above this banner
                                        (0484)     ;---------------------------------------------------
                                        (0485)     ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0486) 
                                        (0487)     mov  A,[EzI2Cs_1_bROM_Buf_Size]
                                        (0488)     dec  A
                                        (0489)     cmp  A,[EzI2Cs_1_bROM_RWcntr]                                    ; Check to see if out of range.
                                        (0490)     jc   .I2C_TRANSMIT_ROM_DATA  ; WARNING!! Bogas data will be transmitted if out of range.   
                                        (0491) 
                                        (0492)     mov  X,[EzI2Cs_1_pROM_Buf_Addr_MSB]                              ; Get MSB of ROM address in X
                                        (0493)     mov  A,[EzI2Cs_1_pROM_Buf_Addr_LSB]                              ; Get LSB of ROM base address
                                        (0494)     add  A,[EzI2Cs_1_bROM_RWcntr]                                    ; Set Offset and add to base address      
                                        (0495)     jnc  .GET_ROM_VALUE
                                        (0496)     inc  X    ; Inc the MSB
                                        (0497) .GET_ROM_VALUE:
                                        (0498)     swap A,X  ; Place MSB of ROM address in A, and LSB in X for ROMX
                                        (0499)     romx      ; Get Rom value in A
                                        (0500)     mov  reg[EzI2Cs_1_DR_REG],A                              ; Base address to RAM buffer.  
                                        (0501)     inc  [EzI2Cs_1_bROM_RWcntr]                                      ; Increment RAM buffer counter to next location.
                                        (0502) 
                                        (0503) .I2C_TRANSMIT_ROM_DATA:     
                                        (0504)     mov  reg[EzI2Cs_1_DR_REG],A                                      ; Write data to transmit register
                                        (0505)     SetEzI2Cs_1_SCR  (EzI2Cs_1_SCR_TRANSMIT)                         ; ACK command and transmit first byte. 
                                        (0506)     jmp  EzI2Cs_1_ISR_END
                                        (0507) 
                                        (0508) ENDIF
                                        (0509) 
                                        (0510) ;; Generic handlers
                                        (0511) 
                                        (0512) I2C_ACK_DATA:
                                        (0513)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_ACK )                             ; ACK Data
09E5: 80 0F    JMP   0x09F5             (0514)     jmp  EzI2Cs_1_ISR_END
09E7: 62 D7 00 MOV   REG[0xD7],0x0      
                                        (0515) 
                                        (0516) I2C_NAK_DATA:   ;; NAK data and return  !!WARNING, NOT SURE IF THIS WILL WORK
                                        (0517)     SetEzI2Cs_1_SCR ( EzI2Cs_1_SCR_NAK )                             ;  NAK Data
09EA: 80 0A    JMP   0x09F5             (0518)     jmp  EzI2Cs_1_ISR_END
                                        (0519) 
                                        (0520) I2C_STATE_RESET:
                                        (0521)     ;@PSoC_UserCode_I2C_RST_Start@ (Do not change this line.)
                                        (0522)     ;---------------------------------------------------
                                        (0523)     ; Insert your custom code below this banner
                                        (0524)     ;---------------------------------------------------
                                        (0525) 
                                        (0526)     ;---------------------------------------------------
                                        (0527)     ; Insert your custom code above this banner
                                        (0528)     ;---------------------------------------------------
                                        (0529)     ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0530) 
09EC: 26 05 F0 AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0xF0(0531)     and  [EzI2Cs_1_bState],~STATE_MASK2                              ; Clear State bit.                       
09EF: 2E 05 00 OR    [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x0(0532)     or   [EzI2Cs_1_bState], STATE_IDLE    ; Reset State
09F2: 55 0C 00 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+12],0x0(0533)     mov [EzI2Cs_1_bBusy_Flag],EzI2Cs_1_I2C_FREE                      ; Clear Busy flag
09F5: 18       POP   A                  
09F6: 60 D0    MOV   REG[0xD0],A        
09F8: 18       POP   A                  
09F9: 60 D3    MOV   REG[0xD3],A        
                                        (0534)     ; Reset pointer buffers as well
                                        (0535)     ;@PSoC_UserCode_I2C_RST_End@ (Do not change this line.)
                                        (0536)     ;---------------------------------------------------
                                        (0537)     ; Insert your custom code below this banner
                                        (0538)     ;---------------------------------------------------
                                        (0539) 
                                        (0540)     ;---------------------------------------------------
                                        (0541)     ; Insert your custom code above this banner
                                        (0542)     ;---------------------------------------------------
                                        (0543)     ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0544) 
                                        (0545) EzI2Cs_1_ISR_END:
                                        (0546) 
                                        (0547) ; This conditional code is only used when using the large memory model.
                                        (0548) IF (SYSTEM_LARGE_MEMORY_MODEL)
                                        (0549)    REG_RESTORE CUR_PP           ; Restore Current Page Pointer
                                        (0550)    REG_RESTORE IDX_PP           ; Restore Index Page Pointer
                                        (0551) ENDIF
09FB: 20       POP   X                  (0552)     pop  X
09FC: 18       POP   A                  (0553)     pop  A
                                        (0554) 
09FD: 7E       RETI                     (0555)     reti
FILE: lib\ezi2cs_1.asm                  (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
09FE: 62 D0 00 MOV   REG[0xD0],0x0      (0003) ;;  FILENAME: EzI2Cs_1.asm
0A01: 71 10    OR    F,0x10             
                                        (0004) ;;  Version: 2.00, Updated on 2013/5/19 at 10:43:36
                                        (0005) ;;  Generated by PSoC Designer 5.4.2946
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: EzI2Cs User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API functions
                                        (0013) ;;        returns. For Large Memory Model devices it is also the caller's 
                                        (0014) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                        (0015) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                        (0016) ;;        now, there is no guarantee that will remain the case in future releases.
                                        (0017) ;;-----------------------------------------------------------------------------
                                        (0018) ;;  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0019) ;;*****************************************************************************
                                        (0020) ;;*****************************************************************************
                                        (0021) 
                                        (0022) include "m8c.inc"
                                        (0023) include "memory.inc"
                                        (0024) include "EzI2Cs_1.inc"
                                        (0025) include "PSoCGPIOINT.inc"
                                        (0026) 
                                        (0027) ;-----------------------------------------------
                                        (0028) ; include instance specific register definitions
                                        (0029) ;-----------------------------------------------
                                        (0030) 
                                        (0031) ;-----------------------------------------------
                                        (0032) ;  Global Symbols
                                        (0033) ;-----------------------------------------------
                                        (0034) ;-------------------------------------------------------------------
                                        (0035) ;  Declare the functions global for both assembler and C compiler.
                                        (0036) ;
                                        (0037) ;  Note that there are two names for each API. First name is
                                        (0038) ;  assembler reference. Name with underscore is name refence for
                                        (0039) ;  C compiler.  Calling function in C source code does not require
                                        (0040) ;  the underscore.
                                        (0041) ;-------------------------------------------------------------------
                                        (0042) 
                                        (0043) export    EzI2Cs_1_EnableInt
                                        (0044) export   _EzI2Cs_1_EnableInt
                                        (0045) export    EzI2Cs_1_ResumeInt
                                        (0046) export   _EzI2Cs_1_ResumeInt
                                        (0047) export    EzI2Cs_1_Start
                                        (0048) export   _EzI2Cs_1_Start
                                        (0049) 
                                        (0050) export    EzI2Cs_1_DisableInt
                                        (0051) export   _EzI2Cs_1_DisableInt
                                        (0052) export    EzI2Cs_1_Stop
                                        (0053) export   _EzI2Cs_1_Stop
                                        (0054) export    EzI2Cs_1_DisableSlave
                                        (0055) export   _EzI2Cs_1_DisableSlave
                                        (0056) export    EzI2Cs_1_SetRamBuffer
                                        (0057) export   _EzI2Cs_1_SetRamBuffer
                                        (0058) export    EzI2Cs_1_GetAddr
                                        (0059) export   _EzI2Cs_1_GetAddr
                                        (0060) export    EzI2Cs_1_GetActivity
                                        (0061) export   _EzI2Cs_1_GetActivity
                                        (0062) 
                                        (0063) 
                                        (0064) IF (EzI2Cs_1_DYNAMIC_ADDR | EzI2Cs_1_AUTO_ADDR_CHECK) ;; Enable this function if Address is Dynamic or the AUTO_ADDR_CHECK is enabled
                                        (0065) export    EzI2Cs_1_SetAddr
                                        (0066) export   _EzI2Cs_1_SetAddr
                                        (0067) ENDIF
                                        (0068) 
                                        (0069) IF (EzI2Cs_1_ROM_ENABLE)  ;; Enable only if alternate ROM Address is Enabled
                                        (0070) export    EzI2Cs_1_SetRomBuffer
                                        (0071) export   _EzI2Cs_1_SetRomBuffer
                                        (0072) ENDIF
                                        (0073) 
                                        (0074) IF (EzI2Cs_1_CY8C22x45)
                                        (0075) export    EzI2Cs_1_EnableHWAddrCheck
                                        (0076) export   _EzI2Cs_1_EnableHWAddrCheck
                                        (0077) export    EzI2Cs_1_DisableHWAddrCheck
                                        (0078) export   _EzI2Cs_1_DisableHWAddrCheck
                                        (0079) ENDIF
                                        (0080) 
                                        (0081) 
                                        (0082) AREA UserModules (ROM, REL, CON)
                                        (0083) 
                                        (0084) .SECTION
                                        (0085) 
                                        (0086) ;-----------------------------------------------------------------------------
                                        (0087) ;  FUNCTION NAME: EzI2Cs_1_Start
                                        (0088) ;
                                        (0089) ;  DESCRIPTION:
                                        (0090) ;   Initialize the EzI2Cs_1 I2C bus interface.
                                        (0091) ;
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) ;
                                        (0094) ;  ARGUMENTS:
                                        (0095) ;
                                        (0096) ;  RETURNS: none
                                        (0097) ;
                                        (0098) ;  SIDE EFFECTS:
                                        (0099) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0100) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0101) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0102) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0103) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0104) ;          
                                        (0105) ;    Page Pointer Registers Modified: 
                                        (0106) ;          CUR_PP
                                        (0107) ;
                                        (0108) ;  THEORY of OPERATION or PROCEDURE:
                                        (0109) ;
                                        (0110) 
                                        (0111)  EzI2Cs_1_Start:
                                        (0112) _EzI2Cs_1_Start:
                                        (0113) 
                                        (0114)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0115)    RAM_SETPAGE_CUR >EzI2Cs_1_varPage
                                        (0116)    
                                        (0117) IF (EzI2Cs_1_DYNAMIC_ADDR)  ;; DYNAMIC ADDRESS
                                        (0118) IF (EzI2Cs_1_AUTO_ADDR_CHECK^1) ;; for CY8C28X45 chip: do not touch the EzI2Cs_1_bAddr variable if AutoAddressCompare feature is enabled.
                                        (0119)    mov  [EzI2Cs_1_bAddr],EzI2Cs_1_SLAVE_ADDR
                                        (0120) ENDIF   
                                        (0121) ENDIF
                                        (0122) IF (EzI2Cs_1_CY8C22x45)
                                        (0123)    M8C_SetBank1
                                        (0124)    mov   reg[EzI2Cs_1_ADDR_REG], (EzI2Cs_1_SLAVE_ADDR>>1)
                                        (0125)    M8C_SetBank0
                                        (0126) ENDIF
                                        (0127) 
                                        (0128)    M8C_SetBank1 ;The SDA and SCL pins are setting to Hi-z drive mode
0A03: 41 04 5F AND   REG[0x4],0x5F      (0129)    and reg[EzI2Cs_1SDA_DriveMode_0_ADDR],~(EzI2Cs_1SDA_MASK|EzI2Cs_1SCL_MASK)
0A06: 43 05 A0 OR    REG[0x5],0xA0      (0130)    or  reg[EzI2Cs_1SDA_DriveMode_1_ADDR], (EzI2Cs_1SDA_MASK|EzI2Cs_1SCL_MASK)
0A09: 70 EF    AND   F,0xEF             
                                        (0131)    M8C_SetBank0
0A0B: 43 07 A0 OR    REG[0x7],0xA0      (0132)    or  reg[EzI2Cs_1SDA_DriveMode_2_ADDR], (EzI2Cs_1SDA_MASK|EzI2Cs_1SCL_MASK)
                                        (0133) 
0A0E: 55 05 00 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x0(0134)    mov  [EzI2Cs_1_bState],0x00    ;; Make sure state machine is initialized
0A11: 55 0C 00 MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+12],0x0(0135)    mov [EzI2Cs_1_bBusy_Flag],EzI2Cs_1_I2C_FREE ;; Clear Busy flag
                                        (0136) 
0A14: 90 29    CALL  _EzI2Cs_1_EnableInt(0137)    call EzI2Cs_1_EnableInt
0A16: 90 2E    CALL  0x0A46             (0138)    call EzI2Cs_1_EnableSlave
                                        (0139) 
0A18: 40       NOP                      (0140)    nop
0A19: 40       NOP                      (0141)    nop
0A1A: 40       NOP                      (0142)    nop
0A1B: 40       NOP                      (0143)    nop
0A1C: 40       NOP                      (0144)    nop
                                        (0145)    
0A1D: 50 00    MOV   A,0x0              (0146)    mov A, 0
0A1F: 53 06    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+6],A(0147)    mov [EzI2Cs_1_bRAM_RWoffset], A
0A21: 71 10    OR    F,0x10             
                                        (0148) IF (EzI2Cs_1_ROM_ENABLE)
                                        (0149)    mov [EzI2Cs_1_bROM_RWoffset], A
                                        (0150) ENDIF
                                        (0151)    
                                        (0152)    M8C_SetBank1 ;The SDA and SCL pins are restored to Open Drain Low drive mode
0A23: 43 04 A0 OR    REG[0x4],0xA0      (0153)    or reg[EzI2Cs_1SDA_DriveMode_0_ADDR], (EzI2Cs_1SDA_MASK|EzI2Cs_1SCL_MASK)
0A26: 43 05 A0 OR    REG[0x5],0xA0      (0154)    or reg[EzI2Cs_1SDA_DriveMode_1_ADDR], (EzI2Cs_1SDA_MASK|EzI2Cs_1SCL_MASK)
0A29: 70 EF    AND   F,0xEF             
                                        (0155)    M8C_SetBank0
0A2B: 43 07 A0 OR    REG[0x7],0xA0      (0156)    or reg[EzI2Cs_1SDA_DriveMode_2_ADDR], (EzI2Cs_1SDA_MASK|EzI2Cs_1SCL_MASK)
                                        (0157) 
                                        (0158)    RAM_EPILOGUE RAM_USE_CLASS_4
0A2E: 7F       RET                      (0159)    ret
0A2F: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0160) 
                                        (0161) .ENDSECTION
                                        (0162) 
                                        (0163) IF (EzI2Cs_1_DYNAMIC_ADDR | EzI2Cs_1_AUTO_ADDR_CHECK) ;; Enable this function if Address is Dynamic or the AUTO_ADDR_CHECK is enabled
                                        (0164) .SECTION
                                        (0165) ;-----------------------------------------------------------------------------
                                        (0166) ;  FUNCTION NAME: EzI2Cs_1_SetAddr(BYTE bAddr)
                                        (0167) ;
                                        (0168) ;  DESCRIPTION:
                                        (0169) ;   Set the I2C slave address for the EzI2Cs_1 I2C bus interface.
                                        (0170) ;
                                        (0171) ;-----------------------------------------------------------------------------
                                        (0172) ;
                                        (0173) ;  ARGUMENTS:
                                        (0174) ;      A =>  Slave address
                                        (0175) ;
                                        (0176) ;  RETURNS: none
                                        (0177) ;
                                        (0178) ;  SIDE EFFECTS;    
                                        (0179) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0180) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0181) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0182) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0183) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0184) ;          
                                        (0185) ;    Page Pointer Registers Modified: 
                                        (0186) ;          CUR_PP
                                        (0187) ;
                                        (0188) ;  THEORY of OPERATION or PROCEDURE:
                                        (0189) ;
                                        (0190) 
                                        (0191)  EzI2Cs_1_SetAddr:
                                        (0192) _EzI2Cs_1_SetAddr:
                                        (0193)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0194) IF (EzI2Cs_1_AUTO_ADDR_CHECK^1) ;; for CY8C28X45 chip: do not touch the EzI2Cs_1_bAddr variable if AutoAddressCompare feature is enabled.
                                        (0195)    RAM_SETPAGE_CUR >EzI2Cs_1_bAddr
                                        (0196)  IF (EzI2Cs_1_CY8C22x45)
                                        (0197)    and   A, ~EzI2Cs_1_HW_ADDR_EN
                                        (0198)    M8C_SetBank1
                                        (0199)    mov   reg[EzI2Cs_1_ADDR_REG], A
                                        (0200)    M8C_SetBank0
                                        (0201)  ENDIF
                                        (0202)    asl   A
                                        (0203)    mov   [EzI2Cs_1_bAddr],A
                                        (0204) ELSE                          ;; write to the ADDR register instead
                                        (0205)    RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0206)    and  A, ~EzI2Cs_1_HW_ADDR_MASK	; verify address value
                                        (0207)    mov  X, SP
                                        (0208)    push A                                   ; store address value
                                        (0209)    M8C_SetBank1               ;; Set Bank 1
                                        (0210)    mov  A, reg[EzI2Cs_1_ADDR_REG]   ; get value from address register
                                        (0211)    and  A, EzI2Cs_1_HW_ADDR_MASK    ; define highest bit
                                        (0212)    or   A, [X]                              ; form address value 	
                                        (0213)    mov  reg[EzI2Cs_1_ADDR_REG], A   ; set new address value to register
                                        (0214)    M8C_SetBank0               ;; Set Bank 0
                                        (0215)    pop  A
                                        (0216)    RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0217) ENDIF
                                        (0218)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0219)    ret
                                        (0220) 
                                        (0221) .ENDSECTION
                                        (0222) ENDIF
                                        (0223) 
                                        (0224) .SECTION
                                        (0225) ;-----------------------------------------------------------------------------
                                        (0226) ;  FUNCTION NAME:BYTE EzI2Cs_1_GetActivity(void)
                                        (0227) ;
                                        (0228) ;  DESCRIPTION:
                                        (0229) ;    Return a non-zero value if the I2C hardware has seen activity on the bus.
                                        (0230) ;    The activity flag will be cleared if set when calling this function.
                                        (0231) ;
                                        (0232) ;-----------------------------------------------------------------------------
                                        (0233) ;
                                        (0234) ;  ARGUMENTS:  none
                                        (0235) ;
                                        (0236) ;  RETURNS: 
                                        (0237) ;    BYTE  non-zero = Activity
                                        (0238) ;          zero     = No Activity
                                        (0239) ;
                                        (0240) ;  SIDE EFFECTS;    
                                        (0241) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0242) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0243) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0244) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0245) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0246) ;          
                                        (0247) ;    Page Pointer Registers Modified: 
                                        (0248) ;          CUR_PP
                                        (0249) ;
                                        (0250) ;  THEORY of OPERATION or PROCEDURE:
                                        (0251) ;
                                        (0252) 
                                        (0253)  EzI2Cs_1_GetActivity:
                                        (0254) _EzI2Cs_1_GetActivity:
                                        (0255)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0256)    RAM_SETPAGE_CUR >EzI2Cs_1_bState
0A32: 51 05    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5](0257)    mov   A,[EzI2Cs_1_bState]
0A34: 21 B0    AND   A,0xB0             (0258)    and   A,EzI2Cs_1_ACTIVITY_MASK         ; Mask off activity bits
0A36: 26 05 4F AND   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+5],0x4F(0259)    and   [EzI2Cs_1_bState],~EzI2Cs_1_ACTIVITY_MASK ; Clear system activity bits
                                        (0260) 
                                        (0261) EzI2Cs_1_GetActivity_End:
                                        (0262)    RAM_EPILOGUE RAM_USE_CLASS_4
0A39: 7F       RET                      (0263)    ret
                                        (0264) 
                                        (0265) .ENDSECTION
                                        (0266) 
                                        (0267) .SECTION
                                        (0268) ;-----------------------------------------------------------------------------
                                        (0269) ;  FUNCTION NAME: BYTE EzI2Cs_1_GetAddr(Void)
                                        (0270) ;
                                        (0271) ;  DESCRIPTION:
                                        (0272) ;   Get the I2C slave address for the EzI2Cs_1 I2C bus interface.
                                        (0273) ;
                                        (0274) ;-----------------------------------------------------------------------------
                                        (0275) ;
                                        (0276) ;  ARGUMENTS: none
                                        (0277) ;
                                        (0278) ;  RETURNS: none
                                        (0279) ;
                                        (0280) ;  SIDE EFFECTS;    
                                        (0281) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0282) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0283) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0284) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0285) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0286) ;          
                                        (0287) ;    Page Pointer Registers Modified: 
                                        (0288) ;          CUR_PP
                                        (0289) ;
                                        (0290) ;
                                        (0291) ;  THEORY of OPERATION or PROCEDURE:
                                        (0292) ;
                                        (0293) 
                                        (0294)  EzI2Cs_1_GetAddr:
                                        (0295) _EzI2Cs_1_GetAddr:
                                        (0296) 
                                        (0297) IF (EzI2Cs_1_DYNAMIC_ADDR | EzI2Cs_1_AUTO_ADDR_CHECK) ;; if Address is Dynamic or the AUTO_ADDR_CHECK is enabled
                                        (0298)    RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0299) IF (EzI2Cs_1_AUTO_ADDR_CHECK^1) ;; for CY8C28X45 chip: do not touch the EzI2Cs_1_bAddr variable if AutoAddressCompare feature is enabled.
                                        (0300)    RAM_SETPAGE_CUR >EzI2Cs_1_bAddr
                                        (0301)    mov   A,[EzI2Cs_1_bAddr]
                                        (0302)    asr   A                          ; Shift Addr to right to drop RW bit.
                                        (0303) ELSE                          ;; read the address from ADDR register instead
                                        (0304)    M8C_SetBank1               ;; Set Bank 1 
                                        (0305)    mov A, reg[EzI2Cs_1_ADDR_REG]
                                        (0306)    M8C_SetBank0               ;; Set Bank 0
                                        (0307) ENDIF
                                        (0308)    and   A, 0x7f              ; Mask off bogus MSb
                                        (0309)    RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0310) ELSE
0A3A: 50 1E    MOV   A,0x1E             (0311)    mov   A,0x1e            
                                        (0312) ENDIF
0A3C: 7F       RET                      (0313)    ret
                                        (0314) 
                                        (0315) .ENDSECTION
                                        (0316) 
                                        (0317) 
                                        (0318) 
                                        (0319) .SECTION
                                        (0320) ;-----------------------------------------------------------------------------
                                        (0321) ;  FUNCTION NAME: EzI2Cs_1_EnableInt
                                        (0322) ;  FUNCTION NAME: EzI2Cs_1_ResumeInt
                                        (0323) ;  DESCRIPTION:
                                        (0324) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                        (0325) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0326) ;	  EzI2Cs_1_ResumeInt performs the enable int function without fist clearing
                                        (0327) ;     pending interrupts.
                                        (0328) ;-----------------------------------------------------------------------------
                                        (0329) ;
                                        (0330) ;  ARGUMENTS: none
                                        (0331) ;
                                        (0332) ;  RETURNS: none
                                        (0333) ;
                                        (0334) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0335) ;
                                        (0336) ;  THEORY of OPERATION or PROCEDURE:
                                        (0337) ;
                                        (0338)  EzI2Cs_1_ResumeInt:
                                        (0339) _EzI2Cs_1_ResumeInt:
                                        (0340)    RAM_PROLOGUE RAM_USE_CLASS_1
0A3D: 80 04    JMP   0x0A42             (0341)    jmp   ResumeEntry
0A3F: 62 DD FE MOV   REG[0xDD],0xFE     
0A42: 43 DE 01 OR    REG[0xDE],0x1      
                                        (0342) 
                                        (0343)  EzI2Cs_1_EnableInt:
                                        (0344) _EzI2Cs_1_EnableInt:
                                        (0345)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0346)    ;first clear any pending interrupts
                                        (0347)    M8C_ClearIntFlag INT_CLR3, EzI2Cs_1_INT_MASK   
                                        (0348) ResumeEntry:
                                        (0349)    M8C_EnableIntMask EzI2Cs_1_INT_REG, EzI2Cs_1_INT_MASK
                                        (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
0A45: 7F       RET                      (0351)    ret
                                        (0352) 
                                        (0353) .ENDSECTION
                                        (0354) 
                                        (0355) .SECTION
                                        (0356) ;-----------------------------------------------------------------------------
                                        (0357) ;  FUNCTION NAME: EzI2Cs_1_EnableSlave
                                        (0358) ;
                                        (0359) ;  DESCRIPTION:
                                        (0360) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                        (0361) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                        (0362) ;
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;
                                        (0365) ;  ARGUMENTS: none
                                        (0366) ;
                                        (0367) ;  RETURNS: none
                                        (0368) ;
                                        (0369) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0370) ;
                                        (0371) ;  THEORY of OPERATION or PROCEDURE:
                                        (0372) ;
                                        (0373) 
                                        (0374)  EzI2Cs_1_EnableSlave:
                                        (0375) _EzI2Cs_1_EnableSlave:
                                        (0376) 
                                        (0377)     RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0378)     
                                        (0379)     IF (EzI2Cs_1_CY8C27XXXA_ID) ;; Enable this code if we have CY8C27XXXA chip ID
                                        (0380)     ; Save original CPU clock speed
                                        (0381)     M8C_SetBank1          ; Set Bank 1 
                                        (0382)     mov  A,reg[OSC_CR0]   ; Get current configuration of OSC_CR0 (Bank 1)
                                        (0383)     push A                ; Save OSC_CR0 configuration
                                        (0384)     and  A,0xF8           ; Mask off CPU speed
                                        (0385)     or   A,0x05           ; Set clock to 750KHz
                                        (0386)     mov  reg[OSC_CR0],A   ; Write new value to OSC_CR0 (Bank 1)
                                        (0387)     M8C_SetBank0          ; Back to Bank 0
                                        (0388)     ENDIF 
                                        (0389)     ; Enable I2C Slave
                                        (0390)     IF(EzI2Cs_1_USED_I2C_BLOCK)
                                        (0391)     M8C_SetBank1
                                        (0392)     or   reg[EzI2Cs_1_CFG_REG],(EzI2Cs_1_CFG_Slave_EN | EzI2Cs_1_CFG_BUS_ERROR_IE | EzI2Cs_1_CFG_STOP_IE)
                                        (0393)     M8C_SetBank0
                                        (0394)     ELSE
0A46: 43 D6 31 OR    REG[0xD6],0x31     (0395)     or   reg[EzI2Cs_1_CFG_REG],(EzI2Cs_1_CFG_Slave_EN | EzI2Cs_1_CFG_BUS_ERROR_IE | EzI2Cs_1_CFG_STOP_IE)
                                        (0396)     ENDIF
                                        (0397)     IF (EzI2Cs_1_CY8C27XXXA_ID) ;; Enable this code if we have CY8C27XXXA chip ID    
                                        (0398)     ; Restore original CPU clock speed
                                        (0399)     pop  A
                                        (0400)     M8C_SetBank1          ; Set Bank 1
                                        (0401)     mov  reg[OSC_CR0],A   ; Restore
                                        (0402)     M8C_SetBank0          ; Back to Bank 0
                                        (0403)     ENDIF    
                                        (0404)     RAM_EPILOGUE RAM_USE_CLASS_1
0A49: 7F       RET                      (0405)     ret
0A4A: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0406) 
                                        (0407) .ENDSECTION
                                        (0408) 
                                        (0409) .SECTION
                                        (0410) ;-----------------------------------------------------------------------------
                                        (0411) ;  FUNCTION NAME: EzI2Cs_1_DisableInt
                                        (0412) ;  FUNCTION NAME: EzI2Cs_1_Stop
                                        (0413) ;
                                        (0414) ;  DESCRIPTION:
                                        (0415) ;     Disables EzI2Cs_1 slave by disabling SDA interrupt
                                        (0416) ;
                                        (0417) ;-----------------------------------------------------------------------------
                                        (0418) ;
                                        (0419) ;  ARGUMENTS: none
                                        (0420) ;
                                        (0421) ;  RETURNS: none
                                        (0422) ;
                                        (0423) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0424) ;
                                        (0425) ;  THEORY of OPERATION or PROCEDURE:
                                        (0426) ;
                                        (0427) 
                                        (0428)  EzI2Cs_1_Stop:
                                        (0429) _EzI2Cs_1_Stop:
                                        (0430)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0431) 
                                        (0432)    M8C_DisableIntMask EzI2Cs_1_INT_REG, EzI2Cs_1_INT_MASK
                                        (0433)    IF(EzI2Cs_1_USED_I2C_BLOCK)
                                        (0434)    M8C_SetBank1
                                        (0435)    and  reg[EzI2Cs_1_CFG_REG],~EzI2Cs_1_CFG_Slave_EN
                                        (0436)    M8C_SetBank0
                                        (0437)    ELSE
0A4D: 41 D6 FE AND   REG[0xD6],0xFE     (0438)    and  reg[EzI2Cs_1_CFG_REG],~EzI2Cs_1_CFG_Slave_EN
                                        (0439)    ENDIF
                                        (0440)    RAM_EPILOGUE RAM_USE_CLASS_1
0A50: 7F       RET                      (0441)    ret
0A51: 41 DE FE AND   REG[0xDE],0xFE     
                                        (0442) 
                                        (0443) .ENDSECTION
                                        (0444) 
                                        (0445) 
                                        (0446) 
                                        (0447) .SECTION
                                        (0448) ;-----------------------------------------------------------------------------
                                        (0449) ;  FUNCTION NAME: EzI2Cs_1_DisableInt
                                        (0450) ;  FUNCTION NAME: EzI2Cs_1_Stop
                                        (0451) ;
                                        (0452) ;  DESCRIPTION:
                                        (0453) ;     Disables EzI2Cs_1 slave by disabling SDA interrupt
                                        (0454) ;
                                        (0455) ;-----------------------------------------------------------------------------
                                        (0456) ;
                                        (0457) ;  ARGUMENTS: none
                                        (0458) ;
                                        (0459) ;  RETURNS: none
                                        (0460) ;
                                        (0461) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0462) ;
                                        (0463) ;  THEORY of OPERATION or PROCEDURE:
                                        (0464) ;
                                        (0465) 
                                        (0466)  EzI2Cs_1_DisableInt:
                                        (0467) _EzI2Cs_1_DisableInt:
                                        (0468)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0469)    M8C_DisableIntMask EzI2Cs_1_INT_REG, EzI2Cs_1_INT_MASK
                                        (0470)    RAM_EPILOGUE RAM_USE_CLASS_1
0A54: 7F       RET                      (0471)    ret
                                        (0472) 
                                        (0473) .ENDSECTION
                                        (0474) 
                                        (0475) .SECTION
                                        (0476) ;-----------------------------------------------------------------------------
                                        (0477) ;  FUNCTION NAME: EzI2Cs_1_DisableSlave
                                        (0478) ;
                                        (0479) ;  DESCRIPTION:
                                        (0480) ;     Disables EzI2Cs_1 slave by disabling SDA interrupt
                                        (0481) ;
                                        (0482) ;-----------------------------------------------------------------------------
                                        (0483) ;
                                        (0484) ;  ARGUMENTS: none
                                        (0485) ;
                                        (0486) ;  RETURNS: none
                                        (0487) ;
                                        (0488) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0489) ;
                                        (0490) ;  THEORY of OPERATION or PROCEDURE:
                                        (0491) ;
                                        (0492) 
                                        (0493)  EzI2Cs_1_DisableSlave:
                                        (0494) _EzI2Cs_1_DisableSlave:
                                        (0495)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0496)    IF(EzI2Cs_1_USED_I2C_BLOCK)
                                        (0497)    M8C_SetBank1
                                        (0498)    and  reg[EzI2Cs_1_CFG_REG],~EzI2Cs_1_CFG_Slave_EN
                                        (0499)    M8C_SetBank0
                                        (0500)    ELSE
0A55: 41 D6 FE AND   REG[0xD6],0xFE     (0501)    and  reg[EzI2Cs_1_CFG_REG],~EzI2Cs_1_CFG_Slave_EN
                                        (0502)    ENDIF
                                        (0503)    RAM_EPILOGUE RAM_USE_CLASS_1
0A58: 7F       RET                      (0504)    ret
0A59: 62 D0 00 MOV   REG[0xD0],0x0      
                                        (0505) 
                                        (0506) .ENDSECTION
                                        (0507) 
                                        (0508) .SECTION
                                        (0509) ;-----------------------------------------------------------------------------
                                        (0510) ;  FUNCTION NAME: 
                                        (0511) ;          void EzI2Cs_1_SetRamBuffer(BYTE bSize, BYTE bRWboundry, BYTE * pAddr)
                                        (0512) ;
                                        (0513) ;  DESCRIPTION:
                                        (0514) ;     Sets the location and size of the I2C RAM buffer.          
                                        (0515) ;
                                        (0516) ;-----------------------------------------------------------------------------
                                        (0517) ;
                                        (0518) ;  ARGUMENTS: 
                                        (0519) ;     [SP-3] =>  Size of data structure
                                        (0520) ;     [SP-4] =>  R/W boundary of (Must be less than or equal to size.)
                                        (0521) ;     [SP-5] =>  LSB of data pointer
                                        (0522) ;     [SP-6] =>  MSB of data pointer (Only used for large memory model)
                                        (0523) ;
                                        (0524) ;  RETURNS: none
                                        (0525) ;
                                        (0526) ;  SIDE EFFECTS;    
                                        (0527) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0528) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0529) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0530) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0531) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0532) ;          
                                        (0533) ;    Page Pointer Registers Modified: 
                                        (0534) ;          CUR_PP
                                        (0535) ;
                                        (0536) ;  THEORY of OPERATION or PROCEDURE:
                                        (0537) ;
                                        (0538) 
                                        (0539) ; Stack offset constants
                                        (0540) RAMBUF_SIZE:   equ  -3   ; Stack position for data structure size.
                                        (0541) RW_SIZE:       equ  -4   ; Stack position for R/W area size.       
                                        (0542) RAMPTR_LSB:    equ  -5   ; Stack position for RAM pointer LSB.   
                                        (0543) RAMPTR_MSB:    equ  -6   ; Stack position for RAM pointer MSB.   
                                        (0544) 
                                        (0545)  EzI2Cs_1_SetRamBuffer:
                                        (0546) _EzI2Cs_1_SetRamBuffer:
                                        (0547) 
                                        (0548)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0549)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0550)     RAM_SETPAGE_CUR >EzI2Cs_1_bRAM_Buf_Size     ; Set page to global var page.
                                        (0551)                                                         ; All these globals should be
                                        (0552)                                                         ; on the same page.          
0A5C: 4F       MOV   X,SP               (0553)     mov   X,SP
0A5D: 52 FD    MOV   A,[X-3]            (0554)     mov   A,[X+RAMBUF_SIZE]
0A5F: 53 0A    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+10],A(0555)     mov   [EzI2Cs_1_bRAM_Buf_Size],A         ; Store the buffer size
                                        (0556) 
0A61: 52 FC    MOV   A,[X-4]            (0557)     mov   A,[X+RW_SIZE]                            ; Store R/W boundary             
0A63: 53 0B    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+11],A(0558)     mov   [EzI2Cs_1_bRAM_Buf_WSize],A        ; 
                                        (0559)     
0A65: 52 FB    MOV   A,[X-5]            (0560)     mov   A,[X+RAMPTR_LSB]                         ; Store only LSB of data pointer
0A67: 53 09    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+9],A(0561)     mov   [EzI2Cs_1_pRAM_Buf_Addr_LSB],A     ; 
                                        (0562) 
                                        (0563) IF (SYSTEM_LARGE_MEMORY_MODEL)                             ; Only worry about the address MSB
                                        (0564)                                                            ; if in the large memory Model
0A69: 52 FA    MOV   A,[X-6]            (0565)     mov   A,[X+RAMPTR_MSB]                         ; Store only MSB of data pointer
0A6B: 53 08    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+8],A(0566)     mov   [EzI2Cs_1_pRAM_Buf_Addr_MSB],A     ; 
0A6D: 70 3F    AND   F,0x3F             
0A6F: 71 C0    OR    F,0xC0             
                                        (0567) ENDIF
                                        (0568) 
                                        (0569)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0570)     RAM_EPILOGUE RAM_USE_CLASS_4
0A71: 7F       RET                      (0571)     ret
                                        (0572) 
                                        (0573) .ENDSECTION
                                        (0574) 
                                        (0575) IF (EzI2Cs_1_ROM_ENABLE)  ;; Enable only if alternate ROM Address is Enabled
                                        (0576) .SECTION
                                        (0577) ;-----------------------------------------------------------------------------
                                        (0578) ;  FUNCTION NAME: 
                                        (0579) ;          void EzI2Cs_1_SetRomBuffer(BYTE bSize, BYTE * pAddr)
                                        (0580) ;
                                        (0581) ;  DESCRIPTION:
                                        (0582) ;     Sets the location and size of the I2C ROM buffer.          
                                        (0583) ;
                                        (0584) ;-----------------------------------------------------------------------------
                                        (0585) ;
                                        (0586) ;  ARGUMENTS: 
                                        (0587) ;     [SP-3] =>  Size of data const data structure
                                        (0588) ;     [SP-4] =>  LSB of data pointer
                                        (0589) ;     [SP-5] =>  MSB of data pointer (Only used for large memory model)
                                        (0590) ;
                                        (0591) ;  RETURNS: none
                                        (0592) ;
                                        (0593) ;  SIDE EFFECTS;    
                                        (0594) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0595) ;    IN THE LARGE MEMORY MODEL CURRENTLY ONLY THE PAGE POINTER 
                                        (0596) ;    REGISTERS LISTED BELOW ARE MODIFIED.  THIS DOES NOT GUARANTEE 
                                        (0597) ;    THAT IN FUTURE IMPLEMENTATIONS OF THIS FUNCTION OTHER PAGE POINTER 
                                        (0598) ;    REGISTERS WILL NOT BE MODIFIED.
                                        (0599) ;          
                                        (0600) ;    Page Pointer Registers Modified: 
                                        (0601) ;          CUR_PP
                                        (0602) ;
                                        (0603) ;  THEORY of OPERATION or PROCEDURE:
                                        (0604) ;
                                        (0605) 
                                        (0606) ; Stack offset constants
                                        (0607) ROMBUF_SIZE:   equ  -3   ; Stack position for data structure size.
                                        (0608) ROMPTR_LSB:    equ  -4   ; Stack position for ROM pointer LSB.   
                                        (0609) ROMPTR_MSB:    equ  -5   ; Stack position for ROM pointer MSB.   
                                        (0610) 
                                        (0611)  EzI2Cs_1_SetRomBuffer:
                                        (0612) _EzI2Cs_1_SetRomBuffer:
                                        (0613) 
                                        (0614)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0615)     RAM_PROLOGUE RAM_USE_CLASS_2
                                        (0616)     RAM_SETPAGE_CUR >EzI2Cs_1_bROM_Buf_Size     ; Set page to global var page.
                                        (0617)                                                         ; All these globals should be
                                        (0618)                                                         ; on the same page.          
                                        (0619)     mov   X,SP
                                        (0620)     mov   A,[X+ROMBUF_SIZE]
                                        (0621)     mov   [EzI2Cs_1_bROM_Buf_Size],A         ; Store the buffer size
                                        (0622) 
                                        (0623)     mov   A,[X+ROMPTR_LSB]                         ; Store LSB of data pointer
                                        (0624)     mov   [EzI2Cs_1_pROM_Buf_Addr_LSB],A     ; 
                                        (0625)     mov   A,[X+ROMPTR_MSB]                         ; Store MSB of data pointer
                                        (0626)     mov   [EzI2Cs_1_pROM_Buf_Addr_MSB],A     ; 
                                        (0627)     RAM_EPILOGUE RAM_USE_CLASS_2
                                        (0628)     RAM_EPILOGUE RAM_USE_CLASS_4
                                        (0629)     ret
                                        (0630) 
                                        (0631) .ENDSECTION
                                        (0632) ENDIF
                                        (0633) 
                                        (0634) IF (EzI2Cs_1_CY8C22x45)
                                        (0635)  .SECTION
                                        (0636) ;-----------------------------------------------------------------------------
                                        (0637) ;  FUNCTION NAME: void  EzI2Cs_1_EnableHWAddrCheck(void)
                                        (0638) ;
                                        (0639) ;  DESCRIPTION:
                                        (0640) ;   Set respective bit to engage the HardWare Address Recognition 
                                        (0641) ;   feature in I2C slave block.
                                        (0642) ;
                                        (0643) ;-----------------------------------------------------------------------------
                                        (0644) ;
                                        (0645) ;  ARGUMENTS: none
                                        (0646) ;
                                        (0647) ;  RETURNS: none
                                        (0648) ;
                                        (0649) ;  SIDE EFFECTS:
                                        (0650) ;    If the HardWare Address Recognition feature is enabled, the ROM registers reading does not work.
                                        (0651) ;    The HardWare Address Recognition feature should be disabled for using ROM registers.
                                        (0652) ;
                                        (0653) ;    The A and X registers may be modified by this or future implementations
                                        (0654) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0655) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0656) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0657) ;    functions.
                                        (0658) ;
                                        (0659)  EzI2Cs_1_EnableHWAddrCheck:
                                        (0660) _EzI2Cs_1_EnableHWAddrCheck:
                                        (0661)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0662)    M8C_SetBank1
                                        (0663)    or    reg[EzI2Cs_1_ADDR_REG], EzI2Cs_1_HW_ADDR_EN
                                        (0664)    M8C_SetBank0
                                        (0665)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0666)    ret
                                        (0667) .ENDSECTION
                                        (0668) 
                                        (0669) .SECTION
                                        (0670) ;-----------------------------------------------------------------------------
                                        (0671) ;  FUNCTION NAME: void  EzI2Cs_1_DisableHWAddrCheck(void)
                                        (0672) ;
                                        (0673) ;  DESCRIPTION:
                                        (0674) ;   Clear respective bit to disengage the HardWare Address Recognition 
                                        (0675) ;   feature in I2C slave block.
                                        (0676) ;
                                        (0677) ;-----------------------------------------------------------------------------
                                        (0678) ;
                                        (0679) ;  ARGUMENTS: none
                                        (0680) ;
                                        (0681) ;  RETURNS: none
                                        (0682) ;
                                        (0683) ;  SIDE EFFECTS:
                                        (0684) ;    The A and X registers may be modified by this or future implementations
                                        (0685) ;    of this function.  The same is true for all RAM page pointer registers in
                                        (0686) ;    the Large Memory Model.  When necessary, it is the calling function's
                                        (0687) ;    responsibility to perserve their values across calls to fastcall16 
                                        (0688) ;    functions.
                                        (0689) ;
                                        (0690)  EzI2Cs_1_DisableHWAddrCheck:
                                        (0691) _EzI2Cs_1_DisableHWAddrCheck:
                                        (0692)    RAM_PROLOGUE RAM_USE_CLASS_1
                                        (0693)    M8C_SetBank1
                                        (0694)    and   reg[EzI2Cs_1_ADDR_REG], ~EzI2Cs_1_HW_ADDR_EN
                                        (0695)    M8C_SetBank0
                                        (0696)    RAM_EPILOGUE RAM_USE_CLASS_1
                                        (0697)    ret
                                        (0698) .ENDSECTION
                                        (0699) ENDIF
                                        (0700) 
                                        (0701) ; End of File EzI2Cs_1.asm
FILE: C:\Users\tatsuya\Dropbox\\vO~1\PSoC\Designer\CATCHR~2\CATCHR~1\CATCHR~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) #include <stdio.h>
(0008) 
(0009) //MBM & I2C Flag
(0010) #define I2CIO_WRITE		0x80
(0011) #define I2CIO_READ		0x40
(0012) #define I2CIO_UPDATE	0x20
(0013) 
(0014) //BrakeFlag
(0015) #define STOP_X	0x01
(0016) #define STOP_Y	0x02
(0017) #define STOP_Z	0x04
(0018) 
(0019) //set prs
(0020) #define prsSet(dw, b)	(*(BYTE *)&(dw) = (*((BYTE *)&(dw) + 1) = (*((BYTE *)&(dw) + 2) = (*(((BYTE *)&(dw)) + 3) = (b)))))
(0021) 
(0022) //prs poly balue
(0023) #define POLY	0xE0000200
(0024) 
(0025) //brake delay time
(0026) #define STOPCOUNT_X	0xff
(0027) #define STOPINC_X	0x01
(0028) #define STOPCOUNT_Y	0xff
(0029) #define STOPINC_Y	0x01
(0030) #define STOPCOUNT_Z	0xff
(0031) #define STOPINC_Z	0x04
(0032) 
(0033) //rotation direction flag
(0034) #define STOP	0x00
(0035) #define CW		0x01
(0036) #define CCW		0x02
(0037) 
(0038) //bit macro
(0039) #define bitSet(a, b)	((a) |= (b))
(0040) #define bitClear(a, b)	((a) &= ~(b))
(0041) #define bitCheck(a, b)	((a) & (b))
(0042) 
(0043) //I2C buff
(0044) MBM_1_Outbox	OutboxBuff;
(0045) MBM_1_Inbox		InboxBuff;
(0046) 
(0047) //prs seed
(0048) DWORD	prs_X;
(0049) DWORD	prs_Y;
(0050) DWORD	prs_Z;
(0051) 
(0052) //prs seed update flag
(0053) BOOL	sw_X = TRUE;
(0054) BOOL	sw_Y = TRUE;
(0055) BOOL	sw_Z = TRUE;
(0056) 
(0057) BYTE ct;
(0058) BYTE ec;
(0059) 
(0060) BOOL i2cchekc = FALSE;
(0061) 
(0062) void main(void)
(0063) {
__UserModules_end|_main|__text_start|_main:
  tmpx1                --> X+6
  tmpx0                --> X+2
  pZ                   --> X+0
  tmpx1                --> X+6
  tmpx0                --> X+2
  pY                   --> X+0
  tmpx1                --> X+6
  tmpx0                --> X+2
  pX                   --> X+0
  wate                 --> X+0
  wate                 --> X+0
    0A72: 10       PUSH  X
    0A73: 4F       MOV   X,SP
    0A74: 38 07    ADD   SP,0x7
(0064) 	M8C_EnableGInt ; // Uncomment this line to enable Global Interrupts
    0A76: 71 01    OR    F,0x1
(0065) 	// Insert your main routine code here.
(0066) 	
(0067) 	//init LCD
(0068) 	LCD_1_Start();
    0A78: 10       PUSH  X
    0A79: 7C 08 76 LCALL LCD_1_Start|_LCD_1_Init|LCD_1_Init|_LCD_1_Start
(0069) 	LCD_1_Control(LCD_1_DISP_CLEAR_HOME);
    0A7C: 50 01    MOV   A,0x1
    0A7E: 7C 07 C6 LCALL _LCD_1_Control
    0A81: 20       POP   X
(0070) 	
(0071) 	//init MBM
(0072) 	MBM_1_InitializeMailbox();
    0A82: 7C 29 94 LCALL _MBM_1_InitializeMailbox
(0073) 	MBM_1_pMyMailbox = &MBM_1_MyMailbox;
    0A85: 62 D0 00 MOV   REG[0xD0],0x0
    0A88: 55 8B 26 MOV   [MBM_1_pMyMailbox+1],0x26
    0A8B: 55 8A 00 MOV   [MBM_1_pMyMailbox],0x0
(0074) 	
(0075) 	//init EzI2C
(0076) 	EzI2Cs_1_SetRamBuffer(sizeof (MBM_1_MyMailbox), (INBOXFLAG + 1), (BYTE *)&MBM_1_MyMailbox);
    0A8E: 10       PUSH  X
    0A8F: 50 00    MOV   A,0x0
    0A91: 08       PUSH  A
    0A92: 50 26    MOV   A,0x26
    0A94: 08       PUSH  A
    0A95: 50 11    MOV   A,0x11
    0A97: 08       PUSH  A
    0A98: 50 15    MOV   A,0x15
    0A9A: 08       PUSH  A
    0A9B: 7C 0A 59 LCALL _EzI2Cs_1_SetRamBuffer
    0A9E: 38 FC    ADD   SP,0xFC
(0077) 	EzI2Cs_1_Start();
    0AA0: 7C 09 FE LCALL _EzI2Cs_1_Start
(0078) 	EzI2Cs_1_ResumeInt();
    0AA3: 7C 0A 3D LCALL _EzI2Cs_1_ResumeInt
(0079) 	
(0080) 	//init PRS
(0081) 	PRS32_X_WritePolynomial(POLY);
    0AA6: 50 E0    MOV   A,0xE0
    0AA8: 08       PUSH  A
    0AA9: 50 00    MOV   A,0x0
    0AAB: 08       PUSH  A
    0AAC: 50 02    MOV   A,0x2
    0AAE: 08       PUSH  A
    0AAF: 50 00    MOV   A,0x0
    0AB1: 08       PUSH  A
    0AB2: 7C 07 24 LCALL _PRS32_X_WritePolynomial
    0AB5: 38 FC    ADD   SP,0xFC
(0082) 	PRS32_X_WriteSeed(0);
    0AB7: 50 00    MOV   A,0x0
    0AB9: 08       PUSH  A
    0ABA: 08       PUSH  A
    0ABB: 08       PUSH  A
    0ABC: 08       PUSH  A
    0ABD: 7C 07 05 LCALL _PRS32_X_WriteSeed
    0AC0: 38 FC    ADD   SP,0xFC
(0083) 	PRS32_X_Start();
    0AC2: 7C 06 FD LCALL _PRS32_X_Start
(0084) 	
(0085) 	PRS32_Y_WritePolynomial(POLY);
    0AC5: 50 E0    MOV   A,0xE0
    0AC7: 08       PUSH  A
    0AC8: 50 00    MOV   A,0x0
    0ACA: 08       PUSH  A
    0ACB: 50 02    MOV   A,0x2
    0ACD: 08       PUSH  A
    0ACE: 50 00    MOV   A,0x0
    0AD0: 08       PUSH  A
    0AD1: 7C 06 BD LCALL _PRS32_Y_WritePolynomial
    0AD4: 38 FC    ADD   SP,0xFC
(0086) 	PRS32_Y_WriteSeed(0);
    0AD6: 50 00    MOV   A,0x0
    0AD8: 08       PUSH  A
    0AD9: 08       PUSH  A
    0ADA: 08       PUSH  A
    0ADB: 08       PUSH  A
    0ADC: 7C 06 9E LCALL _PRS32_Y_WriteSeed
    0ADF: 38 FC    ADD   SP,0xFC
(0087) 	PRS32_Y_Start();
    0AE1: 7C 06 96 LCALL _PRS32_Y_Start
(0088) 	
(0089) 	PRS32_Z_WritePolynomial(POLY);
    0AE4: 50 E0    MOV   A,0xE0
    0AE6: 08       PUSH  A
    0AE7: 50 00    MOV   A,0x0
    0AE9: 08       PUSH  A
    0AEA: 50 02    MOV   A,0x2
    0AEC: 08       PUSH  A
    0AED: 50 00    MOV   A,0x0
    0AEF: 08       PUSH  A
    0AF0: 7C 06 56 LCALL _PRS32_Z_WritePolynomial
    0AF3: 38 FC    ADD   SP,0xFC
(0090) 	PRS32_Z_WriteSeed(0);
    0AF5: 50 00    MOV   A,0x0
    0AF7: 08       PUSH  A
    0AF8: 08       PUSH  A
    0AF9: 08       PUSH  A
    0AFA: 08       PUSH  A
    0AFB: 7C 06 37 LCALL _PRS32_Z_WriteSeed
    0AFE: 38 FC    ADD   SP,0xFC
(0091) 	PRS32_Z_Start();
    0B00: 7C 06 2F LCALL _PRS32_Z_Start
(0092) 	
(0093) 	//init Timer
(0094) 	Timer8_1_Start();
    0B03: 7C 05 EE LCALL _Timer8_1_Start
(0095) 	Timer8_1_EnableInt();
    0B06: 7C 05 E6 LCALL _Timer8_1_EnableInt
(0096) 	
(0097) 	LCD_1_Position(0, 0);
    0B09: 50 00    MOV   A,0x0
    0B0B: 57 00    MOV   X,0x0
    0B0D: 7C 08 E9 LCALL _LCD_1_Position
    0B10: 20       POP   X
(0098) 	cprintf("DC Motor Module");
    0B11: 50 01    MOV   A,0x1
    0B13: 08       PUSH  A
    0B14: 50 E0    MOV   A,0xE0
    0B16: 08       PUSH  A
    0B17: 7C 49 ED LCALL _cprintf
    0B1A: 38 FE    ADD   SP,0xFE
(0099) 	LCD_1_Position(1, 5);
    0B1C: 10       PUSH  X
    0B1D: 57 05    MOV   X,0x5
    0B1F: 50 01    MOV   A,0x1
    0B21: 7C 08 E9 LCALL _LCD_1_Position
    0B24: 20       POP   X
(0100) 	cprintf("Start");
    0B25: 50 01    MOV   A,0x1
    0B27: 08       PUSH  A
    0B28: 50 DA    MOV   A,0xDA
    0B2A: 08       PUSH  A
    0B2B: 7C 49 ED LCALL _cprintf
    0B2E: 38 FE    ADD   SP,0xFE
    0B30: 7D 19 B2 LJMP  0x19B2
(0101) 	
(0102) 	//main loop
(0103) 	while (TRUE)
(0104) 	{
(0105) 		
(0106) 		//I2C Read
(0107) 		if (bitCheck(MBM_1_MyMailbox.Outbox.OutboxFlag, I2CIO_UPDATE))
    0B33: 62 D0 00 MOV   REG[0xD0],0x0
    0B36: 47 28 20 TST   [MBM_1_MyMailbox+2],0x20
    0B39: A0 56    JZ    0x0B90
(0108) 		{
(0109) 			BYTE wate;
(0110) 			bitSet(MBM_1_MyMailbox.Outbox.OutboxFlag, I2CIO_READ);
    0B3B: 2E 28 40 OR    [MBM_1_MyMailbox+2],0x40
(0111) 			for (wate = 0; wate < 0xff; wate++)
    0B3E: 56 00 00 MOV   [X+0],0x0
    0B41: 80 43    JMP   0x0B85
(0112) 			{
(0113) 				if (bitCheck(~MBM_1_MyMailbox.Outbox.OutboxFlag, I2CIO_WRITE))
    0B43: 62 D0 00 MOV   REG[0xD0],0x0
    0B46: 51 28    MOV   A,[MBM_1_MyMailbox+2]
    0B48: 73       CPL   A
    0B49: 62 D0 00 MOV   REG[0xD0],0x0
    0B4C: 53 49    MOV   [__r0],A
    0B4E: 26 49 80 AND   [__r0],0x80
    0B51: A0 31    JZ    0x0B83
(0114) 				{
(0115) 					OutboxBuff = MBM_1_MyMailbox.Outbox;
    0B53: 55 48 28 MOV   [__r1],0x28
    0B56: 55 49 00 MOV   [__r0],0x0
    0B59: 55 46 59 MOV   [__r3],0x59
    0B5C: 55 47 00 MOV   [__r2],0x0
    0B5F: 51 49    MOV   A,[__r0]
    0B61: 60 D4    MOV   REG[0xD4],A
    0B63: 51 47    MOV   A,[__r2]
    0B65: 60 D5    MOV   REG[0xD5],A
    0B67: 10       PUSH  X
    0B68: 57 0E    MOV   X,0xE
    0B6A: 62 D0 00 MOV   REG[0xD0],0x0
    0B6D: 3E 48    MVI   A,[__r1]
    0B6F: 3F 46    MVI   [__r3],A
    0B71: 79       DEC   X
    0B72: BF F7    JNZ   0x0B6A
    0B74: 20       POP   X
(0116) 					bitClear(MBM_1_MyMailbox.Outbox.OutboxFlag, I2CIO_UPDATE);
    0B75: 62 D0 00 MOV   REG[0xD0],0x0
    0B78: 26 28 DF AND   [MBM_1_MyMailbox+2],0xDF
(0117) 					i2cchekc = TRUE;
    0B7B: 62 D0 00 MOV   REG[0xD0],0x0
    0B7E: 55 96 01 MOV   [i2cchekc],0x1
(0118) 					break;
    0B81: 80 08    JMP   0x0B8A
(0119) 				}
(0120) 			}
    0B83: 77 00    INC   [X+0]
    0B85: 3D 00 FF CMP   [X+0],0xFF
    0B88: CF BA    JC    0x0B43
(0121) 			bitClear(MBM_1_MyMailbox.Outbox.OutboxFlag, I2CIO_READ);
    0B8A: 62 D0 00 MOV   REG[0xD0],0x0
    0B8D: 26 28 BF AND   [MBM_1_MyMailbox+2],0xBF
(0122) 		}
(0123) 		
(0124) 		//I2C Write
(0125) 		if (bitCheck(InboxBuff.InboxFlag, I2CIO_UPDATE))
    0B90: 62 D0 00 MOV   REG[0xD0],0x0
    0B93: 47 67 20 TST   [InboxBuff],0x20
    0B96: A0 5F    JZ    0x0BF6
(0126) 		{
(0127) 			BYTE wate;
(0128) 			bitSet(MBM_1_MyMailbox.Inbox.InboxFlag, I2CIO_WRITE);
    0B98: 62 D0 00 MOV   REG[0xD0],0x0
    0B9B: 2E 36 80 OR    [MBM_1_MyMailbox+16],0x80
(0129) 			for (wate = 0; wate < 0xff; wate++)
    0B9E: 56 00 00 MOV   [X+0],0x0
    0BA1: 80 49    JMP   0x0BEB
(0130) 			{
(0131) 				if (~bitCheck(MBM_1_MyMailbox.Inbox.InboxFlag, I2CIO_READ))
    0BA3: 62 D0 00 MOV   REG[0xD0],0x0
    0BA6: 51 36    MOV   A,[MBM_1_MyMailbox+16]
    0BA8: 21 40    AND   A,0x40
    0BAA: 73       CPL   A
    0BAB: 39 00    CMP   A,0x0
    0BAD: A0 3B    JZ    0x0BE9
(0132) 				{
(0133) 					InboxBuff.InboxFlag = MBM_1_MyMailbox.Inbox.InboxFlag;
    0BAF: 51 36    MOV   A,[MBM_1_MyMailbox+16]
    0BB1: 62 D0 00 MOV   REG[0xD0],0x0
    0BB4: 53 67    MOV   [InboxBuff],A
(0134) 					MBM_1_MyMailbox.Inbox = InboxBuff;
    0BB6: 62 D0 00 MOV   REG[0xD0],0x0
    0BB9: 55 48 67 MOV   [__r1],0x67
    0BBC: 55 49 00 MOV   [__r0],0x0
    0BBF: 55 46 36 MOV   [__r3],0x36
    0BC2: 55 47 00 MOV   [__r2],0x0
    0BC5: 51 49    MOV   A,[__r0]
    0BC7: 60 D4    MOV   REG[0xD4],A
    0BC9: 51 47    MOV   A,[__r2]
    0BCB: 60 D5    MOV   REG[0xD5],A
    0BCD: 10       PUSH  X
    0BCE: 57 05    MOV   X,0x5
    0BD0: 62 D0 00 MOV   REG[0xD0],0x0
    0BD3: 3E 48    MVI   A,[__r1]
    0BD5: 3F 46    MVI   [__r3],A
    0BD7: 79       DEC   X
    0BD8: BF F7    JNZ   0x0BD0
    0BDA: 20       POP   X
(0135) 					bitSet(MBM_1_MyMailbox.Inbox.InboxFlag, I2CIO_UPDATE);
    0BDB: 62 D0 00 MOV   REG[0xD0],0x0
    0BDE: 2E 36 20 OR    [MBM_1_MyMailbox+16],0x20
(0136) 					InboxBuff.InboxFlag = 0;
    0BE1: 62 D0 00 MOV   REG[0xD0],0x0
    0BE4: 55 67 00 MOV   [InboxBuff],0x0
(0137) 					break;
    0BE7: 80 08    JMP   0x0BF0
(0138) 				}
(0139) 			}
    0BE9: 77 00    INC   [X+0]
    0BEB: 3D 00 FF CMP   [X+0],0xFF
    0BEE: CF B4    JC    0x0BA3
(0140) 			bitClear(MBM_1_MyMailbox.Inbox.InboxFlag, I2CIO_WRITE);
    0BF0: 62 D0 00 MOV   REG[0xD0],0x0
    0BF3: 26 36 7F AND   [MBM_1_MyMailbox+16],0x7F
(0141) 		}
(0142) 		
(0143) 		//calclate X motor
(0144) 		if (sw_X)
    0BF6: 62 D0 00 MOV   REG[0xD0],0x0
    0BF9: 3C 97 00 CMP   [sw_X],0x0
    0BFC: A4 3F    JZ    0x103C
(0145) 		{
(0146) 			static BYTE count_X;
(0147) 			static BYTE rd_X;
(0148) 			static INT pwm_X;
(0149) 			static LONG iX;
(0150) 			
(0151) 			//stop & brake 
(0152) 			if (bitCheck(OutboxBuff.TBrakeFlag, STOP_X))
    0BFE: 62 D0 00 MOV   REG[0xD0],0x0
    0C01: 47 5A 01 TST   [OutboxBuff+1],0x1
    0C04: A0 D2    JZ    0x0CD7
(0153) 			{
(0154) 				//brake
(0155) 				if (count_X < (STOPCOUNT_X - STOPINC_X))
    0C06: 62 D0 00 MOV   REG[0xD0],0x0
    0C09: 3C 95 FE CMP   [ct+4],0xFE
    0C0C: D0 A1    JNC   0x0CAE
(0156) 				{
(0157) 					//brake start
(0158) 					if (rd_X)
    0C0E: 62 D0 00 MOV   REG[0xD0],0x0
    0C11: 3C 94 00 CMP   [ct+3],0x0
    0C14: A0 57    JZ    0x0C6C
(0159) 					{
(0160) 						PRS32_X_WriteSeed(0);
    0C16: 10       PUSH  X
    0C17: 50 00    MOV   A,0x0
    0C19: 08       PUSH  A
    0C1A: 08       PUSH  A
    0C1B: 08       PUSH  A
    0C1C: 08       PUSH  A
    0C1D: 7C 07 05 LCALL _PRS32_X_WriteSeed
    0C20: 38 FC    ADD   SP,0xFC
    0C22: 20       POP   X
(0161) 						
(0162) 						//XAH off
(0163) 						XAH_Data_ADDR = bitClear(XAH_DataShadow, XAH_MASK);
    0C23: 62 D0 00 MOV   REG[0xD0],0x0
    0C26: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0C28: 21 F7    AND   A,0xF7
    0C2A: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0C2C: 60 04    MOV   REG[0x4],A
(0164) 						//XBH off
(0165) 						XBH_Data_ADDR = bitClear(XBH_DataShadow, XBH_MASK);
    0C2E: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0C30: 21 EF    AND   A,0xEF
    0C32: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0C34: 60 04    MOV   REG[0x4],A
(0166) 						//XAL prs on
(0167) 						bitSet(XAL_GlobalSelect_ADDR, XAL_MASK);
    0C36: 43 06 04 OR    REG[0x6],0x4
(0168) 						//XBL prs on
(0169) 						bitSet(XBL_GlobalSelect_ADDR, XBL_MASK);
    0C39: 43 06 40 OR    REG[0x6],0x40
(0170) 						
(0171) 						bitSet(InboxBuff.CBrakeFlag, STOP_X);
    0C3C: 62 D0 00 MOV   REG[0xD0],0x0
    0C3F: 2E 68 01 OR    [InboxBuff+1],0x1
(0172) 						bitSet(InboxBuff.InboxFlag, I2CIO_UPDATE);
    0C42: 2E 67 20 OR    [InboxBuff],0x20
(0173) 						InboxBuff.X_crs = 0;
    0C45: 55 69 00 MOV   [InboxBuff+2],0x0
(0174) 						pwm_X = 0;
    0C48: 62 D0 00 MOV   REG[0xD0],0x0
    0C4B: 55 87 00 MOV   [prs_Y+11],0x0
    0C4E: 55 86 00 MOV   [prs_Y+10],0x0
(0175) 						iX = 0;
    0C51: 62 D0 00 MOV   REG[0xD0],0x0
    0C54: 55 78 00 MOV   [prs_Z+4],0x0
    0C57: 55 79 00 MOV   [prs_Z+5],0x0
    0C5A: 55 7A 00 MOV   [prs_Z+6],0x0
    0C5D: 55 7B 00 MOV   [prs_Z+7],0x0
(0176) 						count_X = 0;
    0C60: 62 D0 00 MOV   REG[0xD0],0x0
    0C63: 55 95 00 MOV   [ct+4],0x0
(0177) 						rd_X = STOP;
    0C66: 62 D0 00 MOV   REG[0xD0],0x0
    0C69: 55 94 00 MOV   [ct+3],0x0
(0178) 					}
(0179) 					//set prs
(0180) 					prsSet(prs_X, count_X);
    0C6C: 62 D0 00 MOV   REG[0xD0],0x0
    0C6F: 51 95    MOV   A,[ct+4]
    0C71: 62 D0 00 MOV   REG[0xD0],0x0
    0C74: 53 73    MOV   [prs_X+3],A
    0C76: 62 D0 00 MOV   REG[0xD0],0x0
    0C79: 51 95    MOV   A,[ct+4]
    0C7B: 62 D0 00 MOV   REG[0xD0],0x0
    0C7E: 53 72    MOV   [prs_X+2],A
    0C80: 62 D0 00 MOV   REG[0xD0],0x0
    0C83: 51 95    MOV   A,[ct+4]
    0C85: 62 D0 00 MOV   REG[0xD0],0x0
    0C88: 53 71    MOV   [prs_X+1],A
    0C8A: 62 D0 00 MOV   REG[0xD0],0x0
    0C8D: 51 95    MOV   A,[ct+4]
    0C8F: 62 D0 00 MOV   REG[0xD0],0x0
    0C92: 53 70    MOV   [prs_X],A
(0181) 					PRS32_X_WriteSeed(prs_X);
    0C94: 10       PUSH  X
    0C95: 51 70    MOV   A,[prs_X]
    0C97: 08       PUSH  A
    0C98: 51 71    MOV   A,[prs_X+1]
    0C9A: 08       PUSH  A
    0C9B: 51 72    MOV   A,[prs_X+2]
    0C9D: 08       PUSH  A
    0C9E: 51 73    MOV   A,[prs_X+3]
    0CA0: 08       PUSH  A
    0CA1: 7C 07 05 LCALL _PRS32_X_WriteSeed
    0CA4: 38 FC    ADD   SP,0xFC
    0CA6: 20       POP   X
(0182) 					count_X += STOPINC_X;
    0CA7: 62 D0 00 MOV   REG[0xD0],0x0
    0CAA: 76 95    INC   [ct+4]
(0183) 				}
    0CAC: 83 89    JMP   0x1036
(0184) 				//lock
(0185) 				else if (count_X != 0xff)
    0CAE: 62 D0 00 MOV   REG[0xD0],0x0
    0CB1: 3C 95 FF CMP   [ct+4],0xFF
    0CB4: A3 81    JZ    0x1036
(0186) 				{
(0187) 					//XAL on & prs off
(0188) 					XAL_Data_ADDR = bitSet(XAL_DataShadow, XAL_MASK);
    0CB6: 62 D0 00 MOV   REG[0xD0],0x0
    0CB9: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0CBB: 29 04    OR    A,0x4
    0CBD: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0CBF: 60 04    MOV   REG[0x4],A
(0189) 					bitClear(XAL_GlobalSelect_ADDR, XAL_MASK);
    0CC1: 41 06 FB AND   REG[0x6],0xFB
(0190) 					//XBL on & prs off
(0191) 					XBL_Data_ADDR = bitSet(XBL_DataShadow, XBL_MASK);
    0CC4: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0CC6: 29 40    OR    A,0x40
    0CC8: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0CCA: 60 04    MOV   REG[0x4],A
(0192) 					bitClear(XBL_GlobalSelect_ADDR, XBL_MASK);
    0CCC: 41 06 BF AND   REG[0x6],0xBF
(0193) 					
(0194) 					count_X = 0xff;
    0CCF: 62 D0 00 MOV   REG[0xD0],0x0
    0CD2: 55 95 FF MOV   [ct+4],0xFF
(0195) 				}
(0196) 			}
    0CD5: 83 60    JMP   0x1036
(0197) 			//rotation
(0198) 			else
(0199) 			{
(0200) 				INT pX;
(0201) 				LONG tmpx0;
(0202) 				BYTE tmpx1;
(0203) 				
(0204) 				if (rd_X == STOP)
    0CD7: 62 D0 00 MOV   REG[0xD0],0x0
    0CDA: 3C 94 00 CMP   [ct+3],0x0
    0CDD: B0 0D    JNZ   0x0CEB
(0205) 				{
(0206) 					bitClear(InboxBuff.CBrakeFlag, STOP_X);
    0CDF: 62 D0 00 MOV   REG[0xD0],0x0
    0CE2: 26 68 FE AND   [InboxBuff+1],0xFE
(0207) 					count_X = 0;
    0CE5: 62 D0 00 MOV   REG[0xD0],0x0
    0CE8: 55 95 00 MOV   [ct+4],0x0
(0208) 				}
(0209) 				
(0210) 				//calclate PI
(0211) 				pX = ((*(CHAR *)&(OutboxBuff.X_trs)) - pwm_X);
    0CEB: 62 D0 00 MOV   REG[0xD0],0x0
    0CEE: 51 5B    MOV   A,[OutboxBuff+2]
    0CF0: 62 D0 00 MOV   REG[0xD0],0x0
    0CF3: 53 48    MOV   [__r1],A
    0CF5: 55 49 00 MOV   [__r0],0x0
    0CF8: 47 48 80 TST   [__r1],0x80
    0CFB: A0 04    JZ    0x0D00
    0CFD: 55 49 FF MOV   [__r0],0xFF
    0D00: 62 D0 00 MOV   REG[0xD0],0x0
    0D03: 51 48    MOV   A,[__r1]
    0D05: 62 D0 00 MOV   REG[0xD0],0x0
    0D08: 12 87    SUB   A,[prs_Y+11]
    0D0A: 54 01    MOV   [X+1],A
    0D0C: 62 D0 00 MOV   REG[0xD0],0x0
    0D0F: 51 49    MOV   A,[__r0]
    0D11: 62 D0 00 MOV   REG[0xD0],0x0
    0D14: 1A 86    SBB   A,[prs_Y+10]
    0D16: 54 00    MOV   [X+0],A
(0212) 				iX += pX;
    0D18: 62 D0 00 MOV   REG[0xD0],0x0
    0D1B: 52 01    MOV   A,[X+1]
    0D1D: 53 46    MOV   [__r3],A
    0D1F: 52 00    MOV   A,[X+0]
    0D21: 53 47    MOV   [__r2],A
    0D23: 47 47 80 TST   [__r2],0x80
    0D26: A0 09    JZ    0x0D30
    0D28: 55 48 FF MOV   [__r1],0xFF
    0D2B: 55 49 FF MOV   [__r0],0xFF
    0D2E: 80 0A    JMP   0x0D39
    0D30: 62 D0 00 MOV   REG[0xD0],0x0
    0D33: 55 48 00 MOV   [__r1],0x0
    0D36: 55 49 00 MOV   [__r0],0x0
    0D39: 62 D0 00 MOV   REG[0xD0],0x0
    0D3C: 51 46    MOV   A,[__r3]
    0D3E: 62 D0 00 MOV   REG[0xD0],0x0
    0D41: 04 7B    ADD   [prs_Z+7],A
    0D43: 62 D0 00 MOV   REG[0xD0],0x0
    0D46: 51 47    MOV   A,[__r2]
    0D48: 62 D0 00 MOV   REG[0xD0],0x0
    0D4B: 0C 7A    ADC   [prs_Z+6],A
    0D4D: 62 D0 00 MOV   REG[0xD0],0x0
    0D50: 51 48    MOV   A,[__r1]
    0D52: 62 D0 00 MOV   REG[0xD0],0x0
    0D55: 0C 79    ADC   [prs_Z+5],A
    0D57: 62 D0 00 MOV   REG[0xD0],0x0
    0D5A: 51 49    MOV   A,[__r0]
    0D5C: 62 D0 00 MOV   REG[0xD0],0x0
    0D5F: 0C 78    ADC   [prs_Z+4],A
(0213) 				tmpx0 = (OutboxBuff.Kp_X * (LONG)pX + OutboxBuff.Ki_X * iX);
    0D61: 62 D0 00 MOV   REG[0xD0],0x0
    0D64: 51 60    MOV   A,[OutboxBuff+7]
    0D66: 62 D0 00 MOV   REG[0xD0],0x0
    0D69: 53 46    MOV   [__r3],A
    0D6B: 62 D0 00 MOV   REG[0xD0],0x0
    0D6E: 51 78    MOV   A,[prs_Z+4]
    0D70: 08       PUSH  A
    0D71: 51 79    MOV   A,[prs_Z+5]
    0D73: 08       PUSH  A
    0D74: 51 7A    MOV   A,[prs_Z+6]
    0D76: 08       PUSH  A
    0D77: 51 7B    MOV   A,[prs_Z+7]
    0D79: 08       PUSH  A
    0D7A: 62 D0 00 MOV   REG[0xD0],0x0
    0D7D: 50 00    MOV   A,0x0
    0D7F: 08       PUSH  A
    0D80: 08       PUSH  A
    0D81: 08       PUSH  A
    0D82: 51 46    MOV   A,[__r3]
    0D84: 08       PUSH  A
    0D85: 7C 2E C2 LCALL 0x2EC2
    0D88: 38 FC    ADD   SP,0xFC
    0D8A: 18       POP   A
    0D8B: 53 46    MOV   [__r3],A
    0D8D: 18       POP   A
    0D8E: 53 47    MOV   [__r2],A
    0D90: 18       POP   A
    0D91: 53 48    MOV   [__r1],A
    0D93: 18       POP   A
    0D94: 53 49    MOV   [__r0],A
    0D96: 52 01    MOV   A,[X+1]
    0D98: 53 42    MOV   [__r7],A
    0D9A: 52 00    MOV   A,[X+0]
    0D9C: 53 43    MOV   [__r6],A
    0D9E: 47 43 80 TST   [__r6],0x80
    0DA1: A0 09    JZ    0x0DAB
    0DA3: 55 44 FF MOV   [__r5],0xFF
    0DA6: 55 45 FF MOV   [__r4],0xFF
    0DA9: 80 0A    JMP   0x0DB4
    0DAB: 62 D0 00 MOV   REG[0xD0],0x0
    0DAE: 55 44 00 MOV   [__r5],0x0
    0DB1: 55 45 00 MOV   [__r4],0x0
    0DB4: 62 D0 00 MOV   REG[0xD0],0x0
    0DB7: 51 5F    MOV   A,[OutboxBuff+6]
    0DB9: 62 D0 00 MOV   REG[0xD0],0x0
    0DBC: 53 3E    MOV   [__r11],A
    0DBE: 51 45    MOV   A,[__r4]
    0DC0: 08       PUSH  A
    0DC1: 51 44    MOV   A,[__r5]
    0DC3: 08       PUSH  A
    0DC4: 51 43    MOV   A,[__r6]
    0DC6: 08       PUSH  A
    0DC7: 51 42    MOV   A,[__r7]
    0DC9: 08       PUSH  A
    0DCA: 50 00    MOV   A,0x0
    0DCC: 08       PUSH  A
    0DCD: 08       PUSH  A
    0DCE: 08       PUSH  A
    0DCF: 51 3E    MOV   A,[__r11]
    0DD1: 08       PUSH  A
    0DD2: 7C 2E C2 LCALL 0x2EC2
    0DD5: 38 FC    ADD   SP,0xFC
    0DD7: 18       POP   A
    0DD8: 53 42    MOV   [__r7],A
    0DDA: 18       POP   A
    0DDB: 53 43    MOV   [__r6],A
    0DDD: 18       POP   A
    0DDE: 53 44    MOV   [__r5],A
    0DE0: 18       POP   A
    0DE1: 53 45    MOV   [__r4],A
    0DE3: 51 42    MOV   A,[__r7]
    0DE5: 02 46    ADD   A,[__r3]
    0DE7: 54 05    MOV   [X+5],A
    0DE9: 51 43    MOV   A,[__r6]
    0DEB: 0A 47    ADC   A,[__r2]
    0DED: 54 04    MOV   [X+4],A
    0DEF: 51 44    MOV   A,[__r5]
    0DF1: 0A 48    ADC   A,[__r1]
    0DF3: 54 03    MOV   [X+3],A
    0DF5: 51 45    MOV   A,[__r4]
    0DF7: 0A 49    ADC   A,[__r0]
    0DF9: 54 02    MOV   [X+2],A
(0214) 				if (tmpx0 < 0)
    0DFB: 52 05    MOV   A,[X+5]
    0DFD: 11 00    SUB   A,0x0
    0DFF: 52 04    MOV   A,[X+4]
    0E01: 19 00    SBB   A,0x0
    0E03: 52 03    MOV   A,[X+3]
    0E05: 19 00    SBB   A,0x0
    0E07: 52 02    MOV   A,[X+2]
    0E09: 31 80    XOR   A,0x80
    0E0B: 19 80    SBB   A,0x80
    0E0D: D0 90    JNC   0x0E9E
(0215) 				{
(0216) 					pwm_X += (~((~tmpx0) >> OutboxBuff.bshift_X));
    0E0F: 62 D0 00 MOV   REG[0xD0],0x0
    0E12: 51 5E    MOV   A,[OutboxBuff+5]
    0E14: 62 D0 00 MOV   REG[0xD0],0x0
    0E17: 53 48    MOV   [__r1],A
    0E19: 52 02    MOV   A,[X+2]
    0E1B: 73       CPL   A
    0E1C: 53 45    MOV   [__r4],A
    0E1E: 52 03    MOV   A,[X+3]
    0E20: 73       CPL   A
    0E21: 53 44    MOV   [__r5],A
    0E23: 52 04    MOV   A,[X+4]
    0E25: 73       CPL   A
    0E26: 53 43    MOV   [__r6],A
    0E28: 52 05    MOV   A,[X+5]
    0E2A: 73       CPL   A
    0E2B: 53 42    MOV   [__r7],A
    0E2D: 51 48    MOV   A,[__r1]
    0E2F: 21 1F    AND   A,0x1F
    0E31: A0 0F    JZ    0x0E41
    0E33: 62 D0 00 MOV   REG[0xD0],0x0
    0E36: 68 45    ASR   [__r4]
    0E38: 6E 44    RRC   [__r5]
    0E3A: 6E 43    RRC   [__r6]
    0E3C: 6E 42    RRC   [__r7]
    0E3E: 78       DEC   A
    0E3F: BF F3    JNZ   0x0E33
    0E41: 62 D0 00 MOV   REG[0xD0],0x0
    0E44: 51 43    MOV   A,[__r6]
    0E46: 73       CPL   A
    0E47: 53 47    MOV   [__r2],A
    0E49: 51 42    MOV   A,[__r7]
    0E4B: 73       CPL   A
    0E4C: 53 46    MOV   [__r3],A
    0E4E: 62 D0 00 MOV   REG[0xD0],0x0
    0E51: 51 87    MOV   A,[prs_Y+11]
    0E53: 62 D0 00 MOV   REG[0xD0],0x0
    0E56: 53 42    MOV   [__r7],A
    0E58: 62 D0 00 MOV   REG[0xD0],0x0
    0E5B: 51 86    MOV   A,[prs_Y+10]
    0E5D: 62 D0 00 MOV   REG[0xD0],0x0
    0E60: 53 43    MOV   [__r6],A
    0E62: 47 43 80 TST   [__r6],0x80
    0E65: A0 09    JZ    0x0E6F
    0E67: 55 44 FF MOV   [__r5],0xFF
    0E6A: 55 45 FF MOV   [__r4],0xFF
    0E6D: 80 0A    JMP   0x0E78
    0E6F: 62 D0 00 MOV   REG[0xD0],0x0
    0E72: 55 44 00 MOV   [__r5],0x0
    0E75: 55 45 00 MOV   [__r4],0x0
    0E78: 62 D0 00 MOV   REG[0xD0],0x0
    0E7B: 51 42    MOV   A,[__r7]
    0E7D: 02 46    ADD   A,[__r3]
    0E7F: 53 46    MOV   [__r3],A
    0E81: 51 43    MOV   A,[__r6]
    0E83: 0A 47    ADC   A,[__r2]
    0E85: 53 47    MOV   [__r2],A
    0E87: 51 46    MOV   A,[__r3]
    0E89: 53 48    MOV   [__r1],A
    0E8B: 51 47    MOV   A,[__r2]
    0E8D: 53 49    MOV   [__r0],A
    0E8F: 51 48    MOV   A,[__r1]
    0E91: 08       PUSH  A
    0E92: 51 49    MOV   A,[__r0]
    0E94: 62 D0 00 MOV   REG[0xD0],0x0
    0E97: 53 86    MOV   [prs_Y+10],A
    0E99: 18       POP   A
    0E9A: 53 87    MOV   [prs_Y+11],A
(0217) 				}
    0E9C: 80 79    JMP   0x0F16
(0218) 				else
(0219) 				{
(0220) 					pwm_X += (tmpx0 >> OutboxBuff.bshift_X);
    0E9E: 62 D0 00 MOV   REG[0xD0],0x0
    0EA1: 51 5E    MOV   A,[OutboxBuff+5]
    0EA3: 62 D0 00 MOV   REG[0xD0],0x0
    0EA6: 53 48    MOV   [__r1],A
    0EA8: 52 02    MOV   A,[X+2]
    0EAA: 53 45    MOV   [__r4],A
    0EAC: 52 03    MOV   A,[X+3]
    0EAE: 53 44    MOV   [__r5],A
    0EB0: 52 04    MOV   A,[X+4]
    0EB2: 53 43    MOV   [__r6],A
    0EB4: 52 05    MOV   A,[X+5]
    0EB6: 53 42    MOV   [__r7],A
    0EB8: 51 48    MOV   A,[__r1]
    0EBA: 21 1F    AND   A,0x1F
    0EBC: A0 0F    JZ    0x0ECC
    0EBE: 62 D0 00 MOV   REG[0xD0],0x0
    0EC1: 68 45    ASR   [__r4]
    0EC3: 6E 44    RRC   [__r5]
    0EC5: 6E 43    RRC   [__r6]
    0EC7: 6E 42    RRC   [__r7]
    0EC9: 78       DEC   A
    0ECA: BF F3    JNZ   0x0EBE
    0ECC: 62 D0 00 MOV   REG[0xD0],0x0
    0ECF: 51 87    MOV   A,[prs_Y+11]
    0ED1: 62 D0 00 MOV   REG[0xD0],0x0
    0ED4: 53 46    MOV   [__r3],A
    0ED6: 62 D0 00 MOV   REG[0xD0],0x0
    0ED9: 51 86    MOV   A,[prs_Y+10]
    0EDB: 62 D0 00 MOV   REG[0xD0],0x0
    0EDE: 53 47    MOV   [__r2],A
    0EE0: 47 47 80 TST   [__r2],0x80
    0EE3: A0 09    JZ    0x0EED
    0EE5: 55 48 FF MOV   [__r1],0xFF
    0EE8: 55 49 FF MOV   [__r0],0xFF
    0EEB: 80 0A    JMP   0x0EF6
    0EED: 62 D0 00 MOV   REG[0xD0],0x0
    0EF0: 55 48 00 MOV   [__r1],0x0
    0EF3: 55 49 00 MOV   [__r0],0x0
    0EF6: 62 D0 00 MOV   REG[0xD0],0x0
    0EF9: 51 42    MOV   A,[__r7]
    0EFB: 04 46    ADD   [__r3],A
    0EFD: 51 43    MOV   A,[__r6]
    0EFF: 0C 47    ADC   [__r2],A
    0F01: 51 46    MOV   A,[__r3]
    0F03: 53 48    MOV   [__r1],A
    0F05: 51 47    MOV   A,[__r2]
    0F07: 53 49    MOV   [__r0],A
    0F09: 51 48    MOV   A,[__r1]
    0F0B: 08       PUSH  A
    0F0C: 51 49    MOV   A,[__r0]
    0F0E: 62 D0 00 MOV   REG[0xD0],0x0
    0F11: 53 86    MOV   [prs_Y+10],A
    0F13: 18       POP   A
    0F14: 53 87    MOV   [prs_Y+11],A
(0221) 				}
(0222) 				
(0223) 				//CCW
(0224) 				if (pwm_X < 0)
    0F16: 62 D0 00 MOV   REG[0xD0],0x0
    0F19: 51 87    MOV   A,[prs_Y+11]
    0F1B: 11 00    SUB   A,0x0
    0F1D: 51 86    MOV   A,[prs_Y+10]
    0F1F: 31 80    XOR   A,0x80
    0F21: 19 80    SBB   A,0x80
    0F23: D0 82    JNC   0x0FA6
(0225) 				{
(0226) 					if (bitCheck(~rd_X, CCW))
    0F25: 62 D0 00 MOV   REG[0xD0],0x0
    0F28: 51 94    MOV   A,[ct+3]
    0F2A: 73       CPL   A
    0F2B: 62 D0 00 MOV   REG[0xD0],0x0
    0F2E: 53 49    MOV   [__r0],A
    0F30: 26 49 02 AND   [__r0],0x2
    0F33: A0 35    JZ    0x0F69
(0227) 					{
(0228) 						PRS32_X_WriteSeed(0);
    0F35: 10       PUSH  X
    0F36: 50 00    MOV   A,0x0
    0F38: 08       PUSH  A
    0F39: 08       PUSH  A
    0F3A: 08       PUSH  A
    0F3B: 08       PUSH  A
    0F3C: 7C 07 05 LCALL _PRS32_X_WriteSeed
    0F3F: 38 FC    ADD   SP,0xFC
    0F41: 20       POP   X
(0229) 						
(0230) 						//XAH off
(0231) 						XAH_Data_ADDR = bitClear(XAH_DataShadow, XAH_MASK);
    0F42: 62 D0 00 MOV   REG[0xD0],0x0
    0F45: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0F47: 21 F7    AND   A,0xF7
    0F49: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0F4B: 60 04    MOV   REG[0x4],A
(0232) 						//XBL & prs off
(0233) 						XBL_Data_ADDR = bitClear(XBL_DataShadow, XBL_MASK);
    0F4D: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0F4F: 21 BF    AND   A,0xBF
    0F51: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0F53: 60 04    MOV   REG[0x4],A
(0234) 						bitClear(XBL_GlobalSelect_ADDR, XBL_MASK);
    0F55: 41 06 BF AND   REG[0x6],0xBF
(0235) 						//XBH on
(0236) 						XBH_Data_ADDR = bitSet(XBH_DataShadow, XBH_MASK);
    0F58: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0F5A: 29 10    OR    A,0x10
    0F5C: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0F5E: 60 04    MOV   REG[0x4],A
(0237) 						//XAL prs on
(0238) 						bitSet(XAL_GlobalSelect_ADDR, XAL_MASK);
    0F60: 43 06 04 OR    REG[0x6],0x4
(0239) 						
(0240) 						rd_X = CCW;
    0F63: 62 D0 00 MOV   REG[0xD0],0x0
    0F66: 55 94 02 MOV   [ct+3],0x2
(0241) 					}
(0242) 					
(0243) 					if (pwm_X <= -128)
    0F69: 62 D0 00 MOV   REG[0xD0],0x0
    0F6C: 50 80    MOV   A,0x80
    0F6E: 12 87    SUB   A,[prs_Y+11]
    0F70: 51 86    MOV   A,[prs_Y+10]
    0F72: 31 80    XOR   A,0x80
    0F74: 62 D0 00 MOV   REG[0xD0],0x0
    0F77: 53 3D    MOV   [__rX],A
    0F79: 50 7F    MOV   A,0x7F
    0F7B: 1A 3D    SBB   A,[__rX]
    0F7D: C0 0C    JC    0x0F8A
(0244) 					{
(0245) 						InboxBuff.X_crs = 0x80;
    0F7F: 62 D0 00 MOV   REG[0xD0],0x0
    0F82: 55 69 80 MOV   [InboxBuff+2],0x80
(0246) 						tmpx1 = 255;
    0F85: 56 06 FF MOV   [X+6],0xFF
(0247) 					}
    0F88: 80 94    JMP   0x101D
(0248) 					else
(0249) 					{
(0250) 						(*(CHAR *)&(InboxBuff.X_crs)) = pwm_X;
    0F8A: 62 D0 00 MOV   REG[0xD0],0x0
    0F8D: 51 87    MOV   A,[prs_Y+11]
    0F8F: 62 D0 00 MOV   REG[0xD0],0x0
    0F92: 53 69    MOV   [InboxBuff+2],A
(0251) 						tmpx1 = (((~InboxBuff.X_crs) << 1) + 1);
    0F94: 51 69    MOV   A,[InboxBuff+2]
    0F96: 73       CPL   A
    0F97: 62 D0 00 MOV   REG[0xD0],0x0
    0F9A: 53 49    MOV   [__r0],A
    0F9C: 65 49    ASL   [__r0]
    0F9E: 51 49    MOV   A,[__r0]
    0FA0: 01 01    ADD   A,0x1
    0FA2: 54 06    MOV   [X+6],A
(0252) 					}
(0253) 				}
    0FA4: 80 78    JMP   0x101D
(0254) 				//CW
(0255) 				else
(0256) 				{
(0257) 					if (bitCheck(~rd_X, CW))
    0FA6: 62 D0 00 MOV   REG[0xD0],0x0
    0FA9: 51 94    MOV   A,[ct+3]
    0FAB: 73       CPL   A
    0FAC: 62 D0 00 MOV   REG[0xD0],0x0
    0FAF: 53 49    MOV   [__r0],A
    0FB1: 26 49 01 AND   [__r0],0x1
    0FB4: A0 35    JZ    0x0FEA
(0258) 					{
(0259) 						PRS32_X_WriteSeed(0);
    0FB6: 10       PUSH  X
    0FB7: 50 00    MOV   A,0x0
    0FB9: 08       PUSH  A
    0FBA: 08       PUSH  A
    0FBB: 08       PUSH  A
    0FBC: 08       PUSH  A
    0FBD: 7C 07 05 LCALL _PRS32_X_WriteSeed
    0FC0: 38 FC    ADD   SP,0xFC
    0FC2: 20       POP   X
(0260) 						
(0261) 						//XBH off
(0262) 						XBH_Data_ADDR = bitClear(XBH_DataShadow, XBH_MASK);
    0FC3: 62 D0 00 MOV   REG[0xD0],0x0
    0FC6: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0FC8: 21 EF    AND   A,0xEF
    0FCA: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0FCC: 60 04    MOV   REG[0x4],A
(0263) 						//XAL & prs off
(0264) 						XAL_Data_ADDR = bitClear(XAL_DataShadow, XAL_MASK);
    0FCE: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0FD0: 21 FB    AND   A,0xFB
    0FD2: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0FD4: 60 04    MOV   REG[0x4],A
(0265) 						bitClear(XAL_GlobalSelect_ADDR, XAL_MASK);
    0FD6: 41 06 FB AND   REG[0x6],0xFB
(0266) 						//XAH on
(0267) 						XAH_Data_ADDR = bitSet(XAH_DataShadow, XAH_MASK);
    0FD9: 51 01    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1]
    0FDB: 29 08    OR    A,0x8
    0FDD: 53 01    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+1],A
    0FDF: 60 04    MOV   REG[0x4],A
(0268) 						//XBL prs on
(0269) 						bitSet(XBL_GlobalSelect_ADDR, XBL_MASK);
    0FE1: 43 06 40 OR    REG[0x6],0x40
(0270) 						
(0271) 						rd_X = CW;
    0FE4: 62 D0 00 MOV   REG[0xD0],0x0
    0FE7: 55 94 01 MOV   [ct+3],0x1
(0272) 					}
(0273) 					
(0274) 					if (pwm_X >= 127)
    0FEA: 62 D0 00 MOV   REG[0xD0],0x0
    0FED: 51 87    MOV   A,[prs_Y+11]
    0FEF: 11 7F    SUB   A,0x7F
    0FF1: 51 86    MOV   A,[prs_Y+10]
    0FF3: 31 80    XOR   A,0x80
    0FF5: 19 80    SBB   A,0x80
    0FF7: C0 0C    JC    0x1004
(0275) 					{
(0276) 						InboxBuff.X_crs = 0x7f;
    0FF9: 62 D0 00 MOV   REG[0xD0],0x0
    0FFC: 55 69 7F MOV   [InboxBuff+2],0x7F
(0277) 						tmpx1 = 255;
    0FFF: 56 06 FF MOV   [X+6],0xFF
(0278) 					}
    1002: 80 1A    JMP   0x101D
(0279) 					else
(0280) 					{
(0281) 						(*(CHAR *)&(InboxBuff.X_crs)) = pwm_X;
    1004: 62 D0 00 MOV   REG[0xD0],0x0
    1007: 51 87    MOV   A,[prs_Y+11]
    1009: 62 D0 00 MOV   REG[0xD0],0x0
    100C: 53 69    MOV   [InboxBuff+2],A
(0282) 						tmpx1 = ((InboxBuff.X_crs << 1) + 1);
    100E: 51 69    MOV   A,[InboxBuff+2]
    1010: 62 D0 00 MOV   REG[0xD0],0x0
    1013: 53 49    MOV   [__r0],A
    1015: 65 49    ASL   [__r0]
    1017: 51 49    MOV   A,[__r0]
    1019: 01 01    ADD   A,0x1
    101B: 54 06    MOV   [X+6],A
(0283) 					}
(0284) 				}
(0285) 				
(0286) 				prsSet(prs_X, tmpx1);
    101D: 52 06    MOV   A,[X+6]
    101F: 62 D0 00 MOV   REG[0xD0],0x0
    1022: 53 73    MOV   [prs_X+3],A
    1024: 52 06    MOV   A,[X+6]
    1026: 53 72    MOV   [prs_X+2],A
    1028: 52 06    MOV   A,[X+6]
    102A: 53 71    MOV   [prs_X+1],A
    102C: 52 06    MOV   A,[X+6]
    102E: 53 70    MOV   [prs_X],A
(0287) 				bitSet(InboxBuff.InboxFlag, I2CIO_UPDATE);
    1030: 62 D0 00 MOV   REG[0xD0],0x0
    1033: 2E 67 20 OR    [InboxBuff],0x20
(0288) 			}
(0289) 			
(0290) 			sw_X = FALSE;
    1036: 62 D0 00 MOV   REG[0xD0],0x0
    1039: 55 97 00 MOV   [sw_X],0x0
(0291) 		}
(0292) 		//end X
(0293) 		
(0294) 		//calclate Y motor
(0295) 		if (sw_Y)
    103C: 62 D0 00 MOV   REG[0xD0],0x0
    103F: 3C 98 00 CMP   [sw_Y],0x0
    1042: A4 3F    JZ    0x1482
(0296) 		{
(0297) 			static BYTE count_Y;
(0298) 			static BYTE rd_Y;
(0299) 			static INT pwm_Y;
(0300) 			static LONG iY;
(0301) 			
(0302) 			//stop & brake 
(0303) 			if (bitCheck(OutboxBuff.TBrakeFlag, STOP_Y))
    1044: 62 D0 00 MOV   REG[0xD0],0x0
    1047: 47 5A 02 TST   [OutboxBuff+1],0x2
    104A: A0 D2    JZ    0x111D
(0304) 			{
(0305) 				//brake
(0306) 				if (count_Y < (STOPCOUNT_Y - STOPINC_Y))
    104C: 62 D0 00 MOV   REG[0xD0],0x0
    104F: 3C 93 FE CMP   [ct+2],0xFE
    1052: D0 A1    JNC   0x10F4
(0307) 				{
(0308) 					//brake start
(0309) 					if (rd_Y)
    1054: 62 D0 00 MOV   REG[0xD0],0x0
    1057: 3C 92 00 CMP   [ct+1],0x0
    105A: A0 57    JZ    0x10B2
(0310) 					{
(0311) 						PRS32_Y_WriteSeed(0);
    105C: 10       PUSH  X
    105D: 50 00    MOV   A,0x0
    105F: 08       PUSH  A
    1060: 08       PUSH  A
    1061: 08       PUSH  A
    1062: 08       PUSH  A
    1063: 7C 06 9E LCALL _PRS32_Y_WriteSeed
    1066: 38 FC    ADD   SP,0xFC
    1068: 20       POP   X
(0312) 						
(0313) 						//YAH off
(0314) 						YAH_Data_ADDR = bitClear(YAH_DataShadow, YAH_MASK);
    1069: 62 D0 00 MOV   REG[0xD0],0x0
    106C: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    106E: 21 FE    AND   A,0xFE
    1070: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1072: 60 08    MOV   REG[0x8],A
(0315) 						//YBH off
(0316) 						YBH_Data_ADDR = bitClear(YBH_DataShadow, YBH_MASK);
    1074: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1076: 21 F7    AND   A,0xF7
    1078: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    107A: 60 08    MOV   REG[0x8],A
(0317) 						//YAL prs on
(0318) 						bitSet(YAL_GlobalSelect_ADDR, YAL_MASK);
    107C: 43 0A 02 OR    REG[0xA],0x2
(0319) 						//YBL prs on
(0320) 						bitSet(YBL_GlobalSelect_ADDR, YBL_MASK);
    107F: 43 0A 20 OR    REG[0xA],0x20
(0321) 						
(0322) 						bitSet(InboxBuff.CBrakeFlag, STOP_Y);
    1082: 62 D0 00 MOV   REG[0xD0],0x0
    1085: 2E 68 02 OR    [InboxBuff+1],0x2
(0323) 						bitSet(InboxBuff.InboxFlag, I2CIO_UPDATE);
    1088: 2E 67 20 OR    [InboxBuff],0x20
(0324) 						InboxBuff.Y_crs = 0;
    108B: 55 6A 00 MOV   [InboxBuff+3],0x0
(0325) 						pwm_Y = 0;
    108E: 62 D0 00 MOV   REG[0xD0],0x0
    1091: 55 85 00 MOV   [prs_Y+9],0x0
    1094: 55 84 00 MOV   [prs_Y+8],0x0
(0326) 						iY = 0;
    1097: 62 D0 00 MOV   REG[0xD0],0x0
    109A: 55 80 00 MOV   [prs_Y+4],0x0
    109D: 55 81 00 MOV   [prs_Y+5],0x0
    10A0: 55 82 00 MOV   [prs_Y+6],0x0
    10A3: 55 83 00 MOV   [prs_Y+7],0x0
(0327) 						count_Y = 0;
    10A6: 62 D0 00 MOV   REG[0xD0],0x0
    10A9: 55 93 00 MOV   [ct+2],0x0
(0328) 						rd_Y = STOP;
    10AC: 62 D0 00 MOV   REG[0xD0],0x0
    10AF: 55 92 00 MOV   [ct+1],0x0
(0329) 					}
(0330) 					//set prs
(0331) 					prsSet(prs_Y, count_Y);
    10B2: 62 D0 00 MOV   REG[0xD0],0x0
    10B5: 51 93    MOV   A,[ct+2]
    10B7: 62 D0 00 MOV   REG[0xD0],0x0
    10BA: 53 7F    MOV   [prs_Y+3],A
    10BC: 62 D0 00 MOV   REG[0xD0],0x0
    10BF: 51 93    MOV   A,[ct+2]
    10C1: 62 D0 00 MOV   REG[0xD0],0x0
    10C4: 53 7E    MOV   [prs_Y+2],A
    10C6: 62 D0 00 MOV   REG[0xD0],0x0
    10C9: 51 93    MOV   A,[ct+2]
    10CB: 62 D0 00 MOV   REG[0xD0],0x0
    10CE: 53 7D    MOV   [prs_Y+1],A
    10D0: 62 D0 00 MOV   REG[0xD0],0x0
    10D3: 51 93    MOV   A,[ct+2]
    10D5: 62 D0 00 MOV   REG[0xD0],0x0
    10D8: 53 7C    MOV   [prs_Y],A
(0332) 					PRS32_Y_WriteSeed(prs_Y);
    10DA: 10       PUSH  X
    10DB: 51 7C    MOV   A,[prs_Y]
    10DD: 08       PUSH  A
    10DE: 51 7D    MOV   A,[prs_Y+1]
    10E0: 08       PUSH  A
    10E1: 51 7E    MOV   A,[prs_Y+2]
    10E3: 08       PUSH  A
    10E4: 51 7F    MOV   A,[prs_Y+3]
    10E6: 08       PUSH  A
    10E7: 7C 06 9E LCALL _PRS32_Y_WriteSeed
    10EA: 38 FC    ADD   SP,0xFC
    10EC: 20       POP   X
(0333) 					count_Y += STOPINC_Y;
    10ED: 62 D0 00 MOV   REG[0xD0],0x0
    10F0: 76 93    INC   [ct+2]
(0334) 				}
    10F2: 83 89    JMP   0x147C
(0335) 				//lock
(0336) 				else if (count_Y != 0xff)
    10F4: 62 D0 00 MOV   REG[0xD0],0x0
    10F7: 3C 93 FF CMP   [ct+2],0xFF
    10FA: A3 81    JZ    0x147C
(0337) 				{
(0338) 					//YAL on & prs off
(0339) 					YAL_Data_ADDR = bitSet(YAL_DataShadow, YAL_MASK);
    10FC: 62 D0 00 MOV   REG[0xD0],0x0
    10FF: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1101: 29 02    OR    A,0x2
    1103: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1105: 60 08    MOV   REG[0x8],A
(0340) 					bitClear(YAL_GlobalSelect_ADDR, YAL_MASK);
    1107: 41 0A FD AND   REG[0xA],0xFD
(0341) 					//YBL on & prs off
(0342) 					YBL_Data_ADDR = bitSet(YBL_DataShadow, YBL_MASK);
    110A: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    110C: 29 20    OR    A,0x20
    110E: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1110: 60 08    MOV   REG[0x8],A
(0343) 					bitClear(YBL_GlobalSelect_ADDR, YBL_MASK);
    1112: 41 0A DF AND   REG[0xA],0xDF
(0344) 					
(0345) 					count_Y = 0xff;
    1115: 62 D0 00 MOV   REG[0xD0],0x0
    1118: 55 93 FF MOV   [ct+2],0xFF
(0346) 				}
(0347) 			}
    111B: 83 60    JMP   0x147C
(0348) 			//rotation
(0349) 			else
(0350) 			{
(0351) 				INT pY;
(0352) 				LONG tmpx0;
(0353) 				BYTE tmpx1;
(0354) 				
(0355) 				if (rd_Y == STOP)
    111D: 62 D0 00 MOV   REG[0xD0],0x0
    1120: 3C 92 00 CMP   [ct+1],0x0
    1123: B0 0D    JNZ   0x1131
(0356) 				{
(0357) 					bitClear(InboxBuff.CBrakeFlag, STOP_Y);
    1125: 62 D0 00 MOV   REG[0xD0],0x0
    1128: 26 68 FD AND   [InboxBuff+1],0xFD
(0358) 					count_Y = 0;
    112B: 62 D0 00 MOV   REG[0xD0],0x0
    112E: 55 93 00 MOV   [ct+2],0x0
(0359) 				}
(0360) 				
(0361) 				//calclate PI
(0362) 				pY = ((*(CHAR *)&(OutboxBuff.Y_trs)) - pwm_Y);
    1131: 62 D0 00 MOV   REG[0xD0],0x0
    1134: 51 5C    MOV   A,[OutboxBuff+3]
    1136: 62 D0 00 MOV   REG[0xD0],0x0
    1139: 53 48    MOV   [__r1],A
    113B: 55 49 00 MOV   [__r0],0x0
    113E: 47 48 80 TST   [__r1],0x80
    1141: A0 04    JZ    0x1146
    1143: 55 49 FF MOV   [__r0],0xFF
    1146: 62 D0 00 MOV   REG[0xD0],0x0
    1149: 51 48    MOV   A,[__r1]
    114B: 62 D0 00 MOV   REG[0xD0],0x0
    114E: 12 85    SUB   A,[prs_Y+9]
    1150: 54 01    MOV   [X+1],A
    1152: 62 D0 00 MOV   REG[0xD0],0x0
    1155: 51 49    MOV   A,[__r0]
    1157: 62 D0 00 MOV   REG[0xD0],0x0
    115A: 1A 84    SBB   A,[prs_Y+8]
    115C: 54 00    MOV   [X+0],A
(0363) 				iY += pY;
    115E: 62 D0 00 MOV   REG[0xD0],0x0
    1161: 52 01    MOV   A,[X+1]
    1163: 53 46    MOV   [__r3],A
    1165: 52 00    MOV   A,[X+0]
    1167: 53 47    MOV   [__r2],A
    1169: 47 47 80 TST   [__r2],0x80
    116C: A0 09    JZ    0x1176
    116E: 55 48 FF MOV   [__r1],0xFF
    1171: 55 49 FF MOV   [__r0],0xFF
    1174: 80 0A    JMP   0x117F
    1176: 62 D0 00 MOV   REG[0xD0],0x0
    1179: 55 48 00 MOV   [__r1],0x0
    117C: 55 49 00 MOV   [__r0],0x0
    117F: 62 D0 00 MOV   REG[0xD0],0x0
    1182: 51 46    MOV   A,[__r3]
    1184: 62 D0 00 MOV   REG[0xD0],0x0
    1187: 04 83    ADD   [prs_Y+7],A
    1189: 62 D0 00 MOV   REG[0xD0],0x0
    118C: 51 47    MOV   A,[__r2]
    118E: 62 D0 00 MOV   REG[0xD0],0x0
    1191: 0C 82    ADC   [prs_Y+6],A
    1193: 62 D0 00 MOV   REG[0xD0],0x0
    1196: 51 48    MOV   A,[__r1]
    1198: 62 D0 00 MOV   REG[0xD0],0x0
    119B: 0C 81    ADC   [prs_Y+5],A
    119D: 62 D0 00 MOV   REG[0xD0],0x0
    11A0: 51 49    MOV   A,[__r0]
    11A2: 62 D0 00 MOV   REG[0xD0],0x0
    11A5: 0C 80    ADC   [prs_Y+4],A
(0364) 				tmpx0 = (OutboxBuff.Kp_Y * (LONG)pY + OutboxBuff.Ki_Y * iY);
    11A7: 62 D0 00 MOV   REG[0xD0],0x0
    11AA: 51 63    MOV   A,[OutboxBuff+10]
    11AC: 62 D0 00 MOV   REG[0xD0],0x0
    11AF: 53 46    MOV   [__r3],A
    11B1: 62 D0 00 MOV   REG[0xD0],0x0
    11B4: 51 80    MOV   A,[prs_Y+4]
    11B6: 08       PUSH  A
    11B7: 51 81    MOV   A,[prs_Y+5]
    11B9: 08       PUSH  A
    11BA: 51 82    MOV   A,[prs_Y+6]
    11BC: 08       PUSH  A
    11BD: 51 83    MOV   A,[prs_Y+7]
    11BF: 08       PUSH  A
    11C0: 62 D0 00 MOV   REG[0xD0],0x0
    11C3: 50 00    MOV   A,0x0
    11C5: 08       PUSH  A
    11C6: 08       PUSH  A
    11C7: 08       PUSH  A
    11C8: 51 46    MOV   A,[__r3]
    11CA: 08       PUSH  A
    11CB: 7C 2E C2 LCALL 0x2EC2
    11CE: 38 FC    ADD   SP,0xFC
    11D0: 18       POP   A
    11D1: 53 46    MOV   [__r3],A
    11D3: 18       POP   A
    11D4: 53 47    MOV   [__r2],A
    11D6: 18       POP   A
    11D7: 53 48    MOV   [__r1],A
    11D9: 18       POP   A
    11DA: 53 49    MOV   [__r0],A
    11DC: 52 01    MOV   A,[X+1]
    11DE: 53 42    MOV   [__r7],A
    11E0: 52 00    MOV   A,[X+0]
    11E2: 53 43    MOV   [__r6],A
    11E4: 47 43 80 TST   [__r6],0x80
    11E7: A0 09    JZ    0x11F1
    11E9: 55 44 FF MOV   [__r5],0xFF
    11EC: 55 45 FF MOV   [__r4],0xFF
    11EF: 80 0A    JMP   0x11FA
    11F1: 62 D0 00 MOV   REG[0xD0],0x0
    11F4: 55 44 00 MOV   [__r5],0x0
    11F7: 55 45 00 MOV   [__r4],0x0
    11FA: 62 D0 00 MOV   REG[0xD0],0x0
    11FD: 51 62    MOV   A,[OutboxBuff+9]
    11FF: 62 D0 00 MOV   REG[0xD0],0x0
    1202: 53 3E    MOV   [__r11],A
    1204: 51 45    MOV   A,[__r4]
    1206: 08       PUSH  A
    1207: 51 44    MOV   A,[__r5]
    1209: 08       PUSH  A
    120A: 51 43    MOV   A,[__r6]
    120C: 08       PUSH  A
    120D: 51 42    MOV   A,[__r7]
    120F: 08       PUSH  A
    1210: 50 00    MOV   A,0x0
    1212: 08       PUSH  A
    1213: 08       PUSH  A
    1214: 08       PUSH  A
    1215: 51 3E    MOV   A,[__r11]
    1217: 08       PUSH  A
    1218: 7C 2E C2 LCALL 0x2EC2
    121B: 38 FC    ADD   SP,0xFC
    121D: 18       POP   A
    121E: 53 42    MOV   [__r7],A
    1220: 18       POP   A
    1221: 53 43    MOV   [__r6],A
    1223: 18       POP   A
    1224: 53 44    MOV   [__r5],A
    1226: 18       POP   A
    1227: 53 45    MOV   [__r4],A
    1229: 51 42    MOV   A,[__r7]
    122B: 02 46    ADD   A,[__r3]
    122D: 54 05    MOV   [X+5],A
    122F: 51 43    MOV   A,[__r6]
    1231: 0A 47    ADC   A,[__r2]
    1233: 54 04    MOV   [X+4],A
    1235: 51 44    MOV   A,[__r5]
    1237: 0A 48    ADC   A,[__r1]
    1239: 54 03    MOV   [X+3],A
    123B: 51 45    MOV   A,[__r4]
    123D: 0A 49    ADC   A,[__r0]
    123F: 54 02    MOV   [X+2],A
(0365) 				if (tmpx0 < 0)
    1241: 52 05    MOV   A,[X+5]
    1243: 11 00    SUB   A,0x0
    1245: 52 04    MOV   A,[X+4]
    1247: 19 00    SBB   A,0x0
    1249: 52 03    MOV   A,[X+3]
    124B: 19 00    SBB   A,0x0
    124D: 52 02    MOV   A,[X+2]
    124F: 31 80    XOR   A,0x80
    1251: 19 80    SBB   A,0x80
    1253: D0 90    JNC   0x12E4
(0366) 				{
(0367) 					pwm_Y += (~((~tmpx0) >> OutboxBuff.bshift_Y));
    1255: 62 D0 00 MOV   REG[0xD0],0x0
    1258: 51 61    MOV   A,[OutboxBuff+8]
    125A: 62 D0 00 MOV   REG[0xD0],0x0
    125D: 53 48    MOV   [__r1],A
    125F: 52 02    MOV   A,[X+2]
    1261: 73       CPL   A
    1262: 53 45    MOV   [__r4],A
    1264: 52 03    MOV   A,[X+3]
    1266: 73       CPL   A
    1267: 53 44    MOV   [__r5],A
    1269: 52 04    MOV   A,[X+4]
    126B: 73       CPL   A
    126C: 53 43    MOV   [__r6],A
    126E: 52 05    MOV   A,[X+5]
    1270: 73       CPL   A
    1271: 53 42    MOV   [__r7],A
    1273: 51 48    MOV   A,[__r1]
    1275: 21 1F    AND   A,0x1F
    1277: A0 0F    JZ    0x1287
    1279: 62 D0 00 MOV   REG[0xD0],0x0
    127C: 68 45    ASR   [__r4]
    127E: 6E 44    RRC   [__r5]
    1280: 6E 43    RRC   [__r6]
    1282: 6E 42    RRC   [__r7]
    1284: 78       DEC   A
    1285: BF F3    JNZ   0x1279
    1287: 62 D0 00 MOV   REG[0xD0],0x0
    128A: 51 43    MOV   A,[__r6]
    128C: 73       CPL   A
    128D: 53 47    MOV   [__r2],A
    128F: 51 42    MOV   A,[__r7]
    1291: 73       CPL   A
    1292: 53 46    MOV   [__r3],A
    1294: 62 D0 00 MOV   REG[0xD0],0x0
    1297: 51 85    MOV   A,[prs_Y+9]
    1299: 62 D0 00 MOV   REG[0xD0],0x0
    129C: 53 42    MOV   [__r7],A
    129E: 62 D0 00 MOV   REG[0xD0],0x0
    12A1: 51 84    MOV   A,[prs_Y+8]
    12A3: 62 D0 00 MOV   REG[0xD0],0x0
    12A6: 53 43    MOV   [__r6],A
    12A8: 47 43 80 TST   [__r6],0x80
    12AB: A0 09    JZ    0x12B5
    12AD: 55 44 FF MOV   [__r5],0xFF
    12B0: 55 45 FF MOV   [__r4],0xFF
    12B3: 80 0A    JMP   0x12BE
    12B5: 62 D0 00 MOV   REG[0xD0],0x0
    12B8: 55 44 00 MOV   [__r5],0x0
    12BB: 55 45 00 MOV   [__r4],0x0
    12BE: 62 D0 00 MOV   REG[0xD0],0x0
    12C1: 51 42    MOV   A,[__r7]
    12C3: 02 46    ADD   A,[__r3]
    12C5: 53 46    MOV   [__r3],A
    12C7: 51 43    MOV   A,[__r6]
    12C9: 0A 47    ADC   A,[__r2]
    12CB: 53 47    MOV   [__r2],A
    12CD: 51 46    MOV   A,[__r3]
    12CF: 53 48    MOV   [__r1],A
    12D1: 51 47    MOV   A,[__r2]
    12D3: 53 49    MOV   [__r0],A
    12D5: 51 48    MOV   A,[__r1]
    12D7: 08       PUSH  A
    12D8: 51 49    MOV   A,[__r0]
    12DA: 62 D0 00 MOV   REG[0xD0],0x0
    12DD: 53 84    MOV   [prs_Y+8],A
    12DF: 18       POP   A
    12E0: 53 85    MOV   [prs_Y+9],A
(0368) 				}
    12E2: 80 79    JMP   0x135C
(0369) 				else
(0370) 				{
(0371) 					pwm_Y += (tmpx0 >> OutboxBuff.bshift_Y);
    12E4: 62 D0 00 MOV   REG[0xD0],0x0
    12E7: 51 61    MOV   A,[OutboxBuff+8]
    12E9: 62 D0 00 MOV   REG[0xD0],0x0
    12EC: 53 48    MOV   [__r1],A
    12EE: 52 02    MOV   A,[X+2]
    12F0: 53 45    MOV   [__r4],A
    12F2: 52 03    MOV   A,[X+3]
    12F4: 53 44    MOV   [__r5],A
    12F6: 52 04    MOV   A,[X+4]
    12F8: 53 43    MOV   [__r6],A
    12FA: 52 05    MOV   A,[X+5]
    12FC: 53 42    MOV   [__r7],A
    12FE: 51 48    MOV   A,[__r1]
    1300: 21 1F    AND   A,0x1F
    1302: A0 0F    JZ    0x1312
    1304: 62 D0 00 MOV   REG[0xD0],0x0
    1307: 68 45    ASR   [__r4]
    1309: 6E 44    RRC   [__r5]
    130B: 6E 43    RRC   [__r6]
    130D: 6E 42    RRC   [__r7]
    130F: 78       DEC   A
    1310: BF F3    JNZ   0x1304
    1312: 62 D0 00 MOV   REG[0xD0],0x0
    1315: 51 85    MOV   A,[prs_Y+9]
    1317: 62 D0 00 MOV   REG[0xD0],0x0
    131A: 53 46    MOV   [__r3],A
    131C: 62 D0 00 MOV   REG[0xD0],0x0
    131F: 51 84    MOV   A,[prs_Y+8]
    1321: 62 D0 00 MOV   REG[0xD0],0x0
    1324: 53 47    MOV   [__r2],A
    1326: 47 47 80 TST   [__r2],0x80
    1329: A0 09    JZ    0x1333
    132B: 55 48 FF MOV   [__r1],0xFF
    132E: 55 49 FF MOV   [__r0],0xFF
    1331: 80 0A    JMP   0x133C
    1333: 62 D0 00 MOV   REG[0xD0],0x0
    1336: 55 48 00 MOV   [__r1],0x0
    1339: 55 49 00 MOV   [__r0],0x0
    133C: 62 D0 00 MOV   REG[0xD0],0x0
    133F: 51 42    MOV   A,[__r7]
    1341: 04 46    ADD   [__r3],A
    1343: 51 43    MOV   A,[__r6]
    1345: 0C 47    ADC   [__r2],A
    1347: 51 46    MOV   A,[__r3]
    1349: 53 48    MOV   [__r1],A
    134B: 51 47    MOV   A,[__r2]
    134D: 53 49    MOV   [__r0],A
    134F: 51 48    MOV   A,[__r1]
    1351: 08       PUSH  A
    1352: 51 49    MOV   A,[__r0]
    1354: 62 D0 00 MOV   REG[0xD0],0x0
    1357: 53 84    MOV   [prs_Y+8],A
    1359: 18       POP   A
    135A: 53 85    MOV   [prs_Y+9],A
(0372) 				}
(0373) 				
(0374) 				//CCW
(0375) 				if (pwm_Y < 0)
    135C: 62 D0 00 MOV   REG[0xD0],0x0
    135F: 51 85    MOV   A,[prs_Y+9]
    1361: 11 00    SUB   A,0x0
    1363: 51 84    MOV   A,[prs_Y+8]
    1365: 31 80    XOR   A,0x80
    1367: 19 80    SBB   A,0x80
    1369: D0 82    JNC   0x13EC
(0376) 				{
(0377) 					if (bitCheck(~rd_Y, CCW))
    136B: 62 D0 00 MOV   REG[0xD0],0x0
    136E: 51 92    MOV   A,[ct+1]
    1370: 73       CPL   A
    1371: 62 D0 00 MOV   REG[0xD0],0x0
    1374: 53 49    MOV   [__r0],A
    1376: 26 49 02 AND   [__r0],0x2
    1379: A0 35    JZ    0x13AF
(0378) 					{
(0379) 						PRS32_Y_WriteSeed(0);
    137B: 10       PUSH  X
    137C: 50 00    MOV   A,0x0
    137E: 08       PUSH  A
    137F: 08       PUSH  A
    1380: 08       PUSH  A
    1381: 08       PUSH  A
    1382: 7C 06 9E LCALL _PRS32_Y_WriteSeed
    1385: 38 FC    ADD   SP,0xFC
    1387: 20       POP   X
(0380) 						
(0381) 						//YAH off
(0382) 						YAH_Data_ADDR = bitClear(YAH_DataShadow, YAH_MASK);
    1388: 62 D0 00 MOV   REG[0xD0],0x0
    138B: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    138D: 21 FE    AND   A,0xFE
    138F: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1391: 60 08    MOV   REG[0x8],A
(0383) 						//YBL & prs off
(0384) 						YBL_Data_ADDR = bitClear(YBL_DataShadow, YBL_MASK);
    1393: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1395: 21 DF    AND   A,0xDF
    1397: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1399: 60 08    MOV   REG[0x8],A
(0385) 						bitClear(YBL_GlobalSelect_ADDR, YBL_MASK);
    139B: 41 0A DF AND   REG[0xA],0xDF
(0386) 						//YBH on
(0387) 						YBH_Data_ADDR = bitSet(YBH_DataShadow, YBH_MASK);
    139E: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    13A0: 29 08    OR    A,0x8
    13A2: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    13A4: 60 08    MOV   REG[0x8],A
(0388) 						//YAL prs on
(0389) 						bitSet(YAL_GlobalSelect_ADDR, YAL_MASK);
    13A6: 43 0A 02 OR    REG[0xA],0x2
(0390) 						
(0391) 						rd_Y = CCW;
    13A9: 62 D0 00 MOV   REG[0xD0],0x0
    13AC: 55 92 02 MOV   [ct+1],0x2
(0392) 					}
(0393) 					
(0394) 					if (pwm_Y <= -128)
    13AF: 62 D0 00 MOV   REG[0xD0],0x0
    13B2: 50 80    MOV   A,0x80
    13B4: 12 85    SUB   A,[prs_Y+9]
    13B6: 51 84    MOV   A,[prs_Y+8]
    13B8: 31 80    XOR   A,0x80
    13BA: 62 D0 00 MOV   REG[0xD0],0x0
    13BD: 53 3D    MOV   [__rX],A
    13BF: 50 7F    MOV   A,0x7F
    13C1: 1A 3D    SBB   A,[__rX]
    13C3: C0 0C    JC    0x13D0
(0395) 					{
(0396) 						InboxBuff.Y_crs = 0x80;
    13C5: 62 D0 00 MOV   REG[0xD0],0x0
    13C8: 55 6A 80 MOV   [InboxBuff+3],0x80
(0397) 						tmpx1 = 255;
    13CB: 56 06 FF MOV   [X+6],0xFF
(0398) 					}
    13CE: 80 94    JMP   0x1463
(0399) 					else
(0400) 					{
(0401) 						(*(CHAR *)&(InboxBuff.Y_crs)) = pwm_Y;
    13D0: 62 D0 00 MOV   REG[0xD0],0x0
    13D3: 51 85    MOV   A,[prs_Y+9]
    13D5: 62 D0 00 MOV   REG[0xD0],0x0
    13D8: 53 6A    MOV   [InboxBuff+3],A
(0402) 						tmpx1 = (((~InboxBuff.Y_crs) << 1) + 1);
    13DA: 51 6A    MOV   A,[InboxBuff+3]
    13DC: 73       CPL   A
    13DD: 62 D0 00 MOV   REG[0xD0],0x0
    13E0: 53 49    MOV   [__r0],A
    13E2: 65 49    ASL   [__r0]
    13E4: 51 49    MOV   A,[__r0]
    13E6: 01 01    ADD   A,0x1
    13E8: 54 06    MOV   [X+6],A
(0403) 					}
(0404) 				}
    13EA: 80 78    JMP   0x1463
(0405) 				//CW
(0406) 				else
(0407) 				{
(0408) 					if (bitCheck(~rd_Y, CW))
    13EC: 62 D0 00 MOV   REG[0xD0],0x0
    13EF: 51 92    MOV   A,[ct+1]
    13F1: 73       CPL   A
    13F2: 62 D0 00 MOV   REG[0xD0],0x0
    13F5: 53 49    MOV   [__r0],A
    13F7: 26 49 01 AND   [__r0],0x1
    13FA: A0 35    JZ    0x1430
(0409) 					{
(0410) 						PRS32_Y_WriteSeed(0);
    13FC: 10       PUSH  X
    13FD: 50 00    MOV   A,0x0
    13FF: 08       PUSH  A
    1400: 08       PUSH  A
    1401: 08       PUSH  A
    1402: 08       PUSH  A
    1403: 7C 06 9E LCALL _PRS32_Y_WriteSeed
    1406: 38 FC    ADD   SP,0xFC
    1408: 20       POP   X
(0411) 						
(0412) 						//YBH off
(0413) 						YBH_Data_ADDR = bitClear(YBH_DataShadow, YBH_MASK);
    1409: 62 D0 00 MOV   REG[0xD0],0x0
    140C: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    140E: 21 F7    AND   A,0xF7
    1410: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1412: 60 08    MOV   REG[0x8],A
(0414) 						//YAL & prs off
(0415) 						YAL_Data_ADDR = bitClear(YAL_DataShadow, YAL_MASK);
    1414: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1416: 21 FD    AND   A,0xFD
    1418: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    141A: 60 08    MOV   REG[0x8],A
(0416) 						bitClear(YAL_GlobalSelect_ADDR, YAL_MASK);
    141C: 41 0A FD AND   REG[0xA],0xFD
(0417) 						//YAH on
(0418) 						YAH_Data_ADDR = bitSet(YAH_DataShadow, YAH_MASK);
    141F: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1421: 29 01    OR    A,0x1
    1423: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1425: 60 08    MOV   REG[0x8],A
(0419) 						//YBL prs on
(0420) 						bitSet(YBL_GlobalSelect_ADDR, YBL_MASK);
    1427: 43 0A 20 OR    REG[0xA],0x20
(0421) 						
(0422) 						rd_Y = CW;
    142A: 62 D0 00 MOV   REG[0xD0],0x0
    142D: 55 92 01 MOV   [ct+1],0x1
(0423) 					}
(0424) 					
(0425) 					if (pwm_Y >= 127)
    1430: 62 D0 00 MOV   REG[0xD0],0x0
    1433: 51 85    MOV   A,[prs_Y+9]
    1435: 11 7F    SUB   A,0x7F
    1437: 51 84    MOV   A,[prs_Y+8]
    1439: 31 80    XOR   A,0x80
    143B: 19 80    SBB   A,0x80
    143D: C0 0C    JC    0x144A
(0426) 					{
(0427) 						InboxBuff.Y_crs = 0x7f;
    143F: 62 D0 00 MOV   REG[0xD0],0x0
    1442: 55 6A 7F MOV   [InboxBuff+3],0x7F
(0428) 						tmpx1 = 255;
    1445: 56 06 FF MOV   [X+6],0xFF
(0429) 					}
    1448: 80 1A    JMP   0x1463
(0430) 					else
(0431) 					{
(0432) 						(*(CHAR *)&(InboxBuff.Y_crs)) = pwm_Y;
    144A: 62 D0 00 MOV   REG[0xD0],0x0
    144D: 51 85    MOV   A,[prs_Y+9]
    144F: 62 D0 00 MOV   REG[0xD0],0x0
    1452: 53 6A    MOV   [InboxBuff+3],A
(0433) 						tmpx1 = ((InboxBuff.Y_crs << 1) + 1);
    1454: 51 6A    MOV   A,[InboxBuff+3]
    1456: 62 D0 00 MOV   REG[0xD0],0x0
    1459: 53 49    MOV   [__r0],A
    145B: 65 49    ASL   [__r0]
    145D: 51 49    MOV   A,[__r0]
    145F: 01 01    ADD   A,0x1
    1461: 54 06    MOV   [X+6],A
(0434) 					}
(0435) 				}
(0436) 				
(0437) 				prsSet(prs_Y, tmpx1);
    1463: 52 06    MOV   A,[X+6]
    1465: 62 D0 00 MOV   REG[0xD0],0x0
    1468: 53 7F    MOV   [prs_Y+3],A
    146A: 52 06    MOV   A,[X+6]
    146C: 53 7E    MOV   [prs_Y+2],A
    146E: 52 06    MOV   A,[X+6]
    1470: 53 7D    MOV   [prs_Y+1],A
    1472: 52 06    MOV   A,[X+6]
    1474: 53 7C    MOV   [prs_Y],A
(0438) 				bitSet(InboxBuff.InboxFlag, I2CIO_UPDATE);
    1476: 62 D0 00 MOV   REG[0xD0],0x0
    1479: 2E 67 20 OR    [InboxBuff],0x20
(0439) 			}
(0440) 			
(0441) 			sw_Y = FALSE;
    147C: 62 D0 00 MOV   REG[0xD0],0x0
    147F: 55 98 00 MOV   [sw_Y],0x0
(0442) 		}
(0443) 		//end Y
(0444) 		
(0445) 		//calclate Z motor
(0446) 		if (sw_Z)
    1482: 62 D0 00 MOV   REG[0xD0],0x0
    1485: 3C 8D 00 CMP   [sw_Z],0x0
    1488: A4 49    JZ    0x18D2
(0447) 		{
(0448) 			static BYTE count_Z;
(0449) 			static BYTE rd_Z;
(0450) 			static INT pwm_Z;
(0451) 			static LONG iZ;
(0452) 			
(0453) 			//stop & brake 
(0454) 			if (bitCheck(OutboxBuff.TBrakeFlag, STOP_Z))
    148A: 62 D0 00 MOV   REG[0xD0],0x0
    148D: 47 5A 04 TST   [OutboxBuff+1],0x4
    1490: A0 D6    JZ    0x1567
(0455) 			{
(0456) 				//brake
(0457) 				if (count_Z < (STOPCOUNT_Z - STOPINC_Z))
    1492: 62 D0 00 MOV   REG[0xD0],0x0
    1495: 3C 8C FB CMP   [MBM_1_pMyMailbox+2],0xFB
    1498: D0 A2    JNC   0x153B
(0458) 				{
(0459) 					//brake start
(0460) 					if (rd_Z)
    149A: 62 D0 00 MOV   REG[0xD0],0x0
    149D: 3C 99 00 CMP   [sw_Y+1],0x0
    14A0: A0 57    JZ    0x14F8
(0461) 					{
(0462) 						PRS32_Z_WriteSeed(0);
    14A2: 10       PUSH  X
    14A3: 50 00    MOV   A,0x0
    14A5: 08       PUSH  A
    14A6: 08       PUSH  A
    14A7: 08       PUSH  A
    14A8: 08       PUSH  A
    14A9: 7C 06 37 LCALL _PRS32_Z_WriteSeed
    14AC: 38 FC    ADD   SP,0xFC
    14AE: 20       POP   X
(0463) 						
(0464) 						//ZAH off
(0465) 						ZAH_Data_ADDR = bitClear(ZAH_DataShadow, ZAH_MASK);
    14AF: 62 D0 00 MOV   REG[0xD0],0x0
    14B2: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    14B4: 21 FB    AND   A,0xFB
    14B6: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    14B8: 60 08    MOV   REG[0x8],A
(0466) 						//ZBH off
(0467) 						ZBH_Data_ADDR = bitClear(ZBH_DataShadow, ZBH_MASK);
    14BA: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    14BC: 21 BF    AND   A,0xBF
    14BE: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    14C0: 60 08    MOV   REG[0x8],A
(0468) 						//ZAL prs on
(0469) 						bitSet(ZAL_GlobalSelect_ADDR, ZAL_MASK);
    14C2: 43 0A 80 OR    REG[0xA],0x80
(0470) 						//ZBL prs on
(0471) 						bitSet(ZBL_GlobalSelect_ADDR, ZBL_MASK);
    14C5: 43 02 80 OR    REG[0x2],0x80
(0472) 						
(0473) 						bitSet(InboxBuff.CBrakeFlag, STOP_Z);
    14C8: 62 D0 00 MOV   REG[0xD0],0x0
    14CB: 2E 68 04 OR    [InboxBuff+1],0x4
(0474) 						bitSet(InboxBuff.InboxFlag, I2CIO_UPDATE);
    14CE: 2E 67 20 OR    [InboxBuff],0x20
(0475) 						InboxBuff.Z_crs = 0;
    14D1: 55 6B 00 MOV   [InboxBuff+4],0x0
(0476) 						pwm_Z = 0;
    14D4: 62 D0 00 MOV   REG[0xD0],0x0
    14D7: 55 89 00 MOV   [prs_Y+13],0x0
    14DA: 55 88 00 MOV   [prs_Y+12],0x0
(0477) 						iZ = 0;
    14DD: 62 D0 00 MOV   REG[0xD0],0x0
    14E0: 55 6C 00 MOV   [InboxBuff+5],0x0
    14E3: 55 6D 00 MOV   [InboxBuff+6],0x0
    14E6: 55 6E 00 MOV   [InboxBuff+7],0x0
    14E9: 55 6F 00 MOV   [InboxBuff+8],0x0
(0478) 						count_Z = 0;
    14EC: 62 D0 00 MOV   REG[0xD0],0x0
    14EF: 55 8C 00 MOV   [MBM_1_pMyMailbox+2],0x0
(0479) 						rd_Z = STOP;
    14F2: 62 D0 00 MOV   REG[0xD0],0x0
    14F5: 55 99 00 MOV   [sw_Y+1],0x0
(0480) 					}
(0481) 					//set prs
(0482) 					prsSet(prs_Z, count_Z);
    14F8: 62 D0 00 MOV   REG[0xD0],0x0
    14FB: 51 8C    MOV   A,[MBM_1_pMyMailbox+2]
    14FD: 62 D0 00 MOV   REG[0xD0],0x0
    1500: 53 77    MOV   [prs_Z+3],A
    1502: 62 D0 00 MOV   REG[0xD0],0x0
    1505: 51 8C    MOV   A,[MBM_1_pMyMailbox+2]
    1507: 62 D0 00 MOV   REG[0xD0],0x0
    150A: 53 76    MOV   [prs_Z+2],A
    150C: 62 D0 00 MOV   REG[0xD0],0x0
    150F: 51 8C    MOV   A,[MBM_1_pMyMailbox+2]
    1511: 62 D0 00 MOV   REG[0xD0],0x0
    1514: 53 75    MOV   [prs_Z+1],A
    1516: 62 D0 00 MOV   REG[0xD0],0x0
    1519: 51 8C    MOV   A,[MBM_1_pMyMailbox+2]
    151B: 62 D0 00 MOV   REG[0xD0],0x0
    151E: 53 74    MOV   [prs_Z],A
(0483) 					PRS32_Z_WriteSeed(prs_Z);
    1520: 10       PUSH  X
    1521: 51 74    MOV   A,[prs_Z]
    1523: 08       PUSH  A
    1524: 51 75    MOV   A,[prs_Z+1]
    1526: 08       PUSH  A
    1527: 51 76    MOV   A,[prs_Z+2]
    1529: 08       PUSH  A
    152A: 51 77    MOV   A,[prs_Z+3]
    152C: 08       PUSH  A
    152D: 7C 06 37 LCALL _PRS32_Z_WriteSeed
    1530: 38 FC    ADD   SP,0xFC
    1532: 20       POP   X
(0484) 					count_Z += STOPINC_Z;
    1533: 62 D0 00 MOV   REG[0xD0],0x0
    1536: 06 8C 04 ADD   [MBM_1_pMyMailbox+2],0x4
(0485) 				}
    1539: 83 92    JMP   0x18CC
(0486) 				//lock
(0487) 				else if (count_Z != 0xff)
    153B: 62 D0 00 MOV   REG[0xD0],0x0
    153E: 3C 8C FF CMP   [MBM_1_pMyMailbox+2],0xFF
    1541: A3 8A    JZ    0x18CC
(0488) 				{
(0489) 					//ZAL on & prs off
(0490) 					ZAL_Data_ADDR = bitSet(ZAL_DataShadow, ZAL_MASK);
    1543: 62 D0 00 MOV   REG[0xD0],0x0
    1546: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1548: 29 80    OR    A,0x80
    154A: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    154C: 60 08    MOV   REG[0x8],A
(0491) 					bitClear(ZAL_GlobalSelect_ADDR, ZAL_MASK);
    154E: 41 0A 7F AND   REG[0xA],0x7F
(0492) 					//ZBL on & prs off
(0493) 					ZBL_Data_ADDR = bitSet(ZBL_DataShadow, ZBL_MASK);
    1551: 62 D0 00 MOV   REG[0xD0],0x0
    1554: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw]
    1556: 29 80    OR    A,0x80
    1558: 53 00    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],A
    155A: 60 00    MOV   REG[0x0],A
(0494) 					bitClear(ZBL_GlobalSelect_ADDR, ZBL_MASK);
    155C: 41 02 7F AND   REG[0x2],0x7F
(0495) 					
(0496) 					count_Z = 0xff;
    155F: 62 D0 00 MOV   REG[0xD0],0x0
    1562: 55 8C FF MOV   [MBM_1_pMyMailbox+2],0xFF
(0497) 				}
(0498) 			}
    1565: 83 66    JMP   0x18CC
(0499) 			//rotation
(0500) 			else
(0501) 			{
(0502) 				INT pZ;
(0503) 				LONG tmpx0;
(0504) 				BYTE tmpx1;
(0505) 				
(0506) 				if (rd_Z == STOP)
    1567: 62 D0 00 MOV   REG[0xD0],0x0
    156A: 3C 99 00 CMP   [sw_Y+1],0x0
    156D: B0 0D    JNZ   0x157B
(0507) 				{
(0508) 					bitClear(InboxBuff.CBrakeFlag, STOP_Z);
    156F: 62 D0 00 MOV   REG[0xD0],0x0
    1572: 26 68 FB AND   [InboxBuff+1],0xFB
(0509) 					count_Z = 0;
    1575: 62 D0 00 MOV   REG[0xD0],0x0
    1578: 55 8C 00 MOV   [MBM_1_pMyMailbox+2],0x0
(0510) 				}
(0511) 				
(0512) 				//calclate PI
(0513) 				pZ = ((*(CHAR *)&(OutboxBuff.Z_trs)) - pwm_Z);
    157B: 62 D0 00 MOV   REG[0xD0],0x0
    157E: 51 5D    MOV   A,[OutboxBuff+4]
    1580: 62 D0 00 MOV   REG[0xD0],0x0
    1583: 53 48    MOV   [__r1],A
    1585: 55 49 00 MOV   [__r0],0x0
    1588: 47 48 80 TST   [__r1],0x80
    158B: A0 04    JZ    0x1590
    158D: 55 49 FF MOV   [__r0],0xFF
    1590: 62 D0 00 MOV   REG[0xD0],0x0
    1593: 51 48    MOV   A,[__r1]
    1595: 62 D0 00 MOV   REG[0xD0],0x0
    1598: 12 89    SUB   A,[prs_Y+13]
    159A: 54 01    MOV   [X+1],A
    159C: 62 D0 00 MOV   REG[0xD0],0x0
    159F: 51 49    MOV   A,[__r0]
    15A1: 62 D0 00 MOV   REG[0xD0],0x0
    15A4: 1A 88    SBB   A,[prs_Y+12]
    15A6: 54 00    MOV   [X+0],A
(0514) 				iZ += pZ;
    15A8: 62 D0 00 MOV   REG[0xD0],0x0
    15AB: 52 01    MOV   A,[X+1]
    15AD: 53 46    MOV   [__r3],A
    15AF: 52 00    MOV   A,[X+0]
    15B1: 53 47    MOV   [__r2],A
    15B3: 47 47 80 TST   [__r2],0x80
    15B6: A0 09    JZ    0x15C0
    15B8: 55 48 FF MOV   [__r1],0xFF
    15BB: 55 49 FF MOV   [__r0],0xFF
    15BE: 80 0A    JMP   0x15C9
    15C0: 62 D0 00 MOV   REG[0xD0],0x0
    15C3: 55 48 00 MOV   [__r1],0x0
    15C6: 55 49 00 MOV   [__r0],0x0
    15C9: 62 D0 00 MOV   REG[0xD0],0x0
    15CC: 51 46    MOV   A,[__r3]
    15CE: 62 D0 00 MOV   REG[0xD0],0x0
    15D1: 04 6F    ADD   [InboxBuff+8],A
    15D3: 62 D0 00 MOV   REG[0xD0],0x0
    15D6: 51 47    MOV   A,[__r2]
    15D8: 62 D0 00 MOV   REG[0xD0],0x0
    15DB: 0C 6E    ADC   [InboxBuff+7],A
    15DD: 62 D0 00 MOV   REG[0xD0],0x0
    15E0: 51 48    MOV   A,[__r1]
    15E2: 62 D0 00 MOV   REG[0xD0],0x0
    15E5: 0C 6D    ADC   [InboxBuff+6],A
    15E7: 62 D0 00 MOV   REG[0xD0],0x0
    15EA: 51 49    MOV   A,[__r0]
    15EC: 62 D0 00 MOV   REG[0xD0],0x0
    15EF: 0C 6C    ADC   [InboxBuff+5],A
(0515) 				tmpx0 = (OutboxBuff.Kp_Z * (LONG)pZ + OutboxBuff.Ki_Z * iZ);
    15F1: 62 D0 00 MOV   REG[0xD0],0x0
    15F4: 51 66    MOV   A,[OutboxBuff+13]
    15F6: 62 D0 00 MOV   REG[0xD0],0x0
    15F9: 53 46    MOV   [__r3],A
    15FB: 62 D0 00 MOV   REG[0xD0],0x0
    15FE: 51 6C    MOV   A,[InboxBuff+5]
    1600: 08       PUSH  A
    1601: 51 6D    MOV   A,[InboxBuff+6]
    1603: 08       PUSH  A
    1604: 51 6E    MOV   A,[InboxBuff+7]
    1606: 08       PUSH  A
    1607: 51 6F    MOV   A,[InboxBuff+8]
    1609: 08       PUSH  A
    160A: 62 D0 00 MOV   REG[0xD0],0x0
    160D: 50 00    MOV   A,0x0
    160F: 08       PUSH  A
    1610: 08       PUSH  A
    1611: 08       PUSH  A
    1612: 51 46    MOV   A,[__r3]
    1614: 08       PUSH  A
    1615: 7C 2E C2 LCALL 0x2EC2
    1618: 38 FC    ADD   SP,0xFC
    161A: 18       POP   A
    161B: 53 46    MOV   [__r3],A
    161D: 18       POP   A
    161E: 53 47    MOV   [__r2],A
    1620: 18       POP   A
    1621: 53 48    MOV   [__r1],A
    1623: 18       POP   A
    1624: 53 49    MOV   [__r0],A
    1626: 52 01    MOV   A,[X+1]
    1628: 53 42    MOV   [__r7],A
    162A: 52 00    MOV   A,[X+0]
    162C: 53 43    MOV   [__r6],A
    162E: 47 43 80 TST   [__r6],0x80
    1631: A0 09    JZ    0x163B
    1633: 55 44 FF MOV   [__r5],0xFF
    1636: 55 45 FF MOV   [__r4],0xFF
    1639: 80 0A    JMP   0x1644
    163B: 62 D0 00 MOV   REG[0xD0],0x0
    163E: 55 44 00 MOV   [__r5],0x0
    1641: 55 45 00 MOV   [__r4],0x0
    1644: 62 D0 00 MOV   REG[0xD0],0x0
    1647: 51 65    MOV   A,[OutboxBuff+12]
    1649: 62 D0 00 MOV   REG[0xD0],0x0
    164C: 53 3E    MOV   [__r11],A
    164E: 51 45    MOV   A,[__r4]
    1650: 08       PUSH  A
    1651: 51 44    MOV   A,[__r5]
    1653: 08       PUSH  A
    1654: 51 43    MOV   A,[__r6]
    1656: 08       PUSH  A
    1657: 51 42    MOV   A,[__r7]
    1659: 08       PUSH  A
    165A: 50 00    MOV   A,0x0
    165C: 08       PUSH  A
    165D: 08       PUSH  A
    165E: 08       PUSH  A
    165F: 51 3E    MOV   A,[__r11]
    1661: 08       PUSH  A
    1662: 7C 2E C2 LCALL 0x2EC2
    1665: 38 FC    ADD   SP,0xFC
    1667: 18       POP   A
    1668: 53 42    MOV   [__r7],A
    166A: 18       POP   A
    166B: 53 43    MOV   [__r6],A
    166D: 18       POP   A
    166E: 53 44    MOV   [__r5],A
    1670: 18       POP   A
    1671: 53 45    MOV   [__r4],A
    1673: 51 42    MOV   A,[__r7]
    1675: 02 46    ADD   A,[__r3]
    1677: 54 05    MOV   [X+5],A
    1679: 51 43    MOV   A,[__r6]
    167B: 0A 47    ADC   A,[__r2]
    167D: 54 04    MOV   [X+4],A
    167F: 51 44    MOV   A,[__r5]
    1681: 0A 48    ADC   A,[__r1]
    1683: 54 03    MOV   [X+3],A
    1685: 51 45    MOV   A,[__r4]
    1687: 0A 49    ADC   A,[__r0]
    1689: 54 02    MOV   [X+2],A
(0516) 				if (tmpx0 < 0)
    168B: 52 05    MOV   A,[X+5]
    168D: 11 00    SUB   A,0x0
    168F: 52 04    MOV   A,[X+4]
    1691: 19 00    SBB   A,0x0
    1693: 52 03    MOV   A,[X+3]
    1695: 19 00    SBB   A,0x0
    1697: 52 02    MOV   A,[X+2]
    1699: 31 80    XOR   A,0x80
    169B: 19 80    SBB   A,0x80
    169D: D0 90    JNC   0x172E
(0517) 				{
(0518) 					pwm_Z += (~((~tmpx0) >> OutboxBuff.bshift_Z));
    169F: 62 D0 00 MOV   REG[0xD0],0x0
    16A2: 51 64    MOV   A,[OutboxBuff+11]
    16A4: 62 D0 00 MOV   REG[0xD0],0x0
    16A7: 53 48    MOV   [__r1],A
    16A9: 52 02    MOV   A,[X+2]
    16AB: 73       CPL   A
    16AC: 53 45    MOV   [__r4],A
    16AE: 52 03    MOV   A,[X+3]
    16B0: 73       CPL   A
    16B1: 53 44    MOV   [__r5],A
    16B3: 52 04    MOV   A,[X+4]
    16B5: 73       CPL   A
    16B6: 53 43    MOV   [__r6],A
    16B8: 52 05    MOV   A,[X+5]
    16BA: 73       CPL   A
    16BB: 53 42    MOV   [__r7],A
    16BD: 51 48    MOV   A,[__r1]
    16BF: 21 1F    AND   A,0x1F
    16C1: A0 0F    JZ    0x16D1
    16C3: 62 D0 00 MOV   REG[0xD0],0x0
    16C6: 68 45    ASR   [__r4]
    16C8: 6E 44    RRC   [__r5]
    16CA: 6E 43    RRC   [__r6]
    16CC: 6E 42    RRC   [__r7]
    16CE: 78       DEC   A
    16CF: BF F3    JNZ   0x16C3
    16D1: 62 D0 00 MOV   REG[0xD0],0x0
    16D4: 51 43    MOV   A,[__r6]
    16D6: 73       CPL   A
    16D7: 53 47    MOV   [__r2],A
    16D9: 51 42    MOV   A,[__r7]
    16DB: 73       CPL   A
    16DC: 53 46    MOV   [__r3],A
    16DE: 62 D0 00 MOV   REG[0xD0],0x0
    16E1: 51 89    MOV   A,[prs_Y+13]
    16E3: 62 D0 00 MOV   REG[0xD0],0x0
    16E6: 53 42    MOV   [__r7],A
    16E8: 62 D0 00 MOV   REG[0xD0],0x0
    16EB: 51 88    MOV   A,[prs_Y+12]
    16ED: 62 D0 00 MOV   REG[0xD0],0x0
    16F0: 53 43    MOV   [__r6],A
    16F2: 47 43 80 TST   [__r6],0x80
    16F5: A0 09    JZ    0x16FF
    16F7: 55 44 FF MOV   [__r5],0xFF
    16FA: 55 45 FF MOV   [__r4],0xFF
    16FD: 80 0A    JMP   0x1708
    16FF: 62 D0 00 MOV   REG[0xD0],0x0
    1702: 55 44 00 MOV   [__r5],0x0
    1705: 55 45 00 MOV   [__r4],0x0
    1708: 62 D0 00 MOV   REG[0xD0],0x0
    170B: 51 42    MOV   A,[__r7]
    170D: 02 46    ADD   A,[__r3]
    170F: 53 46    MOV   [__r3],A
    1711: 51 43    MOV   A,[__r6]
    1713: 0A 47    ADC   A,[__r2]
    1715: 53 47    MOV   [__r2],A
    1717: 51 46    MOV   A,[__r3]
    1719: 53 48    MOV   [__r1],A
    171B: 51 47    MOV   A,[__r2]
    171D: 53 49    MOV   [__r0],A
    171F: 51 48    MOV   A,[__r1]
    1721: 08       PUSH  A
    1722: 51 49    MOV   A,[__r0]
    1724: 62 D0 00 MOV   REG[0xD0],0x0
    1727: 53 88    MOV   [prs_Y+12],A
    1729: 18       POP   A
    172A: 53 89    MOV   [prs_Y+13],A
(0519) 				}
    172C: 80 79    JMP   0x17A6
(0520) 				else
(0521) 				{
(0522) 					pwm_Z += (tmpx0 >> OutboxBuff.bshift_Z);
    172E: 62 D0 00 MOV   REG[0xD0],0x0
    1731: 51 64    MOV   A,[OutboxBuff+11]
    1733: 62 D0 00 MOV   REG[0xD0],0x0
    1736: 53 48    MOV   [__r1],A
    1738: 52 02    MOV   A,[X+2]
    173A: 53 45    MOV   [__r4],A
    173C: 52 03    MOV   A,[X+3]
    173E: 53 44    MOV   [__r5],A
    1740: 52 04    MOV   A,[X+4]
    1742: 53 43    MOV   [__r6],A
    1744: 52 05    MOV   A,[X+5]
    1746: 53 42    MOV   [__r7],A
    1748: 51 48    MOV   A,[__r1]
    174A: 21 1F    AND   A,0x1F
    174C: A0 0F    JZ    0x175C
    174E: 62 D0 00 MOV   REG[0xD0],0x0
    1751: 68 45    ASR   [__r4]
    1753: 6E 44    RRC   [__r5]
    1755: 6E 43    RRC   [__r6]
    1757: 6E 42    RRC   [__r7]
    1759: 78       DEC   A
    175A: BF F3    JNZ   0x174E
    175C: 62 D0 00 MOV   REG[0xD0],0x0
    175F: 51 89    MOV   A,[prs_Y+13]
    1761: 62 D0 00 MOV   REG[0xD0],0x0
    1764: 53 46    MOV   [__r3],A
    1766: 62 D0 00 MOV   REG[0xD0],0x0
    1769: 51 88    MOV   A,[prs_Y+12]
    176B: 62 D0 00 MOV   REG[0xD0],0x0
    176E: 53 47    MOV   [__r2],A
    1770: 47 47 80 TST   [__r2],0x80
    1773: A0 09    JZ    0x177D
    1775: 55 48 FF MOV   [__r1],0xFF
    1778: 55 49 FF MOV   [__r0],0xFF
    177B: 80 0A    JMP   0x1786
    177D: 62 D0 00 MOV   REG[0xD0],0x0
    1780: 55 48 00 MOV   [__r1],0x0
    1783: 55 49 00 MOV   [__r0],0x0
    1786: 62 D0 00 MOV   REG[0xD0],0x0
    1789: 51 42    MOV   A,[__r7]
    178B: 04 46    ADD   [__r3],A
    178D: 51 43    MOV   A,[__r6]
    178F: 0C 47    ADC   [__r2],A
    1791: 51 46    MOV   A,[__r3]
    1793: 53 48    MOV   [__r1],A
    1795: 51 47    MOV   A,[__r2]
    1797: 53 49    MOV   [__r0],A
    1799: 51 48    MOV   A,[__r1]
    179B: 08       PUSH  A
    179C: 51 49    MOV   A,[__r0]
    179E: 62 D0 00 MOV   REG[0xD0],0x0
    17A1: 53 88    MOV   [prs_Y+12],A
    17A3: 18       POP   A
    17A4: 53 89    MOV   [prs_Y+13],A
(0523) 				}
(0524) 				
(0525) 				//CCW
(0526) 				if (pwm_Z < 0)
    17A6: 62 D0 00 MOV   REG[0xD0],0x0
    17A9: 51 89    MOV   A,[prs_Y+13]
    17AB: 11 00    SUB   A,0x0
    17AD: 51 88    MOV   A,[prs_Y+12]
    17AF: 31 80    XOR   A,0x80
    17B1: 19 80    SBB   A,0x80
    17B3: D0 88    JNC   0x183C
(0527) 				{
(0528) 					if (bitCheck(~rd_Z, CCW))
    17B5: 62 D0 00 MOV   REG[0xD0],0x0
    17B8: 51 99    MOV   A,[sw_Y+1]
    17BA: 73       CPL   A
    17BB: 62 D0 00 MOV   REG[0xD0],0x0
    17BE: 53 49    MOV   [__r0],A
    17C0: 26 49 02 AND   [__r0],0x2
    17C3: A0 3B    JZ    0x17FF
(0529) 					{
(0530) 						PRS32_Z_WriteSeed(0);
    17C5: 10       PUSH  X
    17C6: 50 00    MOV   A,0x0
    17C8: 08       PUSH  A
    17C9: 08       PUSH  A
    17CA: 08       PUSH  A
    17CB: 08       PUSH  A
    17CC: 7C 06 37 LCALL _PRS32_Z_WriteSeed
    17CF: 38 FC    ADD   SP,0xFC
    17D1: 20       POP   X
(0531) 						
(0532) 						//ZAH off
(0533) 						ZAH_Data_ADDR = bitClear(ZAH_DataShadow, ZAH_MASK);
    17D2: 62 D0 00 MOV   REG[0xD0],0x0
    17D5: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    17D7: 21 FB    AND   A,0xFB
    17D9: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    17DB: 60 08    MOV   REG[0x8],A
(0534) 						//ZBL & prs off
(0535) 						ZBL_Data_ADDR = bitClear(ZBL_DataShadow, ZBL_MASK);
    17DD: 62 D0 00 MOV   REG[0xD0],0x0
    17E0: 51 00    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw]
    17E2: 21 7F    AND   A,0x7F
    17E4: 53 00    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw],A
    17E6: 60 00    MOV   REG[0x0],A
(0536) 						bitClear(ZBL_GlobalSelect_ADDR, ZBL_MASK);
    17E8: 41 02 7F AND   REG[0x2],0x7F
(0537) 						//ZBH on
(0538) 						ZBH_Data_ADDR = bitSet(ZBH_DataShadow, ZBH_MASK);
    17EB: 62 D0 00 MOV   REG[0xD0],0x0
    17EE: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    17F0: 29 40    OR    A,0x40
    17F2: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    17F4: 60 08    MOV   REG[0x8],A
(0539) 						//ZAL prs on
(0540) 						bitSet(ZAL_GlobalSelect_ADDR, ZAL_MASK);
    17F6: 43 0A 80 OR    REG[0xA],0x80
(0541) 						
(0542) 						rd_Z = CCW;
    17F9: 62 D0 00 MOV   REG[0xD0],0x0
    17FC: 55 99 02 MOV   [sw_Y+1],0x2
(0543) 					}
(0544) 					
(0545) 					if (pwm_Z <= -128)
    17FF: 62 D0 00 MOV   REG[0xD0],0x0
    1802: 50 80    MOV   A,0x80
    1804: 12 89    SUB   A,[prs_Y+13]
    1806: 51 88    MOV   A,[prs_Y+12]
    1808: 31 80    XOR   A,0x80
    180A: 62 D0 00 MOV   REG[0xD0],0x0
    180D: 53 3D    MOV   [__rX],A
    180F: 50 7F    MOV   A,0x7F
    1811: 1A 3D    SBB   A,[__rX]
    1813: C0 0C    JC    0x1820
(0546) 					{
(0547) 						InboxBuff.Z_crs = 0x80;
    1815: 62 D0 00 MOV   REG[0xD0],0x0
    1818: 55 6B 80 MOV   [InboxBuff+4],0x80
(0548) 						tmpx1 = 255;
    181B: 56 06 FF MOV   [X+6],0xFF
(0549) 					}
    181E: 80 94    JMP   0x18B3
(0550) 					else
(0551) 					{
(0552) 						(*(CHAR *)&(InboxBuff.Z_crs)) = pwm_Z;
    1820: 62 D0 00 MOV   REG[0xD0],0x0
    1823: 51 89    MOV   A,[prs_Y+13]
    1825: 62 D0 00 MOV   REG[0xD0],0x0
    1828: 53 6B    MOV   [InboxBuff+4],A
(0553) 						tmpx1 = (((~InboxBuff.Z_crs) << 1) + 1);
    182A: 51 6B    MOV   A,[InboxBuff+4]
    182C: 73       CPL   A
    182D: 62 D0 00 MOV   REG[0xD0],0x0
    1830: 53 49    MOV   [__r0],A
    1832: 65 49    ASL   [__r0]
    1834: 51 49    MOV   A,[__r0]
    1836: 01 01    ADD   A,0x1
    1838: 54 06    MOV   [X+6],A
(0554) 					}
(0555) 				}
    183A: 80 78    JMP   0x18B3
(0556) 				//CW
(0557) 				else
(0558) 				{
(0559) 					if (bitCheck(~rd_Z, CW))
    183C: 62 D0 00 MOV   REG[0xD0],0x0
    183F: 51 99    MOV   A,[sw_Y+1]
    1841: 73       CPL   A
    1842: 62 D0 00 MOV   REG[0xD0],0x0
    1845: 53 49    MOV   [__r0],A
    1847: 26 49 01 AND   [__r0],0x1
    184A: A0 35    JZ    0x1880
(0560) 					{
(0561) 						PRS32_Z_WriteSeed(0);
    184C: 10       PUSH  X
    184D: 50 00    MOV   A,0x0
    184F: 08       PUSH  A
    1850: 08       PUSH  A
    1851: 08       PUSH  A
    1852: 08       PUSH  A
    1853: 7C 06 37 LCALL _PRS32_Z_WriteSeed
    1856: 38 FC    ADD   SP,0xFC
    1858: 20       POP   X
(0562) 						
(0563) 						//ZBH off
(0564) 						ZBH_Data_ADDR = bitClear(ZBH_DataShadow, ZBH_MASK);
    1859: 62 D0 00 MOV   REG[0xD0],0x0
    185C: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    185E: 21 BF    AND   A,0xBF
    1860: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1862: 60 08    MOV   REG[0x8],A
(0565) 						//ZAL & prs off
(0566) 						ZAL_Data_ADDR = bitClear(ZAL_DataShadow, ZAL_MASK);
    1864: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1866: 21 7F    AND   A,0x7F
    1868: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    186A: 60 08    MOV   REG[0x8],A
(0567) 						bitClear(ZAL_GlobalSelect_ADDR, ZAL_MASK);
    186C: 41 0A 7F AND   REG[0xA],0x7F
(0568) 						//ZAH on
(0569) 						ZAH_Data_ADDR = bitSet(ZAH_DataShadow, ZAH_MASK);
    186F: 51 02    MOV   A,[iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2]
    1871: 29 04    OR    A,0x4
    1873: 53 02    MOV   [iX|pwm_X|rd_X|count_X|iY|pwm_Y|rd_Y|count_Y|iZ|pwm_Z|rd_Z|count_Z|i2ccount|sw+2],A
    1875: 60 08    MOV   REG[0x8],A
(0570) 						//ZBL prs on
(0571) 						bitSet(ZBL_GlobalSelect_ADDR, ZBL_MASK);
    1877: 43 02 80 OR    REG[0x2],0x80
(0572) 						
(0573) 						rd_Z = CW;
    187A: 62 D0 00 MOV   REG[0xD0],0x0
    187D: 55 99 01 MOV   [sw_Y+1],0x1
(0574) 					}
(0575) 					
(0576) 					if (pwm_Z >= 127)
    1880: 62 D0 00 MOV   REG[0xD0],0x0
    1883: 51 89    MOV   A,[prs_Y+13]
    1885: 11 7F    SUB   A,0x7F
    1887: 51 88    MOV   A,[prs_Y+12]
    1889: 31 80    XOR   A,0x80
    188B: 19 80    SBB   A,0x80
    188D: C0 0C    JC    0x189A
(0577) 					{
(0578) 						InboxBuff.Z_crs = 0x7f;
    188F: 62 D0 00 MOV   REG[0xD0],0x0
    1892: 55 6B 7F MOV   [InboxBuff+4],0x7F
(0579) 						tmpx1 = 255;
    1895: 56 06 FF MOV   [X+6],0xFF
(0580) 					}
    1898: 80 1A    JMP   0x18B3
(0581) 					else
(0582) 					{
(0583) 						(*(CHAR *)&(InboxBuff.Z_crs)) = pwm_Z;
    189A: 62 D0 00 MOV   REG[0xD0],0x0
    189D: 51 89    MOV   A,[prs_Y+13]
    189F: 62 D0 00 MOV   REG[0xD0],0x0
    18A2: 53 6B    MOV   [InboxBuff+4],A
(0584) 						tmpx1 = ((InboxBuff.Z_crs << 1) + 1);
    18A4: 51 6B    MOV   A,[InboxBuff+4]
    18A6: 62 D0 00 MOV   REG[0xD0],0x0
    18A9: 53 49    MOV   [__r0],A
    18AB: 65 49    ASL   [__r0]
    18AD: 51 49    MOV   A,[__r0]
    18AF: 01 01    ADD   A,0x1
    18B1: 54 06    MOV   [X+6],A
(0585) 					}
(0586) 				}
(0587) 				
(0588) 				prsSet(prs_Z, tmpx1);
    18B3: 52 06    MOV   A,[X+6]
    18B5: 62 D0 00 MOV   REG[0xD0],0x0
    18B8: 53 77    MOV   [prs_Z+3],A
    18BA: 52 06    MOV   A,[X+6]
    18BC: 53 76    MOV   [prs_Z+2],A
    18BE: 52 06    MOV   A,[X+6]
    18C0: 53 75    MOV   [prs_Z+1],A
    18C2: 52 06    MOV   A,[X+6]
    18C4: 53 74    MOV   [prs_Z],A
(0589) 				bitSet(InboxBuff.InboxFlag, I2CIO_UPDATE);
    18C6: 62 D0 00 MOV   REG[0xD0],0x0
    18C9: 2E 67 20 OR    [InboxBuff],0x20
(0590) 			}
(0591) 			
(0592) 			sw_Z = FALSE;
    18CC: 62 D0 00 MOV   REG[0xD0],0x0
    18CF: 55 8D 00 MOV   [sw_Z],0x0
(0593) 		}
(0594) 		//end Z
(0595) 		
(0596) 		//LCD print
(0597) 		if ((!sw_X) && (!sw_Y) && (!sw_Z))
    18D2: 62 D0 00 MOV   REG[0xD0],0x0
    18D5: 3C 97 00 CMP   [sw_X],0x0
    18D8: B0 D9    JNZ   0x19B2
    18DA: 62 D0 00 MOV   REG[0xD0],0x0
    18DD: 3C 98 00 CMP   [sw_Y],0x0
    18E0: B0 D1    JNZ   0x19B2
    18E2: 62 D0 00 MOV   REG[0xD0],0x0
    18E5: 3C 8D 00 CMP   [sw_Z],0x0
    18E8: B0 C9    JNZ   0x19B2
(0598) 		{
(0599) 			LCD_1_Position(0, 0);
    18EA: 10       PUSH  X
    18EB: 50 00    MOV   A,0x0
    18ED: 57 00    MOV   X,0x0
    18EF: 7C 08 E9 LCALL _LCD_1_Position
    18F2: 20       POP   X
(0600) 			cprintf("B%1X M:%02X %02X %02X E%02X",
    18F3: 62 D0 00 MOV   REG[0xD0],0x0
    18F6: 51 90    MOV   A,[ec]
    18F8: 62 D0 00 MOV   REG[0xD0],0x0
    18FB: 53 48    MOV   [__r1],A
    18FD: 50 00    MOV   A,0x0
    18FF: 08       PUSH  A
    1900: 51 48    MOV   A,[__r1]
    1902: 08       PUSH  A
    1903: 62 D0 00 MOV   REG[0xD0],0x0
    1906: 51 5D    MOV   A,[OutboxBuff+4]
    1908: 62 D0 00 MOV   REG[0xD0],0x0
    190B: 53 48    MOV   [__r1],A
    190D: 50 00    MOV   A,0x0
    190F: 08       PUSH  A
    1910: 51 48    MOV   A,[__r1]
    1912: 08       PUSH  A
    1913: 62 D0 00 MOV   REG[0xD0],0x0
    1916: 51 5C    MOV   A,[OutboxBuff+3]
    1918: 62 D0 00 MOV   REG[0xD0],0x0
    191B: 53 48    MOV   [__r1],A
    191D: 50 00    MOV   A,0x0
    191F: 08       PUSH  A
    1920: 51 48    MOV   A,[__r1]
    1922: 08       PUSH  A
    1923: 62 D0 00 MOV   REG[0xD0],0x0
    1926: 51 5B    MOV   A,[OutboxBuff+2]
    1928: 62 D0 00 MOV   REG[0xD0],0x0
    192B: 53 48    MOV   [__r1],A
    192D: 50 00    MOV   A,0x0
    192F: 08       PUSH  A
    1930: 51 48    MOV   A,[__r1]
    1932: 08       PUSH  A
    1933: 62 D0 00 MOV   REG[0xD0],0x0
    1936: 51 5A    MOV   A,[OutboxBuff+1]
    1938: 62 D0 00 MOV   REG[0xD0],0x0
    193B: 53 48    MOV   [__r1],A
    193D: 50 00    MOV   A,0x0
    193F: 08       PUSH  A
    1940: 51 48    MOV   A,[__r1]
    1942: 08       PUSH  A
    1943: 50 01    MOV   A,0x1
    1945: 08       PUSH  A
    1946: 50 BE    MOV   A,0xBE
    1948: 08       PUSH  A
    1949: 7C 49 ED LCALL _cprintf
    194C: 38 F4    ADD   SP,0xF4
(0601) 				OutboxBuff.TBrakeFlag,
(0602) 				OutboxBuff.X_trs,
(0603) 				OutboxBuff.Y_trs,
(0604) 				OutboxBuff.Z_trs,
(0605) 				ec);
(0606) 			LCD_1_Position(1, 0);
    194E: 10       PUSH  X
    194F: 57 00    MOV   X,0x0
    1951: 50 01    MOV   A,0x1
    1953: 7C 08 E9 LCALL _LCD_1_Position
    1956: 20       POP   X
(0607) 			cprintf("B%1X M:%02X %02X %02X C%02X",
    1957: 62 D0 00 MOV   REG[0xD0],0x0
    195A: 51 91    MOV   A,[ct]
    195C: 62 D0 00 MOV   REG[0xD0],0x0
    195F: 53 48    MOV   [__r1],A
    1961: 50 00    MOV   A,0x0
    1963: 08       PUSH  A
    1964: 51 48    MOV   A,[__r1]
    1966: 08       PUSH  A
    1967: 62 D0 00 MOV   REG[0xD0],0x0
    196A: 51 6B    MOV   A,[InboxBuff+4]
    196C: 62 D0 00 MOV   REG[0xD0],0x0
    196F: 53 48    MOV   [__r1],A
    1971: 50 00    MOV   A,0x0
    1973: 08       PUSH  A
    1974: 51 48    MOV   A,[__r1]
    1976: 08       PUSH  A
    1977: 62 D0 00 MOV   REG[0xD0],0x0
    197A: 51 6A    MOV   A,[InboxBuff+3]
    197C: 62 D0 00 MOV   REG[0xD0],0x0
    197F: 53 48    MOV   [__r1],A
    1981: 50 00    MOV   A,0x0
    1983: 08       PUSH  A
    1984: 51 48    MOV   A,[__r1]
    1986: 08       PUSH  A
    1987: 62 D0 00 MOV   REG[0xD0],0x0
    198A: 51 69    MOV   A,[InboxBuff+2]
    198C: 62 D0 00 MOV   REG[0xD0],0x0
    198F: 53 48    MOV   [__r1],A
    1991: 50 00    MOV   A,0x0
    1993: 08       PUSH  A
    1994: 51 48    MOV   A,[__r1]
    1996: 08       PUSH  A
    1997: 62 D0 00 MOV   REG[0xD0],0x0
    199A: 51 68    MOV   A,[InboxBuff+1]
    199C: 62 D0 00 MOV   REG[0xD0],0x0
    199F: 53 48    MOV   [__r1],A
    19A1: 50 00    MOV   A,0x0
    19A3: 08       PUSH  A
    19A4: 51 48    MOV   A,[__r1]
    19A6: 08       PUSH  A
    19A7: 50 01    MOV   A,0x1
    19A9: 08       PUSH  A
    19AA: 50 A2    MOV   A,0xA2
    19AC: 08       PUSH  A
    19AD: 7C 49 ED LCALL _cprintf
    19B0: 38 F4    ADD   SP,0xF4
(0608) 				InboxBuff.CBrakeFlag,
(0609) 				InboxBuff.X_crs,
(0610) 				InboxBuff.Y_crs,
(0611) 				InboxBuff.Z_crs,
(0612) 				ct);
(0613) 		}
(0614) 	}
    19B2: 7D 0B 33 LJMP  0x0B33
    19B5: 38 F9    ADD   SP,0xF9
    19B7: 20       POP   X
    19B8: 8F FF    JMP   0x19B8
(0615) 	
(0616) }
(0617) 
(0618) //update motors prs
(0619) #pragma interrupt_handler _Timer8_1_ISR
(0620) #pragma nomac
(0621) void _Timer8_1_ISR(void)
(0622) {
__Timer8_1_ISR:
    19BA: 71 C0    OR    F,0xC0
    19BC: 08       PUSH  A
    19BD: 5D D0    MOV   A,REG[0xD0]
    19BF: 08       PUSH  A
    19C0: 5D D3    MOV   A,REG[0xD3]
    19C2: 08       PUSH  A
    19C3: 5D D4    MOV   A,REG[0xD4]
    19C5: 08       PUSH  A
    19C6: 5D D5    MOV   A,REG[0xD5]
    19C8: 08       PUSH  A
    19C9: 62 D0 00 MOV   REG[0xD0],0x0
    19CC: 51 49    MOV   A,[__r0]
    19CE: 08       PUSH  A
    19CF: 51 48    MOV   A,[__r1]
    19D1: 08       PUSH  A
    19D2: 51 47    MOV   A,[__r2]
    19D4: 08       PUSH  A
    19D5: 51 46    MOV   A,[__r3]
    19D7: 08       PUSH  A
    19D8: 51 45    MOV   A,[__r4]
    19DA: 08       PUSH  A
    19DB: 51 44    MOV   A,[__r5]
    19DD: 08       PUSH  A
    19DE: 51 43    MOV   A,[__r6]
    19E0: 08       PUSH  A
    19E1: 51 42    MOV   A,[__r7]
    19E3: 08       PUSH  A
    19E4: 51 41    MOV   A,[__r8]
    19E6: 08       PUSH  A
    19E7: 51 40    MOV   A,[__r9]
    19E9: 08       PUSH  A
    19EA: 51 3F    MOV   A,[__r10]
    19EC: 08       PUSH  A
    19ED: 51 3E    MOV   A,[__r11]
    19EF: 08       PUSH  A
    19F0: 51 3D    MOV   A,[__rX]
    19F2: 08       PUSH  A
    19F3: 51 3C    MOV   A,[__rY]
    19F5: 08       PUSH  A
    19F6: 51 3B    MOV   A,[__rZ]
    19F8: 08       PUSH  A
(0623) 	static BYTE sw;
(0624) 	static BYTE i2ccount;
(0625) 	
(0626) 	//update X motor prs
(0627) 	if (sw == 0)
    19F9: 62 D0 00 MOV   REG[0xD0],0x0
    19FC: 3C 8E 00 CMP   [sw_Z+1],0x0
    19FF: B0 3A    JNZ   0x1A3A
(0628) 	{
(0629) 		if (sw_X)
    1A01: 62 D0 00 MOV   REG[0xD0],0x0
    1A04: 3C 97 00 CMP   [sw_X],0x0
    1A07: A0 0B    JZ    0x1A13
(0630) 		{
(0631) 			MBM_1_SetBusyFlag();
    1A09: 7C 29 9E LCALL _MBM_1_SetBusyFlag
(0632) 			ec++;
    1A0C: 62 D0 00 MOV   REG[0xD0],0x0
    1A0F: 76 90    INC   [ec]
(0633) 		}
    1A11: 80 04    JMP   0x1A16
(0634) 		else
(0635) 		{
(0636) 			MBM_1_ClearBusyFlag();
    1A13: 7C 29 A5 LCALL _MBM_1_ClearBusyFlag
(0637) 		}
(0638) 		PRS32_X_WriteSeed(prs_X);
    1A16: 10       PUSH  X
    1A17: 62 D0 00 MOV   REG[0xD0],0x0
    1A1A: 51 70    MOV   A,[prs_X]
    1A1C: 08       PUSH  A
    1A1D: 51 71    MOV   A,[prs_X+1]
    1A1F: 08       PUSH  A
    1A20: 51 72    MOV   A,[prs_X+2]
    1A22: 08       PUSH  A
    1A23: 51 73    MOV   A,[prs_X+3]
    1A25: 08       PUSH  A
    1A26: 7C 07 05 LCALL _PRS32_X_WriteSeed
    1A29: 38 FC    ADD   SP,0xFC
    1A2B: 20       POP   X
(0639) 		sw_X = TRUE;
    1A2C: 62 D0 00 MOV   REG[0xD0],0x0
    1A2F: 55 97 01 MOV   [sw_X],0x1
(0640) 		sw = 1;
    1A32: 62 D0 00 MOV   REG[0xD0],0x0
    1A35: 55 8E 01 MOV   [sw_Z+1],0x1
(0641) 	}
    1A38: 80 79    JMP   0x1AB2
(0642) 	
(0643) 	//update Y motor prs
(0644) 	else if (sw == 1)
    1A3A: 62 D0 00 MOV   REG[0xD0],0x0
    1A3D: 3C 8E 01 CMP   [sw_Z+1],0x1
    1A40: B0 3A    JNZ   0x1A7B
(0645) 	{
(0646) 		if (sw_Y)
    1A42: 62 D0 00 MOV   REG[0xD0],0x0
    1A45: 3C 98 00 CMP   [sw_Y],0x0
    1A48: A0 0B    JZ    0x1A54
(0647) 		{
(0648) 			MBM_1_SetBusyFlag();
    1A4A: 7C 29 9E LCALL _MBM_1_SetBusyFlag
(0649) 			ec++;
    1A4D: 62 D0 00 MOV   REG[0xD0],0x0
    1A50: 76 90    INC   [ec]
(0650) 		}
    1A52: 80 04    JMP   0x1A57
(0651) 		else
(0652) 		{
(0653) 			MBM_1_ClearBusyFlag();
    1A54: 7C 29 A5 LCALL _MBM_1_ClearBusyFlag
(0654) 		}
(0655) 		PRS32_Y_WriteSeed(prs_Y);
    1A57: 10       PUSH  X
    1A58: 62 D0 00 MOV   REG[0xD0],0x0
    1A5B: 51 7C    MOV   A,[prs_Y]
    1A5D: 08       PUSH  A
    1A5E: 51 7D    MOV   A,[prs_Y+1]
    1A60: 08       PUSH  A
    1A61: 51 7E    MOV   A,[prs_Y+2]
    1A63: 08       PUSH  A
    1A64: 51 7F    MOV   A,[prs_Y+3]
    1A66: 08       PUSH  A
    1A67: 7C 06 9E LCALL _PRS32_Y_WriteSeed
    1A6A: 38 FC    ADD   SP,0xFC
    1A6C: 20       POP   X
(0656) 		sw_Y = TRUE;
    1A6D: 62 D0 00 MOV   REG[0xD0],0x0
    1A70: 55 98 01 MOV   [sw_Y],0x1
(0657) 		sw = 2;
    1A73: 62 D0 00 MOV   REG[0xD0],0x0
    1A76: 55 8E 02 MOV   [sw_Z+1],0x2
(0658) 	}
    1A79: 80 38    JMP   0x1AB2
(0659) 	
(0660) 	//update Z motor prs
(0661) 	else
(0662) 	{
(0663) 		if (sw_Z)
    1A7B: 62 D0 00 MOV   REG[0xD0],0x0
    1A7E: 3C 8D 00 CMP   [sw_Z],0x0
    1A81: A0 0B    JZ    0x1A8D
(0664) 		{
(0665) 			MBM_1_SetBusyFlag();
    1A83: 7C 29 9E LCALL _MBM_1_SetBusyFlag
(0666) 			ec++;
    1A86: 62 D0 00 MOV   REG[0xD0],0x0
    1A89: 76 90    INC   [ec]
(0667) 		}
    1A8B: 80 04    JMP   0x1A90
(0668) 		else
(0669) 		{
(0670) 			MBM_1_ClearBusyFlag();
    1A8D: 7C 29 A5 LCALL _MBM_1_ClearBusyFlag
(0671) 		}
(0672) 		PRS32_Z_WriteSeed(prs_Z);
    1A90: 10       PUSH  X
    1A91: 62 D0 00 MOV   REG[0xD0],0x0
    1A94: 51 74    MOV   A,[prs_Z]
    1A96: 08       PUSH  A
    1A97: 51 75    MOV   A,[prs_Z+1]
    1A99: 08       PUSH  A
    1A9A: 51 76    MOV   A,[prs_Z+2]
    1A9C: 08       PUSH  A
    1A9D: 51 77    MOV   A,[prs_Z+3]
    1A9F: 08       PUSH  A
    1AA0: 7C 06 37 LCALL _PRS32_Z_WriteSeed
    1AA3: 38 FC    ADD   SP,0xFC
    1AA5: 20       POP   X
(0673) 		sw_Z = TRUE;
    1AA6: 62 D0 00 MOV   REG[0xD0],0x0
    1AA9: 55 8D 01 MOV   [sw_Z],0x1
(0674) 		sw = 0;
    1AAC: 62 D0 00 MOV   REG[0xD0],0x0
    1AAF: 55 8E 00 MOV   [sw_Z+1],0x0
(0675) 	}
(0676) 	
(0677) 	if (i2cchekc)
    1AB2: 62 D0 00 MOV   REG[0xD0],0x0
    1AB5: 3C 96 00 CMP   [i2cchekc],0x0
    1AB8: A0 0F    JZ    0x1AC8
(0678) 	{
(0679) 		i2ccount = 0;
    1ABA: 62 D0 00 MOV   REG[0xD0],0x0
    1ABD: 55 8F 00 MOV   [sw_Z+2],0x0
(0680) 		i2cchekc = FALSE;
    1AC0: 62 D0 00 MOV   REG[0xD0],0x0
    1AC3: 55 96 00 MOV   [i2cchekc],0x0
(0681) 	}
    1AC6: 80 17    JMP   0x1ADE
(0682) 	else
(0683) 	{
(0684) 		//1 count = 2.73 ms
(0685) 		if (i2ccount > 35)
    1AC8: 62 D0 00 MOV   REG[0xD0],0x0
    1ACB: 50 23    MOV   A,0x23
    1ACD: 3A 8F    CMP   A,[sw_Z+2]
    1ACF: D0 09    JNC   0x1AD9
(0686) 		{
(0687) 			//stop
(0688) 			bitSet(OutboxBuff.TBrakeFlag, (STOP_X | STOP_Y | STOP_Z));
    1AD1: 62 D0 00 MOV   REG[0xD0],0x0
    1AD4: 2E 5A 07 OR    [OutboxBuff+1],0x7
(0689) 		}
    1AD7: 80 06    JMP   0x1ADE
(0690) 		else
(0691) 		{
(0692) 			i2ccount++;
    1AD9: 62 D0 00 MOV   REG[0xD0],0x0
    1ADC: 76 8F    INC   [sw_Z+2]
(0693) 		}
(0694) 	}	
(0695) 	
(0696) 	ct++;
    1ADE: 62 D0 00 MOV   REG[0xD0],0x0
    1AE1: 76 91    INC   [ct]
    1AE3: 62 D0 00 MOV   REG[0xD0],0x0
    1AE6: 18       POP   A
    1AE7: 53 3B    MOV   [__rZ],A
    1AE9: 18       POP   A
    1AEA: 53 3C    MOV   [__rY],A
    1AEC: 18       POP   A
    1AED: 53 3D    MOV   [__rX],A
    1AEF: 18       POP   A
    1AF0: 53 3E    MOV   [__r11],A
    1AF2: 18       POP   A
    1AF3: 53 3F    MOV   [__r10],A
    1AF5: 18       POP   A
    1AF6: 53 40    MOV   [__r9],A
    1AF8: 18       POP   A
    1AF9: 53 41    MOV   [__r8],A
    1AFB: 18       POP   A
    1AFC: 53 42    MOV   [__r7],A
    1AFE: 18       POP   A
    1AFF: 53 43    MOV   [__r6],A
    1B01: 18       POP   A
    1B02: 53 44    MOV   [__r5],A
    1B04: 18       POP   A
    1B05: 53 45    MOV   [__r4],A
    1B07: 18       POP   A
    1B08: 53 46    MOV   [__r3],A
    1B0A: 18       POP   A
    1B0B: 53 47    MOV   [__r2],A
    1B0D: 18       POP   A
    1B0E: 53 48    MOV   [__r1],A
    1B10: 18       POP   A
    1B11: 53 49    MOV   [__r0],A
    1B13: 18       POP   A
    1B14: 60 D5    MOV   REG[0xD5],A
    1B16: 18       POP   A
    1B17: 60 D4    MOV   REG[0xD4],A
    1B19: 18       POP   A
    1B1A: 60 D3    MOV   REG[0xD3],A
    1B1C: 18       POP   A
    1B1D: 60 D0    MOV   REG[0xD0],A
    1B1F: 18       POP   A
    1B20: 7E       RETI  
(0697) }
(0698) #pragma usemac
(0699) 
(0700) //putchar for LCD cprintf
(0701) int putchar(char c)
(0702) {
_putchar:
  str                  --> X+0
  c                    --> X-4
    1B21: 10       PUSH  X
    1B22: 4F       MOV   X,SP
    1B23: 38 02    ADD   SP,0x2
(0703) 	char str[2] = {0};
    1B25: 62 D0 00 MOV   REG[0xD0],0x0
    1B28: 55 48 A0 MOV   [__r1],0xA0
    1B2B: 55 49 01 MOV   [__r0],0x1
    1B2E: 5A 46    MOV   [__r3],X
    1B30: 62 D5 07 MOV   REG[0xD5],0x7
    1B33: 10       PUSH  X
    1B34: 55 3D 00 MOV   [__rX],0x0
    1B37: 51 49    MOV   A,[__r0]
    1B39: 58 48    MOV   X,[__r1]
    1B3B: 08       PUSH  A
    1B3C: 28       ROMX  
    1B3D: 62 D0 00 MOV   REG[0xD0],0x0
    1B40: 3F 46    MVI   [__r3],A
    1B42: 18       POP   A
    1B43: 75       INC   X
    1B44: 09 00    ADC   A,0x0
    1B46: 76 3D    INC   [__rX]
    1B48: 3C 3D 02 CMP   [__rX],0x2
    1B4B: BF EF    JNZ   0x1B3B
    1B4D: 20       POP   X
(0704) 	str[0] = c;
    1B4E: 52 FC    MOV   A,[X-4]
    1B50: 54 00    MOV   [X+0],A
(0705) 	LCD_1_PrString(str);
    1B52: 10       PUSH  X
    1B53: 50 07    MOV   A,0x7
    1B55: 08       PUSH  A
    1B56: 18       POP   A
    1B57: 7C 07 A0 LCALL _LCD_1_PrString
    1B5A: 20       POP   X
(0706) 	return c;
    1B5B: 62 D0 00 MOV   REG[0xD0],0x0
    1B5E: 52 FC    MOV   A,[X-4]
    1B60: 53 48    MOV   [__r1],A
    1B62: 55 49 00 MOV   [__r0],0x0
    1B65: 38 FE    ADD   SP,0xFE
    1B67: 20       POP   X
    1B68: 7F       RET   
FILE: C:\Users\tatsuya\Dropbox\\vO~1\PSoC\Designer\CATCHR~2\CATCHR~1\CATCHR~1\lib\mbm_1.c
(0001) //*****************************************************************************
(0002) //*****************************************************************************
(0003) //  FILENAME: MBM_1.c
(0004) //  Version: 1.1, Updated on 2013/5/19 at 10:43:55
(0005) //  Generated by PSoC Designer 5.4.2946
(0006) //
(0007) //  DESCRIPTION: MBM_1 User Module C Language implementation file
(0008) //-----------------------------------------------------------------------------
(0009) //  Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
(0010) //*****************************************************************************
(0011) //*****************************************************************************
(0012) 
(0013) #include "MBM_1.h"
(0014) 
(0015) // ---------------------------------------------------------------------------
(0016) //
(0017) // MBM_1_InitializeMailbox() - initializes mailbox
(0018) //
(0019) // arguments: 
(0020) //      pointer mailbox to initialize
(0021) //
(0022) // ---------------------------------------------------------------------------
(0023) void MBM_1_InitializeMailbox(void)
(0024) {
(0025)     // initialize flags
(0026)     MBM_1_MyMailbox.MailboxConfig0 &= ~MBM_1_BUSY ;             // clear busy flag
_MBM_1_InitializeMailbox:
    2994: 62 D0 00 MOV   REG[0xD0],0x0
    2997: 26 26 3F AND   [MBM_1_MyMailbox],0x3F
(0027)     MBM_1_MyMailbox.MailboxConfig0 &= ~MBM_1_DIRTY ;            // clear dirty flag
(0028)     // set mailbox size as identifier
(0029)     MBM_1_MyMailbox.MailboxConfig0 = sizeof(MBM_1_MyMailbox) ;           
    299A: 55 26 15 MOV   [MBM_1_MyMailbox],0x15
    299D: 7F       RET   
(0030) }
(0031) 
(0032) // ---------------------------------------------------------------------------
(0033) //
(0034) // MBM_1_SetBusyFlag() - sets BUSY flag for mailbox.
(0035) //
(0036) // arguments: 
(0037) //      pointer mailbox where the BUSY flag needs to be set
(0038) //
(0039) // ---------------------------------------------------------------------------
(0040) void MBM_1_SetBusyFlag(void)
(0041) {
(0042)     MBM_1_MyMailbox.MailboxConfig0 |= MBM_1_BUSY ;        /* Set busy flag. */
_MBM_1_SetBusyFlag:
    299E: 62 D0 00 MOV   REG[0xD0],0x0
    29A1: 2E 26 80 OR    [MBM_1_MyMailbox],0x80
    29A4: 7F       RET   
(0043) }
(0044) 
(0045) // ---------------------------------------------------------------------------
(0046) //
(0047) // MBM_1_ClearBusyFlag() - clears BUSY flag in desired mailbox.
(0048) //
(0049) // arguments: 
(0050) //      pointer mailbox where the BUSY flag needs to be cleared
(0051) //
(0052) // ---------------------------------------------------------------------------
(0053) void MBM_1_ClearBusyFlag(void)
(0054) {
(0055)    MBM_1_MyMailbox.MailboxConfig0 &= ~MBM_1_BUSY ;        /* Set busy flag. */
_MBM_1_ClearBusyFlag:
    29A5: 62 D0 00 MOV   REG[0xD0],0x0
    29A8: 26 26 7F AND   [MBM_1_MyMailbox],0x7F
    29AB: 7F       RET   
(0056) }
(0057) 
(0058) // ---------------------------------------------------------------------------
(0059) //
(0060) // MBM_1_CheckDirtyFlag() - checks for DIRTY flag in desired mailbox.
(0061) //
(0062) // arguments: 
(0063) //      pointer mailbox where the check for DIRTY flag needs to be done
(0064) //
(0065) // ---------------------------------------------------------------------------
(0066) BYTE MBM_1_CheckDirtyFlag(void)
(0067) {
(0068)     if(MBM_1_MyMailbox.MailboxConfig0 & MBM_1_DIRTY)
_MBM_1_CheckDirtyFlag:
    29AC: 62 D0 00 MOV   REG[0xD0],0x0
    29AF: 47 26 40 TST   [MBM_1_MyMailbox],0x40
    29B2: A0 08    JZ    0x29BB
(0069) 		return TRUE;
    29B4: 62 D0 00 MOV   REG[0xD0],0x0
    29B7: 50 01    MOV   A,0x1
    29B9: 80 06    JMP   0x29C0
(0070) 	else
(0071) 		return FALSE;
    29BB: 62 D0 00 MOV   REG[0xD0],0x0
(0072) }
(0073) 
(0074) // ---------------------------------------------------------------------------
(0075) // MBM_1 global mailbox variable in RAM and pointer to this mailbox
(0076) // ---------------------------------------------------------------------------
(0077) MBM_1_Mailbox MBM_1_MyMailbox;
(0078) MBM_1_Mailbox* MBM_1_pMyMailbox;
    29BE: 50 00    MOV   A,0x0
    29C0: 7F       RET   
_strlenLMM:
    2F48: 62 D0 00 MOV   REG[0xD0],0x0
    2F4B: 10       PUSH  X
    2F4C: 4F       MOV   X,SP
    2F4D: 52 FB    MOV   A,[X-5]
    2F4F: 60 D4    MOV   REG[0xD4],A
    2F51: 80 03    JMP   0x2F55
_strlen:
    2F53: 10       PUSH  X
    2F54: 4F       MOV   X,SP
    2F55: 55 48 00 MOV   [__r1],0x0
    2F58: 55 49 00 MOV   [__r0],0x0
    2F5B: 52 FC    MOV   A,[X-4]
    2F5D: 53 47    MOV   [__r2],A
    2F5F: 3E 47    MVI   A,[__r2]
    2F61: 39 00    CMP   A,0x0
    2F63: A0 08    JZ    0x2F6C
    2F65: 76 48    INC   [__r1]
    2F67: 0E 49 00 ADC   [__r0],0x0
    2F6A: 8F F4    JMP   0x2F5F
    2F6C: 20       POP   X
    2F6D: 7F       RET   
_cstrlenLMM:
    2F6E: 62 D0 00 MOV   REG[0xD0],0x0
_cstrlen:
    2F71: 10       PUSH  X
    2F72: 4F       MOV   X,SP
    2F73: 55 48 00 MOV   [__r1],0x0
    2F76: 55 49 00 MOV   [__r0],0x0
    2F79: 10       PUSH  X
    2F7A: 52 FB    MOV   A,[X-5]
    2F7C: 59 FC    MOV   X,[X-4]
    2F7E: 28       ROMX  
    2F7F: 20       POP   X
    2F80: 39 00    CMP   A,0x0
    2F82: A0 0D    JZ    0x2F90
    2F84: 76 48    INC   [__r1]
    2F86: 0E 49 00 ADC   [__r0],0x0
    2F89: 77 FC    INC   [X-4]
    2F8B: 0F FB 00 ADC   [X-5],0x0
    2F8E: 8F EA    JMP   0x2F79
    2F90: 20       POP   X
    2F91: 7F       RET   
__plcall:
    2F92: 53 3D    MOV   [__rX],A
    2F94: 28       ROMX  
    2F95: 08       PUSH  A
    2F96: 51 3D    MOV   A,[__rX]
    2F98: 75       INC   X
    2F99: 09 00    ADC   A,0x0
    2F9B: 28       ROMX  
    2F9C: 08       PUSH  A
    2F9D: 7F       RET   
_itoa:
    2F9E: 10       PUSH  X
    2F9F: 4F       MOV   X,SP
    2FA0: 38 09    ADD   SP,0x9
    2FA2: 52 FA    MOV   A,[X-6]
    2FA4: 54 03    MOV   [X+3],A
    2FA6: 52 F9    MOV   A,[X-7]
    2FA8: 54 02    MOV   [X+2],A
    2FAA: 3D F9 00 CMP   [X-7],0x0
    2FAD: B0 2F    JNZ   0x2FDD
    2FAF: 3D FA 00 CMP   [X-6],0x0
    2FB2: B0 2A    JNZ   0x2FDD
    2FB4: 62 D0 00 MOV   REG[0xD0],0x0
    2FB7: 52 FC    MOV   A,[X-4]
    2FB9: 53 48    MOV   [__r1],A
    2FBB: 52 FB    MOV   A,[X-5]
    2FBD: 60 D5    MOV   REG[0xD5],A
    2FBF: 50 30    MOV   A,0x30
    2FC1: 3F 48    MVI   [__r1],A
    2FC3: 52 FC    MOV   A,[X-4]
    2FC5: 01 01    ADD   A,0x1
    2FC7: 53 48    MOV   [__r1],A
    2FC9: 52 FB    MOV   A,[X-5]
    2FCB: 09 00    ADC   A,0x0
    2FCD: 60 D5    MOV   REG[0xD5],A
    2FCF: 50 00    MOV   A,0x0
    2FD1: 3F 48    MVI   [__r1],A
    2FD3: 52 FC    MOV   A,[X-4]
    2FD5: 53 48    MOV   [__r1],A
    2FD7: 52 FB    MOV   A,[X-5]
    2FD9: 53 49    MOV   [__r0],A
    2FDB: 81 97    JMP   0x3173
    2FDD: 52 FA    MOV   A,[X-6]
    2FDF: 11 00    SUB   A,0x0
    2FE1: 52 F9    MOV   A,[X-7]
    2FE3: 31 80    XOR   A,0x80
    2FE5: 19 80    SBB   A,0x80
    2FE7: D0 29    JNC   0x3011
    2FE9: 3D F7 00 CMP   [X-9],0x0
    2FEC: B0 24    JNZ   0x3011
    2FEE: 3D F8 0A CMP   [X-8],0xA
    2FF1: B0 1F    JNZ   0x3011
    2FF3: 56 06 01 MOV   [X+6],0x1
    2FF6: 62 D0 00 MOV   REG[0xD0],0x0
    2FF9: 52 03    MOV   A,[X+3]
    2FFB: 73       CPL   A
    2FFC: 53 48    MOV   [__r1],A
    2FFE: 52 02    MOV   A,[X+2]
    3000: 73       CPL   A
    3001: 53 49    MOV   [__r0],A
    3003: 51 48    MOV   A,[__r1]
    3005: 01 01    ADD   A,0x1
    3007: 54 03    MOV   [X+3],A
    3009: 51 49    MOV   A,[__r0]
    300B: 09 00    ADC   A,0x0
    300D: 54 02    MOV   [X+2],A
    300F: 80 04    JMP   0x3014
    3011: 56 06 00 MOV   [X+6],0x0
    3014: 52 FC    MOV   A,[X-4]
    3016: 54 01    MOV   [X+1],A
    3018: 52 FB    MOV   A,[X-5]
    301A: 54 00    MOV   [X+0],A
    301C: 62 D0 00 MOV   REG[0xD0],0x0
    301F: 52 F7    MOV   A,[X-9]
    3021: 08       PUSH  A
    3022: 52 F8    MOV   A,[X-8]
    3024: 08       PUSH  A
    3025: 52 02    MOV   A,[X+2]
    3027: 08       PUSH  A
    3028: 52 03    MOV   A,[X+3]
    302A: 08       PUSH  A
    302B: 7C 29 C1 LCALL 0x29C1
    302E: 38 FE    ADD   SP,0xFE
    3030: 18       POP   A
    3031: 53 48    MOV   [__r1],A
    3033: 18       POP   A
    3034: 53 49    MOV   [__r0],A
    3036: 51 48    MOV   A,[__r1]
    3038: 54 08    MOV   [X+8],A
    303A: 51 49    MOV   A,[__r0]
    303C: 54 07    MOV   [X+7],A
    303E: 50 09    MOV   A,0x9
    3040: 13 08    SUB   A,[X+8]
    3042: 52 07    MOV   A,[X+7]
    3044: 31 80    XOR   A,0x80
    3046: 53 3D    MOV   [__rX],A
    3048: 50 80    MOV   A,0x80
    304A: 1A 3D    SBB   A,[__rX]
    304C: C0 28    JC    0x3075
    304E: 62 D0 00 MOV   REG[0xD0],0x0
    3051: 52 01    MOV   A,[X+1]
    3053: 53 48    MOV   [__r1],A
    3055: 52 00    MOV   A,[X+0]
    3057: 53 49    MOV   [__r0],A
    3059: 51 48    MOV   A,[__r1]
    305B: 01 01    ADD   A,0x1
    305D: 54 01    MOV   [X+1],A
    305F: 51 49    MOV   A,[__r0]
    3061: 09 00    ADC   A,0x0
    3063: 54 00    MOV   [X+0],A
    3065: 52 08    MOV   A,[X+8]
    3067: 01 30    ADD   A,0x30
    3069: 53 47    MOV   [__r2],A
    306B: 51 49    MOV   A,[__r0]
    306D: 60 D5    MOV   REG[0xD5],A
    306F: 51 47    MOV   A,[__r2]
    3071: 3F 48    MVI   [__r1],A
    3073: 80 26    JMP   0x309A
    3075: 62 D0 00 MOV   REG[0xD0],0x0
    3078: 52 01    MOV   A,[X+1]
    307A: 53 48    MOV   [__r1],A
    307C: 52 00    MOV   A,[X+0]
    307E: 53 49    MOV   [__r0],A
    3080: 51 48    MOV   A,[__r1]
    3082: 01 01    ADD   A,0x1
    3084: 54 01    MOV   [X+1],A
    3086: 51 49    MOV   A,[__r0]
    3088: 09 00    ADC   A,0x0
    308A: 54 00    MOV   [X+0],A
    308C: 52 08    MOV   A,[X+8]
    308E: 01 57    ADD   A,0x57
    3090: 53 47    MOV   [__r2],A
    3092: 51 49    MOV   A,[__r0]
    3094: 60 D5    MOV   REG[0xD5],A
    3096: 51 47    MOV   A,[__r2]
    3098: 3F 48    MVI   [__r1],A
    309A: 52 F7    MOV   A,[X-9]
    309C: 08       PUSH  A
    309D: 52 F8    MOV   A,[X-8]
    309F: 08       PUSH  A
    30A0: 52 02    MOV   A,[X+2]
    30A2: 08       PUSH  A
    30A3: 52 03    MOV   A,[X+3]
    30A5: 08       PUSH  A
    30A6: 62 D0 00 MOV   REG[0xD0],0x0
    30A9: 7C 29 C1 LCALL 0x29C1
    30AC: 18       POP   A
    30AD: 54 03    MOV   [X+3],A
    30AF: 18       POP   A
    30B0: 54 02    MOV   [X+2],A
    30B2: 38 FE    ADD   SP,0xFE
    30B4: 3D 02 00 CMP   [X+2],0x0
    30B7: BF 64    JNZ   0x301C
    30B9: 3D 03 00 CMP   [X+3],0x0
    30BC: BF 5F    JNZ   0x301C
    30BE: 3D 06 00 CMP   [X+6],0x0
    30C1: A0 20    JZ    0x30E2
    30C3: 62 D0 00 MOV   REG[0xD0],0x0
    30C6: 52 01    MOV   A,[X+1]
    30C8: 53 48    MOV   [__r1],A
    30CA: 52 00    MOV   A,[X+0]
    30CC: 53 49    MOV   [__r0],A
    30CE: 51 48    MOV   A,[__r1]
    30D0: 01 01    ADD   A,0x1
    30D2: 54 01    MOV   [X+1],A
    30D4: 51 49    MOV   A,[__r0]
    30D6: 09 00    ADC   A,0x0
    30D8: 54 00    MOV   [X+0],A
    30DA: 51 49    MOV   A,[__r0]
    30DC: 60 D5    MOV   REG[0xD5],A
    30DE: 50 2D    MOV   A,0x2D
    30E0: 3F 48    MVI   [__r1],A
    30E2: 62 D0 00 MOV   REG[0xD0],0x0
    30E5: 52 01    MOV   A,[X+1]
    30E7: 53 48    MOV   [__r1],A
    30E9: 52 00    MOV   A,[X+0]
    30EB: 53 49    MOV   [__r0],A
    30ED: 51 48    MOV   A,[__r1]
    30EF: 01 FF    ADD   A,0xFF
    30F1: 54 01    MOV   [X+1],A
    30F3: 51 49    MOV   A,[__r0]
    30F5: 09 FF    ADC   A,0xFF
    30F7: 54 00    MOV   [X+0],A
    30F9: 51 49    MOV   A,[__r0]
    30FB: 60 D5    MOV   REG[0xD5],A
    30FD: 50 00    MOV   A,0x0
    30FF: 3F 48    MVI   [__r1],A
    3101: 52 FC    MOV   A,[X-4]
    3103: 54 05    MOV   [X+5],A
    3105: 52 FB    MOV   A,[X-5]
    3107: 54 04    MOV   [X+4],A
    3109: 80 54    JMP   0x315E
    310B: 62 D0 00 MOV   REG[0xD0],0x0
    310E: 52 05    MOV   A,[X+5]
    3110: 53 48    MOV   [__r1],A
    3112: 52 04    MOV   A,[X+4]
    3114: 60 D4    MOV   REG[0xD4],A
    3116: 3E 48    MVI   A,[__r1]
    3118: 54 06    MOV   [X+6],A
    311A: 52 05    MOV   A,[X+5]
    311C: 53 48    MOV   [__r1],A
    311E: 52 04    MOV   A,[X+4]
    3120: 53 49    MOV   [__r0],A
    3122: 51 48    MOV   A,[__r1]
    3124: 01 01    ADD   A,0x1
    3126: 54 05    MOV   [X+5],A
    3128: 51 49    MOV   A,[__r0]
    312A: 09 00    ADC   A,0x0
    312C: 54 04    MOV   [X+4],A
    312E: 52 01    MOV   A,[X+1]
    3130: 53 46    MOV   [__r3],A
    3132: 52 00    MOV   A,[X+0]
    3134: 60 D4    MOV   REG[0xD4],A
    3136: 3E 46    MVI   A,[__r3]
    3138: 53 47    MOV   [__r2],A
    313A: 51 49    MOV   A,[__r0]
    313C: 60 D5    MOV   REG[0xD5],A
    313E: 51 47    MOV   A,[__r2]
    3140: 3F 48    MVI   [__r1],A
    3142: 52 01    MOV   A,[X+1]
    3144: 53 48    MOV   [__r1],A
    3146: 52 00    MOV   A,[X+0]
    3148: 53 49    MOV   [__r0],A
    314A: 51 48    MOV   A,[__r1]
    314C: 01 FF    ADD   A,0xFF
    314E: 54 01    MOV   [X+1],A
    3150: 51 49    MOV   A,[__r0]
    3152: 09 FF    ADC   A,0xFF
    3154: 54 00    MOV   [X+0],A
    3156: 51 49    MOV   A,[__r0]
    3158: 60 D5    MOV   REG[0xD5],A
    315A: 52 06    MOV   A,[X+6]
    315C: 3F 48    MVI   [__r1],A
    315E: 52 05    MOV   A,[X+5]
    3160: 13 01    SUB   A,[X+1]
    3162: 52 04    MOV   A,[X+4]
    3164: 1B 00    SBB   A,[X+0]
    3166: CF A4    JC    0x310B
    3168: 62 D0 00 MOV   REG[0xD0],0x0
    316B: 52 FC    MOV   A,[X-4]
    316D: 53 48    MOV   [__r1],A
    316F: 52 FB    MOV   A,[X-5]
    3171: 53 49    MOV   [__r0],A
    3173: 38 F7    ADD   SP,0xF7
    3175: 20       POP   X
    3176: 7F       RET   
_ltoa:
    3177: 10       PUSH  X
    3178: 4F       MOV   X,SP
    3179: 38 0B    ADD   SP,0xB
    317B: 52 F7    MOV   A,[X-9]
    317D: 54 02    MOV   [X+2],A
    317F: 52 F8    MOV   A,[X-8]
    3181: 54 03    MOV   [X+3],A
    3183: 52 F9    MOV   A,[X-7]
    3185: 54 04    MOV   [X+4],A
    3187: 52 FA    MOV   A,[X-6]
    3189: 54 05    MOV   [X+5],A
    318B: 3D F7 00 CMP   [X-9],0x0
    318E: B0 39    JNZ   0x31C8
    3190: 3D F8 00 CMP   [X-8],0x0
    3193: B0 34    JNZ   0x31C8
    3195: 3D F9 00 CMP   [X-7],0x0
    3198: B0 2F    JNZ   0x31C8
    319A: 3D FA 00 CMP   [X-6],0x0
    319D: B0 2A    JNZ   0x31C8
    319F: 62 D0 00 MOV   REG[0xD0],0x0
    31A2: 52 FC    MOV   A,[X-4]
    31A4: 53 48    MOV   [__r1],A
    31A6: 52 FB    MOV   A,[X-5]
    31A8: 60 D5    MOV   REG[0xD5],A
    31AA: 50 30    MOV   A,0x30
    31AC: 3F 48    MVI   [__r1],A
    31AE: 52 FC    MOV   A,[X-4]
    31B0: 01 01    ADD   A,0x1
    31B2: 53 48    MOV   [__r1],A
    31B4: 52 FB    MOV   A,[X-5]
    31B6: 09 00    ADC   A,0x0
    31B8: 60 D5    MOV   REG[0xD5],A
    31BA: 50 00    MOV   A,0x0
    31BC: 3F 48    MVI   [__r1],A
    31BE: 52 FC    MOV   A,[X-4]
    31C0: 53 48    MOV   [__r1],A
    31C2: 52 FB    MOV   A,[X-5]
    31C4: 53 49    MOV   [__r0],A
    31C6: 82 25    JMP   0x33EC
    31C8: 52 FA    MOV   A,[X-6]
    31CA: 11 00    SUB   A,0x0
    31CC: 52 F9    MOV   A,[X-7]
    31CE: 19 00    SBB   A,0x0
    31D0: 52 F8    MOV   A,[X-8]
    31D2: 19 00    SBB   A,0x0
    31D4: 52 F7    MOV   A,[X-9]
    31D6: 31 80    XOR   A,0x80
    31D8: 19 80    SBB   A,0x80
    31DA: D0 3B    JNC   0x3216
    31DC: 3D F5 00 CMP   [X-11],0x0
    31DF: B0 36    JNZ   0x3216
    31E1: 3D F6 0A CMP   [X-10],0xA
    31E4: B0 31    JNZ   0x3216
    31E6: 56 08 01 MOV   [X+8],0x1
    31E9: 62 D0 00 MOV   REG[0xD0],0x0
    31EC: 52 02    MOV   A,[X+2]
    31EE: 73       CPL   A
    31EF: 53 49    MOV   [__r0],A
    31F1: 52 03    MOV   A,[X+3]
    31F3: 73       CPL   A
    31F4: 53 48    MOV   [__r1],A
    31F6: 52 04    MOV   A,[X+4]
    31F8: 73       CPL   A
    31F9: 53 47    MOV   [__r2],A
    31FB: 52 05    MOV   A,[X+5]
    31FD: 73       CPL   A
    31FE: 01 01    ADD   A,0x1
    3200: 54 05    MOV   [X+5],A
    3202: 51 47    MOV   A,[__r2]
    3204: 09 00    ADC   A,0x0
    3206: 54 04    MOV   [X+4],A
    3208: 51 48    MOV   A,[__r1]
    320A: 09 00    ADC   A,0x0
    320C: 54 03    MOV   [X+3],A
    320E: 51 49    MOV   A,[__r0]
    3210: 09 00    ADC   A,0x0
    3212: 54 02    MOV   [X+2],A
    3214: 80 04    JMP   0x3219
    3216: 56 08 00 MOV   [X+8],0x0
    3219: 52 FC    MOV   A,[X-4]
    321B: 54 01    MOV   [X+1],A
    321D: 52 FB    MOV   A,[X-5]
    321F: 54 00    MOV   [X+0],A
    3221: 62 D0 00 MOV   REG[0xD0],0x0
    3224: 52 F6    MOV   A,[X-10]
    3226: 53 46    MOV   [__r3],A
    3228: 52 F5    MOV   A,[X-11]
    322A: 53 47    MOV   [__r2],A
    322C: 47 47 80 TST   [__r2],0x80
    322F: A0 09    JZ    0x3239
    3231: 55 48 FF MOV   [__r1],0xFF
    3234: 55 49 FF MOV   [__r0],0xFF
    3237: 80 0A    JMP   0x3242
    3239: 62 D0 00 MOV   REG[0xD0],0x0
    323C: 55 48 00 MOV   [__r1],0x0
    323F: 55 49 00 MOV   [__r0],0x0
    3242: 62 D0 00 MOV   REG[0xD0],0x0
    3245: 51 49    MOV   A,[__r0]
    3247: 08       PUSH  A
    3248: 51 48    MOV   A,[__r1]
    324A: 08       PUSH  A
    324B: 51 47    MOV   A,[__r2]
    324D: 08       PUSH  A
    324E: 51 46    MOV   A,[__r3]
    3250: 08       PUSH  A
    3251: 52 02    MOV   A,[X+2]
    3253: 08       PUSH  A
    3254: 52 03    MOV   A,[X+3]
    3256: 08       PUSH  A
    3257: 52 04    MOV   A,[X+4]
    3259: 08       PUSH  A
    325A: 52 05    MOV   A,[X+5]
    325C: 08       PUSH  A
    325D: 7C 29 CC LCALL 0x29CC
    3260: 38 FC    ADD   SP,0xFC
    3262: 18       POP   A
    3263: 53 46    MOV   [__r3],A
    3265: 18       POP   A
    3266: 53 47    MOV   [__r2],A
    3268: 18       POP   A
    3269: 18       POP   A
    326A: 51 46    MOV   A,[__r3]
    326C: 53 48    MOV   [__r1],A
    326E: 51 47    MOV   A,[__r2]
    3270: 53 49    MOV   [__r0],A
    3272: 51 48    MOV   A,[__r1]
    3274: 54 0A    MOV   [X+10],A
    3276: 51 49    MOV   A,[__r0]
    3278: 54 09    MOV   [X+9],A
    327A: 50 09    MOV   A,0x9
    327C: 13 0A    SUB   A,[X+10]
    327E: 52 09    MOV   A,[X+9]
    3280: 31 80    XOR   A,0x80
    3282: 53 3D    MOV   [__rX],A
    3284: 50 80    MOV   A,0x80
    3286: 1A 3D    SBB   A,[__rX]
    3288: C0 28    JC    0x32B1
    328A: 62 D0 00 MOV   REG[0xD0],0x0
    328D: 52 01    MOV   A,[X+1]
    328F: 53 48    MOV   [__r1],A
    3291: 52 00    MOV   A,[X+0]
    3293: 53 49    MOV   [__r0],A
    3295: 51 48    MOV   A,[__r1]
    3297: 01 01    ADD   A,0x1
    3299: 54 01    MOV   [X+1],A
    329B: 51 49    MOV   A,[__r0]
    329D: 09 00    ADC   A,0x0
    329F: 54 00    MOV   [X+0],A
    32A1: 52 0A    MOV   A,[X+10]
    32A3: 01 30    ADD   A,0x30
    32A5: 53 47    MOV   [__r2],A
    32A7: 51 49    MOV   A,[__r0]
    32A9: 60 D5    MOV   REG[0xD5],A
    32AB: 51 47    MOV   A,[__r2]
    32AD: 3F 48    MVI   [__r1],A
    32AF: 80 26    JMP   0x32D6
    32B1: 62 D0 00 MOV   REG[0xD0],0x0
    32B4: 52 01    MOV   A,[X+1]
    32B6: 53 48    MOV   [__r1],A
    32B8: 52 00    MOV   A,[X+0]
    32BA: 53 49    MOV   [__r0],A
    32BC: 51 48    MOV   A,[__r1]
    32BE: 01 01    ADD   A,0x1
    32C0: 54 01    MOV   [X+1],A
    32C2: 51 49    MOV   A,[__r0]
    32C4: 09 00    ADC   A,0x0
    32C6: 54 00    MOV   [X+0],A
    32C8: 52 0A    MOV   A,[X+10]
    32CA: 01 57    ADD   A,0x57
    32CC: 53 47    MOV   [__r2],A
    32CE: 51 49    MOV   A,[__r0]
    32D0: 60 D5    MOV   REG[0xD5],A
    32D2: 51 47    MOV   A,[__r2]
    32D4: 3F 48    MVI   [__r1],A
    32D6: 62 D0 00 MOV   REG[0xD0],0x0
    32D9: 52 F6    MOV   A,[X-10]
    32DB: 53 46    MOV   [__r3],A
    32DD: 52 F5    MOV   A,[X-11]
    32DF: 53 47    MOV   [__r2],A
    32E1: 47 47 80 TST   [__r2],0x80
    32E4: A0 09    JZ    0x32EE
    32E6: 55 48 FF MOV   [__r1],0xFF
    32E9: 55 49 FF MOV   [__r0],0xFF
    32EC: 80 0A    JMP   0x32F7
    32EE: 62 D0 00 MOV   REG[0xD0],0x0
    32F1: 55 48 00 MOV   [__r1],0x0
    32F4: 55 49 00 MOV   [__r0],0x0
    32F7: 62 D0 00 MOV   REG[0xD0],0x0
    32FA: 51 49    MOV   A,[__r0]
    32FC: 08       PUSH  A
    32FD: 51 48    MOV   A,[__r1]
    32FF: 08       PUSH  A
    3300: 51 47    MOV   A,[__r2]
    3302: 08       PUSH  A
    3303: 51 46    MOV   A,[__r3]
    3305: 08       PUSH  A
    3306: 52 02    MOV   A,[X+2]
    3308: 08       PUSH  A
    3309: 52 03    MOV   A,[X+3]
    330B: 08       PUSH  A
    330C: 52 04    MOV   A,[X+4]
    330E: 08       PUSH  A
    330F: 52 05    MOV   A,[X+5]
    3311: 08       PUSH  A
    3312: 7C 29 CC LCALL 0x29CC
    3315: 18       POP   A
    3316: 54 05    MOV   [X+5],A
    3318: 18       POP   A
    3319: 54 04    MOV   [X+4],A
    331B: 18       POP   A
    331C: 54 03    MOV   [X+3],A
    331E: 18       POP   A
    331F: 54 02    MOV   [X+2],A
    3321: 38 FC    ADD   SP,0xFC
    3323: 3D 02 00 CMP   [X+2],0x0
    3326: BE FA    JNZ   0x3221
    3328: 3D 03 00 CMP   [X+3],0x0
    332B: BE F5    JNZ   0x3221
    332D: 3D 04 00 CMP   [X+4],0x0
    3330: BE F0    JNZ   0x3221
    3332: 3D 05 00 CMP   [X+5],0x0
    3335: BE EB    JNZ   0x3221
    3337: 3D 08 00 CMP   [X+8],0x0
    333A: A0 20    JZ    0x335B
    333C: 62 D0 00 MOV   REG[0xD0],0x0
    333F: 52 01    MOV   A,[X+1]
    3341: 53 48    MOV   [__r1],A
    3343: 52 00    MOV   A,[X+0]
    3345: 53 49    MOV   [__r0],A
    3347: 51 48    MOV   A,[__r1]
    3349: 01 01    ADD   A,0x1
    334B: 54 01    MOV   [X+1],A
    334D: 51 49    MOV   A,[__r0]
    334F: 09 00    ADC   A,0x0
    3351: 54 00    MOV   [X+0],A
    3353: 51 49    MOV   A,[__r0]
    3355: 60 D5    MOV   REG[0xD5],A
    3357: 50 2D    MOV   A,0x2D
    3359: 3F 48    MVI   [__r1],A
    335B: 62 D0 00 MOV   REG[0xD0],0x0
    335E: 52 01    MOV   A,[X+1]
    3360: 53 48    MOV   [__r1],A
    3362: 52 00    MOV   A,[X+0]
    3364: 53 49    MOV   [__r0],A
    3366: 51 48    MOV   A,[__r1]
    3368: 01 FF    ADD   A,0xFF
    336A: 54 01    MOV   [X+1],A
    336C: 51 49    MOV   A,[__r0]
    336E: 09 FF    ADC   A,0xFF
    3370: 54 00    MOV   [X+0],A
    3372: 51 49    MOV   A,[__r0]
    3374: 60 D5    MOV   REG[0xD5],A
    3376: 50 00    MOV   A,0x0
    3378: 3F 48    MVI   [__r1],A
    337A: 52 FC    MOV   A,[X-4]
    337C: 54 07    MOV   [X+7],A
    337E: 52 FB    MOV   A,[X-5]
    3380: 54 06    MOV   [X+6],A
    3382: 80 54    JMP   0x33D7
    3384: 62 D0 00 MOV   REG[0xD0],0x0
    3387: 52 07    MOV   A,[X+7]
    3389: 53 48    MOV   [__r1],A
    338B: 52 06    MOV   A,[X+6]
    338D: 60 D4    MOV   REG[0xD4],A
    338F: 3E 48    MVI   A,[__r1]
    3391: 54 08    MOV   [X+8],A
    3393: 52 07    MOV   A,[X+7]
    3395: 53 48    MOV   [__r1],A
    3397: 52 06    MOV   A,[X+6]
    3399: 53 49    MOV   [__r0],A
    339B: 51 48    MOV   A,[__r1]
    339D: 01 01    ADD   A,0x1
    339F: 54 07    MOV   [X+7],A
    33A1: 51 49    MOV   A,[__r0]
    33A3: 09 00    ADC   A,0x0
    33A5: 54 06    MOV   [X+6],A
    33A7: 52 01    MOV   A,[X+1]
    33A9: 53 46    MOV   [__r3],A
    33AB: 52 00    MOV   A,[X+0]
    33AD: 60 D4    MOV   REG[0xD4],A
    33AF: 3E 46    MVI   A,[__r3]
    33B1: 53 47    MOV   [__r2],A
    33B3: 51 49    MOV   A,[__r0]
    33B5: 60 D5    MOV   REG[0xD5],A
    33B7: 51 47    MOV   A,[__r2]
    33B9: 3F 48    MVI   [__r1],A
    33BB: 52 01    MOV   A,[X+1]
    33BD: 53 48    MOV   [__r1],A
    33BF: 52 00    MOV   A,[X+0]
    33C1: 53 49    MOV   [__r0],A
    33C3: 51 48    MOV   A,[__r1]
    33C5: 01 FF    ADD   A,0xFF
    33C7: 54 01    MOV   [X+1],A
    33C9: 51 49    MOV   A,[__r0]
    33CB: 09 FF    ADC   A,0xFF
    33CD: 54 00    MOV   [X+0],A
    33CF: 51 49    MOV   A,[__r0]
    33D1: 60 D5    MOV   REG[0xD5],A
    33D3: 52 08    MOV   A,[X+8]
    33D5: 3F 48    MVI   [__r1],A
    33D7: 52 07    MOV   A,[X+7]
    33D9: 13 01    SUB   A,[X+1]
    33DB: 52 06    MOV   A,[X+6]
    33DD: 1B 00    SBB   A,[X+0]
    33DF: CF A4    JC    0x3384
    33E1: 62 D0 00 MOV   REG[0xD0],0x0
    33E4: 52 FC    MOV   A,[X-4]
    33E6: 53 48    MOV   [__r1],A
    33E8: 52 FB    MOV   A,[X-5]
    33EA: 53 49    MOV   [__r0],A
    33EC: 38 F5    ADD   SP,0xF5
    33EE: 20       POP   X
    33EF: 7F       RET   
_ultoa:
    33F0: 10       PUSH  X
    33F1: 4F       MOV   X,SP
    33F2: 38 07    ADD   SP,0x7
    33F4: 52 FC    MOV   A,[X-4]
    33F6: 54 01    MOV   [X+1],A
    33F8: 52 FB    MOV   A,[X-5]
    33FA: 54 00    MOV   [X+0],A
    33FC: 62 D0 00 MOV   REG[0xD0],0x0
    33FF: 52 F6    MOV   A,[X-10]
    3401: 53 46    MOV   [__r3],A
    3403: 52 F5    MOV   A,[X-11]
    3405: 53 47    MOV   [__r2],A
    3407: 47 47 80 TST   [__r2],0x80
    340A: A0 09    JZ    0x3414
    340C: 55 48 FF MOV   [__r1],0xFF
    340F: 55 49 FF MOV   [__r0],0xFF
    3412: 80 0A    JMP   0x341D
    3414: 62 D0 00 MOV   REG[0xD0],0x0
    3417: 55 48 00 MOV   [__r1],0x0
    341A: 55 49 00 MOV   [__r0],0x0
    341D: 62 D0 00 MOV   REG[0xD0],0x0
    3420: 51 49    MOV   A,[__r0]
    3422: 08       PUSH  A
    3423: 51 48    MOV   A,[__r1]
    3425: 08       PUSH  A
    3426: 51 47    MOV   A,[__r2]
    3428: 08       PUSH  A
    3429: 51 46    MOV   A,[__r3]
    342B: 08       PUSH  A
    342C: 52 F7    MOV   A,[X-9]
    342E: 08       PUSH  A
    342F: 52 F8    MOV   A,[X-8]
    3431: 08       PUSH  A
    3432: 52 F9    MOV   A,[X-7]
    3434: 08       PUSH  A
    3435: 52 FA    MOV   A,[X-6]
    3437: 08       PUSH  A
    3438: 7C 29 CC LCALL 0x29CC
    343B: 38 FC    ADD   SP,0xFC
    343D: 18       POP   A
    343E: 53 46    MOV   [__r3],A
    3440: 18       POP   A
    3441: 53 47    MOV   [__r2],A
    3443: 18       POP   A
    3444: 18       POP   A
    3445: 51 46    MOV   A,[__r3]
    3447: 53 48    MOV   [__r1],A
    3449: 51 47    MOV   A,[__r2]
    344B: 53 49    MOV   [__r0],A
    344D: 51 48    MOV   A,[__r1]
    344F: 54 06    MOV   [X+6],A
    3451: 51 49    MOV   A,[__r0]
    3453: 54 05    MOV   [X+5],A
    3455: 50 09    MOV   A,0x9
    3457: 13 06    SUB   A,[X+6]
    3459: 52 05    MOV   A,[X+5]
    345B: 31 80    XOR   A,0x80
    345D: 53 3D    MOV   [__rX],A
    345F: 50 80    MOV   A,0x80
    3461: 1A 3D    SBB   A,[__rX]
    3463: C0 28    JC    0x348C
    3465: 62 D0 00 MOV   REG[0xD0],0x0
    3468: 52 01    MOV   A,[X+1]
    346A: 53 48    MOV   [__r1],A
    346C: 52 00    MOV   A,[X+0]
    346E: 53 49    MOV   [__r0],A
    3470: 51 48    MOV   A,[__r1]
    3472: 01 01    ADD   A,0x1
    3474: 54 01    MOV   [X+1],A
    3476: 51 49    MOV   A,[__r0]
    3478: 09 00    ADC   A,0x0
    347A: 54 00    MOV   [X+0],A
    347C: 52 06    MOV   A,[X+6]
    347E: 01 30    ADD   A,0x30
    3480: 53 47    MOV   [__r2],A
    3482: 51 49    MOV   A,[__r0]
    3484: 60 D5    MOV   REG[0xD5],A
    3486: 51 47    MOV   A,[__r2]
    3488: 3F 48    MVI   [__r1],A
    348A: 80 26    JMP   0x34B1
    348C: 62 D0 00 MOV   REG[0xD0],0x0
    348F: 52 01    MOV   A,[X+1]
    3491: 53 48    MOV   [__r1],A
    3493: 52 00    MOV   A,[X+0]
    3495: 53 49    MOV   [__r0],A
    3497: 51 48    MOV   A,[__r1]
    3499: 01 01    ADD   A,0x1
    349B: 54 01    MOV   [X+1],A
    349D: 51 49    MOV   A,[__r0]
    349F: 09 00    ADC   A,0x0
    34A1: 54 00    MOV   [X+0],A
    34A3: 52 06    MOV   A,[X+6]
    34A5: 01 57    ADD   A,0x57
    34A7: 53 47    MOV   [__r2],A
    34A9: 51 49    MOV   A,[__r0]
    34AB: 60 D5    MOV   REG[0xD5],A
    34AD: 51 47    MOV   A,[__r2]
    34AF: 3F 48    MVI   [__r1],A
    34B1: 62 D0 00 MOV   REG[0xD0],0x0
    34B4: 52 F6    MOV   A,[X-10]
    34B6: 53 46    MOV   [__r3],A
    34B8: 52 F5    MOV   A,[X-11]
    34BA: 53 47    MOV   [__r2],A
    34BC: 47 47 80 TST   [__r2],0x80
    34BF: A0 09    JZ    0x34C9
    34C1: 55 48 FF MOV   [__r1],0xFF
    34C4: 55 49 FF MOV   [__r0],0xFF
    34C7: 80 0A    JMP   0x34D2
    34C9: 62 D0 00 MOV   REG[0xD0],0x0
    34CC: 55 48 00 MOV   [__r1],0x0
    34CF: 55 49 00 MOV   [__r0],0x0
    34D2: 62 D0 00 MOV   REG[0xD0],0x0
    34D5: 51 49    MOV   A,[__r0]
    34D7: 08       PUSH  A
    34D8: 51 48    MOV   A,[__r1]
    34DA: 08       PUSH  A
    34DB: 51 47    MOV   A,[__r2]
    34DD: 08       PUSH  A
    34DE: 51 46    MOV   A,[__r3]
    34E0: 08       PUSH  A
    34E1: 52 F7    MOV   A,[X-9]
    34E3: 08       PUSH  A
    34E4: 52 F8    MOV   A,[X-8]
    34E6: 08       PUSH  A
    34E7: 52 F9    MOV   A,[X-7]
    34E9: 08       PUSH  A
    34EA: 52 FA    MOV   A,[X-6]
    34EC: 08       PUSH  A
    34ED: 7C 29 CC LCALL 0x29CC
    34F0: 18       POP   A
    34F1: 54 FA    MOV   [X-6],A
    34F3: 18       POP   A
    34F4: 54 F9    MOV   [X-7],A
    34F6: 18       POP   A
    34F7: 54 F8    MOV   [X-8],A
    34F9: 18       POP   A
    34FA: 54 F7    MOV   [X-9],A
    34FC: 38 FC    ADD   SP,0xFC
    34FE: 3D F7 00 CMP   [X-9],0x0
    3501: BE FA    JNZ   0x33FC
    3503: 3D F8 00 CMP   [X-8],0x0
    3506: BE F5    JNZ   0x33FC
    3508: 3D F9 00 CMP   [X-7],0x0
    350B: BE F0    JNZ   0x33FC
    350D: 3D FA 00 CMP   [X-6],0x0
    3510: BE EB    JNZ   0x33FC
    3512: 62 D0 00 MOV   REG[0xD0],0x0
    3515: 52 01    MOV   A,[X+1]
    3517: 53 48    MOV   [__r1],A
    3519: 52 00    MOV   A,[X+0]
    351B: 53 49    MOV   [__r0],A
    351D: 51 48    MOV   A,[__r1]
    351F: 01 FF    ADD   A,0xFF
    3521: 54 01    MOV   [X+1],A
    3523: 51 49    MOV   A,[__r0]
    3525: 09 FF    ADC   A,0xFF
    3527: 54 00    MOV   [X+0],A
    3529: 51 49    MOV   A,[__r0]
    352B: 60 D5    MOV   REG[0xD5],A
    352D: 50 00    MOV   A,0x0
    352F: 3F 48    MVI   [__r1],A
    3531: 52 FC    MOV   A,[X-4]
    3533: 54 03    MOV   [X+3],A
    3535: 52 FB    MOV   A,[X-5]
    3537: 54 02    MOV   [X+2],A
    3539: 80 54    JMP   0x358E
    353B: 62 D0 00 MOV   REG[0xD0],0x0
    353E: 52 03    MOV   A,[X+3]
    3540: 53 48    MOV   [__r1],A
    3542: 52 02    MOV   A,[X+2]
    3544: 60 D4    MOV   REG[0xD4],A
    3546: 3E 48    MVI   A,[__r1]
    3548: 54 04    MOV   [X+4],A
    354A: 52 03    MOV   A,[X+3]
    354C: 53 48    MOV   [__r1],A
    354E: 52 02    MOV   A,[X+2]
    3550: 53 49    MOV   [__r0],A
    3552: 51 48    MOV   A,[__r1]
    3554: 01 01    ADD   A,0x1
    3556: 54 03    MOV   [X+3],A
    3558: 51 49    MOV   A,[__r0]
    355A: 09 00    ADC   A,0x0
    355C: 54 02    MOV   [X+2],A
    355E: 52 01    MOV   A,[X+1]
    3560: 53 46    MOV   [__r3],A
    3562: 52 00    MOV   A,[X+0]
    3564: 60 D4    MOV   REG[0xD4],A
    3566: 3E 46    MVI   A,[__r3]
    3568: 53 47    MOV   [__r2],A
    356A: 51 49    MOV   A,[__r0]
    356C: 60 D5    MOV   REG[0xD5],A
    356E: 51 47    MOV   A,[__r2]
    3570: 3F 48    MVI   [__r1],A
    3572: 52 01    MOV   A,[X+1]
    3574: 53 48    MOV   [__r1],A
    3576: 52 00    MOV   A,[X+0]
    3578: 53 49    MOV   [__r0],A
    357A: 51 48    MOV   A,[__r1]
    357C: 01 FF    ADD   A,0xFF
    357E: 54 01    MOV   [X+1],A
    3580: 51 49    MOV   A,[__r0]
    3582: 09 FF    ADC   A,0xFF
    3584: 54 00    MOV   [X+0],A
    3586: 51 49    MOV   A,[__r0]
    3588: 60 D5    MOV   REG[0xD5],A
    358A: 52 04    MOV   A,[X+4]
    358C: 3F 48    MVI   [__r1],A
    358E: 52 03    MOV   A,[X+3]
    3590: 13 01    SUB   A,[X+1]
    3592: 52 02    MOV   A,[X+2]
    3594: 1B 00    SBB   A,[X+0]
    3596: CF A4    JC    0x353B
    3598: 62 D0 00 MOV   REG[0xD0],0x0
    359B: 52 FC    MOV   A,[X-4]
    359D: 53 48    MOV   [__r1],A
    359F: 52 FB    MOV   A,[X-5]
    35A1: 53 49    MOV   [__r0],A
    35A3: 38 F9    ADD   SP,0xF9
    35A5: 20       POP   X
    35A6: 7F       RET   
_utoa:
    35A7: 10       PUSH  X
    35A8: 4F       MOV   X,SP
    35A9: 38 07    ADD   SP,0x7
    35AB: 52 FC    MOV   A,[X-4]
    35AD: 54 01    MOV   [X+1],A
    35AF: 52 FB    MOV   A,[X-5]
    35B1: 54 00    MOV   [X+0],A
    35B3: 62 D0 00 MOV   REG[0xD0],0x0
    35B6: 52 F7    MOV   A,[X-9]
    35B8: 08       PUSH  A
    35B9: 52 F8    MOV   A,[X-8]
    35BB: 08       PUSH  A
    35BC: 52 F9    MOV   A,[X-7]
    35BE: 08       PUSH  A
    35BF: 52 FA    MOV   A,[X-6]
    35C1: 08       PUSH  A
    35C2: 7C 29 C1 LCALL 0x29C1
    35C5: 38 FE    ADD   SP,0xFE
    35C7: 18       POP   A
    35C8: 53 48    MOV   [__r1],A
    35CA: 18       POP   A
    35CB: 53 49    MOV   [__r0],A
    35CD: 51 48    MOV   A,[__r1]
    35CF: 54 06    MOV   [X+6],A
    35D1: 51 49    MOV   A,[__r0]
    35D3: 54 05    MOV   [X+5],A
    35D5: 50 09    MOV   A,0x9
    35D7: 13 06    SUB   A,[X+6]
    35D9: 52 05    MOV   A,[X+5]
    35DB: 31 80    XOR   A,0x80
    35DD: 53 3D    MOV   [__rX],A
    35DF: 50 80    MOV   A,0x80
    35E1: 1A 3D    SBB   A,[__rX]
    35E3: C0 28    JC    0x360C
    35E5: 62 D0 00 MOV   REG[0xD0],0x0
    35E8: 52 01    MOV   A,[X+1]
    35EA: 53 48    MOV   [__r1],A
    35EC: 52 00    MOV   A,[X+0]
    35EE: 53 49    MOV   [__r0],A
    35F0: 51 48    MOV   A,[__r1]
    35F2: 01 01    ADD   A,0x1
    35F4: 54 01    MOV   [X+1],A
    35F6: 51 49    MOV   A,[__r0]
    35F8: 09 00    ADC   A,0x0
    35FA: 54 00    MOV   [X+0],A
    35FC: 52 06    MOV   A,[X+6]
    35FE: 01 30    ADD   A,0x30
    3600: 53 47    MOV   [__r2],A
    3602: 51 49    MOV   A,[__r0]
    3604: 60 D5    MOV   REG[0xD5],A
    3606: 51 47    MOV   A,[__r2]
    3608: 3F 48    MVI   [__r1],A
    360A: 80 26    JMP   0x3631
    360C: 62 D0 00 MOV   REG[0xD0],0x0
    360F: 52 01    MOV   A,[X+1]
    3611: 53 48    MOV   [__r1],A
    3613: 52 00    MOV   A,[X+0]
    3615: 53 49    MOV   [__r0],A
    3617: 51 48    MOV   A,[__r1]
    3619: 01 01    ADD   A,0x1
    361B: 54 01    MOV   [X+1],A
    361D: 51 49    MOV   A,[__r0]
    361F: 09 00    ADC   A,0x0
    3621: 54 00    MOV   [X+0],A
    3623: 52 06    MOV   A,[X+6]
    3625: 01 57    ADD   A,0x57
    3627: 53 47    MOV   [__r2],A
    3629: 51 49    MOV   A,[__r0]
    362B: 60 D5    MOV   REG[0xD5],A
    362D: 51 47    MOV   A,[__r2]
    362F: 3F 48    MVI   [__r1],A
    3631: 52 F7    MOV   A,[X-9]
    3633: 08       PUSH  A
    3634: 52 F8    MOV   A,[X-8]
    3636: 08       PUSH  A
    3637: 52 F9    MOV   A,[X-7]
    3639: 08       PUSH  A
    363A: 52 FA    MOV   A,[X-6]
    363C: 08       PUSH  A
    363D: 62 D0 00 MOV   REG[0xD0],0x0
    3640: 7C 29 C1 LCALL 0x29C1
    3643: 18       POP   A
    3644: 54 FA    MOV   [X-6],A
    3646: 18       POP   A
    3647: 54 F9    MOV   [X-7],A
    3649: 38 FE    ADD   SP,0xFE
    364B: 3D F9 00 CMP   [X-7],0x0
    364E: BF 64    JNZ   0x35B3
    3650: 3D FA 00 CMP   [X-6],0x0
    3653: BF 5F    JNZ   0x35B3
    3655: 62 D0 00 MOV   REG[0xD0],0x0
    3658: 52 01    MOV   A,[X+1]
    365A: 53 48    MOV   [__r1],A
    365C: 52 00    MOV   A,[X+0]
    365E: 53 49    MOV   [__r0],A
    3660: 51 48    MOV   A,[__r1]
    3662: 01 FF    ADD   A,0xFF
    3664: 54 01    MOV   [X+1],A
    3666: 51 49    MOV   A,[__r0]
    3668: 09 FF    ADC   A,0xFF
    366A: 54 00    MOV   [X+0],A
    366C: 51 49    MOV   A,[__r0]
    366E: 60 D5    MOV   REG[0xD5],A
    3670: 50 00    MOV   A,0x0
    3672: 3F 48    MVI   [__r1],A
    3674: 52 FC    MOV   A,[X-4]
    3676: 54 03    MOV   [X+3],A
    3678: 52 FB    MOV   A,[X-5]
    367A: 54 02    MOV   [X+2],A
    367C: 80 54    JMP   0x36D1
    367E: 62 D0 00 MOV   REG[0xD0],0x0
    3681: 52 03    MOV   A,[X+3]
    3683: 53 48    MOV   [__r1],A
    3685: 52 02    MOV   A,[X+2]
    3687: 60 D4    MOV   REG[0xD4],A
    3689: 3E 48    MVI   A,[__r1]
    368B: 54 04    MOV   [X+4],A
    368D: 52 03    MOV   A,[X+3]
    368F: 53 48    MOV   [__r1],A
    3691: 52 02    MOV   A,[X+2]
    3693: 53 49    MOV   [__r0],A
    3695: 51 48    MOV   A,[__r1]
    3697: 01 01    ADD   A,0x1
    3699: 54 03    MOV   [X+3],A
    369B: 51 49    MOV   A,[__r0]
    369D: 09 00    ADC   A,0x0
    369F: 54 02    MOV   [X+2],A
    36A1: 52 01    MOV   A,[X+1]
    36A3: 53 46    MOV   [__r3],A
    36A5: 52 00    MOV   A,[X+0]
    36A7: 60 D4    MOV   REG[0xD4],A
    36A9: 3E 46    MVI   A,[__r3]
    36AB: 53 47    MOV   [__r2],A
    36AD: 51 49    MOV   A,[__r0]
    36AF: 60 D5    MOV   REG[0xD5],A
    36B1: 51 47    MOV   A,[__r2]
    36B3: 3F 48    MVI   [__r1],A
    36B5: 52 01    MOV   A,[X+1]
    36B7: 53 48    MOV   [__r1],A
    36B9: 52 00    MOV   A,[X+0]
    36BB: 53 49    MOV   [__r0],A
    36BD: 51 48    MOV   A,[__r1]
    36BF: 01 FF    ADD   A,0xFF
    36C1: 54 01    MOV   [X+1],A
    36C3: 51 49    MOV   A,[__r0]
    36C5: 09 FF    ADC   A,0xFF
    36C7: 54 00    MOV   [X+0],A
    36C9: 51 49    MOV   A,[__r0]
    36CB: 60 D5    MOV   REG[0xD5],A
    36CD: 52 04    MOV   A,[X+4]
    36CF: 3F 48    MVI   [__r1],A
    36D1: 52 03    MOV   A,[X+3]
    36D3: 13 01    SUB   A,[X+1]
    36D5: 52 02    MOV   A,[X+2]
    36D7: 1B 00    SBB   A,[X+0]
    36D9: CF A4    JC    0x367E
    36DB: 62 D0 00 MOV   REG[0xD0],0x0
    36DE: 52 FC    MOV   A,[X-4]
    36E0: 53 48    MOV   [__r1],A
    36E2: 52 FB    MOV   A,[X-5]
    36E4: 53 49    MOV   [__r0],A
    36E6: 38 F9    ADD   SP,0xF9
    36E8: 20       POP   X
    36E9: 7F       RET   
_ftoa:
    36EA: 10       PUSH  X
    36EB: 4F       MOV   X,SP
    36EC: 38 16    ADD   SP,0x16
    36EE: 62 D0 00 MOV   REG[0xD0],0x0
    36F1: 52 F8    MOV   A,[X-8]
    36F3: 53 48    MOV   [__r1],A
    36F5: 52 F7    MOV   A,[X-9]
    36F7: 60 D5    MOV   REG[0xD5],A
    36F9: 50 00    MOV   A,0x0
    36FB: 3F 48    MVI   [__r1],A
    36FD: 3F 48    MVI   [__r1],A
    36FF: 08       PUSH  A
    3700: 08       PUSH  A
    3701: 08       PUSH  A
    3702: 08       PUSH  A
    3703: 52 F9    MOV   A,[X-7]
    3705: 08       PUSH  A
    3706: 52 FA    MOV   A,[X-6]
    3708: 08       PUSH  A
    3709: 52 FB    MOV   A,[X-5]
    370B: 08       PUSH  A
    370C: 52 FC    MOV   A,[X-4]
    370E: 08       PUSH  A
    370F: 7C 2B 96 LCALL 0x2B96
    3712: 38 F8    ADD   SP,0xF8
    3714: 39 00    CMP   A,0x0
    3716: B0 1B    JNZ   0x3732
    3718: 62 D0 00 MOV   REG[0xD0],0x0
    371B: 55 4A 30 MOV   [0x4A],0x30
    371E: 55 4B 2E MOV   [0x4B],0x2E
    3721: 55 4C 30 MOV   [0x4C],0x30
    3724: 55 4D 00 MOV   [0x4D],0x0
    3727: 62 D0 00 MOV   REG[0xD0],0x0
    372A: 55 48 4A MOV   [__r1],0x4A
    372D: 55 49 00 MOV   [__r0],0x0
    3730: 84 04    JMP   0x3B35
    3732: 52 F9    MOV   A,[X-7]
    3734: 54 06    MOV   [X+6],A
    3736: 52 FA    MOV   A,[X-6]
    3738: 54 07    MOV   [X+7],A
    373A: 52 FB    MOV   A,[X-5]
    373C: 54 08    MOV   [X+8],A
    373E: 52 FC    MOV   A,[X-4]
    3740: 54 09    MOV   [X+9],A
    3742: 62 D0 00 MOV   REG[0xD0],0x0
    3745: 52 06    MOV   A,[X+6]
    3747: 53 49    MOV   [__r0],A
    3749: 52 07    MOV   A,[X+7]
    374B: 53 48    MOV   [__r1],A
    374D: 52 08    MOV   A,[X+8]
    374F: 53 47    MOV   [__r2],A
    3751: 52 09    MOV   A,[X+9]
    3753: 53 46    MOV   [__r3],A
    3755: 50 17    MOV   A,0x17
    3757: 62 D0 00 MOV   REG[0xD0],0x0
    375A: 68 49    ASR   [__r0]
    375C: 6E 48    RRC   [__r1]
    375E: 6E 47    RRC   [__r2]
    3760: 6E 46    RRC   [__r3]
    3762: 78       DEC   A
    3763: BF F3    JNZ   0x3757
    3765: 51 46    MOV   A,[__r3]
    3767: 11 7F    SUB   A,0x7F
    3769: 54 0B    MOV   [X+11],A
    376B: 50 00    MOV   A,0x0
    376D: 19 00    SBB   A,0x0
    376F: 54 0A    MOV   [X+10],A
    3771: 52 09    MOV   A,[X+9]
    3773: 53 46    MOV   [__r3],A
    3775: 52 08    MOV   A,[X+8]
    3777: 53 47    MOV   [__r2],A
    3779: 52 07    MOV   A,[X+7]
    377B: 53 48    MOV   [__r1],A
    377D: 52 06    MOV   A,[X+6]
    377F: 21 00    AND   A,0x0
    3781: 53 49    MOV   [__r0],A
    3783: 51 46    MOV   A,[__r3]
    3785: 54 13    MOV   [X+19],A
    3787: 51 47    MOV   A,[__r2]
    3789: 54 12    MOV   [X+18],A
    378B: 51 48    MOV   A,[__r1]
    378D: 29 80    OR    A,0x80
    378F: 54 11    MOV   [X+17],A
    3791: 51 49    MOV   A,[__r0]
    3793: 54 10    MOV   [X+16],A
    3795: 56 02 00 MOV   [X+2],0x0
    3798: 56 03 00 MOV   [X+3],0x0
    379B: 56 04 00 MOV   [X+4],0x0
    379E: 56 05 00 MOV   [X+5],0x0
    37A1: 56 0C 00 MOV   [X+12],0x0
    37A4: 56 0D 00 MOV   [X+13],0x0
    37A7: 56 0E 00 MOV   [X+14],0x0
    37AA: 56 0F 00 MOV   [X+15],0x0
    37AD: 52 0B    MOV   A,[X+11]
    37AF: 11 1F    SUB   A,0x1F
    37B1: 52 0A    MOV   A,[X+10]
    37B3: 31 80    XOR   A,0x80
    37B5: 19 80    SBB   A,0x80
    37B7: C0 1C    JC    0x37D4
    37B9: 62 D0 00 MOV   REG[0xD0],0x0
    37BC: 52 F8    MOV   A,[X-8]
    37BE: 53 48    MOV   [__r1],A
    37C0: 52 F7    MOV   A,[X-9]
    37C2: 60 D5    MOV   REG[0xD5],A
    37C4: 50 FF    MOV   A,0xFF
    37C6: 3F 48    MVI   [__r1],A
    37C8: 50 FE    MOV   A,0xFE
    37CA: 3F 48    MVI   [__r1],A
    37CC: 55 48 00 MOV   [__r1],0x0
    37CF: 55 49 00 MOV   [__r0],0x0
    37D2: 83 62    JMP   0x3B35
    37D4: 52 0B    MOV   A,[X+11]
    37D6: 11 E9    SUB   A,0xE9
    37D8: 52 0A    MOV   A,[X+10]
    37DA: 31 80    XOR   A,0x80
    37DC: 19 7F    SBB   A,0x7F
    37DE: D0 1A    JNC   0x37F9
    37E0: 62 D0 00 MOV   REG[0xD0],0x0
    37E3: 52 F8    MOV   A,[X-8]
    37E5: 53 48    MOV   [__r1],A
    37E7: 52 F7    MOV   A,[X-9]
    37E9: 60 D5    MOV   REG[0xD5],A
    37EB: 50 FF    MOV   A,0xFF
    37ED: 3F 48    MVI   [__r1],A
    37EF: 3F 48    MVI   [__r1],A
    37F1: 55 48 00 MOV   [__r1],0x0
    37F4: 55 49 00 MOV   [__r0],0x0
    37F7: 83 3D    JMP   0x3B35
    37F9: 52 0B    MOV   A,[X+11]
    37FB: 11 17    SUB   A,0x17
    37FD: 52 0A    MOV   A,[X+10]
    37FF: 31 80    XOR   A,0x80
    3801: 19 80    SBB   A,0x80
    3803: C0 43    JC    0x3847
    3805: 62 D0 00 MOV   REG[0xD0],0x0
    3808: 52 0B    MOV   A,[X+11]
    380A: 11 17    SUB   A,0x17
    380C: 53 48    MOV   [__r1],A
    380E: 52 10    MOV   A,[X+16]
    3810: 53 45    MOV   [__r4],A
    3812: 52 11    MOV   A,[X+17]
    3814: 53 44    MOV   [__r5],A
    3816: 52 12    MOV   A,[X+18]
    3818: 53 43    MOV   [__r6],A
    381A: 52 13    MOV   A,[X+19]
    381C: 53 42    MOV   [__r7],A
    381E: 51 48    MOV   A,[__r1]
    3820: 21 1F    AND   A,0x1F
    3822: A0 0F    JZ    0x3832
    3824: 62 D0 00 MOV   REG[0xD0],0x0
    3827: 65 42    ASL   [__r7]
    3829: 6B 43    RLC   [__r6]
    382B: 6B 44    RLC   [__r5]
    382D: 6B 45    RLC   [__r4]
    382F: 78       DEC   A
    3830: BF F3    JNZ   0x3824
    3832: 62 D0 00 MOV   REG[0xD0],0x0
    3835: 51 45    MOV   A,[__r4]
    3837: 54 0C    MOV   [X+12],A
    3839: 51 44    MOV   A,[__r5]
    383B: 54 0D    MOV   [X+13],A
    383D: 51 43    MOV   A,[__r6]
    383F: 54 0E    MOV   [X+14],A
    3841: 51 42    MOV   A,[__r7]
    3843: 54 0F    MOV   [X+15],A
    3845: 80 D0    JMP   0x3916
    3847: 52 0B    MOV   A,[X+11]
    3849: 11 00    SUB   A,0x0
    384B: 52 0A    MOV   A,[X+10]
    384D: 31 80    XOR   A,0x80
    384F: 19 80    SBB   A,0x80
    3851: C0 7F    JC    0x38D1
    3853: 62 D0 00 MOV   REG[0xD0],0x0
    3856: 50 17    MOV   A,0x17
    3858: 13 0B    SUB   A,[X+11]
    385A: 53 48    MOV   [__r1],A
    385C: 52 10    MOV   A,[X+16]
    385E: 53 45    MOV   [__r4],A
    3860: 52 11    MOV   A,[X+17]
    3862: 53 44    MOV   [__r5],A
    3864: 52 12    MOV   A,[X+18]
    3866: 53 43    MOV   [__r6],A
    3868: 52 13    MOV   A,[X+19]
    386A: 53 42    MOV   [__r7],A
    386C: 51 48    MOV   A,[__r1]
    386E: 21 1F    AND   A,0x1F
    3870: A0 0F    JZ    0x3880
    3872: 62 D0 00 MOV   REG[0xD0],0x0
    3875: 68 45    ASR   [__r4]
    3877: 6E 44    RRC   [__r5]
    3879: 6E 43    RRC   [__r6]
    387B: 6E 42    RRC   [__r7]
    387D: 78       DEC   A
    387E: BF F3    JNZ   0x3872
    3880: 62 D0 00 MOV   REG[0xD0],0x0
    3883: 51 45    MOV   A,[__r4]
    3885: 54 0C    MOV   [X+12],A
    3887: 51 44    MOV   A,[__r5]
    3889: 54 0D    MOV   [X+13],A
    388B: 51 43    MOV   A,[__r6]
    388D: 54 0E    MOV   [X+14],A
    388F: 51 42    MOV   A,[__r7]
    3891: 54 0F    MOV   [X+15],A
    3893: 52 0B    MOV   A,[X+11]
    3895: 01 01    ADD   A,0x1
    3897: 53 48    MOV   [__r1],A
    3899: 52 10    MOV   A,[X+16]
    389B: 53 45    MOV   [__r4],A
    389D: 52 11    MOV   A,[X+17]
    389F: 53 44    MOV   [__r5],A
    38A1: 52 12    MOV   A,[X+18]
    38A3: 53 43    MOV   [__r6],A
    38A5: 52 13    MOV   A,[X+19]
    38A7: 53 42    MOV   [__r7],A
    38A9: 51 48    MOV   A,[__r1]
    38AB: 21 1F    AND   A,0x1F
    38AD: A0 0F    JZ    0x38BD
    38AF: 62 D0 00 MOV   REG[0xD0],0x0
    38B2: 65 42    ASL   [__r7]
    38B4: 6B 43    RLC   [__r6]
    38B6: 6B 44    RLC   [__r5]
    38B8: 6B 45    RLC   [__r4]
    38BA: 78       DEC   A
    38BB: BF F3    JNZ   0x38AF
    38BD: 62 D0 00 MOV   REG[0xD0],0x0
    38C0: 51 42    MOV   A,[__r7]
    38C2: 54 05    MOV   [X+5],A
    38C4: 51 43    MOV   A,[__r6]
    38C6: 54 04    MOV   [X+4],A
    38C8: 51 44    MOV   A,[__r5]
    38CA: 54 03    MOV   [X+3],A
    38CC: 56 02 00 MOV   [X+2],0x0
    38CF: 80 46    JMP   0x3916
    38D1: 62 D0 00 MOV   REG[0xD0],0x0
    38D4: 52 0B    MOV   A,[X+11]
    38D6: 01 01    ADD   A,0x1
    38D8: 73       CPL   A
    38D9: 11 FF    SUB   A,0xFF
    38DB: 53 48    MOV   [__r1],A
    38DD: 52 13    MOV   A,[X+19]
    38DF: 53 42    MOV   [__r7],A
    38E1: 52 12    MOV   A,[X+18]
    38E3: 53 43    MOV   [__r6],A
    38E5: 52 11    MOV   A,[X+17]
    38E7: 53 44    MOV   [__r5],A
    38E9: 52 10    MOV   A,[X+16]
    38EB: 21 00    AND   A,0x0
    38ED: 53 45    MOV   [__r4],A
    38EF: 51 48    MOV   A,[__r1]
    38F1: 21 1F    AND   A,0x1F
    38F3: A0 0F    JZ    0x3903
    38F5: 62 D0 00 MOV   REG[0xD0],0x0
    38F8: 68 45    ASR   [__r4]
    38FA: 6E 44    RRC   [__r5]
    38FC: 6E 43    RRC   [__r6]
    38FE: 6E 42    RRC   [__r7]
    3900: 78       DEC   A
    3901: BF F3    JNZ   0x38F5
    3903: 62 D0 00 MOV   REG[0xD0],0x0
    3906: 51 45    MOV   A,[__r4]
    3908: 54 02    MOV   [X+2],A
    390A: 51 44    MOV   A,[__r5]
    390C: 54 03    MOV   [X+3],A
    390E: 51 43    MOV   A,[__r6]
    3910: 54 04    MOV   [X+4],A
    3912: 51 42    MOV   A,[__r7]
    3914: 54 05    MOV   [X+5],A
    3916: 56 01 4A MOV   [X+1],0x4A
    3919: 56 00 00 MOV   [X+0],0x0
    391C: 52 09    MOV   A,[X+9]
    391E: 11 00    SUB   A,0x0
    3920: 52 08    MOV   A,[X+8]
    3922: 19 00    SBB   A,0x0
    3924: 52 07    MOV   A,[X+7]
    3926: 19 00    SBB   A,0x0
    3928: 52 06    MOV   A,[X+6]
    392A: 31 80    XOR   A,0x80
    392C: 19 80    SBB   A,0x80
    392E: D0 20    JNC   0x394F
    3930: 62 D0 00 MOV   REG[0xD0],0x0
    3933: 52 01    MOV   A,[X+1]
    3935: 53 48    MOV   [__r1],A
    3937: 52 00    MOV   A,[X+0]
    3939: 53 49    MOV   [__r0],A
    393B: 51 48    MOV   A,[__r1]
    393D: 01 01    ADD   A,0x1
    393F: 54 01    MOV   [X+1],A
    3941: 51 49    MOV   A,[__r0]
    3943: 09 00    ADC   A,0x0
    3945: 54 00    MOV   [X+0],A
    3947: 51 49    MOV   A,[__r0]
    3949: 60 D5    MOV   REG[0xD5],A
    394B: 50 2D    MOV   A,0x2D
    394D: 3F 48    MVI   [__r1],A
    394F: 3D 0C 00 CMP   [X+12],0x0
    3952: B0 31    JNZ   0x3984
    3954: 3D 0D 00 CMP   [X+13],0x0
    3957: B0 2C    JNZ   0x3984
    3959: 3D 0E 00 CMP   [X+14],0x0
    395C: B0 27    JNZ   0x3984
    395E: 3D 0F 00 CMP   [X+15],0x0
    3961: B0 22    JNZ   0x3984
    3963: 62 D0 00 MOV   REG[0xD0],0x0
    3966: 52 01    MOV   A,[X+1]
    3968: 53 48    MOV   [__r1],A
    396A: 52 00    MOV   A,[X+0]
    396C: 53 49    MOV   [__r0],A
    396E: 51 48    MOV   A,[__r1]
    3970: 01 01    ADD   A,0x1
    3972: 54 01    MOV   [X+1],A
    3974: 51 49    MOV   A,[__r0]
    3976: 09 00    ADC   A,0x0
    3978: 54 00    MOV   [X+0],A
    397A: 51 49    MOV   A,[__r0]
    397C: 60 D5    MOV   REG[0xD5],A
    397E: 50 30    MOV   A,0x30
    3980: 3F 48    MVI   [__r1],A
    3982: 80 36    JMP   0x39B9
    3984: 50 00    MOV   A,0x0
    3986: 08       PUSH  A
    3987: 50 0A    MOV   A,0xA
    3989: 08       PUSH  A
    398A: 52 0C    MOV   A,[X+12]
    398C: 08       PUSH  A
    398D: 52 0D    MOV   A,[X+13]
    398F: 08       PUSH  A
    3990: 52 0E    MOV   A,[X+14]
    3992: 08       PUSH  A
    3993: 52 0F    MOV   A,[X+15]
    3995: 08       PUSH  A
    3996: 52 00    MOV   A,[X+0]
    3998: 08       PUSH  A
    3999: 52 01    MOV   A,[X+1]
    399B: 08       PUSH  A
    399C: 7C 31 77 LCALL _ltoa
    399F: 38 F8    ADD   SP,0xF8
    39A1: 80 06    JMP   0x39A8
    39A3: 77 01    INC   [X+1]
    39A5: 0F 00 00 ADC   [X+0],0x0
    39A8: 62 D0 00 MOV   REG[0xD0],0x0
    39AB: 52 01    MOV   A,[X+1]
    39AD: 53 48    MOV   [__r1],A
    39AF: 52 00    MOV   A,[X+0]
    39B1: 60 D4    MOV   REG[0xD4],A
    39B3: 3E 48    MVI   A,[__r1]
    39B5: 39 00    CMP   A,0x0
    39B7: BF EB    JNZ   0x39A3
    39B9: 62 D0 00 MOV   REG[0xD0],0x0
    39BC: 52 01    MOV   A,[X+1]
    39BE: 53 48    MOV   [__r1],A
    39C0: 52 00    MOV   A,[X+0]
    39C2: 53 49    MOV   [__r0],A
    39C4: 51 48    MOV   A,[__r1]
    39C6: 01 01    ADD   A,0x1
    39C8: 54 01    MOV   [X+1],A
    39CA: 51 49    MOV   A,[__r0]
    39CC: 09 00    ADC   A,0x0
    39CE: 54 00    MOV   [X+0],A
    39D0: 51 49    MOV   A,[__r0]
    39D2: 60 D5    MOV   REG[0xD5],A
    39D4: 50 2E    MOV   A,0x2E
    39D6: 3F 48    MVI   [__r1],A
    39D8: 3D 02 00 CMP   [X+2],0x0
    39DB: B0 31    JNZ   0x3A0D
    39DD: 3D 03 00 CMP   [X+3],0x0
    39E0: B0 2C    JNZ   0x3A0D
    39E2: 3D 04 00 CMP   [X+4],0x0
    39E5: B0 27    JNZ   0x3A0D
    39E7: 3D 05 00 CMP   [X+5],0x0
    39EA: B0 22    JNZ   0x3A0D
    39EC: 62 D0 00 MOV   REG[0xD0],0x0
    39EF: 52 01    MOV   A,[X+1]
    39F1: 53 48    MOV   [__r1],A
    39F3: 52 00    MOV   A,[X+0]
    39F5: 53 49    MOV   [__r0],A
    39F7: 51 48    MOV   A,[__r1]
    39F9: 01 01    ADD   A,0x1
    39FB: 54 01    MOV   [X+1],A
    39FD: 51 49    MOV   A,[__r0]
    39FF: 09 00    ADC   A,0x0
    3A01: 54 00    MOV   [X+0],A
    3A03: 51 49    MOV   A,[__r0]
    3A05: 60 D5    MOV   REG[0xD5],A
    3A07: 50 30    MOV   A,0x30
    3A09: 3F 48    MVI   [__r1],A
    3A0B: 81 14    JMP   0x3B20
    3A0D: 62 D0 00 MOV   REG[0xD0],0x0
    3A10: 52 01    MOV   A,[X+1]
    3A12: 11 4A    SUB   A,0x4A
    3A14: 53 48    MOV   [__r1],A
    3A16: 52 00    MOV   A,[X+0]
    3A18: 19 00    SBB   A,0x0
    3A1A: 53 49    MOV   [__r0],A
    3A1C: 50 0F    MOV   A,0xF
    3A1E: 12 48    SUB   A,[__r1]
    3A20: 53 48    MOV   [__r1],A
    3A22: 50 00    MOV   A,0x0
    3A24: 1A 49    SBB   A,[__r0]
    3A26: 53 49    MOV   [__r0],A
    3A28: 16 48 01 SUB   [__r1],0x1
    3A2B: 1E 49 00 SBB   [__r0],0x0
    3A2E: 51 48    MOV   A,[__r1]
    3A30: 54 15    MOV   [X+21],A
    3A32: 50 07    MOV   A,0x7
    3A34: 3B 15    CMP   A,[X+21]
    3A36: D0 04    JNC   0x3A3B
    3A38: 56 15 07 MOV   [X+21],0x7
    3A3B: 56 14 00 MOV   [X+20],0x0
    3A3E: 80 A5    JMP   0x3AE4
    3A40: 62 D0 00 MOV   REG[0xD0],0x0
    3A43: 52 02    MOV   A,[X+2]
    3A45: 53 49    MOV   [__r0],A
    3A47: 52 03    MOV   A,[X+3]
    3A49: 53 48    MOV   [__r1],A
    3A4B: 52 04    MOV   A,[X+4]
    3A4D: 53 47    MOV   [__r2],A
    3A4F: 52 05    MOV   A,[X+5]
    3A51: 53 46    MOV   [__r3],A
    3A53: 65 46    ASL   [__r3]
    3A55: 6B 47    RLC   [__r2]
    3A57: 6B 48    RLC   [__r1]
    3A59: 6B 49    RLC   [__r0]
    3A5B: 52 02    MOV   A,[X+2]
    3A5D: 53 45    MOV   [__r4],A
    3A5F: 52 03    MOV   A,[X+3]
    3A61: 53 44    MOV   [__r5],A
    3A63: 52 04    MOV   A,[X+4]
    3A65: 53 43    MOV   [__r6],A
    3A67: 52 05    MOV   A,[X+5]
    3A69: 53 42    MOV   [__r7],A
    3A6B: 50 03    MOV   A,0x3
    3A6D: 62 D0 00 MOV   REG[0xD0],0x0
    3A70: 65 42    ASL   [__r7]
    3A72: 6B 43    RLC   [__r6]
    3A74: 6B 44    RLC   [__r5]
    3A76: 6B 45    RLC   [__r4]
    3A78: 78       DEC   A
    3A79: BF F3    JNZ   0x3A6D
    3A7B: 51 42    MOV   A,[__r7]
    3A7D: 02 46    ADD   A,[__r3]
    3A7F: 54 05    MOV   [X+5],A
    3A81: 51 43    MOV   A,[__r6]
    3A83: 0A 47    ADC   A,[__r2]
    3A85: 54 04    MOV   [X+4],A
    3A87: 51 44    MOV   A,[__r5]
    3A89: 0A 48    ADC   A,[__r1]
    3A8B: 54 03    MOV   [X+3],A
    3A8D: 51 45    MOV   A,[__r4]
    3A8F: 0A 49    ADC   A,[__r0]
    3A91: 54 02    MOV   [X+2],A
    3A93: 52 01    MOV   A,[X+1]
    3A95: 53 48    MOV   [__r1],A
    3A97: 52 00    MOV   A,[X+0]
    3A99: 53 49    MOV   [__r0],A
    3A9B: 51 48    MOV   A,[__r1]
    3A9D: 01 01    ADD   A,0x1
    3A9F: 54 01    MOV   [X+1],A
    3AA1: 51 49    MOV   A,[__r0]
    3AA3: 09 00    ADC   A,0x0
    3AA5: 54 00    MOV   [X+0],A
    3AA7: 52 02    MOV   A,[X+2]
    3AA9: 53 45    MOV   [__r4],A
    3AAB: 52 03    MOV   A,[X+3]
    3AAD: 53 44    MOV   [__r5],A
    3AAF: 52 04    MOV   A,[X+4]
    3AB1: 53 43    MOV   [__r6],A
    3AB3: 52 05    MOV   A,[X+5]
    3AB5: 53 42    MOV   [__r7],A
    3AB7: 50 18    MOV   A,0x18
    3AB9: 62 D0 00 MOV   REG[0xD0],0x0
    3ABC: 68 45    ASR   [__r4]
    3ABE: 6E 44    RRC   [__r5]
    3AC0: 6E 43    RRC   [__r6]
    3AC2: 6E 42    RRC   [__r7]
    3AC4: 78       DEC   A
    3AC5: BF F3    JNZ   0x3AB9
    3AC7: 06 42 30 ADD   [__r7],0x30
    3ACA: 0E 43 00 ADC   [__r6],0x0
    3ACD: 0E 44 00 ADC   [__r5],0x0
    3AD0: 0E 45 00 ADC   [__r4],0x0
    3AD3: 51 42    MOV   A,[__r7]
    3AD5: 53 47    MOV   [__r2],A
    3AD7: 51 49    MOV   A,[__r0]
    3AD9: 60 D5    MOV   REG[0xD5],A
    3ADB: 51 47    MOV   A,[__r2]
    3ADD: 3F 48    MVI   [__r1],A
    3ADF: 27 02 00 AND   [X+2],0x0
    3AE2: 77 14    INC   [X+20]
    3AE4: 52 14    MOV   A,[X+20]
    3AE6: 3B 15    CMP   A,[X+21]
    3AE8: CF 57    JC    0x3A40
    3AEA: 07 01 FF ADD   [X+1],0xFF
    3AED: 0F 00 FF ADC   [X+0],0xFF
    3AF0: 80 07    JMP   0x3AF8
    3AF2: 07 01 FF ADD   [X+1],0xFF
    3AF5: 0F 00 FF ADC   [X+0],0xFF
    3AF8: 62 D0 00 MOV   REG[0xD0],0x0
    3AFB: 52 01    MOV   A,[X+1]
    3AFD: 53 48    MOV   [__r1],A
    3AFF: 52 00    MOV   A,[X+0]
    3B01: 60 D4    MOV   REG[0xD4],A
    3B03: 3E 48    MVI   A,[__r1]
    3B05: 39 30    CMP   A,0x30
    3B07: B0 13    JNZ   0x3B1B
    3B09: 52 01    MOV   A,[X+1]
    3B0B: 01 FF    ADD   A,0xFF
    3B0D: 53 48    MOV   [__r1],A
    3B0F: 52 00    MOV   A,[X+0]
    3B11: 09 FF    ADC   A,0xFF
    3B13: 60 D4    MOV   REG[0xD4],A
    3B15: 3E 48    MVI   A,[__r1]
    3B17: 39 2E    CMP   A,0x2E
    3B19: BF D8    JNZ   0x3AF2
    3B1B: 77 01    INC   [X+1]
    3B1D: 0F 00 00 ADC   [X+0],0x0
    3B20: 62 D0 00 MOV   REG[0xD0],0x0
    3B23: 52 01    MOV   A,[X+1]
    3B25: 53 48    MOV   [__r1],A
    3B27: 52 00    MOV   A,[X+0]
    3B29: 60 D5    MOV   REG[0xD5],A
    3B2B: 50 00    MOV   A,0x0
    3B2D: 3F 48    MVI   [__r1],A
    3B2F: 55 48 4A MOV   [__r1],0x4A
    3B32: 55 49 00 MOV   [__r0],0x0
    3B35: 38 EA    ADD   SP,0xEA
    3B37: 20       POP   X
    3B38: 7F       RET   
_isdigit:
    3B39: 10       PUSH  X
    3B3A: 4F       MOV   X,SP
    3B3B: 62 D0 00 MOV   REG[0xD0],0x0
    3B3E: 52 FC    MOV   A,[X-4]
    3B40: 01 13    ADD   A,0x13
    3B42: 53 48    MOV   [__r1],A
    3B44: 52 FB    MOV   A,[X-5]
    3B46: 09 03    ADC   A,0x3
    3B48: 10       PUSH  X
    3B49: 58 48    MOV   X,[__r1]
    3B4B: 28       ROMX  
    3B4C: 20       POP   X
    3B4D: 53 48    MOV   [__r1],A
    3B4F: 55 49 00 MOV   [__r0],0x0
    3B52: 26 48 04 AND   [__r1],0x4
    3B55: 26 49 00 AND   [__r0],0x0
    3B58: 20       POP   X
    3B59: 7F       RET   
_islower:
    3B5A: 10       PUSH  X
    3B5B: 4F       MOV   X,SP
    3B5C: 62 D0 00 MOV   REG[0xD0],0x0
    3B5F: 52 FC    MOV   A,[X-4]
    3B61: 01 13    ADD   A,0x13
    3B63: 53 48    MOV   [__r1],A
    3B65: 52 FB    MOV   A,[X-5]
    3B67: 09 03    ADC   A,0x3
    3B69: 10       PUSH  X
    3B6A: 58 48    MOV   X,[__r1]
    3B6C: 28       ROMX  
    3B6D: 20       POP   X
    3B6E: 53 48    MOV   [__r1],A
    3B70: 55 49 00 MOV   [__r0],0x0
    3B73: 26 48 02 AND   [__r1],0x2
    3B76: 26 49 00 AND   [__r0],0x0
    3B79: 20       POP   X
    3B7A: 7F       RET   
_isspace:
    3B7B: 10       PUSH  X
    3B7C: 4F       MOV   X,SP
    3B7D: 62 D0 00 MOV   REG[0xD0],0x0
    3B80: 52 FC    MOV   A,[X-4]
    3B82: 01 13    ADD   A,0x13
    3B84: 53 48    MOV   [__r1],A
    3B86: 52 FB    MOV   A,[X-5]
    3B88: 09 03    ADC   A,0x3
    3B8A: 10       PUSH  X
    3B8B: 58 48    MOV   X,[__r1]
    3B8D: 28       ROMX  
    3B8E: 20       POP   X
    3B8F: 53 48    MOV   [__r1],A
    3B91: 55 49 00 MOV   [__r0],0x0
    3B94: 26 48 10 AND   [__r1],0x10
    3B97: 26 49 00 AND   [__r0],0x0
    3B9A: 20       POP   X
    3B9B: 7F       RET   
_toupper:
    3B9C: 10       PUSH  X
    3B9D: 4F       MOV   X,SP
    3B9E: 52 FB    MOV   A,[X-5]
    3BA0: 08       PUSH  A
    3BA1: 52 FC    MOV   A,[X-4]
    3BA3: 08       PUSH  A
    3BA4: 7C 3B 5A LCALL _islower
    3BA7: 38 FE    ADD   SP,0xFE
    3BA9: 62 D0 00 MOV   REG[0xD0],0x0
    3BAC: 3C 49 00 CMP   [__r0],0x0
    3BAF: B0 06    JNZ   0x3BB6
    3BB1: 3C 48 00 CMP   [__r1],0x0
    3BB4: A0 18    JZ    0x3BCD
    3BB6: 62 D0 00 MOV   REG[0xD0],0x0
    3BB9: 52 FC    MOV   A,[X-4]
    3BBB: 11 61    SUB   A,0x61
    3BBD: 53 48    MOV   [__r1],A
    3BBF: 52 FB    MOV   A,[X-5]
    3BC1: 19 00    SBB   A,0x0
    3BC3: 53 49    MOV   [__r0],A
    3BC5: 06 48 41 ADD   [__r1],0x41
    3BC8: 0E 49 00 ADC   [__r0],0x0
    3BCB: 80 0C    JMP   0x3BD8
    3BCD: 62 D0 00 MOV   REG[0xD0],0x0
    3BD0: 52 FC    MOV   A,[X-4]
    3BD2: 53 48    MOV   [__r1],A
    3BD4: 52 FB    MOV   A,[X-5]
    3BD6: 53 49    MOV   [__r0],A
    3BD8: 20       POP   X
    3BD9: 7F       RET   
    3BDA: 10       PUSH  X
    3BDB: 4F       MOV   X,SP
    3BDC: 38 02    ADD   SP,0x2
    3BDE: 3D F9 FF CMP   [X-7],0xFF
    3BE1: B0 0E    JNZ   0x3BF0
    3BE3: 3D FA FE CMP   [X-6],0xFE
    3BE6: B0 09    JNZ   0x3BF0
    3BE8: 56 01 13 MOV   [X+1],0x13
    3BEB: 56 00 04 MOV   [X+0],0x4
    3BEE: 80 19    JMP   0x3C08
    3BF0: 3D F9 FF CMP   [X-7],0xFF
    3BF3: B0 0E    JNZ   0x3C02
    3BF5: 3D FA FF CMP   [X-6],0xFF
    3BF8: B0 09    JNZ   0x3C02
    3BFA: 56 01 2E MOV   [X+1],0x2E
    3BFD: 56 00 04 MOV   [X+0],0x4
    3C00: 80 07    JMP   0x3C08
    3C02: 56 01 4B MOV   [X+1],0x4B
    3C05: 56 00 04 MOV   [X+0],0x4
    3C08: 62 D0 00 MOV   REG[0xD0],0x0
    3C0B: 52 01    MOV   A,[X+1]
    3C0D: 53 48    MOV   [__r1],A
    3C0F: 52 00    MOV   A,[X+0]
    3C11: 53 49    MOV   [__r0],A
    3C13: 38 FE    ADD   SP,0xFE
    3C15: 20       POP   X
    3C16: 7F       RET   
__FormatFP_1:
    3C17: 10       PUSH  X
    3C18: 4F       MOV   X,SP
    3C19: 38 31    ADD   SP,0x31
    3C1B: 56 23 FF MOV   [X+35],0xFF
    3C1E: 56 22 FF MOV   [X+34],0xFF
    3C21: 56 06 FF MOV   [X+6],0xFF
    3C24: 56 05 FF MOV   [X+5],0xFF
    3C27: 56 10 FF MOV   [X+16],0xFF
    3C2A: 56 0F FF MOV   [X+15],0xFF
    3C2D: 56 0C FF MOV   [X+12],0xFF
    3C30: 56 0B FF MOV   [X+11],0xFF
    3C33: 56 1F FF MOV   [X+31],0xFF
    3C36: 56 1E FF MOV   [X+30],0xFF
    3C39: 56 13 FF MOV   [X+19],0xFF
    3C3C: 56 12 FF MOV   [X+18],0xFF
    3C3F: 56 16 00 MOV   [X+22],0x0
    3C42: 56 15 00 MOV   [X+21],0x0
    3C45: 56 29 FF MOV   [X+41],0xFF
    3C48: 56 28 00 MOV   [X+40],0x0
    3C4B: 56 25 00 MOV   [X+37],0x0
    3C4E: 56 24 00 MOV   [X+36],0x0
    3C51: 56 0E 00 MOV   [X+14],0x0
    3C54: 56 0D 00 MOV   [X+13],0x0
    3C57: 56 14 20 MOV   [X+20],0x20
    3C5A: 56 19 20 MOV   [X+25],0x20
    3C5D: 56 2C 65 MOV   [X+44],0x65
    3C60: 50 14    MOV   A,0x14
    3C62: 13 F2    SUB   A,[X-14]
    3C64: 52 F1    MOV   A,[X-15]
    3C66: 31 80    XOR   A,0x80
    3C68: 62 D0 00 MOV   REG[0xD0],0x0
    3C6B: 53 3D    MOV   [__rX],A
    3C6D: 50 80    MOV   A,0x80
    3C6F: 1A 3D    SBB   A,[__rX]
    3C71: D0 07    JNC   0x3C79
    3C73: 56 F2 14 MOV   [X-14],0x14
    3C76: 56 F1 00 MOV   [X-15],0x0
    3C79: 50 14    MOV   A,0x14
    3C7B: 13 F0    SUB   A,[X-16]
    3C7D: 52 EF    MOV   A,[X-17]
    3C7F: 31 80    XOR   A,0x80
    3C81: 62 D0 00 MOV   REG[0xD0],0x0
    3C84: 53 3D    MOV   [__rX],A
    3C86: 50 80    MOV   A,0x80
    3C88: 1A 3D    SBB   A,[__rX]
    3C8A: D0 07    JNC   0x3C92
    3C8C: 56 F0 14 MOV   [X-16],0x14
    3C8F: 56 EF 00 MOV   [X-17],0x0
    3C92: 3D F9 00 CMP   [X-7],0x0
    3C95: B0 06    JNZ   0x3C9C
    3C97: 3D FA 00 CMP   [X-6],0x0
    3C9A: A1 39    JZ    0x3DD4
    3C9C: 3D F9 00 CMP   [X-7],0x0
    3C9F: B0 06    JNZ   0x3CA6
    3CA1: 3D FA 01 CMP   [X-6],0x1
    3CA4: A0 24    JZ    0x3CC9
    3CA6: 3D F9 00 CMP   [X-7],0x0
    3CA9: B0 06    JNZ   0x3CB0
    3CAB: 3D FA 02 CMP   [X-6],0x2
    3CAE: A0 17    JZ    0x3CC6
    3CB0: 3D F9 00 CMP   [X-7],0x0
    3CB3: B0 06    JNZ   0x3CBA
    3CB5: 3D FA 03 CMP   [X-6],0x3
    3CB8: A0 1B    JZ    0x3CD4
    3CBA: 3D F9 00 CMP   [X-7],0x0
    3CBD: B0 06    JNZ   0x3CC4
    3CBF: 3D FA 04 CMP   [X-6],0x4
    3CC2: A0 0E    JZ    0x3CD1
    3CC4: 81 0F    JMP   0x3DD4
    3CC6: 56 2C 45 MOV   [X+44],0x45
    3CC9: 56 0E 01 MOV   [X+14],0x1
    3CCC: 56 0D 00 MOV   [X+13],0x0
    3CCF: 81 04    JMP   0x3DD4
    3CD1: 56 2C 45 MOV   [X+44],0x45
    3CD4: 52 F5    MOV   A,[X-11]
    3CD6: 54 2D    MOV   [X+45],A
    3CD8: 52 F6    MOV   A,[X-10]
    3CDA: 54 2E    MOV   [X+46],A
    3CDC: 52 F7    MOV   A,[X-9]
    3CDE: 54 2F    MOV   [X+47],A
    3CE0: 52 F8    MOV   A,[X-8]
    3CE2: 54 30    MOV   [X+48],A
    3CE4: 50 00    MOV   A,0x0
    3CE6: 08       PUSH  A
    3CE7: 08       PUSH  A
    3CE8: 08       PUSH  A
    3CE9: 08       PUSH  A
    3CEA: 52 F5    MOV   A,[X-11]
    3CEC: 08       PUSH  A
    3CED: 52 F6    MOV   A,[X-10]
    3CEF: 08       PUSH  A
    3CF0: 52 F7    MOV   A,[X-9]
    3CF2: 08       PUSH  A
    3CF3: 52 F8    MOV   A,[X-8]
    3CF5: 08       PUSH  A
    3CF6: 62 D0 00 MOV   REG[0xD0],0x0
    3CF9: 7C 2B 96 LCALL 0x2B96
    3CFC: 38 F8    ADD   SP,0xF8
    3CFE: 39 00    CMP   A,0x0
    3D00: A0 2C    JZ    0x3D2D
    3D02: 39 01    CMP   A,0x1
    3D04: A0 28    JZ    0x3D2D
    3D06: 52 F5    MOV   A,[X-11]
    3D08: 08       PUSH  A
    3D09: 52 F6    MOV   A,[X-10]
    3D0B: 08       PUSH  A
    3D0C: 52 F7    MOV   A,[X-9]
    3D0E: 08       PUSH  A
    3D0F: 52 F8    MOV   A,[X-8]
    3D11: 08       PUSH  A
    3D12: 50 BF    MOV   A,0xBF
    3D14: 08       PUSH  A
    3D15: 50 80    MOV   A,0x80
    3D17: 08       PUSH  A
    3D18: 50 00    MOV   A,0x0
    3D1A: 08       PUSH  A
    3D1B: 08       PUSH  A
    3D1C: 7C 2C D6 LCALL 0x2CD6
    3D1F: 18       POP   A
    3D20: 54 30    MOV   [X+48],A
    3D22: 18       POP   A
    3D23: 54 2F    MOV   [X+47],A
    3D25: 18       POP   A
    3D26: 54 2E    MOV   [X+46],A
    3D28: 18       POP   A
    3D29: 54 2D    MOV   [X+45],A
    3D2B: 38 FC    ADD   SP,0xFC
    3D2D: 56 1A 3F MOV   [X+26],0x3F
    3D30: 56 1B 80 MOV   [X+27],0x80
    3D33: 56 1C 00 MOV   [X+28],0x0
    3D36: 56 1D 00 MOV   [X+29],0x0
    3D39: 56 01 00 MOV   [X+1],0x0
    3D3C: 56 00 00 MOV   [X+0],0x0
    3D3F: 80 30    JMP   0x3D70
    3D41: 52 1A    MOV   A,[X+26]
    3D43: 08       PUSH  A
    3D44: 52 1B    MOV   A,[X+27]
    3D46: 08       PUSH  A
    3D47: 52 1C    MOV   A,[X+28]
    3D49: 08       PUSH  A
    3D4A: 52 1D    MOV   A,[X+29]
    3D4C: 08       PUSH  A
    3D4D: 50 41    MOV   A,0x41
    3D4F: 08       PUSH  A
    3D50: 50 20    MOV   A,0x20
    3D52: 08       PUSH  A
    3D53: 50 00    MOV   A,0x0
    3D55: 08       PUSH  A
    3D56: 08       PUSH  A
    3D57: 62 D0 00 MOV   REG[0xD0],0x0
    3D5A: 7C 2C D6 LCALL 0x2CD6
    3D5D: 18       POP   A
    3D5E: 54 1D    MOV   [X+29],A
    3D60: 18       POP   A
    3D61: 54 1C    MOV   [X+28],A
    3D63: 18       POP   A
    3D64: 54 1B    MOV   [X+27],A
    3D66: 18       POP   A
    3D67: 54 1A    MOV   [X+26],A
    3D69: 38 FC    ADD   SP,0xFC
    3D6B: 77 01    INC   [X+1]
    3D6D: 0F 00 00 ADC   [X+0],0x0
    3D70: 52 01    MOV   A,[X+1]
    3D72: 13 F0    SUB   A,[X-16]
    3D74: 52 EF    MOV   A,[X-17]
    3D76: 31 80    XOR   A,0x80
    3D78: 62 D0 00 MOV   REG[0xD0],0x0
    3D7B: 53 3D    MOV   [__rX],A
    3D7D: 52 00    MOV   A,[X+0]
    3D7F: 31 80    XOR   A,0x80
    3D81: 1A 3D    SBB   A,[__rX]
    3D83: CF BD    JC    0x3D41
    3D85: 50 38    MOV   A,0x38
    3D87: 08       PUSH  A
    3D88: 50 D1    MOV   A,0xD1
    3D8A: 08       PUSH  A
    3D8B: 50 B7    MOV   A,0xB7
    3D8D: 08       PUSH  A
    3D8E: 50 17    MOV   A,0x17
    3D90: 08       PUSH  A
    3D91: 52 2D    MOV   A,[X+45]
    3D93: 08       PUSH  A
    3D94: 52 2E    MOV   A,[X+46]
    3D96: 08       PUSH  A
    3D97: 52 2F    MOV   A,[X+47]
    3D99: 08       PUSH  A
    3D9A: 52 30    MOV   A,[X+48]
    3D9C: 08       PUSH  A
    3D9D: 62 D0 00 MOV   REG[0xD0],0x0
    3DA0: 7C 2B 96 LCALL 0x2B96
    3DA3: 38 F8    ADD   SP,0xF8
    3DA5: 39 FF    CMP   A,0xFF
    3DA7: A0 26    JZ    0x3DCE
    3DA9: 52 1A    MOV   A,[X+26]
    3DAB: 08       PUSH  A
    3DAC: 52 1B    MOV   A,[X+27]
    3DAE: 08       PUSH  A
    3DAF: 52 1C    MOV   A,[X+28]
    3DB1: 08       PUSH  A
    3DB2: 52 1D    MOV   A,[X+29]
    3DB4: 08       PUSH  A
    3DB5: 52 2D    MOV   A,[X+45]
    3DB7: 08       PUSH  A
    3DB8: 52 2E    MOV   A,[X+46]
    3DBA: 08       PUSH  A
    3DBB: 52 2F    MOV   A,[X+47]
    3DBD: 08       PUSH  A
    3DBE: 52 30    MOV   A,[X+48]
    3DC0: 08       PUSH  A
    3DC1: 7C 2B 96 LCALL 0x2B96
    3DC4: 38 F8    ADD   SP,0xF8
    3DC6: 39 00    CMP   A,0x0
    3DC8: A0 0B    JZ    0x3DD4
    3DCA: 39 01    CMP   A,0x1
    3DCC: B0 07    JNZ   0x3DD4
    3DCE: 56 0E 01 MOV   [X+14],0x1
    3DD1: 56 0D 00 MOV   [X+13],0x0
    3DD4: 62 D0 00 MOV   REG[0xD0],0x0
    3DD7: 52 F4    MOV   A,[X-12]
    3DD9: 21 10    AND   A,0x10
    3DDB: 53 48    MOV   [__r1],A
    3DDD: 52 F3    MOV   A,[X-13]
    3DDF: 21 00    AND   A,0x0
    3DE1: 39 00    CMP   A,0x0
    3DE3: B0 06    JNZ   0x3DEA
    3DE5: 3C 48 00 CMP   [__r1],0x0
    3DE8: A0 04    JZ    0x3DED
    3DEA: 56 14 30 MOV   [X+20],0x30
    3DED: 52 14    MOV   A,[X+20]
    3DEF: 54 11    MOV   [X+17],A
    3DF1: 62 D0 00 MOV   REG[0xD0],0x0
    3DF4: 52 F4    MOV   A,[X-12]
    3DF6: 21 08    AND   A,0x8
    3DF8: 53 48    MOV   [__r1],A
    3DFA: 52 F3    MOV   A,[X-13]
    3DFC: 21 00    AND   A,0x0
    3DFE: 39 00    CMP   A,0x0
    3E00: B0 06    JNZ   0x3E07
    3E02: 3C 48 00 CMP   [__r1],0x0
    3E05: A0 04    JZ    0x3E0A
    3E07: 56 11 2B MOV   [X+17],0x2B
    3E0A: 3D 0D 00 CMP   [X+13],0x0
    3E0D: B0 06    JNZ   0x3E14
    3E0F: 3D 0E 00 CMP   [X+14],0x0
    3E12: A0 2D    JZ    0x3E40
    3E14: 62 D0 00 MOV   REG[0xD0],0x0
    3E17: 5A 48    MOV   [__r1],X
    3E19: 06 48 2A ADD   [__r1],0x2A
    3E1C: 50 07    MOV   A,0x7
    3E1E: 08       PUSH  A
    3E1F: 51 48    MOV   A,[__r1]
    3E21: 08       PUSH  A
    3E22: 52 F5    MOV   A,[X-11]
    3E24: 08       PUSH  A
    3E25: 52 F6    MOV   A,[X-10]
    3E27: 08       PUSH  A
    3E28: 52 F7    MOV   A,[X-9]
    3E2A: 08       PUSH  A
    3E2B: 52 F8    MOV   A,[X-8]
    3E2D: 08       PUSH  A
    3E2E: 7C 36 EA LCALL _ftoa
    3E31: 38 FA    ADD   SP,0xFA
    3E33: 62 D0 00 MOV   REG[0xD0],0x0
    3E36: 51 48    MOV   A,[__r1]
    3E38: 54 0A    MOV   [X+10],A
    3E3A: 51 49    MOV   A,[__r0]
    3E3C: 54 09    MOV   [X+9],A
    3E3E: 81 18    JMP   0x3F57
    3E40: 56 1A 3F MOV   [X+26],0x3F
    3E43: 56 1B 00 MOV   [X+27],0x0
    3E46: 56 1C 00 MOV   [X+28],0x0
    3E49: 56 1D 00 MOV   [X+29],0x0
    3E4C: 56 01 00 MOV   [X+1],0x0
    3E4F: 56 00 00 MOV   [X+0],0x0
    3E52: 80 30    JMP   0x3E83
    3E54: 50 41    MOV   A,0x41
    3E56: 08       PUSH  A
    3E57: 50 20    MOV   A,0x20
    3E59: 08       PUSH  A
    3E5A: 50 00    MOV   A,0x0
    3E5C: 08       PUSH  A
    3E5D: 08       PUSH  A
    3E5E: 52 1A    MOV   A,[X+26]
    3E60: 08       PUSH  A
    3E61: 52 1B    MOV   A,[X+27]
    3E63: 08       PUSH  A
    3E64: 52 1C    MOV   A,[X+28]
    3E66: 08       PUSH  A
    3E67: 52 1D    MOV   A,[X+29]
    3E69: 08       PUSH  A
    3E6A: 62 D0 00 MOV   REG[0xD0],0x0
    3E6D: 7C 2B F3 LCALL 0x2BF3
    3E70: 18       POP   A
    3E71: 54 1D    MOV   [X+29],A
    3E73: 18       POP   A
    3E74: 54 1C    MOV   [X+28],A
    3E76: 18       POP   A
    3E77: 54 1B    MOV   [X+27],A
    3E79: 18       POP   A
    3E7A: 54 1A    MOV   [X+26],A
    3E7C: 38 FC    ADD   SP,0xFC
    3E7E: 77 01    INC   [X+1]
    3E80: 0F 00 00 ADC   [X+0],0x0
    3E83: 52 01    MOV   A,[X+1]
    3E85: 13 F0    SUB   A,[X-16]
    3E87: 52 EF    MOV   A,[X-17]
    3E89: 31 80    XOR   A,0x80
    3E8B: 62 D0 00 MOV   REG[0xD0],0x0
    3E8E: 53 3D    MOV   [__rX],A
    3E90: 52 00    MOV   A,[X+0]
    3E92: 31 80    XOR   A,0x80
    3E94: 1A 3D    SBB   A,[__rX]
    3E96: CF BD    JC    0x3E54
    3E98: 50 00    MOV   A,0x0
    3E9A: 08       PUSH  A
    3E9B: 08       PUSH  A
    3E9C: 08       PUSH  A
    3E9D: 08       PUSH  A
    3E9E: 52 F5    MOV   A,[X-11]
    3EA0: 08       PUSH  A
    3EA1: 52 F6    MOV   A,[X-10]
    3EA3: 08       PUSH  A
    3EA4: 52 F7    MOV   A,[X-9]
    3EA6: 08       PUSH  A
    3EA7: 52 F8    MOV   A,[X-8]
    3EA9: 08       PUSH  A
    3EAA: 62 D0 00 MOV   REG[0xD0],0x0
    3EAD: 7C 2B 96 LCALL 0x2B96
    3EB0: 38 F8    ADD   SP,0xF8
    3EB2: 39 00    CMP   A,0x0
    3EB4: A0 53    JZ    0x3F08
    3EB6: 39 01    CMP   A,0x1
    3EB8: A0 4F    JZ    0x3F08
    3EBA: 5A 48    MOV   [__r1],X
    3EBC: 06 48 2A ADD   [__r1],0x2A
    3EBF: 50 07    MOV   A,0x7
    3EC1: 08       PUSH  A
    3EC2: 51 48    MOV   A,[__r1]
    3EC4: 08       PUSH  A
    3EC5: 52 1A    MOV   A,[X+26]
    3EC7: 08       PUSH  A
    3EC8: 52 1B    MOV   A,[X+27]
    3ECA: 08       PUSH  A
    3ECB: 52 1C    MOV   A,[X+28]
    3ECD: 08       PUSH  A
    3ECE: 52 1D    MOV   A,[X+29]
    3ED0: 08       PUSH  A
    3ED1: 52 F5    MOV   A,[X-11]
    3ED3: 08       PUSH  A
    3ED4: 52 F6    MOV   A,[X-10]
    3ED6: 08       PUSH  A
    3ED7: 52 F7    MOV   A,[X-9]
    3ED9: 08       PUSH  A
    3EDA: 52 F8    MOV   A,[X-8]
    3EDC: 08       PUSH  A
    3EDD: 7C 2E 00 LCALL 0x2E00
    3EE0: 18       POP   A
    3EE1: 53 46    MOV   [__r3],A
    3EE3: 18       POP   A
    3EE4: 53 47    MOV   [__r2],A
    3EE6: 18       POP   A
    3EE7: 53 48    MOV   [__r1],A
    3EE9: 18       POP   A
    3EEA: 38 FC    ADD   SP,0xFC
    3EEC: 08       PUSH  A
    3EED: 51 48    MOV   A,[__r1]
    3EEF: 08       PUSH  A
    3EF0: 51 47    MOV   A,[__r2]
    3EF2: 08       PUSH  A
    3EF3: 51 46    MOV   A,[__r3]
    3EF5: 08       PUSH  A
    3EF6: 7C 36 EA LCALL _ftoa
    3EF9: 38 FA    ADD   SP,0xFA
    3EFB: 62 D0 00 MOV   REG[0xD0],0x0
    3EFE: 51 48    MOV   A,[__r1]
    3F00: 54 0A    MOV   [X+10],A
    3F02: 51 49    MOV   A,[__r0]
    3F04: 54 09    MOV   [X+9],A
    3F06: 80 50    JMP   0x3F57
    3F08: 62 D0 00 MOV   REG[0xD0],0x0
    3F0B: 5A 48    MOV   [__r1],X
    3F0D: 06 48 2A ADD   [__r1],0x2A
    3F10: 50 07    MOV   A,0x7
    3F12: 08       PUSH  A
    3F13: 51 48    MOV   A,[__r1]
    3F15: 08       PUSH  A
    3F16: 52 1A    MOV   A,[X+26]
    3F18: 08       PUSH  A
    3F19: 52 1B    MOV   A,[X+27]
    3F1B: 08       PUSH  A
    3F1C: 52 1C    MOV   A,[X+28]
    3F1E: 08       PUSH  A
    3F1F: 52 1D    MOV   A,[X+29]
    3F21: 08       PUSH  A
    3F22: 52 F5    MOV   A,[X-11]
    3F24: 08       PUSH  A
    3F25: 52 F6    MOV   A,[X-10]
    3F27: 08       PUSH  A
    3F28: 52 F7    MOV   A,[X-9]
    3F2A: 08       PUSH  A
    3F2B: 52 F8    MOV   A,[X-8]
    3F2D: 08       PUSH  A
    3F2E: 7C 2A 96 LCALL 0x2A96
    3F31: 18       POP   A
    3F32: 53 46    MOV   [__r3],A
    3F34: 18       POP   A
    3F35: 53 47    MOV   [__r2],A
    3F37: 18       POP   A
    3F38: 53 48    MOV   [__r1],A
    3F3A: 18       POP   A
    3F3B: 38 FC    ADD   SP,0xFC
    3F3D: 08       PUSH  A
    3F3E: 51 48    MOV   A,[__r1]
    3F40: 08       PUSH  A
    3F41: 51 47    MOV   A,[__r2]
    3F43: 08       PUSH  A
    3F44: 51 46    MOV   A,[__r3]
    3F46: 08       PUSH  A
    3F47: 7C 36 EA LCALL _ftoa
    3F4A: 38 FA    ADD   SP,0xFA
    3F4C: 62 D0 00 MOV   REG[0xD0],0x0
    3F4F: 51 48    MOV   A,[__r1]
    3F51: 54 0A    MOV   [X+10],A
    3F53: 51 49    MOV   A,[__r0]
    3F55: 54 09    MOV   [X+9],A
    3F57: 3D 2A 00 CMP   [X+42],0x0
    3F5A: B0 06    JNZ   0x3F61
    3F5C: 3D 2B 00 CMP   [X+43],0x0
    3F5F: A0 14    JZ    0x3F74
    3F61: 52 2A    MOV   A,[X+42]
    3F63: 08       PUSH  A
    3F64: 52 2B    MOV   A,[X+43]
    3F66: 08       PUSH  A
    3F67: 52 FB    MOV   A,[X-5]
    3F69: 08       PUSH  A
    3F6A: 52 FC    MOV   A,[X-4]
    3F6C: 08       PUSH  A
    3F6D: 9C 6B    CALL  0x3BDA
    3F6F: 38 FC    ADD   SP,0xFC
    3F71: 7D 49 E9 LJMP  0x49E9
    3F74: 56 01 00 MOV   [X+1],0x0
    3F77: 56 00 00 MOV   [X+0],0x0
    3F7A: 3D 0D 00 CMP   [X+13],0x0
    3F7D: B0 35    JNZ   0x3FB3
    3F7F: 3D 0E 00 CMP   [X+14],0x0
    3F82: B0 30    JNZ   0x3FB3
    3F84: 52 06    MOV   A,[X+6]
    3F86: 11 00    SUB   A,0x0
    3F88: 52 05    MOV   A,[X+5]
    3F8A: 31 80    XOR   A,0x80
    3F8C: 19 80    SBB   A,0x80
    3F8E: C0 24    JC    0x3FB3
    3F90: 62 D0 00 MOV   REG[0xD0],0x0
    3F93: 52 01    MOV   A,[X+1]
    3F95: 13 06    SUB   A,[X+6]
    3F97: 53 48    MOV   [__r1],A
    3F99: 52 00    MOV   A,[X+0]
    3F9B: 1B 05    SBB   A,[X+5]
    3F9D: 53 49    MOV   [__r0],A
    3F9F: 52 F0    MOV   A,[X-16]
    3FA1: 12 48    SUB   A,[__r1]
    3FA3: 51 49    MOV   A,[__r0]
    3FA5: 31 80    XOR   A,0x80
    3FA7: 53 3D    MOV   [__rX],A
    3FA9: 52 EF    MOV   A,[X-17]
    3FAB: 31 80    XOR   A,0x80
    3FAD: 1A 3D    SBB   A,[__rX]
    3FAF: D0 03    JNC   0x3FB3
    3FB1: 80 C5    JMP   0x4077
    3FB3: 62 D0 00 MOV   REG[0xD0],0x0
    3FB6: 52 01    MOV   A,[X+1]
    3FB8: 03 0A    ADD   A,[X+10]
    3FBA: 53 48    MOV   [__r1],A
    3FBC: 52 00    MOV   A,[X+0]
    3FBE: 0B 09    ADC   A,[X+9]
    3FC0: 60 D4    MOV   REG[0xD4],A
    3FC2: 3E 48    MVI   A,[__r1]
    3FC4: 54 04    MOV   [X+4],A
    3FC6: 3D 04 30 CMP   [X+4],0x30
    3FC9: C0 7A    JC    0x4044
    3FCB: 50 39    MOV   A,0x39
    3FCD: 3B 04    CMP   A,[X+4]
    3FCF: C0 74    JC    0x4044
    3FD1: 52 01    MOV   A,[X+1]
    3FD3: 54 23    MOV   [X+35],A
    3FD5: 52 00    MOV   A,[X+0]
    3FD7: 54 22    MOV   [X+34],A
    3FD9: 50 30    MOV   A,0x30
    3FDB: 3B 04    CMP   A,[X+4]
    3FDD: D0 15    JNC   0x3FF3
    3FDF: 52 1F    MOV   A,[X+31]
    3FE1: 11 00    SUB   A,0x0
    3FE3: 52 1E    MOV   A,[X+30]
    3FE5: 31 80    XOR   A,0x80
    3FE7: 19 80    SBB   A,0x80
    3FE9: D0 09    JNC   0x3FF3
    3FEB: 52 01    MOV   A,[X+1]
    3FED: 54 1F    MOV   [X+31],A
    3FEF: 52 00    MOV   A,[X+0]
    3FF1: 54 1E    MOV   [X+30],A
    3FF3: 52 06    MOV   A,[X+6]
    3FF5: 11 00    SUB   A,0x0
    3FF7: 52 05    MOV   A,[X+5]
    3FF9: 31 80    XOR   A,0x80
    3FFB: 19 80    SBB   A,0x80
    3FFD: D0 2C    JNC   0x402A
    3FFF: 52 0C    MOV   A,[X+12]
    4001: 11 00    SUB   A,0x0
    4003: 52 0B    MOV   A,[X+11]
    4005: 31 80    XOR   A,0x80
    4007: 19 80    SBB   A,0x80
    4009: D0 0F    JNC   0x4019
    400B: 50 30    MOV   A,0x30
    400D: 3B 04    CMP   A,[X+4]
    400F: D0 09    JNC   0x4019
    4011: 52 01    MOV   A,[X+1]
    4013: 54 0C    MOV   [X+12],A
    4015: 52 00    MOV   A,[X+0]
    4017: 54 0B    MOV   [X+11],A
    4019: 52 0C    MOV   A,[X+12]
    401B: 11 00    SUB   A,0x0
    401D: 52 0B    MOV   A,[X+11]
    401F: 31 80    XOR   A,0x80
    4021: 19 80    SBB   A,0x80
    4023: C0 06    JC    0x402A
    4025: 77 16    INC   [X+22]
    4027: 0F 15 00 ADC   [X+21],0x0
    402A: 52 06    MOV   A,[X+6]
    402C: 11 00    SUB   A,0x0
    402E: 52 05    MOV   A,[X+5]
    4030: 31 80    XOR   A,0x80
    4032: 19 80    SBB   A,0x80
    4034: C0 0F    JC    0x4044
    4036: 50 30    MOV   A,0x30
    4038: 3B 04    CMP   A,[X+4]
    403A: D0 09    JNC   0x4044
    403C: 52 01    MOV   A,[X+1]
    403E: 54 13    MOV   [X+19],A
    4040: 52 00    MOV   A,[X+0]
    4042: 54 12    MOV   [X+18],A
    4044: 3D 04 2E CMP   [X+4],0x2E
    4047: B0 09    JNZ   0x4051
    4049: 52 01    MOV   A,[X+1]
    404B: 54 06    MOV   [X+6],A
    404D: 52 00    MOV   A,[X+0]
    404F: 54 05    MOV   [X+5],A
    4051: 3D 04 2D CMP   [X+4],0x2D
    4054: B0 0A    JNZ   0x405F
    4056: 56 25 01 MOV   [X+37],0x1
    4059: 56 24 00 MOV   [X+36],0x0
    405C: 56 11 2D MOV   [X+17],0x2D
    405F: 3D 04 00 CMP   [X+4],0x0
    4062: B0 03    JNZ   0x4066
    4064: 80 12    JMP   0x4077
    4066: 77 01    INC   [X+1]
    4068: 0F 00 00 ADC   [X+0],0x0
    406B: 52 01    MOV   A,[X+1]
    406D: 11 14    SUB   A,0x14
    406F: 52 00    MOV   A,[X+0]
    4071: 31 80    XOR   A,0x80
    4073: 19 80    SBB   A,0x80
    4075: CF 04    JC    0x3F7A
    4077: 52 06    MOV   A,[X+6]
    4079: 11 00    SUB   A,0x0
    407B: 52 05    MOV   A,[X+5]
    407D: 31 80    XOR   A,0x80
    407F: 19 80    SBB   A,0x80
    4081: D0 1B    JNC   0x409D
    4083: 52 23    MOV   A,[X+35]
    4085: 01 01    ADD   A,0x1
    4087: 54 10    MOV   [X+16],A
    4089: 52 22    MOV   A,[X+34]
    408B: 09 00    ADC   A,0x0
    408D: 54 0F    MOV   [X+15],A
    408F: 52 10    MOV   A,[X+16]
    4091: 01 01    ADD   A,0x1
    4093: 54 21    MOV   [X+33],A
    4095: 52 0F    MOV   A,[X+15]
    4097: 09 00    ADC   A,0x0
    4099: 54 20    MOV   [X+32],A
    409B: 80 2F    JMP   0x40CB
    409D: 52 06    MOV   A,[X+6]
    409F: 54 10    MOV   [X+16],A
    40A1: 52 05    MOV   A,[X+5]
    40A3: 54 0F    MOV   [X+15],A
    40A5: 52 13    MOV   A,[X+19]
    40A7: 11 00    SUB   A,0x0
    40A9: 52 12    MOV   A,[X+18]
    40AB: 31 80    XOR   A,0x80
    40AD: 19 80    SBB   A,0x80
    40AF: D0 0F    JNC   0x40BF
    40B1: 52 10    MOV   A,[X+16]
    40B3: 01 01    ADD   A,0x1
    40B5: 54 21    MOV   [X+33],A
    40B7: 52 0F    MOV   A,[X+15]
    40B9: 09 00    ADC   A,0x0
    40BB: 54 20    MOV   [X+32],A
    40BD: 80 0D    JMP   0x40CB
    40BF: 52 13    MOV   A,[X+19]
    40C1: 01 01    ADD   A,0x1
    40C3: 54 21    MOV   [X+33],A
    40C5: 52 12    MOV   A,[X+18]
    40C7: 09 00    ADC   A,0x0
    40C9: 54 20    MOV   [X+32],A
    40CB: 52 0C    MOV   A,[X+12]
    40CD: 11 00    SUB   A,0x0
    40CF: 52 0B    MOV   A,[X+11]
    40D1: 31 80    XOR   A,0x80
    40D3: 19 80    SBB   A,0x80
    40D5: D0 0D    JNC   0x40E3
    40D7: 52 10    MOV   A,[X+16]
    40D9: 11 01    SUB   A,0x1
    40DB: 54 0C    MOV   [X+12],A
    40DD: 52 0F    MOV   A,[X+15]
    40DF: 19 00    SBB   A,0x0
    40E1: 54 0B    MOV   [X+11],A
    40E3: 3D 0D 00 CMP   [X+13],0x0
    40E6: B0 06    JNZ   0x40ED
    40E8: 3D 0E 00 CMP   [X+14],0x0
    40EB: A5 8A    JZ    0x4676
    40ED: 52 1F    MOV   A,[X+31]
    40EF: 11 00    SUB   A,0x0
    40F1: 52 1E    MOV   A,[X+30]
    40F3: 31 80    XOR   A,0x80
    40F5: 19 80    SBB   A,0x80
    40F7: D0 09    JNC   0x4101
    40F9: 52 0C    MOV   A,[X+12]
    40FB: 54 1F    MOV   [X+31],A
    40FD: 52 0B    MOV   A,[X+11]
    40FF: 54 1E    MOV   [X+30],A
    4101: 56 01 00 MOV   [X+1],0x0
    4104: 56 00 00 MOV   [X+0],0x0
    4107: 52 11    MOV   A,[X+17]
    4109: 3B 14    CMP   A,[X+20]
    410B: A0 28    JZ    0x4134
    410D: 62 D0 00 MOV   REG[0xD0],0x0
    4110: 52 01    MOV   A,[X+1]
    4112: 53 48    MOV   [__r1],A
    4114: 52 00    MOV   A,[X+0]
    4116: 53 49    MOV   [__r0],A
    4118: 51 48    MOV   A,[__r1]
    411A: 01 01    ADD   A,0x1
    411C: 54 01    MOV   [X+1],A
    411E: 51 49    MOV   A,[__r0]
    4120: 09 00    ADC   A,0x0
    4122: 54 00    MOV   [X+0],A
    4124: 52 FC    MOV   A,[X-4]
    4126: 04 48    ADD   [__r1],A
    4128: 52 FB    MOV   A,[X-5]
    412A: 0C 49    ADC   [__r0],A
    412C: 51 49    MOV   A,[__r0]
    412E: 60 D5    MOV   REG[0xD5],A
    4130: 52 11    MOV   A,[X+17]
    4132: 3F 48    MVI   [__r1],A
    4134: 62 D0 00 MOV   REG[0xD0],0x0
    4137: 52 01    MOV   A,[X+1]
    4139: 53 48    MOV   [__r1],A
    413B: 52 00    MOV   A,[X+0]
    413D: 53 49    MOV   [__r0],A
    413F: 51 48    MOV   A,[__r1]
    4141: 01 01    ADD   A,0x1
    4143: 54 01    MOV   [X+1],A
    4145: 51 49    MOV   A,[__r0]
    4147: 09 00    ADC   A,0x0
    4149: 54 00    MOV   [X+0],A
    414B: 52 1F    MOV   A,[X+31]
    414D: 03 0A    ADD   A,[X+10]
    414F: 53 46    MOV   [__r3],A
    4151: 52 1E    MOV   A,[X+30]
    4153: 0B 09    ADC   A,[X+9]
    4155: 60 D4    MOV   REG[0xD4],A
    4157: 3E 46    MVI   A,[__r3]
    4159: 53 47    MOV   [__r2],A
    415B: 52 FC    MOV   A,[X-4]
    415D: 04 48    ADD   [__r1],A
    415F: 52 FB    MOV   A,[X-5]
    4161: 0C 49    ADC   [__r0],A
    4163: 51 49    MOV   A,[__r0]
    4165: 60 D5    MOV   REG[0xD5],A
    4167: 51 47    MOV   A,[__r2]
    4169: 3F 48    MVI   [__r1],A
    416B: 52 01    MOV   A,[X+1]
    416D: 03 FC    ADD   A,[X-4]
    416F: 53 48    MOV   [__r1],A
    4171: 52 00    MOV   A,[X+0]
    4173: 0B FB    ADC   A,[X-5]
    4175: 60 D5    MOV   REG[0xD5],A
    4177: 50 2E    MOV   A,0x2E
    4179: 3F 48    MVI   [__r1],A
    417B: 50 00    MOV   A,0x0
    417D: 13 F0    SUB   A,[X-16]
    417F: 52 EF    MOV   A,[X-17]
    4181: 31 80    XOR   A,0x80
    4183: 53 3D    MOV   [__rX],A
    4185: 50 80    MOV   A,0x80
    4187: 1A 3D    SBB   A,[__rX]
    4189: D0 06    JNC   0x4190
    418B: 77 01    INC   [X+1]
    418D: 0F 00 00 ADC   [X+0],0x0
    4190: 52 1F    MOV   A,[X+31]
    4192: 01 01    ADD   A,0x1
    4194: 54 03    MOV   [X+3],A
    4196: 52 1E    MOV   A,[X+30]
    4198: 09 00    ADC   A,0x0
    419A: 54 02    MOV   [X+2],A
    419C: 56 08 00 MOV   [X+8],0x0
    419F: 56 07 00 MOV   [X+7],0x0
    41A2: 80 AC    JMP   0x424F
    41A4: 52 02    MOV   A,[X+2]
    41A6: 3B 0F    CMP   A,[X+15]
    41A8: B0 07    JNZ   0x41B0
    41AA: 52 03    MOV   A,[X+3]
    41AC: 3B 10    CMP   A,[X+16]
    41AE: A0 9B    JZ    0x424A
    41B0: 52 03    MOV   A,[X+3]
    41B2: 13 21    SUB   A,[X+33]
    41B4: 52 20    MOV   A,[X+32]
    41B6: 31 80    XOR   A,0x80
    41B8: 62 D0 00 MOV   REG[0xD0],0x0
    41BB: 53 3D    MOV   [__rX],A
    41BD: 52 02    MOV   A,[X+2]
    41BF: 31 80    XOR   A,0x80
    41C1: 1A 3D    SBB   A,[__rX]
    41C3: D0 3A    JNC   0x41FE
    41C5: 62 D0 00 MOV   REG[0xD0],0x0
    41C8: 52 01    MOV   A,[X+1]
    41CA: 53 48    MOV   [__r1],A
    41CC: 52 00    MOV   A,[X+0]
    41CE: 53 49    MOV   [__r0],A
    41D0: 51 48    MOV   A,[__r1]
    41D2: 01 01    ADD   A,0x1
    41D4: 54 01    MOV   [X+1],A
    41D6: 51 49    MOV   A,[__r0]
    41D8: 09 00    ADC   A,0x0
    41DA: 54 00    MOV   [X+0],A
    41DC: 52 03    MOV   A,[X+3]
    41DE: 03 0A    ADD   A,[X+10]
    41E0: 53 46    MOV   [__r3],A
    41E2: 52 02    MOV   A,[X+2]
    41E4: 0B 09    ADC   A,[X+9]
    41E6: 60 D4    MOV   REG[0xD4],A
    41E8: 3E 46    MVI   A,[__r3]
    41EA: 53 47    MOV   [__r2],A
    41EC: 52 FC    MOV   A,[X-4]
    41EE: 04 48    ADD   [__r1],A
    41F0: 52 FB    MOV   A,[X-5]
    41F2: 0C 49    ADC   [__r0],A
    41F4: 51 49    MOV   A,[__r0]
    41F6: 60 D5    MOV   REG[0xD5],A
    41F8: 51 47    MOV   A,[__r2]
    41FA: 3F 48    MVI   [__r1],A
    41FC: 80 48    JMP   0x4245
    41FE: 62 D0 00 MOV   REG[0xD0],0x0
    4201: 52 F4    MOV   A,[X-12]
    4203: 21 01    AND   A,0x1
    4205: 53 48    MOV   [__r1],A
    4207: 52 F3    MOV   A,[X-13]
    4209: 21 00    AND   A,0x0
    420B: 39 00    CMP   A,0x0
    420D: B0 10    JNZ   0x421E
    420F: 3C 48 00 CMP   [__r1],0x0
    4212: B0 0B    JNZ   0x421E
    4214: 3D 07 00 CMP   [X+7],0x0
    4217: B0 58    JNZ   0x4270
    4219: 3D 08 00 CMP   [X+8],0x0
    421C: B0 53    JNZ   0x4270
    421E: 62 D0 00 MOV   REG[0xD0],0x0
    4221: 52 01    MOV   A,[X+1]
    4223: 53 48    MOV   [__r1],A
    4225: 52 00    MOV   A,[X+0]
    4227: 53 49    MOV   [__r0],A
    4229: 51 48    MOV   A,[__r1]
    422B: 01 01    ADD   A,0x1
    422D: 54 01    MOV   [X+1],A
    422F: 51 49    MOV   A,[__r0]
    4231: 09 00    ADC   A,0x0
    4233: 54 00    MOV   [X+0],A
    4235: 52 FC    MOV   A,[X-4]
    4237: 04 48    ADD   [__r1],A
    4239: 52 FB    MOV   A,[X-5]
    423B: 0C 49    ADC   [__r0],A
    423D: 51 49    MOV   A,[__r0]
    423F: 60 D5    MOV   REG[0xD5],A
    4241: 50 30    MOV   A,0x30
    4243: 3F 48    MVI   [__r1],A
    4245: 77 08    INC   [X+8]
    4247: 0F 07 00 ADC   [X+7],0x0
    424A: 77 03    INC   [X+3]
    424C: 0F 02 00 ADC   [X+2],0x0
    424F: 52 08    MOV   A,[X+8]
    4251: 13 F0    SUB   A,[X-16]
    4253: 52 EF    MOV   A,[X-17]
    4255: 31 80    XOR   A,0x80
    4257: 62 D0 00 MOV   REG[0xD0],0x0
    425A: 53 3D    MOV   [__rX],A
    425C: 52 07    MOV   A,[X+7]
    425E: 31 80    XOR   A,0x80
    4260: 1A 3D    SBB   A,[__rX]
    4262: D0 0D    JNC   0x4270
    4264: 52 01    MOV   A,[X+1]
    4266: 11 0E    SUB   A,0xE
    4268: 52 00    MOV   A,[X+0]
    426A: 31 80    XOR   A,0x80
    426C: 19 80    SBB   A,0x80
    426E: CF 35    JC    0x41A4
    4270: 52 01    MOV   A,[X+1]
    4272: 11 01    SUB   A,0x1
    4274: 54 08    MOV   [X+8],A
    4276: 52 00    MOV   A,[X+0]
    4278: 19 00    SBB   A,0x0
    427A: 54 07    MOV   [X+7],A
    427C: 3D EF 00 CMP   [X-17],0x0
    427F: B0 0E    JNZ   0x428E
    4281: 3D F0 00 CMP   [X-16],0x0
    4284: B0 09    JNZ   0x428E
    4286: 52 01    MOV   A,[X+1]
    4288: 54 08    MOV   [X+8],A
    428A: 52 00    MOV   A,[X+0]
    428C: 54 07    MOV   [X+7],A
    428E: 62 D0 00 MOV   REG[0xD0],0x0
    4291: 52 10    MOV   A,[X+16]
    4293: 13 1F    SUB   A,[X+31]
    4295: 53 48    MOV   [__r1],A
    4297: 52 0F    MOV   A,[X+15]
    4299: 1B 1E    SBB   A,[X+30]
    429B: 53 49    MOV   [__r0],A
    429D: 51 48    MOV   A,[__r1]
    429F: 11 01    SUB   A,0x1
    42A1: 54 29    MOV   [X+41],A
    42A3: 51 49    MOV   A,[__r0]
    42A5: 19 00    SBB   A,0x0
    42A7: 54 28    MOV   [X+40],A
    42A9: 52 03    MOV   A,[X+3]
    42AB: 13 21    SUB   A,[X+33]
    42AD: 52 20    MOV   A,[X+32]
    42AF: 31 80    XOR   A,0x80
    42B1: 53 3D    MOV   [__rX],A
    42B3: 52 02    MOV   A,[X+2]
    42B5: 31 80    XOR   A,0x80
    42B7: 1A 3D    SBB   A,[__rX]
    42B9: D0 1B    JNC   0x42D5
    42BB: 62 D0 00 MOV   REG[0xD0],0x0
    42BE: 52 03    MOV   A,[X+3]
    42C0: 03 0A    ADD   A,[X+10]
    42C2: 53 48    MOV   [__r1],A
    42C4: 52 02    MOV   A,[X+2]
    42C6: 0B 09    ADC   A,[X+9]
    42C8: 60 D4    MOV   REG[0xD4],A
    42CA: 3E 48    MVI   A,[__r1]
    42CC: 39 2E    CMP   A,0x2E
    42CE: B0 06    JNZ   0x42D5
    42D0: 77 03    INC   [X+3]
    42D2: 0F 02 00 ADC   [X+2],0x0
    42D5: 52 03    MOV   A,[X+3]
    42D7: 13 21    SUB   A,[X+33]
    42D9: 52 20    MOV   A,[X+32]
    42DB: 31 80    XOR   A,0x80
    42DD: 62 D0 00 MOV   REG[0xD0],0x0
    42E0: 53 3D    MOV   [__rX],A
    42E2: 52 02    MOV   A,[X+2]
    42E4: 31 80    XOR   A,0x80
    42E6: 1A 3D    SBB   A,[__rX]
    42E8: D1 5D    JNC   0x4446
    42EA: 62 D0 00 MOV   REG[0xD0],0x0
    42ED: 52 03    MOV   A,[X+3]
    42EF: 03 0A    ADD   A,[X+10]
    42F1: 53 48    MOV   [__r1],A
    42F3: 52 02    MOV   A,[X+2]
    42F5: 0B 09    ADC   A,[X+9]
    42F7: 60 D4    MOV   REG[0xD4],A
    42F9: 3E 48    MVI   A,[__r1]
    42FB: 53 48    MOV   [__r1],A
    42FD: 55 49 00 MOV   [__r0],0x0
    4300: 11 35    SUB   A,0x35
    4302: 50 00    MOV   A,0x0
    4304: 31 80    XOR   A,0x80
    4306: 19 80    SBB   A,0x80
    4308: C1 3D    JC    0x4446
    430A: 62 D0 00 MOV   REG[0xD0],0x0
    430D: 50 39    MOV   A,0x39
    430F: 12 48    SUB   A,[__r1]
    4311: 51 49    MOV   A,[__r0]
    4313: 31 80    XOR   A,0x80
    4315: 53 3D    MOV   [__rX],A
    4317: 50 80    MOV   A,0x80
    4319: 1A 3D    SBB   A,[__rX]
    431B: C1 2A    JC    0x4446
    431D: 81 1C    JMP   0x443A
    431F: 62 D0 00 MOV   REG[0xD0],0x0
    4322: 52 08    MOV   A,[X+8]
    4324: 03 FC    ADD   A,[X-4]
    4326: 53 48    MOV   [__r1],A
    4328: 52 07    MOV   A,[X+7]
    432A: 0B FB    ADC   A,[X-5]
    432C: 60 D4    MOV   REG[0xD4],A
    432E: 3E 48    MVI   A,[__r1]
    4330: 53 48    MOV   [__r1],A
    4332: 55 49 00 MOV   [__r0],0x0
    4335: 11 30    SUB   A,0x30
    4337: 50 00    MOV   A,0x0
    4339: 31 80    XOR   A,0x80
    433B: 19 80    SBB   A,0x80
    433D: C0 38    JC    0x4376
    433F: 62 D0 00 MOV   REG[0xD0],0x0
    4342: 50 38    MOV   A,0x38
    4344: 12 48    SUB   A,[__r1]
    4346: 51 49    MOV   A,[__r0]
    4348: 31 80    XOR   A,0x80
    434A: 53 3D    MOV   [__rX],A
    434C: 50 80    MOV   A,0x80
    434E: 1A 3D    SBB   A,[__rX]
    4350: C0 25    JC    0x4376
    4352: 62 D0 00 MOV   REG[0xD0],0x0
    4355: 52 08    MOV   A,[X+8]
    4357: 03 FC    ADD   A,[X-4]
    4359: 53 48    MOV   [__r1],A
    435B: 52 07    MOV   A,[X+7]
    435D: 0B FB    ADC   A,[X-5]
    435F: 53 49    MOV   [__r0],A
    4361: 60 D4    MOV   REG[0xD4],A
    4363: 3E 48    MVI   A,[__r1]
    4365: 7A 48    DEC   [__r1]
    4367: 53 47    MOV   [__r2],A
    4369: 06 47 01 ADD   [__r2],0x1
    436C: 51 49    MOV   A,[__r0]
    436E: 60 D5    MOV   REG[0xD5],A
    4370: 51 47    MOV   A,[__r2]
    4372: 3F 48    MVI   [__r1],A
    4374: 80 D1    JMP   0x4446
    4376: 62 D0 00 MOV   REG[0xD0],0x0
    4379: 52 08    MOV   A,[X+8]
    437B: 03 FC    ADD   A,[X-4]
    437D: 53 48    MOV   [__r1],A
    437F: 52 07    MOV   A,[X+7]
    4381: 0B FB    ADC   A,[X-5]
    4383: 60 D4    MOV   REG[0xD4],A
    4385: 3E 48    MVI   A,[__r1]
    4387: 39 2E    CMP   A,0x2E
    4389: B0 86    JNZ   0x4410
    438B: 7B 08    DEC   [X+8]
    438D: 1F 07 00 SBB   [X+7],0x0
    4390: 52 08    MOV   A,[X+8]
    4392: 03 FC    ADD   A,[X-4]
    4394: 53 48    MOV   [__r1],A
    4396: 52 07    MOV   A,[X+7]
    4398: 0B FB    ADC   A,[X-5]
    439A: 60 D4    MOV   REG[0xD4],A
    439C: 3E 48    MVI   A,[__r1]
    439E: 53 48    MOV   [__r1],A
    43A0: 55 49 00 MOV   [__r0],0x0
    43A3: 11 30    SUB   A,0x30
    43A5: 50 00    MOV   A,0x0
    43A7: 31 80    XOR   A,0x80
    43A9: 19 80    SBB   A,0x80
    43AB: C0 38    JC    0x43E4
    43AD: 62 D0 00 MOV   REG[0xD0],0x0
    43B0: 50 38    MOV   A,0x38
    43B2: 12 48    SUB   A,[__r1]
    43B4: 51 49    MOV   A,[__r0]
    43B6: 31 80    XOR   A,0x80
    43B8: 53 3D    MOV   [__rX],A
    43BA: 50 80    MOV   A,0x80
    43BC: 1A 3D    SBB   A,[__rX]
    43BE: C0 25    JC    0x43E4
    43C0: 62 D0 00 MOV   REG[0xD0],0x0
    43C3: 52 08    MOV   A,[X+8]
    43C5: 03 FC    ADD   A,[X-4]
    43C7: 53 48    MOV   [__r1],A
    43C9: 52 07    MOV   A,[X+7]
    43CB: 0B FB    ADC   A,[X-5]
    43CD: 53 49    MOV   [__r0],A
    43CF: 60 D4    MOV   REG[0xD4],A
    43D1: 3E 48    MVI   A,[__r1]
    43D3: 7A 48    DEC   [__r1]
    43D5: 53 47    MOV   [__r2],A
    43D7: 06 47 01 ADD   [__r2],0x1
    43DA: 51 49    MOV   A,[__r0]
    43DC: 60 D5    MOV   REG[0xD5],A
    43DE: 51 47    MOV   A,[__r2]
    43E0: 3F 48    MVI   [__r1],A
    43E2: 80 63    JMP   0x4446
    43E4: 62 D0 00 MOV   REG[0xD0],0x0
    43E7: 52 08    MOV   A,[X+8]
    43E9: 03 FC    ADD   A,[X-4]
    43EB: 53 48    MOV   [__r1],A
    43ED: 52 07    MOV   A,[X+7]
    43EF: 0B FB    ADC   A,[X-5]
    43F1: 60 D4    MOV   REG[0xD4],A
    43F3: 3E 48    MVI   A,[__r1]
    43F5: 39 39    CMP   A,0x39
    43F7: B0 18    JNZ   0x4410
    43F9: 52 08    MOV   A,[X+8]
    43FB: 03 FC    ADD   A,[X-4]
    43FD: 53 48    MOV   [__r1],A
    43FF: 52 07    MOV   A,[X+7]
    4401: 0B FB    ADC   A,[X-5]
    4403: 60 D5    MOV   REG[0xD5],A
    4405: 50 31    MOV   A,0x31
    4407: 3F 48    MVI   [__r1],A
    4409: 77 29    INC   [X+41]
    440B: 0F 28 00 ADC   [X+40],0x0
    440E: 80 37    JMP   0x4446
    4410: 62 D0 00 MOV   REG[0xD0],0x0
    4413: 52 08    MOV   A,[X+8]
    4415: 03 FC    ADD   A,[X-4]
    4417: 53 48    MOV   [__r1],A
    4419: 52 07    MOV   A,[X+7]
    441B: 0B FB    ADC   A,[X-5]
    441D: 60 D4    MOV   REG[0xD4],A
    441F: 3E 48    MVI   A,[__r1]
    4421: 39 39    CMP   A,0x39
    4423: B0 11    JNZ   0x4435
    4425: 52 08    MOV   A,[X+8]
    4427: 03 FC    ADD   A,[X-4]
    4429: 53 48    MOV   [__r1],A
    442B: 52 07    MOV   A,[X+7]
    442D: 0B FB    ADC   A,[X-5]
    442F: 60 D5    MOV   REG[0xD5],A
    4431: 50 30    MOV   A,0x30
    4433: 3F 48    MVI   [__r1],A
    4435: 7B 08    DEC   [X+8]
    4437: 1F 07 00 SBB   [X+7],0x0
    443A: 52 08    MOV   A,[X+8]
    443C: 11 00    SUB   A,0x0
    443E: 52 07    MOV   A,[X+7]
    4440: 31 80    XOR   A,0x80
    4442: 19 80    SBB   A,0x80
    4444: DE DA    JNC   0x431F
    4446: 62 D0 00 MOV   REG[0xD0],0x0
    4449: 52 01    MOV   A,[X+1]
    444B: 53 48    MOV   [__r1],A
    444D: 52 00    MOV   A,[X+0]
    444F: 53 49    MOV   [__r0],A
    4451: 51 48    MOV   A,[__r1]
    4453: 01 01    ADD   A,0x1
    4455: 54 01    MOV   [X+1],A
    4457: 51 49    MOV   A,[__r0]
    4459: 09 00    ADC   A,0x0
    445B: 54 00    MOV   [X+0],A
    445D: 52 FC    MOV   A,[X-4]
    445F: 04 48    ADD   [__r1],A
    4461: 52 FB    MOV   A,[X-5]
    4463: 0C 49    ADC   [__r0],A
    4465: 51 49    MOV   A,[__r0]
    4467: 60 D5    MOV   REG[0xD5],A
    4469: 52 2C    MOV   A,[X+44]
    446B: 3F 48    MVI   [__r1],A
    446D: 52 29    MOV   A,[X+41]
    446F: 11 00    SUB   A,0x0
    4471: 52 28    MOV   A,[X+40]
    4473: 31 80    XOR   A,0x80
    4475: 19 80    SBB   A,0x80
    4477: D0 32    JNC   0x44AA
    4479: 62 D0 00 MOV   REG[0xD0],0x0
    447C: 52 01    MOV   A,[X+1]
    447E: 53 48    MOV   [__r1],A
    4480: 52 00    MOV   A,[X+0]
    4482: 53 49    MOV   [__r0],A
    4484: 51 48    MOV   A,[__r1]
    4486: 01 01    ADD   A,0x1
    4488: 54 01    MOV   [X+1],A
    448A: 51 49    MOV   A,[__r0]
    448C: 09 00    ADC   A,0x0
    448E: 54 00    MOV   [X+0],A
    4490: 52 FC    MOV   A,[X-4]
    4492: 04 48    ADD   [__r1],A
    4494: 52 FB    MOV   A,[X-5]
    4496: 0C 49    ADC   [__r0],A
    4498: 51 49    MOV   A,[__r0]
    449A: 60 D5    MOV   REG[0xD5],A
    449C: 50 2D    MOV   A,0x2D
    449E: 3F 48    MVI   [__r1],A
    44A0: 52 29    MOV   A,[X+41]
    44A2: 73       CPL   A
    44A3: 54 29    MOV   [X+41],A
    44A5: 52 28    MOV   A,[X+40]
    44A7: 73       CPL   A
    44A8: 54 28    MOV   [X+40],A
    44AA: 50 00    MOV   A,0x0
    44AC: 08       PUSH  A
    44AD: 50 0A    MOV   A,0xA
    44AF: 08       PUSH  A
    44B0: 52 28    MOV   A,[X+40]
    44B2: 08       PUSH  A
    44B3: 52 29    MOV   A,[X+41]
    44B5: 08       PUSH  A
    44B6: 62 D0 00 MOV   REG[0xD0],0x0
    44B9: 52 01    MOV   A,[X+1]
    44BB: 03 FC    ADD   A,[X-4]
    44BD: 53 48    MOV   [__r1],A
    44BF: 52 00    MOV   A,[X+0]
    44C1: 0B FB    ADC   A,[X-5]
    44C3: 08       PUSH  A
    44C4: 51 48    MOV   A,[__r1]
    44C6: 08       PUSH  A
    44C7: 7C 2F 9E LCALL _itoa
    44CA: 38 FA    ADD   SP,0xFA
    44CC: 56 01 00 MOV   [X+1],0x0
    44CF: 56 00 00 MOV   [X+0],0x0
    44D2: 62 D0 00 MOV   REG[0xD0],0x0
    44D5: 52 01    MOV   A,[X+1]
    44D7: 03 FC    ADD   A,[X-4]
    44D9: 53 48    MOV   [__r1],A
    44DB: 52 00    MOV   A,[X+0]
    44DD: 0B FB    ADC   A,[X-5]
    44DF: 60 D4    MOV   REG[0xD4],A
    44E1: 3E 48    MVI   A,[__r1]
    44E3: 39 00    CMP   A,0x0
    44E5: B0 0B    JNZ   0x44F1
    44E7: 52 01    MOV   A,[X+1]
    44E9: 54 18    MOV   [X+24],A
    44EB: 52 00    MOV   A,[X+0]
    44ED: 54 17    MOV   [X+23],A
    44EF: 80 12    JMP   0x4502
    44F1: 77 01    INC   [X+1]
    44F3: 0F 00 00 ADC   [X+0],0x0
    44F6: 52 01    MOV   A,[X+1]
    44F8: 11 14    SUB   A,0x14
    44FA: 52 00    MOV   A,[X+0]
    44FC: 31 80    XOR   A,0x80
    44FE: 19 80    SBB   A,0x80
    4500: CF D1    JC    0x44D2
    4502: 62 D0 00 MOV   REG[0xD0],0x0
    4505: 52 F4    MOV   A,[X-12]
    4507: 21 04    AND   A,0x4
    4509: 53 48    MOV   [__r1],A
    450B: 52 F3    MOV   A,[X-13]
    450D: 21 00    AND   A,0x0
    450F: 39 00    CMP   A,0x0
    4511: B0 06    JNZ   0x4518
    4513: 3C 48 00 CMP   [__r1],0x0
    4516: A0 6E    JZ    0x4585
    4518: 52 18    MOV   A,[X+24]
    451A: 13 F2    SUB   A,[X-14]
    451C: 52 F1    MOV   A,[X-15]
    451E: 31 80    XOR   A,0x80
    4520: 62 D0 00 MOV   REG[0xD0],0x0
    4523: 53 3D    MOV   [__rX],A
    4525: 52 17    MOV   A,[X+23]
    4527: 31 80    XOR   A,0x80
    4529: 1A 3D    SBB   A,[__rX]
    452B: D4 B2    JNC   0x49DE
    452D: 52 18    MOV   A,[X+24]
    452F: 54 03    MOV   [X+3],A
    4531: 52 17    MOV   A,[X+23]
    4533: 54 02    MOV   [X+2],A
    4535: 80 19    JMP   0x454F
    4537: 62 D0 00 MOV   REG[0xD0],0x0
    453A: 52 03    MOV   A,[X+3]
    453C: 03 FC    ADD   A,[X-4]
    453E: 53 48    MOV   [__r1],A
    4540: 52 02    MOV   A,[X+2]
    4542: 0B FB    ADC   A,[X-5]
    4544: 60 D5    MOV   REG[0xD5],A
    4546: 52 19    MOV   A,[X+25]
    4548: 3F 48    MVI   [__r1],A
    454A: 77 03    INC   [X+3]
    454C: 0F 02 00 ADC   [X+2],0x0
    454F: 52 03    MOV   A,[X+3]
    4551: 13 F2    SUB   A,[X-14]
    4553: 52 F1    MOV   A,[X-15]
    4555: 31 80    XOR   A,0x80
    4557: 62 D0 00 MOV   REG[0xD0],0x0
    455A: 53 3D    MOV   [__rX],A
    455C: 52 02    MOV   A,[X+2]
    455E: 31 80    XOR   A,0x80
    4560: 1A 3D    SBB   A,[__rX]
    4562: CF D4    JC    0x4537
    4564: 62 D0 00 MOV   REG[0xD0],0x0
    4567: 52 F2    MOV   A,[X-14]
    4569: 11 01    SUB   A,0x1
    456B: 53 48    MOV   [__r1],A
    456D: 52 F1    MOV   A,[X-15]
    456F: 19 00    SBB   A,0x0
    4571: 53 49    MOV   [__r0],A
    4573: 52 FC    MOV   A,[X-4]
    4575: 04 48    ADD   [__r1],A
    4577: 52 FB    MOV   A,[X-5]
    4579: 0C 49    ADC   [__r0],A
    457B: 51 49    MOV   A,[__r0]
    457D: 60 D5    MOV   REG[0xD5],A
    457F: 50 00    MOV   A,0x0
    4581: 3F 48    MVI   [__r1],A
    4583: 84 5A    JMP   0x49DE
    4585: 52 18    MOV   A,[X+24]
    4587: 13 F2    SUB   A,[X-14]
    4589: 52 F1    MOV   A,[X-15]
    458B: 31 80    XOR   A,0x80
    458D: 62 D0 00 MOV   REG[0xD0],0x0
    4590: 53 3D    MOV   [__rX],A
    4592: 52 17    MOV   A,[X+23]
    4594: 31 80    XOR   A,0x80
    4596: 1A 3D    SBB   A,[__rX]
    4598: D4 45    JNC   0x49DE
    459A: 52 18    MOV   A,[X+24]
    459C: 54 03    MOV   [X+3],A
    459E: 52 17    MOV   A,[X+23]
    45A0: 54 02    MOV   [X+2],A
    45A2: 80 3D    JMP   0x45E0
    45A4: 62 D0 00 MOV   REG[0xD0],0x0
    45A7: 52 03    MOV   A,[X+3]
    45A9: 03 FC    ADD   A,[X-4]
    45AB: 53 48    MOV   [__r1],A
    45AD: 52 02    MOV   A,[X+2]
    45AF: 0B FB    ADC   A,[X-5]
    45B1: 60 D4    MOV   REG[0xD4],A
    45B3: 3E 48    MVI   A,[__r1]
    45B5: 53 49    MOV   [__r0],A
    45B7: 52 03    MOV   A,[X+3]
    45B9: 03 F2    ADD   A,[X-14]
    45BB: 53 46    MOV   [__r3],A
    45BD: 52 02    MOV   A,[X+2]
    45BF: 0B F1    ADC   A,[X-15]
    45C1: 53 47    MOV   [__r2],A
    45C3: 52 18    MOV   A,[X+24]
    45C5: 14 46    SUB   [__r3],A
    45C7: 52 17    MOV   A,[X+23]
    45C9: 1C 47    SBB   [__r2],A
    45CB: 52 FC    MOV   A,[X-4]
    45CD: 04 46    ADD   [__r3],A
    45CF: 52 FB    MOV   A,[X-5]
    45D1: 0C 47    ADC   [__r2],A
    45D3: 51 47    MOV   A,[__r2]
    45D5: 60 D5    MOV   REG[0xD5],A
    45D7: 51 49    MOV   A,[__r0]
    45D9: 3F 46    MVI   [__r3],A
    45DB: 7B 03    DEC   [X+3]
    45DD: 1F 02 00 SBB   [X+2],0x0
    45E0: 52 03    MOV   A,[X+3]
    45E2: 11 00    SUB   A,0x0
    45E4: 52 02    MOV   A,[X+2]
    45E6: 31 80    XOR   A,0x80
    45E8: 19 80    SBB   A,0x80
    45EA: DF B9    JNC   0x45A4
    45EC: 62 D0 00 MOV   REG[0xD0],0x0
    45EF: 52 F2    MOV   A,[X-14]
    45F1: 13 18    SUB   A,[X+24]
    45F3: 53 48    MOV   [__r1],A
    45F5: 52 F1    MOV   A,[X-15]
    45F7: 1B 17    SBB   A,[X+23]
    45F9: 53 49    MOV   [__r0],A
    45FB: 51 48    MOV   A,[__r1]
    45FD: 11 01    SUB   A,0x1
    45FF: 54 03    MOV   [X+3],A
    4601: 51 49    MOV   A,[__r0]
    4603: 19 00    SBB   A,0x0
    4605: 54 02    MOV   [X+2],A
    4607: 80 19    JMP   0x4621
    4609: 62 D0 00 MOV   REG[0xD0],0x0
    460C: 52 03    MOV   A,[X+3]
    460E: 03 FC    ADD   A,[X-4]
    4610: 53 48    MOV   [__r1],A
    4612: 52 02    MOV   A,[X+2]
    4614: 0B FB    ADC   A,[X-5]
    4616: 60 D5    MOV   REG[0xD5],A
    4618: 52 14    MOV   A,[X+20]
    461A: 3F 48    MVI   [__r1],A
    461C: 7B 03    DEC   [X+3]
    461E: 1F 02 00 SBB   [X+2],0x0
    4621: 52 03    MOV   A,[X+3]
    4623: 11 00    SUB   A,0x0
    4625: 52 02    MOV   A,[X+2]
    4627: 31 80    XOR   A,0x80
    4629: 19 80    SBB   A,0x80
    462B: DF DD    JNC   0x4609
    462D: 62 D0 00 MOV   REG[0xD0],0x0
    4630: 52 F4    MOV   A,[X-12]
    4632: 21 10    AND   A,0x10
    4634: 53 48    MOV   [__r1],A
    4636: 52 F3    MOV   A,[X-13]
    4638: 21 00    AND   A,0x0
    463A: 39 00    CMP   A,0x0
    463C: B0 06    JNZ   0x4643
    463E: 3C 48 00 CMP   [__r1],0x0
    4641: A3 9C    JZ    0x49DE
    4643: 52 11    MOV   A,[X+17]
    4645: 3B 14    CMP   A,[X+20]
    4647: A3 96    JZ    0x49DE
    4649: 62 D0 00 MOV   REG[0xD0],0x0
    464C: 52 FC    MOV   A,[X-4]
    464E: 53 48    MOV   [__r1],A
    4650: 52 FB    MOV   A,[X-5]
    4652: 60 D5    MOV   REG[0xD5],A
    4654: 52 11    MOV   A,[X+17]
    4656: 3F 48    MVI   [__r1],A
    4658: 52 F2    MOV   A,[X-14]
    465A: 13 18    SUB   A,[X+24]
    465C: 53 48    MOV   [__r1],A
    465E: 52 F1    MOV   A,[X-15]
    4660: 1B 17    SBB   A,[X+23]
    4662: 53 49    MOV   [__r0],A
    4664: 52 FC    MOV   A,[X-4]
    4666: 04 48    ADD   [__r1],A
    4668: 52 FB    MOV   A,[X-5]
    466A: 0C 49    ADC   [__r0],A
    466C: 51 49    MOV   A,[__r0]
    466E: 60 D5    MOV   REG[0xD5],A
    4670: 52 14    MOV   A,[X+20]
    4672: 3F 48    MVI   [__r1],A
    4674: 83 69    JMP   0x49DE
    4676: 62 D0 00 MOV   REG[0xD0],0x0
    4679: 52 F4    MOV   A,[X-12]
    467B: 21 01    AND   A,0x1
    467D: 53 48    MOV   [__r1],A
    467F: 52 F3    MOV   A,[X-13]
    4681: 21 00    AND   A,0x0
    4683: 39 00    CMP   A,0x0
    4685: B0 06    JNZ   0x468C
    4687: 3C 48 00 CMP   [__r1],0x0
    468A: A0 3F    JZ    0x46CA
    468C: 62 D0 00 MOV   REG[0xD0],0x0
    468F: 52 10    MOV   A,[X+16]
    4691: 03 F0    ADD   A,[X-16]
    4693: 53 48    MOV   [__r1],A
    4695: 52 0F    MOV   A,[X+15]
    4697: 0B EF    ADC   A,[X-17]
    4699: 53 49    MOV   [__r0],A
    469B: 51 48    MOV   A,[__r1]
    469D: 13 21    SUB   A,[X+33]
    469F: 52 20    MOV   A,[X+32]
    46A1: 31 80    XOR   A,0x80
    46A3: 53 3D    MOV   [__rX],A
    46A5: 51 49    MOV   A,[__r0]
    46A7: 31 80    XOR   A,0x80
    46A9: 1A 3D    SBB   A,[__rX]
    46AB: C0 41    JC    0x46ED
    46AD: 62 D0 00 MOV   REG[0xD0],0x0
    46B0: 52 10    MOV   A,[X+16]
    46B2: 03 F0    ADD   A,[X-16]
    46B4: 53 48    MOV   [__r1],A
    46B6: 52 0F    MOV   A,[X+15]
    46B8: 0B EF    ADC   A,[X-17]
    46BA: 53 49    MOV   [__r0],A
    46BC: 51 48    MOV   A,[__r1]
    46BE: 01 01    ADD   A,0x1
    46C0: 54 21    MOV   [X+33],A
    46C2: 51 49    MOV   A,[__r0]
    46C4: 09 00    ADC   A,0x0
    46C6: 54 20    MOV   [X+32],A
    46C8: 80 24    JMP   0x46ED
    46CA: 62 D0 00 MOV   REG[0xD0],0x0
    46CD: 52 10    MOV   A,[X+16]
    46CF: 01 01    ADD   A,0x1
    46D1: 53 48    MOV   [__r1],A
    46D3: 52 0F    MOV   A,[X+15]
    46D5: 09 00    ADC   A,0x0
    46D7: 53 49    MOV   [__r0],A
    46D9: 52 20    MOV   A,[X+32]
    46DB: 3A 49    CMP   A,[__r0]
    46DD: B0 0F    JNZ   0x46ED
    46DF: 52 21    MOV   A,[X+33]
    46E1: 3A 48    CMP   A,[__r1]
    46E3: B0 09    JNZ   0x46ED
    46E5: 52 10    MOV   A,[X+16]
    46E7: 54 21    MOV   [X+33],A
    46E9: 52 0F    MOV   A,[X+15]
    46EB: 54 20    MOV   [X+32],A
    46ED: 50 14    MOV   A,0x14
    46EF: 13 21    SUB   A,[X+33]
    46F1: 52 20    MOV   A,[X+32]
    46F3: 31 80    XOR   A,0x80
    46F5: 62 D0 00 MOV   REG[0xD0],0x0
    46F8: 53 3D    MOV   [__rX],A
    46FA: 50 80    MOV   A,0x80
    46FC: 1A 3D    SBB   A,[__rX]
    46FE: D0 07    JNC   0x4706
    4700: 56 21 14 MOV   [X+33],0x14
    4703: 56 20 00 MOV   [X+32],0x0
    4706: 52 21    MOV   A,[X+33]
    4708: 13 0C    SUB   A,[X+12]
    470A: 54 18    MOV   [X+24],A
    470C: 52 20    MOV   A,[X+32]
    470E: 1B 0B    SBB   A,[X+11]
    4710: 54 17    MOV   [X+23],A
    4712: 52 11    MOV   A,[X+17]
    4714: 3B 14    CMP   A,[X+20]
    4716: A0 06    JZ    0x471D
    4718: 77 18    INC   [X+24]
    471A: 0F 17 00 ADC   [X+23],0x0
    471D: 52 F2    MOV   A,[X-14]
    471F: 13 18    SUB   A,[X+24]
    4721: 52 17    MOV   A,[X+23]
    4723: 31 80    XOR   A,0x80
    4725: 62 D0 00 MOV   REG[0xD0],0x0
    4728: 53 3D    MOV   [__rX],A
    472A: 52 F1    MOV   A,[X-15]
    472C: 31 80    XOR   A,0x80
    472E: 1A 3D    SBB   A,[__rX]
    4730: D0 09    JNC   0x473A
    4732: 52 18    MOV   A,[X+24]
    4734: 54 F2    MOV   [X-14],A
    4736: 52 17    MOV   A,[X+23]
    4738: 54 F1    MOV   [X-15],A
    473A: 50 14    MOV   A,0x14
    473C: 13 F2    SUB   A,[X-14]
    473E: 52 F1    MOV   A,[X-15]
    4740: 31 80    XOR   A,0x80
    4742: 62 D0 00 MOV   REG[0xD0],0x0
    4745: 53 3D    MOV   [__rX],A
    4747: 50 80    MOV   A,0x80
    4749: 1A 3D    SBB   A,[__rX]
    474B: D0 07    JNC   0x4753
    474D: 56 F2 14 MOV   [X-14],0x14
    4750: 56 F1 00 MOV   [X-15],0x0
    4753: 50 14    MOV   A,0x14
    4755: 13 18    SUB   A,[X+24]
    4757: 52 17    MOV   A,[X+23]
    4759: 31 80    XOR   A,0x80
    475B: 62 D0 00 MOV   REG[0xD0],0x0
    475E: 53 3D    MOV   [__rX],A
    4760: 50 80    MOV   A,0x80
    4762: 1A 3D    SBB   A,[__rX]
    4764: D0 07    JNC   0x476C
    4766: 56 18 14 MOV   [X+24],0x14
    4769: 56 17 00 MOV   [X+23],0x0
    476C: 62 D0 00 MOV   REG[0xD0],0x0
    476F: 52 F4    MOV   A,[X-12]
    4771: 21 04    AND   A,0x4
    4773: 53 48    MOV   [__r1],A
    4775: 52 F3    MOV   A,[X-13]
    4777: 21 00    AND   A,0x0
    4779: 39 00    CMP   A,0x0
    477B: B0 12    JNZ   0x478E
    477D: 3C 48 00 CMP   [__r1],0x0
    4780: B0 0D    JNZ   0x478E
    4782: 52 F1    MOV   A,[X-15]
    4784: 3B 17    CMP   A,[X+23]
    4786: B0 2A    JNZ   0x47B1
    4788: 52 F2    MOV   A,[X-14]
    478A: 3B 18    CMP   A,[X+24]
    478C: B0 24    JNZ   0x47B1
    478E: 56 27 00 MOV   [X+39],0x0
    4791: 56 26 00 MOV   [X+38],0x0
    4794: 52 11    MOV   A,[X+17]
    4796: 3B 14    CMP   A,[X+20]
    4798: A0 9E    JZ    0x4837
    479A: 62 D0 00 MOV   REG[0xD0],0x0
    479D: 52 FC    MOV   A,[X-4]
    479F: 53 48    MOV   [__r1],A
    47A1: 52 FB    MOV   A,[X-5]
    47A3: 60 D5    MOV   REG[0xD5],A
    47A5: 52 11    MOV   A,[X+17]
    47A7: 3F 48    MVI   [__r1],A
    47A9: 56 27 01 MOV   [X+39],0x1
    47AC: 56 26 00 MOV   [X+38],0x0
    47AF: 80 87    JMP   0x4837
    47B1: 52 F2    MOV   A,[X-14]
    47B3: 13 18    SUB   A,[X+24]
    47B5: 54 27    MOV   [X+39],A
    47B7: 52 F1    MOV   A,[X-15]
    47B9: 1B 17    SBB   A,[X+23]
    47BB: 54 26    MOV   [X+38],A
    47BD: 56 03 00 MOV   [X+3],0x0
    47C0: 56 02 00 MOV   [X+2],0x0
    47C3: 80 19    JMP   0x47DD
    47C5: 62 D0 00 MOV   REG[0xD0],0x0
    47C8: 52 03    MOV   A,[X+3]
    47CA: 03 FC    ADD   A,[X-4]
    47CC: 53 48    MOV   [__r1],A
    47CE: 52 02    MOV   A,[X+2]
    47D0: 0B FB    ADC   A,[X-5]
    47D2: 60 D5    MOV   REG[0xD5],A
    47D4: 52 14    MOV   A,[X+20]
    47D6: 3F 48    MVI   [__r1],A
    47D8: 77 03    INC   [X+3]
    47DA: 0F 02 00 ADC   [X+2],0x0
    47DD: 52 27    MOV   A,[X+39]
    47DF: 13 03    SUB   A,[X+3]
    47E1: 52 02    MOV   A,[X+2]
    47E3: 31 80    XOR   A,0x80
    47E5: 62 D0 00 MOV   REG[0xD0],0x0
    47E8: 53 3D    MOV   [__rX],A
    47EA: 52 26    MOV   A,[X+38]
    47EC: 31 80    XOR   A,0x80
    47EE: 1A 3D    SBB   A,[__rX]
    47F0: DF D4    JNC   0x47C5
    47F2: 52 11    MOV   A,[X+17]
    47F4: 3B 14    CMP   A,[X+20]
    47F6: A0 40    JZ    0x4837
    47F8: 62 D0 00 MOV   REG[0xD0],0x0
    47FB: 52 F4    MOV   A,[X-12]
    47FD: 21 10    AND   A,0x10
    47FF: 53 48    MOV   [__r1],A
    4801: 52 F3    MOV   A,[X-13]
    4803: 21 00    AND   A,0x0
    4805: 39 00    CMP   A,0x0
    4807: B0 06    JNZ   0x480E
    4809: 3C 48 00 CMP   [__r1],0x0
    480C: A0 12    JZ    0x481F
    480E: 62 D0 00 MOV   REG[0xD0],0x0
    4811: 52 FC    MOV   A,[X-4]
    4813: 53 48    MOV   [__r1],A
    4815: 52 FB    MOV   A,[X-5]
    4817: 60 D5    MOV   REG[0xD5],A
    4819: 52 11    MOV   A,[X+17]
    481B: 3F 48    MVI   [__r1],A
    481D: 80 14    JMP   0x4832
    481F: 62 D0 00 MOV   REG[0xD0],0x0
    4822: 52 27    MOV   A,[X+39]
    4824: 03 FC    ADD   A,[X-4]
    4826: 53 48    MOV   [__r1],A
    4828: 52 26    MOV   A,[X+38]
    482A: 0B FB    ADC   A,[X-5]
    482C: 60 D5    MOV   REG[0xD5],A
    482E: 52 11    MOV   A,[X+17]
    4830: 3F 48    MVI   [__r1],A
    4832: 77 27    INC   [X+39]
    4834: 0F 26 00 ADC   [X+38],0x0
    4837: 52 27    MOV   A,[X+39]
    4839: 54 03    MOV   [X+3],A
    483B: 52 26    MOV   A,[X+38]
    483D: 54 02    MOV   [X+2],A
    483F: 3D 15 00 CMP   [X+21],0x0
    4842: B0 1E    JNZ   0x4861
    4844: 3D 16 00 CMP   [X+22],0x0
    4847: B0 19    JNZ   0x4861
    4849: 62 D0 00 MOV   REG[0xD0],0x0
    484C: 52 03    MOV   A,[X+3]
    484E: 03 FC    ADD   A,[X-4]
    4850: 53 48    MOV   [__r1],A
    4852: 52 02    MOV   A,[X+2]
    4854: 0B FB    ADC   A,[X-5]
    4856: 60 D5    MOV   REG[0xD5],A
    4858: 50 30    MOV   A,0x30
    485A: 3F 48    MVI   [__r1],A
    485C: 77 03    INC   [X+3]
    485E: 0F 02 00 ADC   [X+2],0x0
    4861: 56 01 00 MOV   [X+1],0x0
    4864: 56 00 00 MOV   [X+0],0x0
    4867: 80 3A    JMP   0x48A2
    4869: 62 D0 00 MOV   REG[0xD0],0x0
    486C: 52 01    MOV   A,[X+1]
    486E: 03 0A    ADD   A,[X+10]
    4870: 53 48    MOV   [__r1],A
    4872: 52 00    MOV   A,[X+0]
    4874: 0B 09    ADC   A,[X+9]
    4876: 53 49    MOV   [__r0],A
    4878: 52 0C    MOV   A,[X+12]
    487A: 02 48    ADD   A,[__r1]
    487C: 53 48    MOV   [__r1],A
    487E: 52 0B    MOV   A,[X+11]
    4880: 0A 49    ADC   A,[__r0]
    4882: 60 D4    MOV   REG[0xD4],A
    4884: 3E 48    MVI   A,[__r1]
    4886: 53 49    MOV   [__r0],A
    4888: 52 03    MOV   A,[X+3]
    488A: 03 FC    ADD   A,[X-4]
    488C: 53 46    MOV   [__r3],A
    488E: 52 02    MOV   A,[X+2]
    4890: 0B FB    ADC   A,[X-5]
    4892: 60 D5    MOV   REG[0xD5],A
    4894: 51 49    MOV   A,[__r0]
    4896: 3F 46    MVI   [__r3],A
    4898: 77 03    INC   [X+3]
    489A: 0F 02 00 ADC   [X+2],0x0
    489D: 77 01    INC   [X+1]
    489F: 0F 00 00 ADC   [X+0],0x0
    48A2: 52 01    MOV   A,[X+1]
    48A4: 13 16    SUB   A,[X+22]
    48A6: 52 15    MOV   A,[X+21]
    48A8: 31 80    XOR   A,0x80
    48AA: 62 D0 00 MOV   REG[0xD0],0x0
    48AD: 53 3D    MOV   [__rX],A
    48AF: 52 00    MOV   A,[X+0]
    48B1: 31 80    XOR   A,0x80
    48B3: 1A 3D    SBB   A,[__rX]
    48B5: CF B3    JC    0x4869
    48B7: 52 10    MOV   A,[X+16]
    48B9: 13 21    SUB   A,[X+33]
    48BB: 52 20    MOV   A,[X+32]
    48BD: 31 80    XOR   A,0x80
    48BF: 62 D0 00 MOV   REG[0xD0],0x0
    48C2: 53 3D    MOV   [__rX],A
    48C4: 52 0F    MOV   A,[X+15]
    48C6: 31 80    XOR   A,0x80
    48C8: 1A 3D    SBB   A,[__rX]
    48CA: D0 19    JNC   0x48E4
    48CC: 62 D0 00 MOV   REG[0xD0],0x0
    48CF: 52 03    MOV   A,[X+3]
    48D1: 03 FC    ADD   A,[X-4]
    48D3: 53 48    MOV   [__r1],A
    48D5: 52 02    MOV   A,[X+2]
    48D7: 0B FB    ADC   A,[X-5]
    48D9: 60 D5    MOV   REG[0xD5],A
    48DB: 50 2E    MOV   A,0x2E
    48DD: 3F 48    MVI   [__r1],A
    48DF: 77 03    INC   [X+3]
    48E1: 0F 02 00 ADC   [X+2],0x0
    48E4: 56 01 00 MOV   [X+1],0x0
    48E7: 56 00 00 MOV   [X+0],0x0
    48EA: 80 90    JMP   0x497B
    48EC: 62 D0 00 MOV   REG[0xD0],0x0
    48EF: 52 13    MOV   A,[X+19]
    48F1: 13 06    SUB   A,[X+6]
    48F3: 53 48    MOV   [__r1],A
    48F5: 52 12    MOV   A,[X+18]
    48F7: 1B 05    SBB   A,[X+5]
    48F9: 53 49    MOV   [__r0],A
    48FB: 52 01    MOV   A,[X+1]
    48FD: 12 48    SUB   A,[__r1]
    48FF: 51 49    MOV   A,[__r0]
    4901: 31 80    XOR   A,0x80
    4903: 53 3D    MOV   [__rX],A
    4905: 52 00    MOV   A,[X+0]
    4907: 31 80    XOR   A,0x80
    4909: 1A 3D    SBB   A,[__rX]
    490B: D0 3C    JNC   0x4948
    490D: 62 D0 00 MOV   REG[0xD0],0x0
    4910: 52 01    MOV   A,[X+1]
    4912: 03 0A    ADD   A,[X+10]
    4914: 53 48    MOV   [__r1],A
    4916: 52 00    MOV   A,[X+0]
    4918: 0B 09    ADC   A,[X+9]
    491A: 53 49    MOV   [__r0],A
    491C: 52 06    MOV   A,[X+6]
    491E: 02 48    ADD   A,[__r1]
    4920: 53 48    MOV   [__r1],A
    4922: 52 05    MOV   A,[X+5]
    4924: 0A 49    ADC   A,[__r0]
    4926: 53 49    MOV   [__r0],A
    4928: 06 48 01 ADD   [__r1],0x1
    492B: 0E 49 00 ADC   [__r0],0x0
    492E: 51 49    MOV   A,[__r0]
    4930: 60 D4    MOV   REG[0xD4],A
    4932: 3E 48    MVI   A,[__r1]
    4934: 53 49    MOV   [__r0],A
    4936: 52 03    MOV   A,[X+3]
    4938: 03 FC    ADD   A,[X-4]
    493A: 53 46    MOV   [__r3],A
    493C: 52 02    MOV   A,[X+2]
    493E: 0B FB    ADC   A,[X-5]
    4940: 60 D5    MOV   REG[0xD5],A
    4942: 51 49    MOV   A,[__r0]
    4944: 3F 46    MVI   [__r3],A
    4946: 80 2A    JMP   0x4971
    4948: 62 D0 00 MOV   REG[0xD0],0x0
    494B: 52 F4    MOV   A,[X-12]
    494D: 21 01    AND   A,0x1
    494F: 53 48    MOV   [__r1],A
    4951: 52 F3    MOV   A,[X-13]
    4953: 21 00    AND   A,0x0
    4955: 39 00    CMP   A,0x0
    4957: B0 06    JNZ   0x495E
    4959: 3C 48 00 CMP   [__r1],0x0
    495C: A0 59    JZ    0x49B6
    495E: 62 D0 00 MOV   REG[0xD0],0x0
    4961: 52 03    MOV   A,[X+3]
    4963: 03 FC    ADD   A,[X-4]
    4965: 53 48    MOV   [__r1],A
    4967: 52 02    MOV   A,[X+2]
    4969: 0B FB    ADC   A,[X-5]
    496B: 60 D5    MOV   REG[0xD5],A
    496D: 50 30    MOV   A,0x30
    496F: 3F 48    MVI   [__r1],A
    4971: 77 03    INC   [X+3]
    4973: 0F 02 00 ADC   [X+2],0x0
    4976: 77 01    INC   [X+1]
    4978: 0F 00 00 ADC   [X+0],0x0
    497B: 52 01    MOV   A,[X+1]
    497D: 13 F0    SUB   A,[X-16]
    497F: 52 EF    MOV   A,[X-17]
    4981: 31 80    XOR   A,0x80
    4983: 62 D0 00 MOV   REG[0xD0],0x0
    4986: 53 3D    MOV   [__rX],A
    4988: 52 00    MOV   A,[X+0]
    498A: 31 80    XOR   A,0x80
    498C: 1A 3D    SBB   A,[__rX]
    498E: D0 0D    JNC   0x499C
    4990: 52 03    MOV   A,[X+3]
    4992: 11 14    SUB   A,0x14
    4994: 52 02    MOV   A,[X+2]
    4996: 31 80    XOR   A,0x80
    4998: 19 80    SBB   A,0x80
    499A: CF 51    JC    0x48EC
    499C: 80 19    JMP   0x49B6
    499E: 62 D0 00 MOV   REG[0xD0],0x0
    49A1: 52 03    MOV   A,[X+3]
    49A3: 03 FC    ADD   A,[X-4]
    49A5: 53 48    MOV   [__r1],A
    49A7: 52 02    MOV   A,[X+2]
    49A9: 0B FB    ADC   A,[X-5]
    49AB: 60 D5    MOV   REG[0xD5],A
    49AD: 52 19    MOV   A,[X+25]
    49AF: 3F 48    MVI   [__r1],A
    49B1: 77 03    INC   [X+3]
    49B3: 0F 02 00 ADC   [X+2],0x0
    49B6: 52 03    MOV   A,[X+3]
    49B8: 13 F2    SUB   A,[X-14]
    49BA: 52 F1    MOV   A,[X-15]
    49BC: 31 80    XOR   A,0x80
    49BE: 62 D0 00 MOV   REG[0xD0],0x0
    49C1: 53 3D    MOV   [__rX],A
    49C3: 52 02    MOV   A,[X+2]
    49C5: 31 80    XOR   A,0x80
    49C7: 1A 3D    SBB   A,[__rX]
    49C9: CF D4    JC    0x499E
    49CB: 62 D0 00 MOV   REG[0xD0],0x0
    49CE: 52 03    MOV   A,[X+3]
    49D0: 03 FC    ADD   A,[X-4]
    49D2: 53 48    MOV   [__r1],A
    49D4: 52 02    MOV   A,[X+2]
    49D6: 0B FB    ADC   A,[X-5]
    49D8: 60 D5    MOV   REG[0xD5],A
    49DA: 50 00    MOV   A,0x0
    49DC: 3F 48    MVI   [__r1],A
    49DE: 62 D0 00 MOV   REG[0xD0],0x0
    49E1: 52 FC    MOV   A,[X-4]
    49E3: 53 48    MOV   [__r1],A
    49E5: 52 FB    MOV   A,[X-5]
    49E7: 53 49    MOV   [__r0],A
    49E9: 38 CF    ADD   SP,0xCF
    49EB: 20       POP   X
    49EC: 7F       RET   
_cprintf:
    49ED: 10       PUSH  X
    49EE: 4F       MOV   X,SP
    49EF: 38 04    ADD   SP,0x4
    49F1: 62 D0 00 MOV   REG[0xD0],0x0
    49F4: 5A 48    MOV   [__r1],X
    49F6: 16 48 05 SUB   [__r1],0x5
    49F9: 51 48    MOV   A,[__r1]
    49FB: 54 01    MOV   [X+1],A
    49FD: 56 00 07 MOV   [X+0],0x7
    4A00: 52 00    MOV   A,[X+0]
    4A02: 08       PUSH  A
    4A03: 52 01    MOV   A,[X+1]
    4A05: 08       PUSH  A
    4A06: 52 FB    MOV   A,[X-5]
    4A08: 08       PUSH  A
    4A09: 52 FC    MOV   A,[X-4]
    4A0B: 08       PUSH  A
    4A0C: 50 04    MOV   A,0x4
    4A0E: 08       PUSH  A
    4A0F: 50 6A    MOV   A,0x6A
    4A11: 08       PUSH  A
    4A12: 7C 1B 69 LCALL __cprint
    4A15: 38 FA    ADD   SP,0xFA
    4A17: 62 D0 00 MOV   REG[0xD0],0x0
    4A1A: 51 48    MOV   A,[__r1]
    4A1C: 54 03    MOV   [X+3],A
    4A1E: 51 49    MOV   A,[__r0]
    4A20: 54 02    MOV   [X+2],A
    4A22: 52 03    MOV   A,[X+3]
    4A24: 53 48    MOV   [__r1],A
    4A26: 52 02    MOV   A,[X+2]
    4A28: 53 49    MOV   [__r0],A
    4A2A: 38 FC    ADD   SP,0xFC
    4A2C: 20       POP   X
    4A2D: 7F       RET   
