C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE I2C_1_INT
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_903\Debug\I2C_1_INT.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\2.2\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\I2C_1_INT.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_903\Debug\I2C_1_INT.lst) CD DB NOIP 
                    -OT(2,SIZE) DF(DEBUG) INCDIR(Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_903\Debug\I2C_1_INT.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: I2C_1_INT.c
   3          * Version 3.30
   4          *
   5          * Description:
   6          *  This file provides the source code of Interrupt Service Routine (ISR)
   7          *  for I2C component.
   8          *
   9          *  Note:
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "I2C_1_PVT.h"
  19          
  20          
  21          /*******************************************************************************
  22          *  Place your includes, defines and code here
  23          ********************************************************************************/
  24          /* `#START I2C_1_ISR_intc` */
  25          
  26          /* `#END` */
  27          
  28          
  29          /*******************************************************************************
  30          * Function Name: I2C_1_ISR
  31          ********************************************************************************
  32          *
  33          * Summary:
  34          *  Handler for I2C interrupt. The Slave and Master operations are handled here.
  35          *
  36          * Parameters:
  37          *  void
  38          *
  39          * Return:
  40          *  void
  41          *
  42          * Reentrant:
  43          *  No
  44          *
  45          *******************************************************************************/
  46          CY_ISR(I2C_1_ISR)
  47          {
  48   1          #if(I2C_1_MODE_SLAVE_ENABLED)
                     uint8  tmp8;
                  #endif  /* (I2C_1_MODE_SLAVE_ENABLED) */
  51   1      
  52   1          uint8  tmpCsr;
  53   1      
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 2   

  54   1          #if(I2C_1_TIMEOUT_FF_ENABLED)
                      if(0u != I2C_1_TimeoutGetStatus())
                      {
                          I2C_1_TimeoutReset();
                          I2C_1_state = I2C_1_SM_EXIT_IDLE;
                          /* I2C_1_CSR_REG should be cleared after reset */
                      }
                  #endif /* (I2C_1_TIMEOUT_FF_ENABLED) */
  62   1      
  63   1      
  64   1          tmpCsr = I2C_1_CSR_REG;      /* Make copy as interrupts clear */
  65   1      
  66   1          #if(I2C_1_MODE_MULTI_MASTER_SLAVE_ENABLED)
                      if(I2C_1_CHECK_START_GEN(I2C_1_MCSR_REG))
                      {
                          I2C_1_CLEAR_START_GEN;
              
                          /* Set READ complete, but was aborted */
                          I2C_1_mstrStatus |= (I2C_1_MSTAT_ERR_XFER |
                                                          I2C_1_GET_MSTAT_CMPLT);
              
                          /* The slave was addressed */
                          I2C_1_state = I2C_1_SM_SLAVE;
                      }
                  #endif /* (I2C_1_MODE_MULTI_MASTER_SLAVE_ENABLED) */
  79   1      
  80   1      
  81   1          #if(I2C_1_MODE_MULTI_MASTER_ENABLED)
                      if(I2C_1_CHECK_LOST_ARB(tmpCsr))
                      {
                          /* Set errors */
                          I2C_1_mstrStatus |= (I2C_1_MSTAT_ERR_XFER     |
                                                          I2C_1_MSTAT_ERR_ARB_LOST |
                                                          I2C_1_GET_MSTAT_CMPLT);
              
                          I2C_1_DISABLE_INT_ON_STOP; /* Interrupt on Stop is enabled by write */
              
                          #if(I2C_1_MODE_MULTI_MASTER_SLAVE_ENABLED)
                              if(I2C_1_CHECK_ADDRESS_STS(tmpCsr))
                              {
                                  /* The slave was addressed */
                                  I2C_1_state = I2C_1_SM_SLAVE;
                              }
                              else
                              {
                                  I2C_1_BUS_RELEASE;
              
                                  I2C_1_state = I2C_1_SM_EXIT_IDLE;
                              }
                          #else
                              I2C_1_BUS_RELEASE;
              
                              I2C_1_state = I2C_1_SM_EXIT_IDLE;
              
                          #endif /* (I2C_1_MODE_MULTI_MASTER_SLAVE_ENABLED) */
                      }
                  #endif /* (I2C_1_MODE_MULTI_MASTER_ENABLED) */
 111   1      
 112   1          /* Check for Master operation mode */
 113   1          if(I2C_1_CHECK_SM_MASTER)
 114   1          {
 115   2              #if(I2C_1_MODE_MASTER_ENABLED)
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 3   

 116   2                  if(I2C_1_CHECK_BYTE_COMPLETE(tmpCsr))
 117   2                  {
 118   3                      switch (I2C_1_state)
 119   3                      {
 120   4                      case I2C_1_SM_MSTR_WR_ADDR:  /* After address is sent, WRITE data */
 121   4                      case I2C_1_SM_MSTR_RD_ADDR:  /* After address is sent, READ  data */
 122   4      
 123   4                          tmpCsr &= ((uint8) ~I2C_1_CSR_STOP_STATUS); /* Clear STOP bit history on address phase
             - */
 124   4                          
 125   4                          if(I2C_1_CHECK_ADDR_ACK(tmpCsr))
 126   4                          {
 127   5                              /* Setup for transmit or receive of data */
 128   5                              if(I2C_1_state == I2C_1_SM_MSTR_WR_ADDR)   /* TRANSMIT data */
 129   5                              {
 130   6                                  /* Check if at least one byte to transfer */
 131   6                                  if(I2C_1_mstrWrBufSize > 0u)
 132   6                                  {
 133   7                                      /* Load the 1st data byte */
 134   7                                      I2C_1_DATA_REG = I2C_1_mstrWrBufPtr[0u];
 135   7                                      I2C_1_TRANSMIT_DATA;
 136   7                                      I2C_1_mstrWrBufIndex = 1u;   /* Set index to 2nd element */
 137   7      
 138   7                                      /* Set transmit state until done */
 139   7                                      I2C_1_state = I2C_1_SM_MSTR_WR_DATA;
 140   7                                  }
 141   6                                  /* End of buffer: complete writing */
 142   6                                  else if(I2C_1_CHECK_NO_STOP(I2C_1_mstrControl))
 143   6                                  {
 144   7                                      #if(CY_PSOC5A)
                                                  /* Do not handles 0 bytes transfer - HALT is NOT allowed */
                                                  I2C_1_ENABLE_INT_ON_STOP;
                                                  I2C_1_GENERATE_STOP;
                                              
                                              #else
 150   7                                          /* Set WRITE complete and Master HALTED */
 151   7                                          I2C_1_mstrStatus |= (I2C_1_MSTAT_XFER_HALT |
 152   7                                                                          I2C_1_MSTAT_WR_CMPLT);
 153   7      
 154   7                                          I2C_1_state = I2C_1_SM_MSTR_HALT; /* Expect RESTART */
 155   7                                          I2C_1_DisableInt();
 156   7                                      
 157   7                                      #endif /* (CY_PSOC5A) */
 158   7                                  }
 159   6                                  else
 160   6                                  {
 161   7                                      I2C_1_ENABLE_INT_ON_STOP; /* Enable interrupt on STOP, to catch it */
 162   7                                      I2C_1_GENERATE_STOP;
 163   7                                  }
 164   6                              }
 165   5                              else  /* Master Receive data */
 166   5                              {
 167   6                                  I2C_1_READY_TO_READ; /* Release bus to read data */
 168   6      
 169   6                                  I2C_1_state  = I2C_1_SM_MSTR_RD_DATA;
 170   6                              }
 171   5                          }
 172   4                          /* Address is NACKed */
 173   4                          else if(I2C_1_CHECK_ADDR_NAK(tmpCsr))
 174   4                          {
 175   5                              /* Set Address NAK error */
 176   5                              I2C_1_mstrStatus |= (I2C_1_MSTAT_ERR_XFER |
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 4   

 177   5                                                              I2C_1_MSTAT_ERR_ADDR_NAK);
 178   5                                                              
 179   5                              if(I2C_1_CHECK_NO_STOP(I2C_1_mstrControl))
 180   5                              {
 181   6                                  I2C_1_mstrStatus |= (I2C_1_MSTAT_XFER_HALT | 
 182   6                                                                  I2C_1_GET_MSTAT_CMPLT);
 183   6      
 184   6                                  I2C_1_state = I2C_1_SM_MSTR_HALT; /* Expect RESTART */
 185   6                                  I2C_1_DisableInt();
 186   6                              }
 187   5                              else  /* Do normal Stop */
 188   5                              {
 189   6                                  I2C_1_ENABLE_INT_ON_STOP; /* Enable interrupt on STOP, to catch it */
 190   6                                  I2C_1_GENERATE_STOP;
 191   6                              }
 192   5                          }
 193   4                          else
 194   4                          {
 195   5                              /* Address phase is not set for some reason: error */
 196   5                              #if(I2C_1_TIMEOUT_ENABLED)
                                          /* Exit from interrupt to take a chance for timeout timer handle this case */
                                          I2C_1_DisableInt();
                                          I2C_1_ClearPendingInt();
                                      #else
 201   5                                  /* Block execution flow: unexpected condition */
 202   5                                  CYASSERT(0u != 0u);
 203   5                              #endif /* (I2C_1_TIMEOUT_ENABLED) */
 204   5                          }
 205   4                          break;
 206   4      
 207   4                      case I2C_1_SM_MSTR_WR_DATA:
 208   4      
 209   4                          if(I2C_1_CHECK_DATA_ACK(tmpCsr))
 210   4                          {
 211   5                              /* Check if end of buffer */
 212   5                              if(I2C_1_mstrWrBufIndex  < I2C_1_mstrWrBufSize)
 213   5                              {
 214   6                                  I2C_1_DATA_REG =
 215   6                                                           I2C_1_mstrWrBufPtr[I2C_1_mstrWrBufIndex];
 216   6                                  I2C_1_TRANSMIT_DATA;
 217   6                                  I2C_1_mstrWrBufIndex++;
 218   6                              }
 219   5                              /* End of buffer: complete writing */
 220   5                              else if(I2C_1_CHECK_NO_STOP(I2C_1_mstrControl))
 221   5                              {
 222   6                                  /* Set WRITE complete and Master HALTED */
 223   6                                  I2C_1_mstrStatus |= (I2C_1_MSTAT_XFER_HALT |
 224   6                                                                  I2C_1_MSTAT_WR_CMPLT);
 225   6      
 226   6                                  I2C_1_state = I2C_1_SM_MSTR_HALT;    /* Expect RESTART */
 227   6                                  I2C_1_DisableInt();
 228   6                              }
 229   5                              else  /* Do normal STOP */
 230   5                              {
 231   6                                  I2C_1_Workaround();          /* Workaround: empty function */
 232   6                                  I2C_1_ENABLE_INT_ON_STOP;    /* Enable interrupt on STOP, to catch it */
 233   6                                  I2C_1_GENERATE_STOP;
 234   6                              }
 235   5                          }
 236   4                          /* Last byte NAKed: end writing */
 237   4                          else if(I2C_1_CHECK_NO_STOP(I2C_1_mstrControl))
 238   4                          {
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 5   

 239   5                              /* Set WRITE complete, SHORT transfer and Master HALTED */
 240   5                              I2C_1_mstrStatus |= (I2C_1_MSTAT_ERR_XFER       |
 241   5                                                              I2C_1_MSTAT_ERR_SHORT_XFER |
 242   5                                                              I2C_1_MSTAT_XFER_HALT      |
 243   5                                                              I2C_1_MSTAT_WR_CMPLT);
 244   5      
 245   5                              I2C_1_state = I2C_1_SM_MSTR_HALT;    /* Expect RESTART */
 246   5                              I2C_1_DisableInt();
 247   5                          }
 248   4                          else  /* Do normal STOP */
 249   4                          {
 250   5                              I2C_1_ENABLE_INT_ON_STOP;    /* Enable interrupt on STOP, to catch it */
 251   5                              I2C_1_GENERATE_STOP;
 252   5      
 253   5                              /* Set SHORT and ERR transfer */
 254   5                              I2C_1_mstrStatus |= (I2C_1_MSTAT_ERR_SHORT_XFER |
 255   5                                                              I2C_1_MSTAT_ERR_XFER);
 256   5                          }
 257   4                          
 258   4                          break;
 259   4      
 260   4                      case I2C_1_SM_MSTR_RD_DATA:
 261   4      
 262   4                          I2C_1_mstrRdBufPtr[I2C_1_mstrRdBufIndex] = I2C_1_DATA_REG;
 263   4                          I2C_1_mstrRdBufIndex++;
 264   4      
 265   4                          /* Check if end of buffer */
 266   4                          if(I2C_1_mstrRdBufIndex < I2C_1_mstrRdBufSize)
 267   4                          {
 268   5                              I2C_1_ACK_AND_RECEIVE;       /* ACK and receive byte */
 269   5                          }
 270   4                          /* End of buffer: complete reading */
 271   4                          else if(I2C_1_CHECK_NO_STOP(I2C_1_mstrControl))
 272   4                          {                        
 273   5                              /* Set READ complete and Master HALTED */
 274   5                              I2C_1_mstrStatus |= (I2C_1_MSTAT_XFER_HALT |
 275   5                                                              I2C_1_MSTAT_RD_CMPLT);
 276   5                              
 277   5                              I2C_1_state = I2C_1_SM_MSTR_HALT;    /* Expect RESTART */
 278   5                              I2C_1_DisableInt();
 279   5                          }
 280   4                          else
 281   4                          {
 282   5                              I2C_1_ENABLE_INT_ON_STOP;
 283   5                              I2C_1_NAK_AND_RECEIVE;       /* NACK and TRY to generate STOP */
 284   5                          }
 285   4                          break;
 286   4      
 287   4                      default: /* This is an invalid state and should not occur */
 288   4      
 289   4                          #if(I2C_1_TIMEOUT_ENABLED)
                                      /* Exit from interrupt to take a chance for timeout timer handle this case */
                                      I2C_1_DisableInt();
                                      I2C_1_ClearPendingInt();
                                  #else
 294   4                              /* Block execution flow: unexpected condition */
 295   4                              CYASSERT(0u != 0u);
 296   4                          #endif /* (I2C_1_TIMEOUT_ENABLED) */
 297   4      
 298   4                          break;
 299   4                      }
 300   3                  }
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 6   

 301   2      
 302   2                  /* Catches the Stop: end of transaction */
 303   2                  if(I2C_1_CHECK_STOP_STS(tmpCsr))
 304   2                  {
 305   3                      I2C_1_mstrStatus |= I2C_1_GET_MSTAT_CMPLT;
 306   3      
 307   3                      I2C_1_DISABLE_INT_ON_STOP;
 308   3                      I2C_1_state = I2C_1_SM_IDLE;
 309   3                  }
 310   2              #endif /* (I2C_1_MODE_MASTER_ENABLED) */
 311   2          }
 312   1          else if(I2C_1_CHECK_SM_SLAVE)
 313   1          {
 314   2              #if(I2C_1_MODE_SLAVE_ENABLED)
                          
                          if((I2C_1_CHECK_STOP_STS(tmpCsr)) || /* Stop || Restart */
                             (I2C_1_CHECK_BYTE_COMPLETE(tmpCsr) && I2C_1_CHECK_ADDRESS_STS(tmpCsr)))
                          {
                              /* Catch end of master write transcation: use interrupt on Stop */
                              /* The STOP bit history on address phase does not have correct state */
                              if(I2C_1_SM_SL_WR_DATA == I2C_1_state)
                              {
                                  I2C_1_DISABLE_INT_ON_STOP;
              
                                  I2C_1_slStatus &= ((uint8) ~I2C_1_SSTAT_WR_BUSY);
                                  I2C_1_slStatus |= ((uint8)  I2C_1_SSTAT_WR_CMPLT);
              
                                  I2C_1_state = I2C_1_SM_IDLE;
                              }
                          }
              
                          if(I2C_1_CHECK_BYTE_COMPLETE(tmpCsr))
                          {
                              /* The address only issued after Start or ReStart: so check address
                                 to catch this events:
                                  FF : sets Addr phase with byte_complete interrupt trigger.
                                  UDB: sets Addr phase immediately after Start or ReStart. */
                              if(I2C_1_CHECK_ADDRESS_STS(tmpCsr))
                              {
                                  /* Check for software address detection */
                                  #if(I2C_1_SW_ADRR_DECODE)
                                      tmp8 = I2C_1_GET_SLAVE_ADDR(I2C_1_DATA_REG);
              
                                      if(tmp8 == I2C_1_slAddress)   /* Check for address match */
                                      {
                                          if(0u != (I2C_1_DATA_REG & I2C_1_READ_FLAG))
                                          {
                                              /* Place code to prepare read buffer here                  */
                                              /* `#START I2C_1_SW_PREPARE_READ_BUF_interrupt` */
              
                                              /* `#END` */
              
                                              /* Prepare next opeation to read, get data and place in data register */
                                              if(I2C_1_slRdBufIndex < I2C_1_slRdBufSize)
                                              {
                                                  /* Load first data byte from array */
                                                  I2C_1_DATA_REG = I2C_1_slRdBufPtr[I2C_1_slRdBufIndex];
                                                  I2C_1_ACK_AND_TRANSMIT;
                                                  I2C_1_slRdBufIndex++;
              
                                                  I2C_1_slStatus |= I2C_1_SSTAT_RD_BUSY;
                                              }
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 7   

                                              else    /* Overflow: provide 0xFF on the bus */
                                              {
                                                  I2C_1_DATA_REG = I2C_1_OVERFLOW_RETURN;
                                                  I2C_1_ACK_AND_TRANSMIT;
              
                                                  I2C_1_slStatus  |= (I2C_1_SSTAT_RD_BUSY |
                                                                                 I2C_1_SSTAT_RD_ERR_OVFL);
                                              }
              
                                              I2C_1_state = I2C_1_SM_SL_RD_DATA;
                                          }
                                          else  /* Write transaction: receive 1st byte */
                                          {
                                              I2C_1_ACK_AND_RECEIVE;
                                              I2C_1_state = I2C_1_SM_SL_WR_DATA;
              
                                              I2C_1_slStatus |= I2C_1_SSTAT_WR_BUSY;
                                              I2C_1_ENABLE_INT_ON_STOP;
                                          }
                                      }    
                                      else
                                      {
                                          /*     Place code to compare for additional address here    */
                                          /* `#START I2C_1_SW_ADDR_COMPARE_interruptStart` */
              
                                          /* `#END` */
                                          
                                          I2C_1_NAK_AND_RECEIVE;   /* NACK address */
              
                                          /* Place code to end of condition for NACK generation here */
                                          /* `#START I2C_1_SW_ADDR_COMPARE_interruptEnd`  */
              
                                          /* `#END` */
                                      }
                                      
                                  #else /* (I2C_1_HW_ADRR_DECODE) */
                                      
                                      if(0u != (I2C_1_DATA_REG & I2C_1_READ_FLAG))
                                      {
                                          /* Place code to prepare read buffer here                  */
                                          /* `#START I2C_1_HW_PREPARE_READ_BUF_interrupt` */
              
                                          /* `#END` */
              
                                          /* Prepare next opeation to read, get data and place in data register */
                                          if(I2C_1_slRdBufIndex < I2C_1_slRdBufSize)
                                          {
                                              /* Load first data byte from array */
                                              I2C_1_DATA_REG = I2C_1_slRdBufPtr[I2C_1_slRdBufIndex];
                                              I2C_1_ACK_AND_TRANSMIT;
                                              I2C_1_slRdBufIndex++;
              
                                              I2C_1_slStatus |= I2C_1_SSTAT_RD_BUSY;
                                          }
                                          else    /* Overflow: provide 0xFF on the bus */
                                          {
                                              I2C_1_DATA_REG = I2C_1_OVERFLOW_RETURN;
                                              I2C_1_ACK_AND_TRANSMIT;
              
                                              I2C_1_slStatus  |= (I2C_1_SSTAT_RD_BUSY |
                                                                             I2C_1_SSTAT_RD_ERR_OVFL);
                                          }
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 8   

              
                                          I2C_1_state = I2C_1_SM_SL_RD_DATA;
                                      }
                                      else  /* Write transaction: receive 1st byte */
                                      {
                                          I2C_1_ACK_AND_RECEIVE;
                                          I2C_1_state = I2C_1_SM_SL_WR_DATA;
              
                                          I2C_1_slStatus |= I2C_1_SSTAT_WR_BUSY;
                                          I2C_1_ENABLE_INT_ON_STOP;
                                      }
                                      
                                  #endif /* (I2C_1_SW_ADRR_DECODE) */
                              }
                              /* Data states */
                              /* Data master writes into slave */
                              else if(I2C_1_state == I2C_1_SM_SL_WR_DATA)
                              {
                                  if(I2C_1_slWrBufIndex < I2C_1_slWrBufSize)
                                  {
                                      tmp8 = I2C_1_DATA_REG;
                                      I2C_1_ACK_AND_RECEIVE;
                                      I2C_1_slWrBufPtr[I2C_1_slWrBufIndex] = tmp8;
                                      I2C_1_slWrBufIndex++;
                                  }
                                  else  /* of array: complete write, send NACK */
                                  {
                                      I2C_1_NAK_AND_RECEIVE;
              
                                      I2C_1_slStatus |= I2C_1_SSTAT_WR_ERR_OVFL;
                                  }
                              }
                              /* Data master reads from slave */
                              else if(I2C_1_state == I2C_1_SM_SL_RD_DATA)
                              {
                                  if(I2C_1_CHECK_DATA_ACK(tmpCsr))
                                  {
                                      if(I2C_1_slRdBufIndex < I2C_1_slRdBufSize)
                                      {
                                           /* Get data from array */
                                          I2C_1_DATA_REG = I2C_1_slRdBufPtr[I2C_1_slRdBufIndex];
                                          I2C_1_TRANSMIT_DATA;
                                          I2C_1_slRdBufIndex++;
                                      }
                                      else   /* Overflow: provide 0xFF on the bus */
                                      {
                                          I2C_1_DATA_REG = I2C_1_OVERFLOW_RETURN;
                                          I2C_1_TRANSMIT_DATA;
              
                                          I2C_1_slStatus |= I2C_1_SSTAT_RD_ERR_OVFL;
                                      }
                                  }
                                  else  /* Last byte was NACKed: read complete */
                                  {
                                      /* Only NACK appears on the bus */
                                      I2C_1_DATA_REG = I2C_1_OVERFLOW_RETURN;
                                      I2C_1_NAK_AND_TRANSMIT;
              
                                      I2C_1_slStatus &= ((uint8) ~I2C_1_SSTAT_RD_BUSY);
                                      I2C_1_slStatus |= ((uint8)  I2C_1_SSTAT_RD_CMPLT);
              
                                      I2C_1_state = I2C_1_SM_IDLE;
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 9   

                                  }
                              }
                              else
                              {
                                  #if(I2C_1_TIMEOUT_ENABLED)
                                      /* Exit from interrupt to take a chance for timeout timer handle this case */
                                      I2C_1_DisableInt();
                                      I2C_1_ClearPendingInt();
                                  #else
                                      /* Block execution flow: unexpected condition */
                                      CYASSERT(0u != 0u);
                                  #endif /* (I2C_1_TIMEOUT_ENABLED) */
                              }
                          }
                      #endif /* (I2C_1_MODE_SLAVE_ENABLED) */
 502   2          }
 503   1          else
 504   1          {
 505   2              /* The FSM skips master and slave processing: return to IDLE */
 506   2              I2C_1_state = I2C_1_SM_IDLE;
 507   2          }
 508   1      }
 509          
 510          
 511          #if((I2C_1_FF_IMPLEMENTED) && (I2C_1_WAKEUP_ENABLED))
                  /*******************************************************************************
                  * Function Name: I2C_1_WAKEUP_ISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Empty interrupt handler to trigger after wakeup.
                  *
                  * Parameters:
                  *  void
                  *
                  * Return:
                  *  void
                  *
                  *******************************************************************************/
                  CY_ISR(I2C_1_WAKEUP_ISR)
                  {
                      I2C_1_wakeupSource = 1u;  /* I2C was wakeup source */
                      /* The SCL is stretched unitl the I2C_Wake() is called */
                  }
              #endif /* ((I2C_1_FF_IMPLEMENTED) && (I2C_1_WAKEUP_ENABLED))*/
 532          
 533          
 534          /* [] END OF FILE */
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 10  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION I2C_1_ISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 46
                                           ; SOURCE LINE # 64
002B 9049D7            MOV     DPTR,#049D7H
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#tmpCsr
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
0035 900000      E     MOV     DPTR,#I2C_1_state
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A EF                MOV     A,R7
003B 5440              ANL     A,#040H
003D FF                MOV     R7,A
003E 7E00              MOV     R6,#00H
0040 EF                MOV     A,R7
0041 4E                ORL     A,R6
0042 7003              JNZ     $ + 5H
0044 020000      R     LJMP    ?C0001
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 116
0047 900000      R     MOV     DPTR,#tmpCsr
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 5401              ANL     A,#01H
004F FF                MOV     R7,A
0050 7E00              MOV     R6,#00H
0052 EF                MOV     A,R7
0053 4E                ORL     A,R6
0054 7003              JNZ     $ + 5H
0056 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 117
                                           ; SOURCE LINE # 118
0059 900000      E     MOV     DPTR,#I2C_1_state
005C E0                MOVX    A,@DPTR
005D FF                MOV     R7,A
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 11  

005E EF                MOV     A,R7
005F 120000      E     LCALL   ?C?CCASE
0062 0000        R     DW      ?C0005
0064 45                DB      045H
0065 0000        R     DW      ?C0039
0067 46                DB      046H
0068 0000        R     DW      ?C0005
006A 49                DB      049H
006B 0000        R     DW      ?C0063
006D 4A                DB      04AH
006E 0000              DW      00H
0070 0000        R     DW      ?C0077
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 120
                                           ; SOURCE LINE # 121
0072         ?C0005:
                                           ; SOURCE LINE # 123
0072 900000      R     MOV     DPTR,#tmpCsr
0075 E0                MOVX    A,@DPTR
0076 FF                MOV     R7,A
0077 EF                MOV     A,R7
0078 54DF              ANL     A,#0DFH
007A FF                MOV     R7,A
007B 900000      R     MOV     DPTR,#tmpCsr
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 125
0080 900000      R     MOV     DPTR,#tmpCsr
0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 EF                MOV     A,R7
0086 540A              ANL     A,#0AH
0088 FF                MOV     R7,A
0089 7E00              MOV     R6,#00H
008B EF                MOV     A,R7
008C 6408              XRL     A,#08H
008E 4E                ORL     A,R6
008F 6003              JZ      $ + 5H
0091 020000      R     LJMP    ?C0006
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 128
0094 900000      E     MOV     DPTR,#I2C_1_state
0097 E0                MOVX    A,@DPTR
0098 FF                MOV     R7,A
0099 EF                MOV     A,R7
009A 6445              XRL     A,#045H
009C 7075              JNZ     ?C0024
                                           ; SOURCE LINE # 129
                                           ; SOURCE LINE # 131
009E 900000      E     MOV     DPTR,#I2C_1_mstrWrBufSize
00A1 E0                MOVX    A,@DPTR
00A2 FF                MOV     R7,A
00A3 EF                MOV     A,R7
00A4 D3                SETB    C
00A5 9400              SUBB    A,#00H
00A7 4024              JC      ?C0008
                                           ; SOURCE LINE # 132
                                           ; SOURCE LINE # 134
00A9 900000      E     MOV     DPTR,#I2C_1_mstrWrBufPtr
00AC 120000      E     LCALL   ?C?PLDXDATA
00AF 120000      E     LCALL   ?C?CLDPTR
00B2 FF                MOV     R7,A
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 12  

00B3 9049D8            MOV     DPTR,#049D8H
00B6 EF                MOV     A,R7
00B7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 135
00B8 9049D7            MOV     DPTR,#049D7H
00BB 7404              MOV     A,#04H
00BD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
00BE 900000      E     MOV     DPTR,#I2C_1_mstrWrBufIndex
00C1 7401              MOV     A,#01H
00C3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
00C4 900000      E     MOV     DPTR,#I2C_1_state
00C7 7446              MOV     A,#046H
00C9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 140
00CA 020000      R     LJMP    ?C0002
00CD         ?C0008:
                                           ; SOURCE LINE # 142
00CD 900000      E     MOV     DPTR,#I2C_1_mstrControl
00D0 E0                MOVX    A,@DPTR
00D1 FF                MOV     R7,A
00D2 EF                MOV     A,R7
00D3 5402              ANL     A,#02H
00D5 FF                MOV     R7,A
00D6 7E00              MOV     R6,#00H
00D8 EF                MOV     A,R7
00D9 4E                ORL     A,R6
00DA 601D              JZ      ?C0017
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 151
00DC 900000      E     MOV     DPTR,#I2C_1_mstrStatus
00DF E0                MOVX    A,@DPTR
00E0 FF                MOV     R7,A
00E1 EF                MOV     A,R7
00E2 440A              ORL     A,#0AH
00E4 FF                MOV     R7,A
00E5 900000      E     MOV     DPTR,#I2C_1_mstrStatus
00E8 EF                MOV     A,R7
00E9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
00EA 900000      E     MOV     DPTR,#I2C_1_state
00ED 7460              MOV     A,#060H
00EF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 155
00F0 9044C9            MOV     DPTR,#044C9H
00F3 7480              MOV     A,#080H
00F5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 158
00F6 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 160
00F9         ?C0017:
                                           ; SOURCE LINE # 161
00F9 9049D6            MOV     DPTR,#049D6H
00FC E0                MOVX    A,@DPTR
00FD FF                MOV     R7,A
00FE EF                MOV     A,R7
00FF 4410              ORL     A,#010H
0101 FF                MOV     R7,A
0102 EF                MOV     A,R7
0103 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 13  

0104 9049D9            MOV     DPTR,#049D9H
0107 7410              MOV     A,#010H
0109 F0                MOVX    @DPTR,A
010A 9049D7            MOV     DPTR,#049D7H
010D 7404              MOV     A,#04H
010F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
0110 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 166
0113         ?C0024:
                                           ; SOURCE LINE # 167
0113 9049D7            MOV     DPTR,#049D7H
0116 E4                CLR     A
0117 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 169
0118 900000      E     MOV     DPTR,#I2C_1_state
011B 744A              MOV     A,#04AH
011D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 170
                                           ; SOURCE LINE # 171
011E 020000      R     LJMP    ?C0002
0121         ?C0006:
                                           ; SOURCE LINE # 173
0121 900000      R     MOV     DPTR,#tmpCsr
0124 E0                MOVX    A,@DPTR
0125 FF                MOV     R7,A
0126 EF                MOV     A,R7
0127 540A              ANL     A,#0AH
0129 FF                MOV     R7,A
012A 7E00              MOV     R6,#00H
012C EF                MOV     A,R7
012D 640A              XRL     A,#0AH
012F 4E                ORL     A,R6
0130 706E              JNZ     ?C0026
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 176
0132 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0135 E0                MOVX    A,@DPTR
0136 FF                MOV     R7,A
0137 EF                MOV     A,R7
0138 44A0              ORL     A,#0A0H
013A FF                MOV     R7,A
013B 900000      E     MOV     DPTR,#I2C_1_mstrStatus
013E EF                MOV     A,R7
013F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 179
0140 900000      E     MOV     DPTR,#I2C_1_mstrControl
0143 E0                MOVX    A,@DPTR
0144 FF                MOV     R7,A
0145 EF                MOV     A,R7
0146 5402              ANL     A,#02H
0148 FF                MOV     R7,A
0149 7E00              MOV     R6,#00H
014B EF                MOV     A,R7
014C 4E                ORL     A,R6
014D 6037              JZ      ?C0033
                                           ; SOURCE LINE # 180
                                           ; SOURCE LINE # 181
014F 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0152 E0                MOVX    A,@DPTR
0153 FF                MOV     R7,A
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 14  

0154 900000      E     MOV     DPTR,#I2C_1_state
0157 E0                MOVX    A,@DPTR
0158 FE                MOV     R6,A
0159 EE                MOV     A,R6
015A 5408              ANL     A,#08H
015C FE                MOV     R6,A
015D EE                MOV     A,R6
015E FD                MOV     R5,A
015F 7C00              MOV     R4,#00H
0161 ED                MOV     A,R5
0162 4C                ORL     A,R4
0163 6004              JZ      ?C0028
0165 7E01              MOV     R6,#01H
0167 8002              SJMP    ?C0029
0169         ?C0028:
0169 7E02              MOV     R6,#02H
016B         ?C0029:
016B EE                MOV     A,R6
016C 4408              ORL     A,#08H
016E FE                MOV     R6,A
016F EF                MOV     A,R7
0170 4E                ORL     A,R6
0171 FF                MOV     R7,A
0172 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0175 EF                MOV     A,R7
0176 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 184
0177 900000      E     MOV     DPTR,#I2C_1_state
017A 7460              MOV     A,#060H
017C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 185
017D 9044C9            MOV     DPTR,#044C9H
0180 7480              MOV     A,#080H
0182 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
0183 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 188
0186         ?C0033:
                                           ; SOURCE LINE # 189
0186 9049D6            MOV     DPTR,#049D6H
0189 E0                MOVX    A,@DPTR
018A FF                MOV     R7,A
018B EF                MOV     A,R7
018C 4410              ORL     A,#010H
018E FF                MOV     R7,A
018F EF                MOV     A,R7
0190 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 190
0191 9049D9            MOV     DPTR,#049D9H
0194 7410              MOV     A,#010H
0196 F0                MOVX    @DPTR,A
0197 9049D7            MOV     DPTR,#049D7H
019A 7404              MOV     A,#04H
019C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
019D 020000      R     LJMP    ?C0002
01A0         ?C0026:
                                           ; SOURCE LINE # 194
                                           ; SOURCE LINE # 202
01A0 7F00              MOV     R7,#00H
01A2 120000      E     LCALL   _?CyHalt
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 15  

                                           ; SOURCE LINE # 204
                                           ; SOURCE LINE # 205
01A5 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 207
01A8         ?C0039:
                                           ; SOURCE LINE # 209
01A8 900000      R     MOV     DPTR,#tmpCsr
01AB E0                MOVX    A,@DPTR
01AC FF                MOV     R7,A
01AD EF                MOV     A,R7
01AE 5402              ANL     A,#02H
01B0 FF                MOV     R7,A
01B1 7E00              MOV     R6,#00H
01B3 EF                MOV     A,R7
01B4 4E                ORL     A,R6
01B5 6003              JZ      $ + 5H
01B7 020000      R     LJMP    ?C0040
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 212
01BA 900000      E     MOV     DPTR,#I2C_1_mstrWrBufSize
01BD E0                MOVX    A,@DPTR
01BE FF                MOV     R7,A
01BF 900000      E     MOV     DPTR,#I2C_1_mstrWrBufIndex
01C2 E0                MOVX    A,@DPTR
01C3 FE                MOV     R6,A
01C4 EE                MOV     A,R6
01C5 C3                CLR     C
01C6 9F                SUBB    A,R7
01C7 5029              JNC     ?C0041
                                           ; SOURCE LINE # 213
                                           ; SOURCE LINE # 214
01C9 900000      E     MOV     DPTR,#I2C_1_mstrWrBufPtr
01CC 120000      E     LCALL   ?C?PLDXDATA
01CF 900000      E     MOV     DPTR,#I2C_1_mstrWrBufIndex
01D2 E0                MOVX    A,@DPTR
01D3 FF                MOV     R7,A
01D4 E9                MOV     A,R1
01D5 2F                ADD     A,R7
01D6 F9                MOV     R1,A
01D7 E4                CLR     A
01D8 3A                ADDC    A,R2
01D9 FA                MOV     R2,A
01DA 120000      E     LCALL   ?C?CLDPTR
01DD FF                MOV     R7,A
01DE 9049D8            MOV     DPTR,#049D8H
01E1 EF                MOV     A,R7
01E2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 216
01E3 9049D7            MOV     DPTR,#049D7H
01E6 7404              MOV     A,#04H
01E8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 217
01E9 900000      E     MOV     DPTR,#I2C_1_mstrWrBufIndex
01EC E0                MOVX    A,@DPTR
01ED 04                INC     A
01EE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 218
01EF 020000      R     LJMP    ?C0002
01F2         ?C0041:
                                           ; SOURCE LINE # 220
01F2 900000      E     MOV     DPTR,#I2C_1_mstrControl
01F5 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 16  

01F6 FF                MOV     R7,A
01F7 EF                MOV     A,R7
01F8 5402              ANL     A,#02H
01FA FF                MOV     R7,A
01FB 7E00              MOV     R6,#00H
01FD EF                MOV     A,R7
01FE 4E                ORL     A,R6
01FF 601D              JZ      ?C0046
                                           ; SOURCE LINE # 221
                                           ; SOURCE LINE # 223
0201 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0204 E0                MOVX    A,@DPTR
0205 FF                MOV     R7,A
0206 EF                MOV     A,R7
0207 440A              ORL     A,#0AH
0209 FF                MOV     R7,A
020A 900000      E     MOV     DPTR,#I2C_1_mstrStatus
020D EF                MOV     A,R7
020E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 226
020F 900000      E     MOV     DPTR,#I2C_1_state
0212 7460              MOV     A,#060H
0214 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 227
0215 9044C9            MOV     DPTR,#044C9H
0218 7480              MOV     A,#080H
021A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 228
021B 020000      R     LJMP    ?C0002
021E         ?C0046:
                                           ; SOURCE LINE # 230
                                           ; SOURCE LINE # 231
021E 120000      E     LCALL   I2C_1_Workaround
                                           ; SOURCE LINE # 232
0221 9049D6            MOV     DPTR,#049D6H
0224 E0                MOVX    A,@DPTR
0225 FF                MOV     R7,A
0226 EF                MOV     A,R7
0227 4410              ORL     A,#010H
0229 FF                MOV     R7,A
022A EF                MOV     A,R7
022B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 233
022C 9049D9            MOV     DPTR,#049D9H
022F 7410              MOV     A,#010H
0231 F0                MOVX    @DPTR,A
0232 9049D7            MOV     DPTR,#049D7H
0235 7404              MOV     A,#04H
0237 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
                                           ; SOURCE LINE # 235
0238 020000      R     LJMP    ?C0002
023B         ?C0040:
                                           ; SOURCE LINE # 237
023B 900000      E     MOV     DPTR,#I2C_1_mstrControl
023E E0                MOVX    A,@DPTR
023F FF                MOV     R7,A
0240 EF                MOV     A,R7
0241 5402              ANL     A,#02H
0243 FF                MOV     R7,A
0244 7E00              MOV     R6,#00H
0246 EF                MOV     A,R7
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 17  

0247 4E                ORL     A,R6
0248 601D              JZ      ?C0059
                                           ; SOURCE LINE # 238
                                           ; SOURCE LINE # 240
024A 900000      E     MOV     DPTR,#I2C_1_mstrStatus
024D E0                MOVX    A,@DPTR
024E FF                MOV     R7,A
024F EF                MOV     A,R7
0250 449A              ORL     A,#09AH
0252 FF                MOV     R7,A
0253 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0256 EF                MOV     A,R7
0257 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 245
0258 900000      E     MOV     DPTR,#I2C_1_state
025B 7460              MOV     A,#060H
025D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 246
025E 9044C9            MOV     DPTR,#044C9H
0261 7480              MOV     A,#080H
0263 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 247
0264 020000      R     LJMP    ?C0002
                                           ; SOURCE LINE # 249
0267         ?C0059:
                                           ; SOURCE LINE # 250
0267 9049D6            MOV     DPTR,#049D6H
026A E0                MOVX    A,@DPTR
026B FF                MOV     R7,A
026C EF                MOV     A,R7
026D 4410              ORL     A,#010H
026F FF                MOV     R7,A
0270 EF                MOV     A,R7
0271 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 251
0272 9049D9            MOV     DPTR,#049D9H
0275 7410              MOV     A,#010H
0277 F0                MOVX    @DPTR,A
0278 9049D7            MOV     DPTR,#049D7H
027B 7404              MOV     A,#04H
027D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
027E 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0281 E0                MOVX    A,@DPTR
0282 FF                MOV     R7,A
0283 EF                MOV     A,R7
0284 4490              ORL     A,#090H
0286 FF                MOV     R7,A
0287 900000      E     MOV     DPTR,#I2C_1_mstrStatus
028A EF                MOV     A,R7
028B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 258
028C 8079              SJMP    ?C0002
                                           ; SOURCE LINE # 260
028E         ?C0063:
                                           ; SOURCE LINE # 262
028E 9049D8            MOV     DPTR,#049D8H
0291 E0                MOVX    A,@DPTR
0292 FF                MOV     R7,A
0293 900000      E     MOV     DPTR,#I2C_1_mstrRdBufPtr
0296 120000      E     LCALL   ?C?PLDXDATA
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 18  

0299 900000      E     MOV     DPTR,#I2C_1_mstrRdBufIndex
029C E0                MOVX    A,@DPTR
029D FE                MOV     R6,A
029E E9                MOV     A,R1
029F 2E                ADD     A,R6
02A0 F9                MOV     R1,A
02A1 E4                CLR     A
02A2 3A                ADDC    A,R2
02A3 FA                MOV     R2,A
02A4 EF                MOV     A,R7
02A5 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 263
02A8 900000      E     MOV     DPTR,#I2C_1_mstrRdBufIndex
02AB E0                MOVX    A,@DPTR
02AC 04                INC     A
02AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 266
02AE 900000      E     MOV     DPTR,#I2C_1_mstrRdBufSize
02B1 E0                MOVX    A,@DPTR
02B2 FF                MOV     R7,A
02B3 900000      E     MOV     DPTR,#I2C_1_mstrRdBufIndex
02B6 E0                MOVX    A,@DPTR
02B7 FE                MOV     R6,A
02B8 EE                MOV     A,R6
02B9 C3                CLR     C
02BA 9F                SUBB    A,R7
02BB 5008              JNC     ?C0064
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
02BD 9049D7            MOV     DPTR,#049D7H
02C0 7410              MOV     A,#010H
02C2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 269
02C3 8042              SJMP    ?C0002
02C5         ?C0064:
                                           ; SOURCE LINE # 271
02C5 900000      E     MOV     DPTR,#I2C_1_mstrControl
02C8 E0                MOVX    A,@DPTR
02C9 FF                MOV     R7,A
02CA EF                MOV     A,R7
02CB 5402              ANL     A,#02H
02CD FF                MOV     R7,A
02CE 7E00              MOV     R6,#00H
02D0 EF                MOV     A,R7
02D1 4E                ORL     A,R6
02D2 601C              JZ      ?C0073
                                           ; SOURCE LINE # 272
                                           ; SOURCE LINE # 274
02D4 900000      E     MOV     DPTR,#I2C_1_mstrStatus
02D7 E0                MOVX    A,@DPTR
02D8 FF                MOV     R7,A
02D9 EF                MOV     A,R7
02DA 4409              ORL     A,#09H
02DC FF                MOV     R7,A
02DD 900000      E     MOV     DPTR,#I2C_1_mstrStatus
02E0 EF                MOV     A,R7
02E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
02E2 900000      E     MOV     DPTR,#I2C_1_state
02E5 7460              MOV     A,#060H
02E7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 278
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 19  

02E8 9044C9            MOV     DPTR,#044C9H
02EB 7480              MOV     A,#080H
02ED F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 279
02EE 8017              SJMP    ?C0002
                                           ; SOURCE LINE # 281
02F0         ?C0073:
                                           ; SOURCE LINE # 282
02F0 9049D6            MOV     DPTR,#049D6H
02F3 E0                MOVX    A,@DPTR
02F4 FF                MOV     R7,A
02F5 EF                MOV     A,R7
02F6 4410              ORL     A,#010H
02F8 FF                MOV     R7,A
02F9 EF                MOV     A,R7
02FA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 283
02FB 9049D7            MOV     DPTR,#049D7H
02FE E4                CLR     A
02FF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 284
                                           ; SOURCE LINE # 285
0300 8005              SJMP    ?C0002
                                           ; SOURCE LINE # 287
0302         ?C0077:
                                           ; SOURCE LINE # 295
0302 7F00              MOV     R7,#00H
0304 120000      E     LCALL   _?CyHalt
                                           ; SOURCE LINE # 298
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
0307         ?C0002:
                                           ; SOURCE LINE # 303
0307 900000      R     MOV     DPTR,#tmpCsr
030A E0                MOVX    A,@DPTR
030B FF                MOV     R7,A
030C EF                MOV     A,R7
030D 5420              ANL     A,#020H
030F FF                MOV     R7,A
0310 7E00              MOV     R6,#00H
0312 EF                MOV     A,R7
0313 4E                ORL     A,R6
0314 604C              JZ      ?C0088
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 305
0316 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0319 E0                MOVX    A,@DPTR
031A FF                MOV     R7,A
031B 900000      E     MOV     DPTR,#I2C_1_state
031E E0                MOVX    A,@DPTR
031F FE                MOV     R6,A
0320 EE                MOV     A,R6
0321 5408              ANL     A,#08H
0323 FE                MOV     R6,A
0324 EE                MOV     A,R6
0325 FD                MOV     R5,A
0326 7C00              MOV     R4,#00H
0328 ED                MOV     A,R5
0329 4C                ORL     A,R4
032A 6004              JZ      ?C0080
032C 7E01              MOV     R6,#01H
032E 8002              SJMP    ?C0081
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 20  

0330         ?C0080:
0330 7E02              MOV     R6,#02H
0332         ?C0081:
0332 EF                MOV     A,R7
0333 4E                ORL     A,R6
0334 FF                MOV     R7,A
0335 900000      E     MOV     DPTR,#I2C_1_mstrStatus
0338 EF                MOV     A,R7
0339 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 307
033A 9049D6            MOV     DPTR,#049D6H
033D E0                MOVX    A,@DPTR
033E FF                MOV     R7,A
033F EF                MOV     A,R7
0340 54EF              ANL     A,#0EFH
0342 FF                MOV     R7,A
0343 EF                MOV     A,R7
0344 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
0345 900000      E     MOV     DPTR,#I2C_1_state
0348 7410              MOV     A,#010H
034A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 311
034B 8015              SJMP    ?C0088
034D         ?C0001:
                                           ; SOURCE LINE # 312
034D 900000      E     MOV     DPTR,#I2C_1_state
0350 E0                MOVX    A,@DPTR
0351 FF                MOV     R7,A
0352 EF                MOV     A,R7
0353 5410              ANL     A,#010H
0355 FF                MOV     R7,A
0356 7E00              MOV     R6,#00H
0358 EF                MOV     A,R7
0359 4E                ORL     A,R6
035A 7006              JNZ     ?C0088
                                           ; SOURCE LINE # 313
                                           ; SOURCE LINE # 502
035C         ?C0086:
                                           ; SOURCE LINE # 504
                                           ; SOURCE LINE # 506
035C 900000      E     MOV     DPTR,#I2C_1_state
035F 7410              MOV     A,#010H
0361 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 507
                                           ; SOURCE LINE # 508
0362         ?C0088:
0362 D007              POP     AR7
0364 D006              POP     AR6
0366 D005              POP     AR5
0368 D004              POP     AR4
036A D003              POP     AR3
036C D002              POP     AR2
036E D001              POP     AR1
0370 D000              POP     AR0
0372 D0D0              POP     PSW
0374 D000        E     POP     ?C?XPAGE1SFR
0376 D086              POP     DPS
0378 D084              POP     DPL1
037A D085              POP     DPH1
037C D082              POP     DPL
C51 COMPILER V9.03   I2C_1_INT                                                             08/11/2013 22:22:05 PAGE 21  

037E D083              POP     DPH
0380 D0F0              POP     B
0382 D0E0              POP     ACC
0384 32                RETI    
             ; FUNCTION I2C_1_ISR (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    901    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
