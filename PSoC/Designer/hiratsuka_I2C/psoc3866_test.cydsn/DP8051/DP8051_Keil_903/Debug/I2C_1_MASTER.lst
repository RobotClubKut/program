C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE I2C_1_MASTER
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_903\Debug\I2C_1_MASTER.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\2.2\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\I2C_1_MASTER.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_903\Debug\I2C_1_MASTER.lst) CD DB
                    - NOIP OT(2,SIZE) DF(DEBUG) INCDIR(Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_903\Debug\I2C_1_MASTER.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: I2C_1_MASTER.c
   3          * Version 3.30
   4          *
   5          * Description:
   6          *  This file provides the source code of APIs for the I2C component Master mode.
   7          *
   8          * Note:
   9          *
  10          *******************************************************************************
  11          * Copyright 2012, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "I2C_1_PVT.h"
  18          
  19          #if(I2C_1_MODE_MASTER_ENABLED)
  20          
  21          /**********************************
  22          *      System variables
  23          **********************************/
  24          
  25          volatile uint8 I2C_1_mstrStatus;     /* Master Status byte  */
  26          volatile uint8 I2C_1_mstrControl;    /* Master Control byte */
  27          
  28          /* Transmit buffer variables */
  29          volatile uint8 * I2C_1_mstrRdBufPtr;     /* Pointer to Master Read buffer */
  30          volatile uint8   I2C_1_mstrRdBufSize;    /* Master Read buffer size       */
  31          volatile uint8   I2C_1_mstrRdBufIndex;   /* Master Read buffer Index      */
  32          
  33          /* Receive buffer variables */
  34          volatile uint8 * I2C_1_mstrWrBufPtr;     /* Pointer to Master Write buffer */
  35          volatile uint8   I2C_1_mstrWrBufSize;    /* Master Write buffer size       */
  36          volatile uint8   I2C_1_mstrWrBufIndex;   /* Master Write buffer Index      */
  37          
  38          
  39          /*******************************************************************************
  40          * Function Name: I2C_1_MasterWriteBuf
  41          ********************************************************************************
  42          *
  43          * Summary:
  44          *  Automatically writes an entire buffer of data to a slave device. Once the
  45          *  data transfer is initiated by this function, further data transfer is handled
  46          *  by the included ISR in byte by byte mode.
  47          *
  48          * Parameters:
  49          *  slaveAddr: 7-bit slave address.
  50          *  xferData:  Pointer to buffer of data to be sent.
  51          *  cnt:       Size of buffer to send.
  52          *  mode:      Transfer mode defines: start or restart condition generation at
  53          *             begin of the transfer and complete the transfer or halt before
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 2   

  54          *             generating a stop.
  55          *
  56          * Return:
  57          *  Status error - zero means no errors.
  58          *
  59          * Side Effects:
  60          *  The included ISR will start transfer after start or restart condition will
  61          *  be generated.
  62          *
  63          * Global variables:
  64          *  I2C_1_mstrStatus  - used to store current status of I2C Master.
  65          *  I2C_1_state       - used to store current state of software FSM.
  66          *  I2C_1_mstrControl - used to control master end of transaction with
  67          *  or without the Stop generation.
  68          *  I2C_1_mstrWrBufPtr - used to store pointer to master write buffer.
  69          *  I2C_1_mstrWrBufIndex - used to current index within master write
  70          *  buffer.
  71          *  I2C_1_mstrWrBufSize - used to store master write buffer size.
  72          *
  73          * Reentrant:
  74          *  No
  75          *
  76          *******************************************************************************/
  77          uint8 I2C_1_MasterWriteBuf(uint8 slaveAddress, uint8 * wrData, uint8 cnt, uint8 mode)
  78                
  79          {
  80   1          uint8 errStatus;
  81   1      
  82   1          errStatus = I2C_1_MSTR_NOT_READY;
  83   1      
  84   1          if(NULL != wrData)
  85   1          {
  86   2              /* Check I2C state before transfer: valid are IDLE or HALT */
  87   2              if(I2C_1_SM_IDLE == I2C_1_state)
  88   2              {
  89   3                  /* Check if free: Master is ready to transaction */
  90   3                  if(I2C_1_CHECK_BUS_FREE(I2C_1_MCSR_REG))
  91   3                  {
  92   4                      errStatus = I2C_1_MSTR_NO_ERROR;
  93   4                  }
  94   3                  else
  95   3                  {
  96   4                      errStatus = I2C_1_MSTR_BUS_BUSY;
  97   4                  }
  98   3              }
  99   2              else if(I2C_1_SM_MSTR_HALT == I2C_1_state)
 100   2              {
 101   3                  errStatus = I2C_1_MSTR_NO_ERROR;
 102   3      
 103   3                  CyIntClearPending(I2C_1_ISR_NUMBER);
 104   3                  I2C_1_mstrStatus &= ((uint8) ~I2C_1_MSTAT_XFER_HALT);
 105   3              }
 106   2              else
 107   2              {
 108   3                  /* errStatus = I2C_1_MSTR_NOT_READY was send before */
 109   3              }
 110   2      
 111   2              if(I2C_1_MSTR_NO_ERROR == errStatus)
 112   2              {
 113   3                  I2C_1_state    = I2C_1_SM_MSTR_WR_ADDR;
 114   3                  I2C_1_DATA_REG = ((uint8) (slaveAddress << I2C_1_SLAVE_ADDR_SHIFT));
 115   3      
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 3   

 116   3                  I2C_1_mstrWrBufIndex = 0u;
 117   3                  I2C_1_mstrWrBufSize  = cnt;
 118   3                  I2C_1_mstrWrBufPtr   = (volatile uint8 *) wrData;
 119   3      
 120   3                  I2C_1_mstrControl = mode;    /* Save transaction mode */
 121   3      
 122   3                  /* Generate a Start or ReStart depends on mode */
 123   3                  if(I2C_1_CHECK_RESTART(mode))
 124   3                  {
 125   4                      I2C_1_GENERATE_RESTART;
 126   4                  }
 127   3                  else
 128   3                  {
 129   4                      I2C_1_GENERATE_START;
 130   4                  }
 131   3      
 132   3                  I2C_1_mstrStatus &= ((uint8) ~I2C_1_MSTAT_WR_CMPLT);
 133   3      
 134   3                  I2C_1_EnableInt();   /* Enable intr to complete transfer */
 135   3              }
 136   2          }
 137   1      
 138   1          return(errStatus);
 139   1      }
 140          
 141          
 142          /*******************************************************************************
 143          * Function Name: I2C_1_MasterReadBuf
 144          ********************************************************************************
 145          *
 146          * Summary:
 147          *  Automatically writes an entire buffer of data to a slave device. Once the
 148          *  data transfer is initiated by this function, further data transfer is handled
 149          *  by the included ISR in byte by byte mode.
 150          *
 151          * Parameters:
 152          *  slaveAddr: 7-bit slave address.
 153          *  xferData:  Pointer to buffer where to put data from slave.
 154          *  cnt:       Size of buffer to read.
 155          *  mode:      Transfer mode defines: start or restart condition generation at
 156          *             begin of the transfer and complete the transfer or halt before
 157          *             generating a stop.
 158          *
 159          * Return:
 160          *  Status error - zero means no errors.
 161          *
 162          * Side Effects:
 163          *  The included ISR will start transfer after start or restart condition will
 164          *  be generated.
 165          *
 166          * Global variables:
 167          *  I2C_1_mstrStatus  - used to store current status of I2C Master.
 168          *  I2C_1_state       - used to store current state of software FSM.
 169          *  I2C_1_mstrControl - used to control master end of transaction with
 170          *  or without the Stop generation.
 171          *  I2C_1_mstrRdBufPtr - used to store pointer to master write buffer.
 172          *  I2C_1_mstrRdBufIndex - used to current index within master write
 173          *  buffer.
 174          *  I2C_1_mstrRdBufSize - used to store master write buffer size.
 175          *
 176          * Reentrant:
 177          *  No
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 4   

 178          *
 179          *******************************************************************************/
 180          uint8 I2C_1_MasterReadBuf(uint8 slaveAddress, uint8 * rdData, uint8 cnt, uint8 mode)
 181                
 182          {
 183   1          uint8 errStatus;
 184   1      
 185   1          errStatus = I2C_1_MSTR_NOT_READY;
 186   1      
 187   1          if(NULL != rdData)
 188   1          {
 189   2              /* Check I2C state before transfer: valid are IDLE or HALT */
 190   2              if(I2C_1_SM_IDLE == I2C_1_state)
 191   2              {
 192   3                  /* Check if free: Master is ready to transaction */
 193   3                  if(I2C_1_CHECK_BUS_FREE(I2C_1_MCSR_REG))
 194   3                  {
 195   4                      errStatus = I2C_1_MSTR_NO_ERROR;
 196   4                  }
 197   3                  else
 198   3                  {
 199   4                      errStatus = I2C_1_MSTR_BUS_BUSY;
 200   4                  }
 201   3              }
 202   2              else if(I2C_1_SM_MSTR_HALT == I2C_1_state)
 203   2              {
 204   3                  errStatus = I2C_1_MSTR_NO_ERROR;
 205   3      
 206   3                  CyIntClearPending(I2C_1_ISR_NUMBER);
 207   3                  I2C_1_mstrStatus &= ((uint8) ~I2C_1_MSTAT_XFER_HALT);
 208   3              }
 209   2              else
 210   2              {
 211   3                  /* errStatus = I2C_1_MSTR_NOT_READY was send before */
 212   3              }
 213   2      
 214   2              if(I2C_1_MSTR_NO_ERROR == errStatus)
 215   2              {
 216   3                  I2C_1_state    = I2C_1_SM_MSTR_RD_ADDR;
 217   3                  I2C_1_DATA_REG = (((uint8) (slaveAddress << I2C_1_SLAVE_ADDR_SHIFT)) |
 218   3                                                         I2C_1_READ_FLAG);
 219   3      
 220   3                  I2C_1_mstrRdBufIndex  = 0u;
 221   3                  I2C_1_mstrRdBufSize   = cnt;
 222   3                  I2C_1_mstrRdBufPtr    = (volatile uint8 *) rdData;
 223   3      
 224   3                  I2C_1_mstrControl = mode;    /* Save transaction mode */
 225   3      
 226   3                  /* Generate a Start or ReStart depends on mode */
 227   3                  if(I2C_1_CHECK_RESTART(mode))
 228   3                  {
 229   4                      I2C_1_GENERATE_RESTART;
 230   4                  }
 231   3                  else
 232   3                  {
 233   4                      I2C_1_GENERATE_START;
 234   4                  }
 235   3      
 236   3                  I2C_1_mstrStatus &= ((uint8) ~I2C_1_MSTAT_RD_CMPLT);
 237   3      
 238   3                  I2C_1_EnableInt();   /* Enable intr to complete transfer */
 239   3              }
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 5   

 240   2          }
 241   1      
 242   1          return(errStatus);
 243   1      }
 244          
 245          
 246          /*******************************************************************************
 247          * Function Name: I2C_1_MasterSendStart
 248          ********************************************************************************
 249          *
 250          * Summary:
 251          *  Generates Start condition and sends slave address with read/write bit.
 252          *
 253          * Parameters:
 254          *  slaveAddress:  7-bit slave address.
 255          *  R_nW:          Zero, send write command, non-zero send read command.
 256          *
 257          * Return:
 258          *  Status error - zero means no errors.
 259          *
 260          * Side Effects:
 261          *  This function is entered without a 'byte complete' bit set in the I2C_CSR
 262          *  register. It does not exit until it will be set.
 263          *
 264          * Global variables:
 265          *  I2C_1_state - used to store current state of software FSM.
 266          *
 267          * Reentrant:
 268          *  No
 269          *
 270          *******************************************************************************/
 271          uint8 I2C_1_MasterSendStart(uint8 slaveAddress, uint8 R_nW)
 272                
 273          {
 274   1          uint8 errStatus;
 275   1      
 276   1          errStatus = I2C_1_MSTR_NOT_READY;
 277   1      
 278   1          /* If IDLE, check if bus is free */
 279   1          if(I2C_1_SM_IDLE == I2C_1_state)
 280   1          {
 281   2              /* If bus is free, generate Start condition */
 282   2              if(I2C_1_CHECK_BUS_FREE(I2C_1_MCSR_REG))
 283   2              {
 284   3                  I2C_1_DisableInt();  /* Disable ISR for Manual functions */
 285   3      
 286   3                  slaveAddress = ((uint8) (slaveAddress << I2C_1_SLAVE_ADDR_SHIFT)); /* Set Address */
 287   3                  if(0u != R_nW)                                      /* Set the Read/Write flag */
 288   3                  {
 289   4                      slaveAddress |= I2C_1_READ_FLAG;
 290   4                      I2C_1_state = I2C_1_SM_MSTR_RD_ADDR;
 291   4                  }
 292   3                  else
 293   3                  {
 294   4                      I2C_1_state = I2C_1_SM_MSTR_WR_ADDR;
 295   4                  }
 296   3                  I2C_1_DATA_REG = slaveAddress;   /* Write address to data reg */
 297   3      
 298   3      
 299   3                  I2C_1_GENERATE_START;
 300   3                  while(I2C_1_WAIT_BYTE_COMPLETE(I2C_1_CSR_REG))
 301   3                  {
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 6   

 302   4                      ; /* Wait for the address to be transfered */
 303   4                  }
 304   3      
 305   3                  #if(I2C_1_MODE_MULTI_MASTER_SLAVE_ENABLED)
                              if(I2C_1_CHECK_START_GEN(I2C_1_MCSR_REG))
                              {
                                  I2C_1_CLEAR_START_GEN;
              
                                  /* Start condition was not generated: reset FSM to IDLE */
                                  I2C_1_state = I2C_1_SM_IDLE;
                                  errStatus = I2C_1_MSTR_ERR_ABORT_START_GEN;
                              }
                              else
                          #endif /* (I2C_1_MODE_MULTI_MASTER_SLAVE_ENABLED) */
 316   3      
 317   3                  #if(I2C_1_MODE_MULTI_MASTER_ENABLED)
              
                              if(I2C_1_CHECK_LOST_ARB(I2C_1_CSR_REG))
                              {
                                  I2C_1_BUS_RELEASE;
              
                                  /* Master lost arbitrage: reset FSM to IDLE */
                                  I2C_1_state = I2C_1_SM_IDLE;
                                  errStatus = I2C_1_MSTR_ERR_ARB_LOST;
                              }
                              else
                          #endif /* (I2C_1_MODE_MULTI_MASTER_ENABLED) */
 329   3      
 330   3                      if(I2C_1_CHECK_ADDR_NAK(I2C_1_CSR_REG))
 331   3                      {
 332   4                          /* Address has been NACKed: reset FSM to IDLE */
 333   4                          I2C_1_state = I2C_1_SM_IDLE;
 334   4                          errStatus = I2C_1_MSTR_ERR_LB_NAK;
 335   4                      }
 336   3                      else
 337   3                      {
 338   4                          /* Start was sent witout errors */
 339   4                          errStatus = I2C_1_MSTR_NO_ERROR;
 340   4                      }
 341   3              }
 342   2              else
 343   2              {
 344   3                  errStatus = I2C_1_MSTR_BUS_BUSY; /* Bus is busy */
 345   3              }
 346   2          }
 347   1      
 348   1          return(errStatus);
 349   1      }
 350          
 351          
 352          /*******************************************************************************
 353          * Function Name: I2C_1_MasterSendRestart
 354          ********************************************************************************
 355          *
 356          * Summary:
 357          *  Generates ReStart condition and sends slave address with read/write bit.
 358          *
 359          * Parameters:
 360          *  slaveAddress:  7-bit slave address.
 361          *  R_nW:          Zero, send write command, non-zero send read command.
 362          *
 363          * Return:
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 7   

 364          *  Status error - zero means no errors.
 365          *
 366          * Side Effects:
 367          *  This function is entered without a 'byte complete' bit set in the I2C_CSR
 368          *  register. It does not exit until it will be set.
 369          *
 370          * Global variables:
 371          *  I2C_1_state - used to store current state of software FSM.
 372          *
 373          * Reentrant:
 374          *  No
 375          *
 376          *******************************************************************************/
 377          uint8 I2C_1_MasterSendRestart(uint8 slaveAddress, uint8 R_nW)
 378                
 379          {
 380   1          uint8 errStatus;
 381   1      
 382   1          errStatus = I2C_1_MSTR_NOT_READY;
 383   1      
 384   1          /* Check if START condition was generated */
 385   1          if(I2C_1_CHECK_MASTER_MODE(I2C_1_MCSR_REG))
 386   1          {
 387   2              slaveAddress = ((uint8) (slaveAddress << I2C_1_SLAVE_ADDR_SHIFT)); /* Set Address */
 388   2              if(0u != R_nW)  /* Set the Read/Write flag */
 389   2              {
 390   3                  slaveAddress |= I2C_1_READ_FLAG;
 391   3                  I2C_1_state = I2C_1_SM_MSTR_RD_ADDR;
 392   3              }
 393   2              else
 394   2              {
 395   3                  I2C_1_state = I2C_1_SM_MSTR_WR_ADDR;
 396   3              }
 397   2              I2C_1_DATA_REG = slaveAddress;    /* Write address to data reg */
 398   2      
 399   2      
 400   2              I2C_1_GENERATE_RESTART_MANUAL;
 401   2              while(I2C_1_WAIT_BYTE_COMPLETE(I2C_1_CSR_REG))
 402   2              {
 403   3                  ; /* Wait for the address to be transfered */
 404   3              }
 405   2      
 406   2              #if(I2C_1_MODE_MULTI_MASTER_ENABLED)
                          if(I2C_1_CHECK_LOST_ARB(I2C_1_CSR_REG))
                          {
                              I2C_1_BUS_RELEASE;
              
                              /* Master lost arbitrage: reset FSM to IDLE */
                              I2C_1_state = I2C_1_SM_IDLE;
                              errStatus = I2C_1_MSTR_ERR_ARB_LOST;
                          }
                          else
                      #endif /* (I2C_1_MODE_MULTI_MASTER_ENABLED) */
 417   2      
 418   2                  if(I2C_1_CHECK_ADDR_NAK(I2C_1_CSR_REG))
 419   2                  {
 420   3                      /* Address has been NACKed: reset FSM to IDLE */
 421   3                      I2C_1_state = I2C_1_SM_IDLE;
 422   3                      errStatus = I2C_1_MSTR_ERR_LB_NAK;
 423   3                  }
 424   2                  else
 425   2                  {
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 8   

 426   3                      /* ReStart was sent witout errors */
 427   3                      errStatus = I2C_1_MSTR_NO_ERROR;
 428   3                  }
 429   2          }
 430   1      
 431   1          return(errStatus);
 432   1      }
 433          
 434          
 435          /*******************************************************************************
 436          * Function Name: I2C_1_MasterSendStop
 437          ********************************************************************************
 438          *
 439          * Summary:
 440          *  Generates I2C Stop condition on bus. Function do nothing if Start or Restart
 441          *  condition was failed before call this function.
 442          *
 443          * Parameters:
 444          *  None
 445          *
 446          * Return:
 447          *  Status error - zero means no errors.
 448          *
 449          * Side Effects:
 450          *  The Stop generation is required to complete transaction.
 451          *  This function does not wait whileStop condition will be generated.
 452          *
 453          * Global variables:
 454          *  I2C_1_state - used to store current state of software FSM.
 455          *
 456          * Reentrant:
 457          *  No
 458          *
 459          *******************************************************************************/
 460          uint8 I2C_1_MasterSendStop(void) 
 461          {
 462   1          uint8 errStatus;
 463   1      
 464   1          errStatus = I2C_1_MSTR_NOT_READY;
 465   1      
 466   1          /* Check if START condition was generated */
 467   1          if(I2C_1_CHECK_MASTER_MODE(I2C_1_MCSR_REG))
 468   1          {
 469   2              I2C_1_GENERATE_STOP_MANUAL;              /* Generate STOP */
 470   2              I2C_1_state = I2C_1_SM_IDLE;  /* Reset state to IDLE */
 471   2      
 472   2              while(I2C_1_WAIT_STOP_COMPLETE(I2C_1_CSR_REG))
 473   2              {
 474   3                  ; /* Wait for Stop to be generated */
 475   3              }
 476   2      
 477   2              errStatus = I2C_1_MSTR_NO_ERROR;
 478   2              #if(I2C_1_MODE_MULTI_MASTER_ENABLED)
                          if(I2C_1_CHECK_LOST_ARB(I2C_1_CSR_REG))
                          {
                              I2C_1_BUS_RELEASE;
              
                              /* NACK was generated by enother instead Stop */
                              errStatus = I2C_1_MSTR_ERR_ARB_LOST;
                          }
                      #endif /* (I2C_1_MODE_MULTI_MASTER_ENABLED) */
 487   2          }
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 9   

 488   1      
 489   1          return(errStatus);
 490   1      }
 491          
 492          
 493          /*******************************************************************************
 494          * Function Name: I2C_1_MasterWriteByte
 495          ********************************************************************************
 496          *
 497          * Summary:
 498          *  Sends one byte to a slave. A valid Start or ReStart condition must be
 499          *  generated before this call this function. Function do nothing if Start or
 500          *  Restart condition was failed before call this function.
 501          *
 502          * Parameters:
 503          *  data:  The data byte to send to the slave.
 504          *
 505          * Return:
 506          *  Status error - zero means no errors.
 507          *
 508          * Side Effects:
 509          *  This function is entered without a 'byte complete' bit set in the I2C_CSR
 510          *  register. It does not exit until it will be set.
 511          *
 512          * Global variables:
 513          *  I2C_1_state - used to store current state of software FSM.
 514          *
 515          *******************************************************************************/
 516          uint8 I2C_1_MasterWriteByte(uint8 theByte) 
 517          {
 518   1          uint8 errStatus;
 519   1      
 520   1          errStatus = I2C_1_MSTR_NOT_READY;
 521   1      
 522   1          /* Check if START condition was generated */
 523   1          if(I2C_1_CHECK_MASTER_MODE(I2C_1_MCSR_REG))
 524   1          {
 525   2              I2C_1_DATA_REG = theByte;                        /* Write DATA register */
 526   2              I2C_1_TRANSMIT_DATA_MANUAL;                      /* Set transmit mode */
 527   2              I2C_1_state = I2C_1_SM_MSTR_WR_DATA;  /* Set state WR_DATA */
 528   2      
 529   2              /* Make sure the last byte has been transfered first */
 530   2              while(I2C_1_WAIT_BYTE_COMPLETE(I2C_1_CSR_REG))
 531   2              {
 532   3                  ; /* Wait for byte to be written */
 533   3              }
 534   2      
 535   2              #if(I2C_1_MODE_MULTI_MASTER_ENABLED)
                          if(I2C_1_CHECK_LOST_ARB(I2C_1_CSR_REG))
                          {
                              I2C_1_BUS_RELEASE;
              
                              /* Master lost arbitrage: reset FSM to IDLE */
                              I2C_1_state = I2C_1_SM_IDLE;
                              errStatus = I2C_1_MSTR_ERR_ARB_LOST;
                          }
                          /* Check LRB bit */
                          else
                      #endif /* (I2C_1_MODE_MULTI_MASTER_ENABLED) */
 547   2      
 548   2                  if(I2C_1_CHECK_DATA_ACK(I2C_1_CSR_REG))
 549   2                  {
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 10  

 550   3                      I2C_1_state = I2C_1_SM_MSTR_HALT;     /* Set state to HALT */
 551   3                      errStatus = I2C_1_MSTR_NO_ERROR;                 /* The LRB was ACKed */
 552   3                  }
 553   2                  else
 554   2                  {
 555   3                      I2C_1_state = I2C_1_SM_MSTR_HALT;     /* Set state to HALT */
 556   3                      errStatus = I2C_1_MSTR_ERR_LB_NAK;               /* The LRB was NACKed */
 557   3                  }
 558   2          }
 559   1      
 560   1          return(errStatus);
 561   1      }
 562          
 563          
 564          /*******************************************************************************
 565          * Function Name: I2C_1_MasterReadByte
 566          ********************************************************************************
 567          *
 568          * Summary:
 569          *  Reads one byte from a slave and ACK or NACK the transfer. A valid Start or
 570          *  ReStart condition must be generated before this call this function. Function
 571          *  do nothing if Start or Restart condition was failed before call this
 572          *  function.
 573          *
 574          * Parameters:
 575          *  acknNack:  Zero, response with NACK, if non-zero response with ACK.
 576          *
 577          * Return:
 578          *  Byte read from slave.
 579          *
 580          * Side Effects:
 581          *  This function is entered without a 'byte complete' bit set in the I2C_CSR
 582          *  register. It does not exit until it will be set.
 583          *
 584          * Global variables:
 585          *  I2C_1_state - used to store current state of software FSM.
 586          *
 587          * Reentrant:
 588          *  No
 589          *
 590          *******************************************************************************/
 591          uint8 I2C_1_MasterReadByte(uint8 acknNak) 
 592          {
 593   1          uint8 theByte;
 594   1      
 595   1          theByte = 0u;
 596   1      
 597   1          /* Check if START condition was generated */
 598   1          if(I2C_1_CHECK_MASTER_MODE(I2C_1_MCSR_REG))
 599   1          {
 600   2              /* When address phase need release the bus and receive the byte, then decide ACK or NACK */
 601   2              if(I2C_1_SM_MSTR_RD_ADDR == I2C_1_state)
 602   2              {
 603   3                  I2C_1_state = I2C_1_SM_MSTR_RD_DATA;
 604   3                  I2C_1_READY_TO_READ_MANUAL;
 605   3              }
 606   2      
 607   2              while(I2C_1_WAIT_BYTE_COMPLETE(I2C_1_CSR_REG))
 608   2              {
 609   3                  ; /* Wait for byte to be read */
 610   3              }
 611   2      
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 11  

 612   2              theByte = I2C_1_DATA_REG;
 613   2      
 614   2              /* Now if the ACK flag was set, ACK the data which will release the bus and
 615   2                 start the next byte in otherwise do NOTHING to the CSR reg.
 616   2                 This will allow the calling routine to generate a repeat start or
 617   2                 stop depending on it's preference. */
 618   2              if(acknNak != 0u)   /* Do ACK */
 619   2              {
 620   3                  I2C_1_ACK_AND_RECEIVE_MANUAL;
 621   3              }
 622   2              else                /* Do NACK */
 623   2              {
 624   3                  /* Do nothing to be able work with ReStart */
 625   3                  I2C_1_state = I2C_1_SM_MSTR_HALT;
 626   3              }
 627   2          }
 628   1      
 629   1          return(theByte);
 630   1      }
 631          
 632          
 633          /*******************************************************************************
 634          * Function Name: I2C_1_MasterStatus
 635          ********************************************************************************
 636          *
 637          * Summary:
 638          *  Returns the master's communication status.
 639          *
 640          * Parameters:
 641          *  None
 642          *
 643          * Return:
 644          *  Current status of I2C master.
 645          *
 646          * Global variables:
 647          *  I2C_1_mstrStatus - used to store current status of I2C Master.
 648          *
 649          *******************************************************************************/
 650          uint8 I2C_1_MasterStatus(void) 
 651          {
 652   1          uint8 status;
 653   1      
 654   1          status = I2C_1_mstrStatus;
 655   1      
 656   1          /* When in Master state only transaction is in progress */
 657   1          if(I2C_1_CHECK_SM_MASTER)
 658   1          {
 659   2              /* Add transaction in progress activity to master status */
 660   2              status |= I2C_1_MSTAT_XFER_INP;
 661   2          }
 662   1          else
 663   1          {
 664   2              /* Current master status is valid */
 665   2          }
 666   1      
 667   1          return(status);
 668   1      }
 669          
 670          
 671          /*******************************************************************************
 672          * Function Name: I2C_1_MasterClearStatus
 673          ********************************************************************************
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 12  

 674          *
 675          * Summary:
 676          *  Clears all status flags and returns the master status.
 677          *
 678          * Parameters:
 679          *  None
 680          *
 681          * Return:
 682          *  Current status of I2C master.
 683          *
 684          * Global variables:
 685          *  I2C_1_mstrStatus - used to store current status of I2C Master.
 686          *
 687          * Reentrant:
 688          *  No
 689          *
 690          *******************************************************************************/
 691          uint8 I2C_1_MasterClearStatus(void) 
 692          {
 693   1          /* Current master status */
 694   1          uint8 status;
 695   1      
 696   1          /* Read and clear master status */
 697   1          status = I2C_1_mstrStatus;
 698   1          I2C_1_mstrStatus = I2C_1_MSTAT_CLEAR;
 699   1      
 700   1          return(status);
 701   1      }
 702          
 703          
 704          /*******************************************************************************
 705          * Function Name: I2C_1_MasterGetReadBufSize
 706          ********************************************************************************
 707          *
 708          * Summary:
 709          *  Returns the amount of bytes that has been transferred with an
 710          *  I2C_MasterReadBuf command.
 711          *
 712          * Parameters:
 713          *  None
 714          *
 715          * Return:
 716          *  Byte count of transfer. If the transfer is not yet complete, it will return
 717          *  the byte count transferred so far.
 718          *
 719          * Global variables:
 720          *  I2C_1_mstrRdBufIndex - used to current index within master read
 721          *  buffer.
 722          *
 723          *******************************************************************************/
 724          uint8 I2C_1_MasterGetReadBufSize(void) 
 725          {
 726   1          return(I2C_1_mstrRdBufIndex);
 727   1      }
 728          
 729          
 730          /*******************************************************************************
 731          * Function Name: I2C_1_MasterGetWriteBufSize
 732          ********************************************************************************
 733          *
 734          * Summary:
 735          *  Returns the amount of bytes that has been transferred with an
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 13  

 736          *  I2C_MasterWriteBuf command.
 737          *
 738          * Parameters:
 739          *  None
 740          *
 741          * Return:
 742          *  Byte count of transfer. If the transfer is not yet complete, it will return
 743          *  the byte count transferred so far.
 744          *
 745          * Global variables:
 746          *  I2C_1_mstrWrBufIndex - used to current index within master write
 747          *  buffer.
 748          *
 749          *******************************************************************************/
 750          uint8 I2C_1_MasterGetWriteBufSize(void) 
 751          {
 752   1          return(I2C_1_mstrWrBufIndex);
 753   1      }
 754          
 755          
 756          /*******************************************************************************
 757          * Function Name: I2C_1_MasterClearReadBuf
 758          ********************************************************************************
 759          *
 760          * Summary:
 761          *  Resets the read buffer pointer back to the first byte in the buffer.
 762          *
 763          * Parameters:
 764          *  None
 765          *
 766          * Return:
 767          *  None
 768          *
 769          * Global variables:
 770          *  I2C_1_mstrRdBufIndex - used to current index within master read
 771          *   buffer.
 772          *  I2C_1_mstrStatus - used to store current status of I2C Master.
 773          *
 774          * Reentrant:
 775          *  No
 776          *
 777          *******************************************************************************/
 778          void I2C_1_MasterClearReadBuf(void) 
 779          {
 780   1          I2C_1_mstrRdBufIndex = 0u;
 781   1          I2C_1_mstrStatus    &= ((uint8) ~I2C_1_MSTAT_RD_CMPLT);
 782   1      }
 783          
 784          
 785          /*******************************************************************************
 786          * Function Name: I2C_1_MasterClearWriteBuf
 787          ********************************************************************************
 788          *
 789          * Summary:
 790          *  Resets the write buffer pointer back to the first byte in the buffer.
 791          *
 792          * Parameters:
 793          *  None
 794          *
 795          * Return:
 796          *  None
 797          *
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 14  

 798          * Global variables:
 799          *  I2C_1_mstrRdBufIndex - used to current index within master read
 800          *   buffer.
 801          *  I2C_1_mstrStatus - used to store current status of I2C Master.
 802          *
 803          * Reentrant:
 804          *  No
 805          *
 806          *******************************************************************************/
 807          void I2C_1_MasterClearWriteBuf(void) 
 808          {
 809   1          I2C_1_mstrWrBufIndex = 0u;
 810   1          I2C_1_mstrStatus    &= ((uint8) ~I2C_1_MSTAT_WR_CMPLT);
 811   1      }
 812          
 813          
 814          /*******************************************************************************
 815          * Function Name: I2C_1_Workaround
 816          ********************************************************************************
 817          *
 818          * Summary:
 819          *  Do nothing. This fake fuction use as workaround for CDT 78083.
 820          *
 821          * Parameters:
 822          *  None
 823          *
 824          * Return:
 825          *  None
 826          *
 827          * Reentrant:
 828          *  No
 829          *
 830          *******************************************************************************/
 831          void I2C_1_Workaround(void) 
 832          {
 833   1          /* Does nothing */
 834   1      }
 835          
 836          #endif /* (I2C_1_MODE_MASTER_ENABLED) */
 837          
 838          
 839          /* [] END OF FILE */
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 15  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _I2C_1_MasterWriteBuf (BEGIN)
                                           ; SOURCE LINE # 77
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#wrData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 79
                                           ; SOURCE LINE # 82
000B 900000      R     MOV     DPTR,#errStatus
000E 7402              MOV     A,#02H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 84
0011 7B00              MOV     R3,#00H
0013 7A00              MOV     R2,#00H
0015 7900              MOV     R1,#00H
0017 C003              PUSH    AR3
0019 C002              PUSH    AR2
001B C001              PUSH    AR1
001D 900000      R     MOV     DPTR,#wrData
0020 120000      E     LCALL   ?C?PLDXDATA
0023 D082              POP     DPL
0025 D083              POP     DPH
0027 D0E0              POP     ACC
0029 6B                XRL     A,R3
002A 7008              JNZ     ?C0097
002C E9                MOV     A,R1
002D 6582              XRL     A,DPL
002F 7003              JNZ     ?C0097
0031 EA                MOV     A,R2
0032 6583              XRL     A,DPH
0034         ?C0097:
0034 7003              JNZ     $ + 5H
0036 020000      R     LJMP    ?C0001
                                           ; SOURCE LINE # 85
                                           ; SOURCE LINE # 87
0039 900000      E     MOV     DPTR,#I2C_1_state
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F B4101E            CJNE    A,#010H,?C0002
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 90
0042 9049D9            MOV     DPTR,#049D9H
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 EF                MOV     A,R7
0048 5408              ANL     A,#08H
004A FF                MOV     R7,A
004B 7E00              MOV     R6,#00H
004D EF                MOV     A,R7
004E 4E                ORL     A,R6
004F 7007              JNZ     ?C0003
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 92
0051 900000      R     MOV     DPTR,#errStatus
0054 E4                CLR     A
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 93
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 16  

0056 802A              SJMP    ?C0005
0058         ?C0003:
                                           ; SOURCE LINE # 95
                                           ; SOURCE LINE # 96
0058 900000      R     MOV     DPTR,#errStatus
005B 7401              MOV     A,#01H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
                                           ; SOURCE LINE # 98
005E 8022              SJMP    ?C0005
0060         ?C0002:
                                           ; SOURCE LINE # 99
0060 900000      E     MOV     DPTR,#I2C_1_state
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
0065 EF                MOV     A,R7
0066 B46019            CJNE    A,#060H,?C0005
                                           ; SOURCE LINE # 100
                                           ; SOURCE LINE # 101
0069 900000      R     MOV     DPTR,#errStatus
006C E4                CLR     A
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
006E 9044D9            MOV     DPTR,#044D9H
0071 7480              MOV     A,#080H
0073 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 104
0074 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 EF                MOV     A,R7
007A 54F7              ANL     A,#0F7H
007C FF                MOV     R7,A
007D 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0080 EF                MOV     A,R7
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 109
0082         ?C0005:
                                           ; SOURCE LINE # 111
0082 900000      R     MOV     DPTR,#errStatus
0085 E0                MOVX    A,@DPTR
0086 FF                MOV     R7,A
0087 EF                MOV     A,R7
0088 7070              JNZ     ?C0001
                                           ; SOURCE LINE # 112
                                           ; SOURCE LINE # 113
008A 900000      E     MOV     DPTR,#I2C_1_state
008D 7445              MOV     A,#045H
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0090 900000      R     MOV     DPTR,#slaveAddress
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 EF                MOV     A,R7
0096 25E0              ADD     A,ACC
0098 FF                MOV     R7,A
0099 9049D8            MOV     DPTR,#049D8H
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 17  

009E 900000      R     MOV     DPTR,#I2C_1_mstrWrBufIndex
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 117
00A3 900000      R     MOV     DPTR,#cnt
00A6 E0                MOVX    A,@DPTR
00A7 FF                MOV     R7,A
00A8 900000      R     MOV     DPTR,#I2C_1_mstrWrBufSize
00AB EF                MOV     A,R7
00AC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 118
00AD 900000      R     MOV     DPTR,#wrData
00B0 120000      E     LCALL   ?C?PLDXDATA
00B3 900000      R     MOV     DPTR,#I2C_1_mstrWrBufPtr
00B6 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 120
00B9 900000      R     MOV     DPTR,#mode
00BC E0                MOVX    A,@DPTR
00BD FF                MOV     R7,A
00BE 900000      R     MOV     DPTR,#I2C_1_mstrControl
00C1 EF                MOV     A,R7
00C2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 123
00C3 900000      R     MOV     DPTR,#mode
00C6 E0                MOVX    A,@DPTR
00C7 FF                MOV     R7,A
00C8 EF                MOV     A,R7
00C9 5401              ANL     A,#01H
00CB FF                MOV     R7,A
00CC 7E00              MOV     R6,#00H
00CE EF                MOV     A,R7
00CF 4E                ORL     A,R6
00D0 600E              JZ      ?C0016
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
00D2 9049D9            MOV     DPTR,#049D9H
00D5 7412              MOV     A,#012H
00D7 F0                MOVX    @DPTR,A
00D8 9049D7            MOV     DPTR,#049D7H
00DB 7404              MOV     A,#04H
00DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
00DE 8006              SJMP    ?C0013
                                           ; SOURCE LINE # 128
00E0         ?C0016:
                                           ; SOURCE LINE # 129
00E0 9049D9            MOV     DPTR,#049D9H
00E3 7401              MOV     A,#01H
00E5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
00E6         ?C0013:
                                           ; SOURCE LINE # 132
00E6 900000      R     MOV     DPTR,#I2C_1_mstrStatus
00E9 E0                MOVX    A,@DPTR
00EA FF                MOV     R7,A
00EB EF                MOV     A,R7
00EC 54FD              ANL     A,#0FDH
00EE FF                MOV     R7,A
00EF 900000      R     MOV     DPTR,#I2C_1_mstrStatus
00F2 EF                MOV     A,R7
00F3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 18  

00F4 9044C1            MOV     DPTR,#044C1H
00F7 7480              MOV     A,#080H
00F9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 135
                                           ; SOURCE LINE # 136
00FA         ?C0001:
                                           ; SOURCE LINE # 138
00FA 900000      R     MOV     DPTR,#errStatus
00FD E0                MOVX    A,@DPTR
00FE FF                MOV     R7,A
                                           ; SOURCE LINE # 139
00FF         ?C0017:
00FF 22                RET     
             ; FUNCTION _I2C_1_MasterWriteBuf (END)

             ; FUNCTION _I2C_1_MasterReadBuf (BEGIN)
                                           ; SOURCE LINE # 180
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#rdData
0008 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 182
                                           ; SOURCE LINE # 185
000B 900000      R     MOV     DPTR,#errStatus
000E 7402              MOV     A,#02H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
0011 7B00              MOV     R3,#00H
0013 7A00              MOV     R2,#00H
0015 7900              MOV     R1,#00H
0017 C003              PUSH    AR3
0019 C002              PUSH    AR2
001B C001              PUSH    AR1
001D 900000      R     MOV     DPTR,#rdData
0020 120000      E     LCALL   ?C?PLDXDATA
0023 D082              POP     DPL
0025 D083              POP     DPH
0027 D0E0              POP     ACC
0029 6B                XRL     A,R3
002A 7008              JNZ     ?C0098
002C E9                MOV     A,R1
002D 6582              XRL     A,DPL
002F 7003              JNZ     ?C0098
0031 EA                MOV     A,R2
0032 6583              XRL     A,DPH
0034         ?C0098:
0034 7003              JNZ     $ + 5H
0036 020000      R     LJMP    ?C0018
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 190
0039 900000      E     MOV     DPTR,#I2C_1_state
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F B4101E            CJNE    A,#010H,?C0019
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 193
0042 9049D9            MOV     DPTR,#049D9H
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 EF                MOV     A,R7
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 19  

0048 5408              ANL     A,#08H
004A FF                MOV     R7,A
004B 7E00              MOV     R6,#00H
004D EF                MOV     A,R7
004E 4E                ORL     A,R6
004F 7007              JNZ     ?C0020
                                           ; SOURCE LINE # 194
                                           ; SOURCE LINE # 195
0051 900000      R     MOV     DPTR,#errStatus
0054 E4                CLR     A
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 196
0056 802A              SJMP    ?C0022
0058         ?C0020:
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
0058 900000      R     MOV     DPTR,#errStatus
005B 7401              MOV     A,#01H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 200
                                           ; SOURCE LINE # 201
005E 8022              SJMP    ?C0022
0060         ?C0019:
                                           ; SOURCE LINE # 202
0060 900000      E     MOV     DPTR,#I2C_1_state
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
0065 EF                MOV     A,R7
0066 B46019            CJNE    A,#060H,?C0022
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
0069 900000      R     MOV     DPTR,#errStatus
006C E4                CLR     A
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
006E 9044D9            MOV     DPTR,#044D9H
0071 7480              MOV     A,#080H
0073 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 207
0074 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 EF                MOV     A,R7
007A 54F7              ANL     A,#0F7H
007C FF                MOV     R7,A
007D 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0080 EF                MOV     A,R7
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 212
0082         ?C0022:
                                           ; SOURCE LINE # 214
0082 900000      R     MOV     DPTR,#errStatus
0085 E0                MOVX    A,@DPTR
0086 FF                MOV     R7,A
0087 EF                MOV     A,R7
0088 7074              JNZ     ?C0018
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 216
008A 900000      E     MOV     DPTR,#I2C_1_state
008D 7449              MOV     A,#049H
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 20  

008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 217
0090 900000      R     MOV     DPTR,#slaveAddress
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 EF                MOV     A,R7
0096 25E0              ADD     A,ACC
0098 FF                MOV     R7,A
0099 EF                MOV     A,R7
009A 4401              ORL     A,#01H
009C FF                MOV     R7,A
009D 9049D8            MOV     DPTR,#049D8H
00A0 EF                MOV     A,R7
00A1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 220
00A2 900000      R     MOV     DPTR,#I2C_1_mstrRdBufIndex
00A5 E4                CLR     A
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 221
00A7 900000      R     MOV     DPTR,#cnt
00AA E0                MOVX    A,@DPTR
00AB FF                MOV     R7,A
00AC 900000      R     MOV     DPTR,#I2C_1_mstrRdBufSize
00AF EF                MOV     A,R7
00B0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 222
00B1 900000      R     MOV     DPTR,#rdData
00B4 120000      E     LCALL   ?C?PLDXDATA
00B7 900000      R     MOV     DPTR,#I2C_1_mstrRdBufPtr
00BA 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 224
00BD 900000      R     MOV     DPTR,#mode
00C0 E0                MOVX    A,@DPTR
00C1 FF                MOV     R7,A
00C2 900000      R     MOV     DPTR,#I2C_1_mstrControl
00C5 EF                MOV     A,R7
00C6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 227
00C7 900000      R     MOV     DPTR,#mode
00CA E0                MOVX    A,@DPTR
00CB FF                MOV     R7,A
00CC EF                MOV     A,R7
00CD 5401              ANL     A,#01H
00CF FF                MOV     R7,A
00D0 7E00              MOV     R6,#00H
00D2 EF                MOV     A,R7
00D3 4E                ORL     A,R6
00D4 600E              JZ      ?C0033
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 229
00D6 9049D9            MOV     DPTR,#049D9H
00D9 7412              MOV     A,#012H
00DB F0                MOVX    @DPTR,A
00DC 9049D7            MOV     DPTR,#049D7H
00DF 7404              MOV     A,#04H
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 230
00E2 8006              SJMP    ?C0030
                                           ; SOURCE LINE # 232
00E4         ?C0033:
                                           ; SOURCE LINE # 233
00E4 9049D9            MOV     DPTR,#049D9H
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 21  

00E7 7401              MOV     A,#01H
00E9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
00EA         ?C0030:
                                           ; SOURCE LINE # 236
00EA 900000      R     MOV     DPTR,#I2C_1_mstrStatus
00ED E0                MOVX    A,@DPTR
00EE FF                MOV     R7,A
00EF EF                MOV     A,R7
00F0 54FE              ANL     A,#0FEH
00F2 FF                MOV     R7,A
00F3 900000      R     MOV     DPTR,#I2C_1_mstrStatus
00F6 EF                MOV     A,R7
00F7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 238
00F8 9044C1            MOV     DPTR,#044C1H
00FB 7480              MOV     A,#080H
00FD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 239
                                           ; SOURCE LINE # 240
00FE         ?C0018:
                                           ; SOURCE LINE # 242
00FE 900000      R     MOV     DPTR,#errStatus
0101 E0                MOVX    A,@DPTR
0102 FF                MOV     R7,A
                                           ; SOURCE LINE # 243
0103         ?C0034:
0103 22                RET     
             ; FUNCTION _I2C_1_MasterReadBuf (END)

             ; FUNCTION _I2C_1_MasterSendStart (BEGIN)
                                           ; SOURCE LINE # 271
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#R_nW
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 276
000A 900000      R     MOV     DPTR,#errStatus
000D 7402              MOV     A,#02H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 279
0010 900000      E     MOV     DPTR,#I2C_1_state
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 6410              XRL     A,#010H
0018 6003              JZ      $ + 5H
001A 020000      R     LJMP    ?C0035
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 282
001D 9049D9            MOV     DPTR,#049D9H
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 5408              ANL     A,#08H
0025 FF                MOV     R7,A
0026 7E00              MOV     R6,#00H
0028 EF                MOV     A,R7
0029 4E                ORL     A,R6
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 22  

002A 707D              JNZ     ?C0036
                                           ; SOURCE LINE # 283
                                           ; SOURCE LINE # 284
002C 9044C9            MOV     DPTR,#044C9H
002F 7480              MOV     A,#080H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 286
0032 900000      R     MOV     DPTR,#slaveAddress
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 EF                MOV     A,R7
0038 25E0              ADD     A,ACC
003A FF                MOV     R7,A
003B 900000      R     MOV     DPTR,#slaveAddress
003E EF                MOV     A,R7
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 287
0040 900000      R     MOV     DPTR,#R_nW
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 6016              JZ      ?C0037
                                           ; SOURCE LINE # 288
                                           ; SOURCE LINE # 289
0048 900000      R     MOV     DPTR,#slaveAddress
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
004D EF                MOV     A,R7
004E 4401              ORL     A,#01H
0050 FF                MOV     R7,A
0051 900000      R     MOV     DPTR,#slaveAddress
0054 EF                MOV     A,R7
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 290
0056 900000      E     MOV     DPTR,#I2C_1_state
0059 7449              MOV     A,#049H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
005C 8006              SJMP    ?C0038
005E         ?C0037:
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 294
005E 900000      E     MOV     DPTR,#I2C_1_state
0061 7445              MOV     A,#045H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 295
0064         ?C0038:
                                           ; SOURCE LINE # 296
0064 900000      R     MOV     DPTR,#slaveAddress
0067 E0                MOVX    A,@DPTR
0068 FF                MOV     R7,A
0069 9049D8            MOV     DPTR,#049D8H
006C EF                MOV     A,R7
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 299
006E 9049D9            MOV     DPTR,#049D9H
0071 7401              MOV     A,#01H
0073 F0                MOVX    @DPTR,A
0074         ?C0042:
                                           ; SOURCE LINE # 300
0074 9049D7            MOV     DPTR,#049D7H
0077 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 23  

0078 FF                MOV     R7,A
0079 EF                MOV     A,R7
007A 5401              ANL     A,#01H
007C FF                MOV     R7,A
007D 7E00              MOV     R6,#00H
007F EF                MOV     A,R7
0080 4E                ORL     A,R6
0081 60F1              JZ      ?C0042
                                           ; SOURCE LINE # 301
                                           ; SOURCE LINE # 303
0083         ?C0043:
                                           ; SOURCE LINE # 330
0083 9049D7            MOV     DPTR,#049D7H
0086 E0                MOVX    A,@DPTR
0087 FF                MOV     R7,A
0088 EF                MOV     A,R7
0089 540A              ANL     A,#0AH
008B FF                MOV     R7,A
008C 7E00              MOV     R6,#00H
008E EF                MOV     A,R7
008F 640A              XRL     A,#0AH
0091 4E                ORL     A,R6
0092 700E              JNZ     ?C0044
                                           ; SOURCE LINE # 331
                                           ; SOURCE LINE # 333
0094 900000      E     MOV     DPTR,#I2C_1_state
0097 7410              MOV     A,#010H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 334
009A 900000      R     MOV     DPTR,#errStatus
009D 7403              MOV     A,#03H
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 335
00A0 800D              SJMP    ?C0035
00A2         ?C0044:
                                           ; SOURCE LINE # 337
                                           ; SOURCE LINE # 339
00A2 900000      R     MOV     DPTR,#errStatus
00A5 E4                CLR     A
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
00A7 8006              SJMP    ?C0035
00A9         ?C0036:
                                           ; SOURCE LINE # 343
                                           ; SOURCE LINE # 344
00A9 900000      R     MOV     DPTR,#errStatus
00AC 7401              MOV     A,#01H
00AE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
00AF         ?C0035:
                                           ; SOURCE LINE # 348
00AF 900000      R     MOV     DPTR,#errStatus
00B2 E0                MOVX    A,@DPTR
00B3 FF                MOV     R7,A
                                           ; SOURCE LINE # 349
00B4         ?C0047:
00B4 22                RET     
             ; FUNCTION _I2C_1_MasterSendStart (END)

             ; FUNCTION _I2C_1_MasterSendRestart (BEGIN)
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 24  

                                           ; SOURCE LINE # 377
0000 900000      R     MOV     DPTR,#slaveAddress
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#R_nW
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 379
                                           ; SOURCE LINE # 382
000A 900000      R     MOV     DPTR,#errStatus
000D 7402              MOV     A,#02H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 385
0010 9049D9            MOV     DPTR,#049D9H
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 5404              ANL     A,#04H
0018 FF                MOV     R7,A
0019 7E00              MOV     R6,#00H
001B EF                MOV     A,R7
001C 4E                ORL     A,R6
001D 607B              JZ      ?C0048
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
001F 900000      R     MOV     DPTR,#slaveAddress
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 EF                MOV     A,R7
0025 25E0              ADD     A,ACC
0027 FF                MOV     R7,A
0028 900000      R     MOV     DPTR,#slaveAddress
002B EF                MOV     A,R7
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
002D 900000      R     MOV     DPTR,#R_nW
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 6016              JZ      ?C0049
                                           ; SOURCE LINE # 389
                                           ; SOURCE LINE # 390
0035 900000      R     MOV     DPTR,#slaveAddress
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A EF                MOV     A,R7
003B 4401              ORL     A,#01H
003D FF                MOV     R7,A
003E 900000      R     MOV     DPTR,#slaveAddress
0041 EF                MOV     A,R7
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 391
0043 900000      E     MOV     DPTR,#I2C_1_state
0046 7449              MOV     A,#049H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 392
0049 8006              SJMP    ?C0050
004B         ?C0049:
                                           ; SOURCE LINE # 394
                                           ; SOURCE LINE # 395
004B 900000      E     MOV     DPTR,#I2C_1_state
004E 7445              MOV     A,#045H
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 25  

0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 396
0051         ?C0050:
                                           ; SOURCE LINE # 397
0051 900000      R     MOV     DPTR,#slaveAddress
0054 E0                MOVX    A,@DPTR
0055 FF                MOV     R7,A
0056 9049D8            MOV     DPTR,#049D8H
0059 EF                MOV     A,R7
005A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 400
005B 9049D9            MOV     DPTR,#049D9H
005E 7412              MOV     A,#012H
0060 F0                MOVX    @DPTR,A
0061 9049D7            MOV     DPTR,#049D7H
0064 7404              MOV     A,#04H
0066 F0                MOVX    @DPTR,A
0067         ?C0054:
                                           ; SOURCE LINE # 401
0067 9049D7            MOV     DPTR,#049D7H
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D 5401              ANL     A,#01H
006F FF                MOV     R7,A
0070 7E00              MOV     R6,#00H
0072 EF                MOV     A,R7
0073 4E                ORL     A,R6
0074 60F1              JZ      ?C0054
                                           ; SOURCE LINE # 402
                                           ; SOURCE LINE # 404
0076         ?C0055:
                                           ; SOURCE LINE # 418
0076 9049D7            MOV     DPTR,#049D7H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 540A              ANL     A,#0AH
007E FF                MOV     R7,A
007F 7E00              MOV     R6,#00H
0081 EF                MOV     A,R7
0082 640A              XRL     A,#0AH
0084 4E                ORL     A,R6
0085 700E              JNZ     ?C0056
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 421
0087 900000      E     MOV     DPTR,#I2C_1_state
008A 7410              MOV     A,#010H
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 422
008D 900000      R     MOV     DPTR,#errStatus
0090 7403              MOV     A,#03H
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 423
0093 8005              SJMP    ?C0048
0095         ?C0056:
                                           ; SOURCE LINE # 425
                                           ; SOURCE LINE # 427
0095 900000      R     MOV     DPTR,#errStatus
0098 E4                CLR     A
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 428
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 26  

                                           ; SOURCE LINE # 429
009A         ?C0048:
                                           ; SOURCE LINE # 431
009A 900000      R     MOV     DPTR,#errStatus
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
                                           ; SOURCE LINE # 432
009F         ?C0058:
009F 22                RET     
             ; FUNCTION _I2C_1_MasterSendRestart (END)

             ; FUNCTION I2C_1_MasterSendStop (BEGIN)
                                           ; SOURCE LINE # 460
                                           ; SOURCE LINE # 461
                                           ; SOURCE LINE # 464
0000 900000      R     MOV     DPTR,#errStatus
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 467
0006 9049D9            MOV     DPTR,#049D9H
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 5404              ANL     A,#04H
000E FF                MOV     R7,A
000F 7E00              MOV     R6,#00H
0011 EF                MOV     A,R7
0012 4E                ORL     A,R6
0013 6026              JZ      ?C0059
                                           ; SOURCE LINE # 468
                                           ; SOURCE LINE # 469
0015 9049D9            MOV     DPTR,#049D9H
0018 7410              MOV     A,#010H
001A F0                MOVX    @DPTR,A
001B 9049D7            MOV     DPTR,#049D7H
001E 7404              MOV     A,#04H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 470
0021 900000      E     MOV     DPTR,#I2C_1_state
0024 7410              MOV     A,#010H
0026 F0                MOVX    @DPTR,A
0027         ?C0063:
                                           ; SOURCE LINE # 472
0027 9049D7            MOV     DPTR,#049D7H
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 5421              ANL     A,#021H
002F FF                MOV     R7,A
0030 7E00              MOV     R6,#00H
0032 EF                MOV     A,R7
0033 4E                ORL     A,R6
0034 60F1              JZ      ?C0063
                                           ; SOURCE LINE # 473
                                           ; SOURCE LINE # 475
0036         ?C0064:
                                           ; SOURCE LINE # 477
0036 900000      R     MOV     DPTR,#errStatus
0039 E4                CLR     A
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 487
003B         ?C0059:
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 27  

                                           ; SOURCE LINE # 489
003B 900000      R     MOV     DPTR,#errStatus
003E E0                MOVX    A,@DPTR
003F FF                MOV     R7,A
                                           ; SOURCE LINE # 490
0040         ?C0065:
0040 22                RET     
             ; FUNCTION I2C_1_MasterSendStop (END)

             ; FUNCTION _I2C_1_MasterWriteByte (BEGIN)
                                           ; SOURCE LINE # 516
0000 900000      R     MOV     DPTR,#theByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 517
                                           ; SOURCE LINE # 520
0005 900000      R     MOV     DPTR,#errStatus
0008 7402              MOV     A,#02H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
000B 9049D9            MOV     DPTR,#049D9H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 5404              ANL     A,#04H
0013 FF                MOV     R7,A
0014 7E00              MOV     R6,#00H
0016 EF                MOV     A,R7
0017 4E                ORL     A,R6
0018 604D              JZ      ?C0066
                                           ; SOURCE LINE # 524
                                           ; SOURCE LINE # 525
001A 900000      R     MOV     DPTR,#theByte
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F 9049D8            MOV     DPTR,#049D8H
0022 EF                MOV     A,R7
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 526
0024 9049D7            MOV     DPTR,#049D7H
0027 7404              MOV     A,#04H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
002A 900000      E     MOV     DPTR,#I2C_1_state
002D 7446              MOV     A,#046H
002F F0                MOVX    @DPTR,A
0030         ?C0070:
                                           ; SOURCE LINE # 530
0030 9049D7            MOV     DPTR,#049D7H
0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 5401              ANL     A,#01H
0038 FF                MOV     R7,A
0039 7E00              MOV     R6,#00H
003B EF                MOV     A,R7
003C 4E                ORL     A,R6
003D 60F1              JZ      ?C0070
                                           ; SOURCE LINE # 531
                                           ; SOURCE LINE # 533
003F         ?C0071:
                                           ; SOURCE LINE # 548
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 28  

003F 9049D7            MOV     DPTR,#049D7H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 5402              ANL     A,#02H
0047 FF                MOV     R7,A
0048 7E00              MOV     R6,#00H
004A EF                MOV     A,R7
004B 4E                ORL     A,R6
004C 700D              JNZ     ?C0072
                                           ; SOURCE LINE # 549
                                           ; SOURCE LINE # 550
004E 900000      E     MOV     DPTR,#I2C_1_state
0051 7460              MOV     A,#060H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 551
0054 900000      R     MOV     DPTR,#errStatus
0057 E4                CLR     A
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 552
0059 800C              SJMP    ?C0066
005B         ?C0072:
                                           ; SOURCE LINE # 554
                                           ; SOURCE LINE # 555
005B 900000      E     MOV     DPTR,#I2C_1_state
005E 7460              MOV     A,#060H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 556
0061 900000      R     MOV     DPTR,#errStatus
0064 7403              MOV     A,#03H
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 557
                                           ; SOURCE LINE # 558
0067         ?C0066:
                                           ; SOURCE LINE # 560
0067 900000      R     MOV     DPTR,#errStatus
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
                                           ; SOURCE LINE # 561
006C         ?C0074:
006C 22                RET     
             ; FUNCTION _I2C_1_MasterWriteByte (END)

             ; FUNCTION _I2C_1_MasterReadByte (BEGIN)
                                           ; SOURCE LINE # 591
0000 900000      R     MOV     DPTR,#acknNak
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 592
                                           ; SOURCE LINE # 595
0005 900000      R     MOV     DPTR,#theByte
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 598
000A 9049D9            MOV     DPTR,#049D9H
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 5404              ANL     A,#04H
0012 FF                MOV     R7,A
0013 7E00              MOV     R6,#00H
0015 EF                MOV     A,R7
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 29  

0016 4E                ORL     A,R6
0017 6043              JZ      ?C0075
                                           ; SOURCE LINE # 599
                                           ; SOURCE LINE # 601
0019 900000      E     MOV     DPTR,#I2C_1_state
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F B4490B            CJNE    A,#049H,?C0080
                                           ; SOURCE LINE # 602
                                           ; SOURCE LINE # 603
0022 900000      E     MOV     DPTR,#I2C_1_state
0025 744A              MOV     A,#04AH
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 604
0028 9049D7            MOV     DPTR,#049D7H
002B E4                CLR     A
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 605
002D         ?C0080:
                                           ; SOURCE LINE # 607
002D 9049D7            MOV     DPTR,#049D7H
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 5401              ANL     A,#01H
0035 FF                MOV     R7,A
0036 7E00              MOV     R6,#00H
0038 EF                MOV     A,R7
0039 4E                ORL     A,R6
003A 60F1              JZ      ?C0080
                                           ; SOURCE LINE # 608
                                           ; SOURCE LINE # 610
003C         ?C0081:
                                           ; SOURCE LINE # 612
003C 9049D8            MOV     DPTR,#049D8H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 900000      R     MOV     DPTR,#theByte
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 618
0046 900000      R     MOV     DPTR,#acknNak
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
004B EF                MOV     A,R7
004C 6008              JZ      ?C0082
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 620
004E 9049D7            MOV     DPTR,#049D7H
0051 7410              MOV     A,#010H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 621
0054 8006              SJMP    ?C0075
0056         ?C0082:
                                           ; SOURCE LINE # 623
                                           ; SOURCE LINE # 625
0056 900000      E     MOV     DPTR,#I2C_1_state
0059 7460              MOV     A,#060H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 626
                                           ; SOURCE LINE # 627
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 30  

005C         ?C0075:
                                           ; SOURCE LINE # 629
005C 900000      R     MOV     DPTR,#theByte
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
                                           ; SOURCE LINE # 630
0061         ?C0087:
0061 22                RET     
             ; FUNCTION _I2C_1_MasterReadByte (END)

             ; FUNCTION I2C_1_MasterStatus (BEGIN)
                                           ; SOURCE LINE # 650
                                           ; SOURCE LINE # 651
                                           ; SOURCE LINE # 654
0000 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#status
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 657
000A 900000      E     MOV     DPTR,#I2C_1_state
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 5440              ANL     A,#040H
0012 FF                MOV     R7,A
0013 7E00              MOV     R6,#00H
0015 EF                MOV     A,R7
0016 4E                ORL     A,R6
0017 600E              JZ      ?C0089
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 660
0019 900000      R     MOV     DPTR,#status
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F 4404              ORL     A,#04H
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#status
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 661
                                           ; SOURCE LINE # 663
                                           ; SOURCE LINE # 665
0027         ?C0089:
                                           ; SOURCE LINE # 667
0027 900000      R     MOV     DPTR,#status
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
                                           ; SOURCE LINE # 668
002C         ?C0090:
002C 22                RET     
             ; FUNCTION I2C_1_MasterStatus (END)

             ; FUNCTION I2C_1_MasterClearStatus (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
                                           ; SOURCE LINE # 697
0000 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 31  

0005 900000      R     MOV     DPTR,#status
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 698
000A 900000      R     MOV     DPTR,#I2C_1_mstrStatus
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 700
000F 900000      R     MOV     DPTR,#status
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 701
0014         ?C0091:
0014 22                RET     
             ; FUNCTION I2C_1_MasterClearStatus (END)

             ; FUNCTION I2C_1_MasterGetReadBufSize (BEGIN)
                                           ; SOURCE LINE # 724
                                           ; SOURCE LINE # 725
                                           ; SOURCE LINE # 726
0000 900000      R     MOV     DPTR,#I2C_1_mstrRdBufIndex
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 727
0005         ?C0092:
0005 22                RET     
             ; FUNCTION I2C_1_MasterGetReadBufSize (END)

             ; FUNCTION I2C_1_MasterGetWriteBufSize (BEGIN)
                                           ; SOURCE LINE # 750
                                           ; SOURCE LINE # 751
                                           ; SOURCE LINE # 752
0000 900000      R     MOV     DPTR,#I2C_1_mstrWrBufIndex
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 753
0005         ?C0093:
0005 22                RET     
             ; FUNCTION I2C_1_MasterGetWriteBufSize (END)

             ; FUNCTION I2C_1_MasterClearReadBuf (BEGIN)
                                           ; SOURCE LINE # 778
                                           ; SOURCE LINE # 779
                                           ; SOURCE LINE # 780
0000 900000      R     MOV     DPTR,#I2C_1_mstrRdBufIndex
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
0005 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54FE              ANL     A,#0FEH
000D FF                MOV     R7,A
000E 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 782
0013 22                RET     
             ; FUNCTION I2C_1_MasterClearReadBuf (END)

             ; FUNCTION I2C_1_MasterClearWriteBuf (BEGIN)
C51 COMPILER V9.03   I2C_1_MASTER                                                          08/11/2013 22:22:05 PAGE 32  

                                           ; SOURCE LINE # 807
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 809
0000 900000      R     MOV     DPTR,#I2C_1_mstrWrBufIndex
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 810
0005 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54FD              ANL     A,#0FDH
000D FF                MOV     R7,A
000E 900000      R     MOV     DPTR,#I2C_1_mstrStatus
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0013 22                RET     
             ; FUNCTION I2C_1_MasterClearWriteBuf (END)

             ; FUNCTION I2C_1_Workaround (BEGIN)
                                           ; SOURCE LINE # 831
                                           ; SOURCE LINE # 832
                                           ; SOURCE LINE # 834
0000 22                RET     
             ; FUNCTION I2C_1_Workaround (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1248    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     12      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
