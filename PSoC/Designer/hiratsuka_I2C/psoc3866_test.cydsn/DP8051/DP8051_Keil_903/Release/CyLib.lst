C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_903\Release\CyLib.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\2.2\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_903\Release\CyLib.lst) CD DB NOIP OT(8,S
                    -IZE) DF(NDEBUG) INCDIR(Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_903\Release\CyLib.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 3.40
   4          *
   5          *  Description:
   6          *   Provides system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2013, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset.
  25          *******************************************************************************/
  26          uint8 CYXDATA CyResetStatus;
  27          
  28          
  29          #if(!CY_PSOC5A)
  30          
  31              /* Variable Vdda */
  32              #if(CYDEV_VARIABLE_VDDA == 1)
              
                      uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
                  #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  37          
  38          #endif /* (!CY_PSOC5A) */
  39          
  40          
  41          /* Do not use these definitions directly in your application */
  42          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  43          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  44          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  45          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  46          
  47          
  48          /* Function Prototypes */
  49          static uint8 CyUSB_PowerOnCheck(void)  ;
  50          static void CyIMO_SetTrimValue(uint8 freq) ;
  51          static void CyBusClk_Internal_SetDivider(uint16 divider);
  52          
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 2   

  53          
  54          /*******************************************************************************
  55          * Function Name: CyPLL_OUT_Start
  56          ********************************************************************************
  57          *
  58          * Summary:
  59          *   Enables the PLL.  Optionally waits for it to become stable.
  60          *   Waits at least 250 us or until it is detected that the PLL is stable.
  61          *
  62          * Parameters:
  63          *   wait:
  64          *    0: Return immediately after configuration
  65          *    1: Wait for PLL lock or timeout.
  66          *
  67          * Return:
  68          *   Status
  69          *    CYRET_SUCCESS - Completed successfully
  70          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  71          *     If the input source of the clock is jittery, then the lock indication
  72          *     may not occur.  However, after the timeout has expired the generated PLL
  73          *     clock can still be used.
  74          *
  75          * Side Effects:
  76          *  If wait is enabled: This function wses the Fast Time Wheel to time the wait.
  77          *  Any other use of the Fast Time Wheel will be stopped during the period of
  78          *  this function and then restored. This function also uses the 100 KHz ILO.
  79          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  80          *  this function.
  81          *
  82          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  83          *  Once Per Second interrupt may be made by interrupt routines during the period
  84          *  of this function execution. The current operation of the ILO, Central Time
  85          *  Wheel and Once Per Second interrupt are maintained during the operation of
  86          *  this function provided the reading of the Power Manager Interrupt Status
  87          *  Register is only done using the CyPmReadStatus() function.
  88          *
  89          *******************************************************************************/
  90          cystatus CyPLL_OUT_Start(uint8 wait) 
  91          {
  92   1          cystatus status = CYRET_SUCCESS;
  93   1      
  94   1          uint8 iloEnableState;
  95   1          uint8 pmTwCfg0State;
  96   1          uint8 pmTwCfg2State;
  97   1      
  98   1      
  99   1          /* Enables the PLL circuit  */
 100   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 101   1      
 102   1          if(wait != 0u)
 103   1          {
 104   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 105   2              iloEnableState = SLOWCLK_ILO_CR0;
 106   2              pmTwCfg0State = CY_PM_TW_CFG0_REG;
 107   2              pmTwCfg2State = CY_PM_TW_CFG2_REG;
 108   2      
 109   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 110   2      
 111   2              status = CYRET_TIMEOUT;
 112   2      
 113   2      
 114   2              while(CyPmReadStatus(CY_PM_FTW_INT) != CY_PM_FTW_INT)
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 3   

 115   2              {
 116   3                  /* Wait for the interrupt status */
 117   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 118   3                  {
 119   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 120   4                      {
 121   5                          status = CYRET_SUCCESS;
 122   5                          break;
 123   5                      }
 124   4                  }
 125   3              }
 126   2      
 127   2      
 128   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 129   2              if(0u == (iloEnableState & ILO_CONTROL_100KHZ_ON))
 130   2              {
 131   3                  CyILO_Stop100K();
 132   3              }
 133   2              CY_PM_TW_CFG0_REG = pmTwCfg0State;
 134   2              CY_PM_TW_CFG2_REG = pmTwCfg2State;
 135   2          }
 136   1      
 137   1          return(status);
 138   1      }
 139          
 140          
 141          /*******************************************************************************
 142          * Function Name: CyPLL_OUT_Stop
 143          ********************************************************************************
 144          *
 145          * Summary:
 146          *  Disables the PLL.
 147          *
 148          * Parameters:
 149          *  None
 150          *
 151          * Return:
 152          *  None
 153          *
 154          *******************************************************************************/
 155          void CyPLL_OUT_Stop(void) 
 156          {
 157   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 158   1      }
 159          
 160          
 161          /*******************************************************************************
 162          * Function Name: CyPLL_OUT_SetPQ
 163          ********************************************************************************
 164          *
 165          * Summary:
 166          *  Sets the P and Q dividers and the charge pump current.
 167          *  The Frequency Out will be P/Q * Frequency In.
 168          *  The PLL must be disabled before calling this function.
 169          *
 170          * Parameters:
 171          *  uint8 pDiv:
 172          *   Valid range [8 - 255].
 173          *
 174          *  uint8 qDiv:
 175          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 176          
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 4   

 177          *  uint8 current:
 178          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 179          *   datasheet for more information.
 180          *
 181          * Return:
 182          *  None
 183          *
 184          * Side Effects:
 185          *  If as result of this function execution the CPU clock frequency is increased
 186          *  then the number of clock cycles the cache will wait before it samples data
 187          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 188          *  with appropriate parameter. It can be optionally called if CPU clock
 189          *  frequency is lowered in order to improve CPU performance.
 190          *  See CyFlash_SetWaitCycles() description for more information.
 191          *
 192          *******************************************************************************/
 193          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 194          {
 195   1          /* Halt CPU in debug mode if PLL is enabled */
 196   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 197   1      
 198   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 199   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 200   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 201   1          {
 202   2              /* Set new values */
 203   2              CY_CLK_PLL_P_REG = pDiv;
 204   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 205   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 206   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 207   2          }
 208   1          else
 209   1          {
 210   2              /***********************************************************************
 211   2              * Halt CPU in debug mode if:
 212   2              * - P divider is less than required
 213   2              * - Q divider is out of range
 214   2              * - pump current is out of range
 215   2              ***********************************************************************/
 216   2              CYASSERT(0u != 0u);
 217   2          }
 218   1      
 219   1      }
 220          
 221          
 222          /*******************************************************************************
 223          * Function Name: CyPLL_OUT_SetSource
 224          ********************************************************************************
 225          *
 226          * Summary:
 227          *  Sets the input clock source to the PLL. The PLL must be disabled before
 228          *  calling this function.
 229          *
 230          * Parameters:
 231          *   source: One of the three available PLL clock sources
 232          *            0 :        IMO
 233          *            1 :        MHz Crystal
 234          *            2 :        DSI
 235          *
 236          * Return:
 237          *  None
 238          *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 5   

 239          * Side Effects:
 240          *  If as result of this function execution the CPU clock frequency is increased
 241          *  then the number of clock cycles the cache will wait before it samples data
 242          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 243          *  with appropriate parameter. It can be optionally called if CPU clock
 244          *  frequency is lowered in order to improve CPU performance.
 245          *  See CyFlash_SetWaitCycles() description for more information.
 246          *
 247          *******************************************************************************/
 248          void CyPLL_OUT_SetSource(uint8 source) 
 249          {
 250   1          /* Halt CPU in debug mode if PLL is enabled */
 251   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 252   1      
 253   1          switch(source)
 254   1          {
 255   2              case CY_PLL_SOURCE_IMO:
 256   2              case CY_PLL_SOURCE_XTAL:
 257   2              case CY_PLL_SOURCE_DSI:
 258   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 259   2              break;
 260   2      
 261   2              default:
 262   2                  CYASSERT(0u != 0u);
 263   2              break;
 264   2          }
 265   1      }
 266          
 267          
 268          /*******************************************************************************
 269          * Function Name: CyIMO_Start
 270          ********************************************************************************
 271          *
 272          * Summary:
 273          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 274          *
 275          * Parameters:
 276          *  uint8 wait:
 277          *   0: Return immediately after configuration
 278          *   1: Wait for at least 6 us for the IMO to settle.
 279          *
 280          * Return:
 281          *  None
 282          *
 283          * Side Effects:
 284          *  If wait is enabled: This function wses the Fast Time Wheel to time the wait.
 285          *  Any other use of the Fast Time Wheel will be stopped during the period of
 286          *  this function and then restored. This function also uses the 100 KHz ILO.
 287          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 288          *  this function.
 289          *
 290          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 291          *  Once Per Second interrupt may be made by interrupt routines during the period
 292          *  of this function execution. The current operation of the ILO, Central Time
 293          *  Wheel and Once Per Second interrupt are maintained during the operation of
 294          *  this function provided the reading of the Power Manager Interrupt Status
 295          *  Register is only done using the CyPmReadStatus() function.
 296          *
 297          *******************************************************************************/
 298          void CyIMO_Start(uint8 wait) 
 299          {
 300   1          uint8 pmFtwCfg2Reg;
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 6   

 301   1          uint8 pmFtwCfg0Reg;
 302   1          uint8 iloControlReg;
 303   1      
 304   1          /* Set the bit to enable the clock. */
 305   1          PM_ACT_CFG0 |= IMO_PM_ENABLE;
 306   1      
 307   1          /* Wait for 6 us */
 308   1          if(0u != wait)
 309   1          {
 310   2              /* Need to turn on the 100KHz ILO if it happens to not already be running.*/
 311   2              iloControlReg = SLOWCLK_ILO_CR0;
 312   2      
 313   2              if(0u == (iloControlReg & ILO_CONTROL_100KHZ_ON))
 314   2              {
 315   3                  CyILO_Start100K();
 316   3              }
 317   2      
 318   2              /* Use ILO 100 KHz */
 319   2              pmFtwCfg2Reg = PM_TW_CFG2;
 320   2              pmFtwCfg0Reg = PM_TW_CFG0;
 321   2      
 322   2              /* FTW_EN (bit 0) must be clear to change the period*/
 323   2              PM_TW_CFG2 &= FTW_CLEAR_FTW_BITS;
 324   2      
 325   2              /* Set the FTW interval of 1 100KHz ILO clocks
 326   2              Should result in status getting set at a (100/1)KHz rate*/
 327   2              PM_TW_CFG0 = 0u;
 328   2      
 329   2              /* Enable FTW, but not the interrupt */
 330   2              PM_TW_CFG2 = FTW_ENABLE;
 331   2      
 332   2              /* Read FTW value */
 333   2              while (CyPmReadStatus(CY_PM_FTW_INT) == 0u)
 334   2              {
 335   3                  /* Wait for the interrupt status */
 336   3              }
 337   2      
 338   2              /* Reset the clock */
 339   2              if(0u == (iloControlReg & ILO_CONTROL_100KHZ_ON))
 340   2              {
 341   3                  CyILO_Stop100K();
 342   3              }
 343   2      
 344   2              /* Restore the FTW */
 345   2              PM_TW_CFG0 = pmFtwCfg0Reg;
 346   2              PM_TW_CFG2 = pmFtwCfg2Reg;
 347   2          }
 348   1      }
 349          
 350          
 351          /*******************************************************************************
 352          * Function Name: CyIMO_Stop
 353          ********************************************************************************
 354          *
 355          * Summary:
 356          *   Disables the IMO.
 357          *
 358          * Parameters:
 359          *  None
 360          *
 361          * Return:
 362          *  None
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 7   

 363          *
 364          *******************************************************************************/
 365          void CyIMO_Stop(void) 
 366          {
 367   1          /* Clear the bit to disable the clock. */
 368   1          PM_ACT_CFG0 &= ((uint8)(~IMO_PM_ENABLE));
 369   1      }
 370          
 371          
 372          /*******************************************************************************
 373          * Function Name: CyUSB_PowerOnCheck
 374          ********************************************************************************
 375          *
 376          * Summary:
 377          *  Returns the USB power status value. A private function to cy_boot.
 378          *
 379          * Parameters:
 380          *   None
 381          *
 382          * Return:
 383          *   uint8: one if the USB is enabled, 0 if not enabled.
 384          *
 385          *******************************************************************************/
 386          static uint8 CyUSB_PowerOnCheck(void)  
 387          {
 388   1          uint8 poweredOn = 0u;
 389   1      
 390   1          /* Check whether device is in Active or AltActiv and if USB is powered on */
 391   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 392   1             (0u != (CY_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 393   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 394   1             (0u != (CY_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 395   1          {
 396   2              poweredOn = 1u;
 397   2          }
 398   1      
 399   1          return (poweredOn);
 400   1      }
 401          
 402          
 403          /*******************************************************************************
 404          * Function Name: CyIMO_SetTrimValue
 405          ********************************************************************************
 406          *
 407          * Summary:
 408          *  Sets the IMO factory trim values.
 409          *
 410          * Parameters:
 411          *  uint8 freq - frequency for which trims must be set
 412          *
 413          * Return:
 414          *  None
 415          *
 416          *******************************************************************************/
 417          static void CyIMO_SetTrimValue(uint8 freq) 
 418          {
 419   1          uint8 usb_power_on = CyUSB_PowerOnCheck();
 420   1      
 421   1          /* If USB is powered */
 422   1          if(usb_power_on == 1u)
 423   1          {
 424   2              /* Unlock USB write */
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 8   

 425   2              CY_USB_CR1 &= ((uint8)(~CLOCK_USB_ENABLE));
 426   2          }
 427   1          switch(freq)
 428   1          {
 429   2          case CY_IMO_FREQ_3MHZ:
 430   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_3MHZ_PTR);
 431   2              break;
 432   2      
 433   2          case CY_IMO_FREQ_6MHZ:
 434   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_6MHZ_PTR);
 435   2              break;
 436   2      
 437   2          case CY_IMO_FREQ_12MHZ:
 438   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_12MHZ_PTR);
 439   2              break;
 440   2      
 441   2          case CY_IMO_FREQ_24MHZ:
 442   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_24MHZ_PTR);
 443   2              break;
 444   2      
 445   2          case CY_IMO_FREQ_48MHZ:
 446   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_MFG_CFG_IMO_TR1_PTR);
 447   2              break;
 448   2      
 449   2          /* The IMO frequencies above 48 MHz are not supported by PSoC5 */
 450   2          #if(!CY_PSOC5A)
 451   2      
 452   2              case CY_IMO_FREQ_62MHZ:
 453   2                  IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_67MHZ_PTR);
 454   2                  break;
 455   2      
 456   2          #endif  /* (!CY_PSOC5A) */
 457   2      
 458   2          case CY_IMO_FREQ_USB:
 459   2              IMO_TR1 = CY_GET_XTND_REG8(FLSHID_CUST_TABLES_IMO_USB_PTR);
 460   2      
 461   2              /* If USB is powered */
 462   2              if(usb_power_on == 1u)
 463   2              {
 464   3                  /* Lock the USB Oscillator */
 465   3                  CY_USB_CR1 |= CLOCK_USB_ENABLE;
 466   3              }
 467   2              break;
 468   2      
 469   2          default:
 470   2                  CYASSERT(0u != 0u);
 471   2              break;
 472   2          }
 473   1      
 474   1      }
 475          
 476          
 477          /*******************************************************************************
 478          * Function Name: CyIMO_SetFreq
 479          ********************************************************************************
 480          *
 481          * Summary:
 482          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 483          *
 484          * Parameters:
 485          *  freq: Frequency of IMO operation
 486          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 9   

 487          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 488          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 489          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 490          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 491          *       CY_IMO_FREQ_62MHZ to set 62 MHz (unsupported by PSoC 5)
 492          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 493          *
 494          * Return:
 495          *  None
 496          *
 497          * Side Effects:
 498          *  If as result of this function execution the CPU clock frequency is increased
 499          *  then the number of clock cycles the cache will wait before it samples data
 500          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 501          *  with appropriate parameter. It can be optionally called if CPU clock
 502          *  frequency is lowered in order to improve CPU performance.
 503          *  See CyFlash_SetWaitCycles() description for more information.
 504          *
 505          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 506          *  Otherwise this circuit is disabled. The USB block must be powered before
 507          *  selecting the USB setting.
 508          *
 509          *******************************************************************************/
 510          void CyIMO_SetFreq(uint8 freq) 
 511          {
 512   1          uint8 currentFreq;
 513   1          uint8 nextFreq;
 514   1      
 515   1          /***************************************************************************
 516   1          * When changing the IMO frequency the Trim values must also be set
 517   1          * accordingly.This requires reading the current frequency. If the new
 518   1          * frequency is faster, then set the new trim and then change the frequency,
 519   1          * otherwise change the frequency and then set the new trim values.
 520   1          ***************************************************************************/
 521   1      
 522   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 523   1      
 524   1          /* Check if the requested frequency is USB. */
 525   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 526   1      
 527   1          switch (currentFreq)
 528   1          {
 529   2          case 0u:
 530   2              currentFreq = CY_IMO_FREQ_12MHZ;
 531   2              break;
 532   2      
 533   2          case 1u:
 534   2              currentFreq = CY_IMO_FREQ_6MHZ;
 535   2              break;
 536   2      
 537   2          case 2u:
 538   2              currentFreq = CY_IMO_FREQ_24MHZ;
 539   2              break;
 540   2      
 541   2          case 3u:
 542   2              currentFreq = CY_IMO_FREQ_3MHZ;
 543   2              break;
 544   2      
 545   2          case 4u:
 546   2              currentFreq = CY_IMO_FREQ_48MHZ;
 547   2              break;
 548   2      
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 10  

 549   2          /* The IMO frequencies above 48 MHz are not supported by PSoC5 */
 550   2          #if(!CY_PSOC5A)
 551   2      
 552   2              case 5u:
 553   2                  currentFreq = CY_IMO_FREQ_62MHZ;
 554   2                  break;
 555   2      
 556   2          #endif  /* (!CY_PSOC5A) */
 557   2      
 558   2          default:
 559   2              CYASSERT(0u != 0u);
 560   2              break;
 561   2          }
 562   1      
 563   1          if (nextFreq >= currentFreq)
 564   1          {
 565   2              /* Set the new trim first */
 566   2              CyIMO_SetTrimValue(freq);
 567   2          }
 568   1      
 569   1          /* Set the usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 570   1          switch(freq)
 571   1          {
 572   2          case CY_IMO_FREQ_3MHZ:
 573   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 574   2                  CLOCK_IMO_3MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 575   2              break;
 576   2      
 577   2          case CY_IMO_FREQ_6MHZ:
 578   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 579   2                  CLOCK_IMO_6MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 580   2              break;
 581   2      
 582   2          case CY_IMO_FREQ_12MHZ:
 583   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 584   2                  CLOCK_IMO_12MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 585   2              break;
 586   2      
 587   2          case CY_IMO_FREQ_24MHZ:
 588   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 589   2                  CLOCK_IMO_24MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 590   2              break;
 591   2      
 592   2          case CY_IMO_FREQ_48MHZ:
 593   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 594   2                  CLOCK_IMO_48MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 595   2              break;
 596   2      
 597   2          /* The IMO frequencies above 48 MHz are not supported by PSoC5 */
 598   2          #if(!CY_PSOC5A)
 599   2      
 600   2          case CY_IMO_FREQ_62MHZ:
 601   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 602   2                  CLOCK_IMO_62MHZ_VALUE) & ((uint8)(~FASTCLK_IMO_USBCLK_ON_SET));
 603   2              break;
 604   2      
 605   2          #endif  /* (!CY_PSOC5A) */
 606   2      
 607   2          case CY_IMO_FREQ_USB:
 608   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 609   2                  CLOCK_IMO_24MHZ_VALUE) | FASTCLK_IMO_USBCLK_ON_SET;
 610   2              break;
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 11  

 611   2      
 612   2          default:
 613   2              CYASSERT(0u != 0u);
 614   2              break;
 615   2          }
 616   1      
 617   1          /* Turn on the IMO Doubler, if switching to CY_IMO_FREQ_USB */
 618   1          if (freq == CY_IMO_FREQ_USB)
 619   1          {
 620   2              CyIMO_EnableDoubler();
 621   2          }
 622   1          else
 623   1          {
 624   2              CyIMO_DisableDoubler();
 625   2          }
 626   1      
 627   1          if (nextFreq < currentFreq)
 628   1          {
 629   2              /* Set the new trim after setting the frequency */
 630   2              CyIMO_SetTrimValue(freq);
 631   2          }
 632   1      }
 633          
 634          
 635          /*******************************************************************************
 636          * Function Name: CyIMO_SetSource
 637          ********************************************************************************
 638          *
 639          * Summary:
 640          *  Sets the source of the clock output from the IMO block.
 641          *
 642          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 643          *  Crystal or a DSI input can be the source of the IMO output instead.
 644          *
 645          * Parameters:
 646          *   source, CY_IMO_SOURCE_DSI to set the DSI as source.
 647          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 648          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 649          *
 650          * Return:
 651          *  None
 652          *
 653          * Side Effects:
 654          *  If as result of this function execution the CPU clock frequency is increased
 655          *  then the number of clock cycles the cache will wait before it samples data
 656          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 657          *  with appropriate parameter. It can be optionally called if CPU clock
 658          *  frequency is lowered in order to improve CPU performance.
 659          *  See CyFlash_SetWaitCycles() description for more information.
 660          *
 661          *******************************************************************************/
 662          void CyIMO_SetSource(uint8 source) 
 663          {
 664   1          switch(source)
 665   1          {
 666   2          case CY_IMO_SOURCE_DSI:
 667   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 668   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 669   2              break;
 670   2      
 671   2          case CY_IMO_SOURCE_XTAL:
 672   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 12  

 673   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 674   2              break;
 675   2      
 676   2          case CY_IMO_SOURCE_IMO:
 677   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 678   2              break;
 679   2      
 680   2          default:
 681   2              /* Incorrect source value */
 682   2              CYASSERT(0u != 0u);
 683   2              break;
 684   2          }
 685   1      }
 686          
 687          
 688          /*******************************************************************************
 689          * Function Name: CyIMO_EnableDoubler
 690          ********************************************************************************
 691          *
 692          * Summary:
 693          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 694          *  input to a 48 MHz output for use by the USB block.
 695          *
 696          * Parameters:
 697          *  None
 698          *
 699          * Return:
 700          *  None
 701          *
 702          *******************************************************************************/
 703          void CyIMO_EnableDoubler(void) 
 704          {
 705   1          /* Set the FASTCLK_IMO_CR_PTR regigster's 4th bit */
 706   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 707   1      }
 708          
 709          
 710          /*******************************************************************************
 711          * Function Name: CyIMO_DisableDoubler
 712          ********************************************************************************
 713          *
 714          * Summary:
 715          *   Disables the IMO doubler.
 716          *
 717          * Parameters:
 718          *  None
 719          *
 720          * Return:
 721          *  None
 722          *
 723          *******************************************************************************/
 724          void CyIMO_DisableDoubler(void) 
 725          {
 726   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 727   1      }
 728          
 729          
 730          /*******************************************************************************
 731          * Function Name: CyMasterClk_SetSource
 732          ********************************************************************************
 733          *
 734          * Summary:
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 13  

 735          *  Sets the source of the master clock.
 736          *
 737          * Parameters:
 738          *   source: One of the four available Master clock sources.
 739          *     CY_MASTER_SOURCE_IMO
 740          *     CY_MASTER_SOURCE_PLL
 741          *     CY_MASTER_SOURCE_XTAL
 742          *     CY_MASTER_SOURCE_DSI
 743          *
 744          * Return:
 745          *  None
 746          *
 747          * Side Effects:
 748          *  The current source and the new source must both be running and stable before
 749          *  calling this function.
 750          *
 751          *  If as result of this function execution the CPU clock frequency is increased
 752          *  then the number of clock cycles the cache will wait before it samples data
 753          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 754          *  with appropriate parameter. It can be optionally called if CPU clock
 755          *  frequency is lowered in order to improve CPU performance.
 756          *  See CyFlash_SetWaitCycles() description for more information.
 757          *
 758          *******************************************************************************/
 759          void CyMasterClk_SetSource(uint8 source) 
 760          {
 761   1          #if(CY_PSOC5A)
              
                      uint8 masterReg0;
              
                      /* Read the current setting */
                      masterReg0 = CY_LIB_CLKDIST_MSTR0_REG;
              
                      /* Write a non-zero period to the master mux clock divider */
                      if (masterReg0 == 0x00u)
                      {
                          CY_LIB_CLKDIST_MSTR0_REG = 3u;
                      }
              
                  #endif  /* (CY_PSOC5A) */
 775   1      
 776   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 777   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 778   1      
 779   1          #if(CY_PSOC5A)
              
                      /* Restore zero period (if desired) to the master mux clock divider */
                      if (masterReg0 == 0x00u)
                      {
                          CY_LIB_CLKDIST_MSTR0_REG = 0u;
                      }
              
                  #endif  /* (CY_PSOC5A) */
 788   1      }
 789          
 790          
 791          /*******************************************************************************
 792          * Function Name: CyMasterClk_SetDivider
 793          ********************************************************************************
 794          *
 795          * Summary:
 796          *  Sets the divider value used to generate Master Clock.
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 14  

 797          *
 798          * Parameters:
 799          *  uint8 divider:
 800          *   Valid range [0-255]. The clock will be divided by this value + 1.
 801          *   For example to divide by 2 this parameter should be set to 1.
 802          *
 803          * Return:
 804          *  None
 805          *
 806          * Side Effects:
 807          *  If as result of this function execution the CPU clock frequency is increased
 808          *  then the number of clock cycles the cache will wait before it samples data
 809          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 810          *  with appropriate parameter. It can be optionally called if CPU clock
 811          *  frequency is lowered in order to improve CPU performance.
 812          *  See CyFlash_SetWaitCycles() description for more information.
 813          *
 814          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 815          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 816          *  than the final/expected div-by-1 period.
 817          *
 818          *******************************************************************************/
 819          void CyMasterClk_SetDivider(uint8 divider) 
 820          {
 821   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 822   1      }
 823          
 824          
 825          /*******************************************************************************
 826          * Function Name: CyBusClk_Internal_SetDivider
 827          ********************************************************************************
 828          *
 829          * Summary:
 830          *  Function used by CyBusClk_SetDivider(). For internal use only.
 831          *
 832          * Parameters:
 833          *   divider: Valid range [0-65535].
 834          *   The clock will be divided by this value + 1.
 835          *   For example to divide by 2 this parameter should be set to 1.
 836          *
 837          * Return:
 838          *  None
 839          *
 840          *******************************************************************************/
 841          static void CyBusClk_Internal_SetDivider(uint16 divider)
 842          {
 843   1          /* Mask bits to enable shadow loads  */
 844   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 845   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 846   1      
 847   1          /* Enable mask bits to enable shadow loads */
 848   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 849   1      
 850   1          /* Update Shadow Divider Value Register with the new divider */
 851   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 852   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 853   1      
 854   1      
 855   1          /***************************************************************************
 856   1          * Copy shadow value defined in Shadow Divider Value Register
 857   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 858   1          * dividers selected in Analog and Digital Clock Mask Registers
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 15  

 859   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 860   1          ***************************************************************************/
 861   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 862   1      }
 863          
 864          
 865          /*******************************************************************************
 866          * Function Name: CyBusClk_SetDivider
 867          ********************************************************************************
 868          *
 869          * Summary:
 870          *  Sets the divider value used to generate Bus Clock.
 871          *
 872          * Parameters:
 873          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 874          *  For example to divide by 2 this parameter should be set to 1.
 875          *
 876          * Return:
 877          *  None
 878          *
 879          * Side Effects:
 880          *  If as result of this function execution the CPU clock frequency is increased
 881          *  then the number of clock cycles the cache will wait before it samples data
 882          *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 883          *  with appropriate parameter. It can be optionally called if CPU clock
 884          *  frequency is lowered in order to improve CPU performance.
 885          *  See CyFlash_SetWaitCycles() description for more information.
 886          *
 887          *******************************************************************************/
 888          void CyBusClk_SetDivider(uint16 divider) 
 889          {
 890   1          uint8  masterClkDiv;
 891   1          uint16 busClkDiv;
 892   1          uint8 interruptState;
 893   1      
 894   1          interruptState = CyEnterCriticalSection();
 895   1      
 896   1          /* Work around to set the bus clock divider value */
 897   1          busClkDiv = ((uint16)(((uint16)(CY_LIB_CLKDIST_BCFG_MSB_REG)) << 8u)) | CY_LIB_CLKDIST_BCFG_LSB_REG;
 898   1      
 899   1          if ((divider == 0u) || (busClkDiv == 0u))
 900   1          {
 901   2              /* Save away the master clock divider value */
 902   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 903   2      
 904   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 905   2              {
 906   3                  /* Set master clock divider to 7 */
 907   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 908   3              }
 909   2      
 910   2              if (divider == 0u)
 911   2              {
 912   3                  /* Set the SSS bit and the divider register desired value */
 913   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 914   3                  CyBusClk_Internal_SetDivider(divider);
 915   3              }
 916   2              else
 917   2              {
 918   3                  CyBusClk_Internal_SetDivider(divider);
 919   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 920   3              }
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 16  

 921   2      
 922   2              /* Restore the master clock */
 923   2              CyMasterClk_SetDivider(masterClkDiv);
 924   2          }
 925   1          else
 926   1          {
 927   2              CyBusClk_Internal_SetDivider(divider);
 928   2          }
 929   1      
 930   1          CyExitCriticalSection(interruptState);
 931   1      }
 932          
 933          
 934          #if(CY_PSOC3)
 935          
 936              /*******************************************************************************
 937              * Function Name: CyCpuClk_SetDivider
 938              ********************************************************************************
 939              *
 940              * Summary:
 941              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 942              *  PSoC 3 parts.
 943              *
 944              * Parameters:
 945              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 946              *  For example to divide by 2 this parameter should be set to 1.
 947              *
 948              * Return:
 949              *  None
 950              *
 951              * Side Effects:
 952              *  If as result of this function execution the CPU clock frequency is increased
 953              *  then the number of clock cycles the cache will wait before it samples data
 954              *  coming back from Flash must be adjusted by calling CyFlash_SetWaitCycles()
 955              *  with appropriate parameter. It can be optionally called if CPU clock
 956              *  frequency is lowered in order to improve CPU performance.
 957              *  See CyFlash_SetWaitCycles() description for more information.
 958              *
 959              *******************************************************************************/
 960              void CyCpuClk_SetDivider(uint8 divider) 
 961              {
 962   1                  CLKDIST_MSTR1 = (CLKDIST_MSTR1 & CLKDIST_MSTR1_DIV_CLEAR) |
 963   1                                      ((uint8)(divider << CLKDIST_DIV_POSITION));
 964   1          }
 965          
 966          #endif /* (CY_PSOC3) */
 967          
 968          
 969          /*******************************************************************************
 970          * Function Name: CyUsbClk_SetSource
 971          ********************************************************************************
 972          *
 973          * Summary:
 974          *  Sets the source of the USB clock.
 975          *
 976          * Parameters:
 977          *  source: One of the four available USB clock sources
 978          *             USB_CLK_IMO2X     - IMO 2x
 979          *             USB_CLK_IMO       - IMO
 980          *             USB_CLK_PLL       - PLL
 981          *             USB_CLK_DSI       - DSI
 982          *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 17  

 983          * Return:
 984          *  None
 985          *
 986          *******************************************************************************/
 987          void CyUsbClk_SetSource(uint8 source) 
 988          {
 989   1          CLKDIST_UCFG = (CLKDIST_UCFG & ((uint8)(~USB_CLKDIST_CONFIG_MASK))) |
 990   1                              (USB_CLKDIST_CONFIG_MASK & source);
 991   1      }
 992          
 993          
 994          /*******************************************************************************
 995          * Function Name: CyILO_Start1K
 996          ********************************************************************************
 997          *
 998          * Summary:
 999          *  Enables the ILO 1 KHz oscillator.
1000          *
1001          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
1002          *  selection in the Clock Editor. Therefore, this API is only needed if the
1003          *  oscillator was turned off manually.
1004          *
1005          * Parameters:
1006          *  None
1007          *
1008          * Return:
1009          *  None
1010          *
1011          *******************************************************************************/
1012          void CyILO_Start1K(void) 
1013          {
1014   1          /* Set the bit 1 of ILO RS */
1015   1          SLOWCLK_ILO_CR0 |= ILO_CONTROL_1KHZ_ON;
1016   1      }
1017          
1018          
1019          /*******************************************************************************
1020          * Function Name: CyILO_Stop1K
1021          ********************************************************************************
1022          *
1023          * Summary:
1024          *  Disables the ILO 1 KHz oscillator.
1025          *
1026          *  Note The ILO 1 KHz oscillator must be enabled if Sleep or Hibernate low power
1027          *  mode APIs are expected to be used. For more information, refer to the Power
1028          *  Management section of this document.
1029          *
1030          * Parameters:
1031          *  None
1032          *
1033          * Return:
1034          *  None
1035          *
1036          * Side Effects:
1037          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1038          *
1039          *******************************************************************************/
1040          void CyILO_Stop1K(void) 
1041          {
1042   1          /* Clear the bit 1 of ILO RS */
1043   1          SLOWCLK_ILO_CR0 &= ((uint8)(~ILO_CONTROL_1KHZ_ON));
1044   1      }
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 18  

1045          
1046          
1047          /*******************************************************************************
1048          * Function Name: CyILO_Start100K
1049          ********************************************************************************
1050          *
1051          * Summary:
1052          *  Enables the ILO 100 KHz oscillator.
1053          *
1054          * Parameters:
1055          *  None
1056          *
1057          * Return:
1058          *  None
1059          *
1060          *******************************************************************************/
1061          void CyILO_Start100K(void) 
1062          {
1063   1          /* Set the bit 2 of ILO RS */
1064   1          SLOWCLK_ILO_CR0 |= ILO_CONTROL_100KHZ_ON;
1065   1      }
1066          
1067          
1068          /*******************************************************************************
1069          * Function Name: CyILO_Stop100K
1070          ********************************************************************************
1071          *
1072          * Summary:
1073          *  Disables the ILO 100 KHz oscillator.
1074          *
1075          * Parameters:
1076          *  None
1077          *
1078          * Return:
1079          *  None
1080          *
1081          *******************************************************************************/
1082          void CyILO_Stop100K(void) 
1083          {
1084   1          /* Clear the bit 2 of ILO RS */
1085   1          SLOWCLK_ILO_CR0 &= ((uint8)(~ILO_CONTROL_100KHZ_ON));
1086   1      }
1087          
1088          
1089          /*******************************************************************************
1090          * Function Name: CyILO_Enable33K
1091          ********************************************************************************
1092          *
1093          * Summary:
1094          *  Enables the ILO 33 KHz divider.
1095          *
1096          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1097          *  so it must also be running in order to generate the 33 KHz output.
1098          *
1099          * Parameters:
1100          *  None
1101          *
1102          * Return:
1103          *  None
1104          *
1105          *******************************************************************************/
1106          void CyILO_Enable33K(void) 
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 19  

1107          {
1108   1          /* Set the bit 5 of ILO RS */
1109   1          SLOWCLK_ILO_CR0 |= ILO_CONTROL_33KHZ_ON;
1110   1      }
1111          
1112          
1113          /*******************************************************************************
1114          * Function Name: CyILO_Disable33K
1115          ********************************************************************************
1116          *
1117          * Summary:
1118          *  Disables the ILO 33 KHz divider.
1119          *
1120          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1121          *  API does not disable the 100 KHz clock.
1122          *
1123          * Parameters:
1124          *  None
1125          *
1126          * Return:
1127          *  None
1128          *
1129          *******************************************************************************/
1130          void CyILO_Disable33K(void) 
1131          {
1132   1          /* Clear the bit 5 of ILO RS */
1133   1          SLOWCLK_ILO_CR0 &= ((uint8)(~ILO_CONTROL_33KHZ_ON));
1134   1      }
1135          
1136          
1137          /*******************************************************************************
1138          * Function Name: CyILO_SetSource
1139          ********************************************************************************
1140          *
1141          * Summary:
1142          *  Sets the source of the clock output from the ILO block.
1143          *
1144          * Parameters:
1145          *  source: One of the three available ILO output sources
1146          *       Value        Define                Source
1147          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1148          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1149          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1150          *
1151          * Return:
1152          *  None
1153          *
1154          *******************************************************************************/
1155          void CyILO_SetSource(uint8 source) 
1156          {
1157   1          CLKDIST_CR = (CLKDIST_CR & CY_ILO_SOURCE_BITS_CLEAR) |
1158   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1159   1      }
1160          
1161          
1162          /*******************************************************************************
1163          * Function Name: CyILO_SetPowerMode
1164          ********************************************************************************
1165          *
1166          * Summary:
1167          *  Sets the power mode used by the ILO during power down. Allows for lower power
1168          *  down power usage resulting in a slower startup time.
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 20  

1169          *
1170          * Parameters:
1171          *  uint8 mode
1172          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1173          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1174          *
1175          * Return:
1176          *   Prevous power mode state.
1177          *
1178          *******************************************************************************/
1179          uint8 CyILO_SetPowerMode(uint8 mode) 
1180          {
1181   1          uint8 state;
1182   1      
1183   1          /* Get current state. */
1184   1          state = SLOWCLK_ILO_CR0;
1185   1      
1186   1          /* Set the the oscillator power mode. */
1187   1          if(mode != CY_ILO_FAST_START)
1188   1          {
1189   2              SLOWCLK_ILO_CR0 = (state | ILO_CONTROL_PD_MODE);
1190   2          }
1191   1          else
1192   1          {
1193   2              SLOWCLK_ILO_CR0 = (state & ((uint8)(~ILO_CONTROL_PD_MODE)));
1194   2          }
1195   1      
1196   1          /* Return the old mode. */
1197   1          return ((state & ILO_CONTROL_PD_MODE) >> ILO_CONTROL_PD_POSITION);
1198   1      }
1199          
1200          
1201          /*******************************************************************************
1202          * Function Name: CyXTAL_32KHZ_Start
1203          ********************************************************************************
1204          *
1205          * Summary:
1206          *  Enables the 32 KHz Crystal Oscillator.
1207          *
1208          * Parameters:
1209          *  None
1210          *
1211          * Return:
1212          *  None
1213          *
1214          *******************************************************************************/
1215          void CyXTAL_32KHZ_Start(void) 
1216          {
1217   1          volatile uint16 i;
1218   1      
1219   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1220   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1221   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1222   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1223   1      
1224   1          #if(CY_PSOC3)
1225   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1226   1          #endif  /* (CY_PSOC3) */
1227   1      
1228   1          /* Enable operation of the 32K Crystal Oscillator */
1229   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1230   1      
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 21  

1231   1          for (i = 1000u; i > 0u; i--)
1232   1          {
1233   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1234   2              {
1235   3                  /* Ready - switch to the hign power mode */
1236   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1237   3      
1238   3                  break;
1239   3              }
1240   2              CyDelayUs(1u);
1241   2          }
1242   1      }
1243          
1244          
1245          /*******************************************************************************
1246          * Function Name: CyXTAL_32KHZ_Stop
1247          ********************************************************************************
1248          *
1249          * Summary:
1250          *  Disables the 32KHz Crystal Oscillator.
1251          *
1252          * Parameters:
1253          *  None
1254          *
1255          * Return:
1256          *  None
1257          *
1258          *******************************************************************************/
1259          void CyXTAL_32KHZ_Stop(void) 
1260          {
1261   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1262   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1263   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) | CY_CLK_XTAL3
             -2_CFG_LP_DEFAULT;
1264   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1265   1      
1266   1          #if(CY_PSOC3)
1267   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1268   1          #endif  /* (CY_PSOC3) */
1269   1      }
1270          
1271          
1272          /*******************************************************************************
1273          * Function Name: CyXTAL_32KHZ_ReadStatus
1274          ********************************************************************************
1275          *
1276          * Summary:
1277          *  Returns status of the 32 KHz oscillator.
1278          *
1279          * Parameters:
1280          *  None
1281          *
1282          * Return:
1283          *  Value     Define                    Source
1284          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1285          *                                       1: Stable
1286          *                                       0: Not stable
1287          *
1288          *******************************************************************************/
1289          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1290          {
1291   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 22  

1292   1      }
1293          
1294          
1295          /*******************************************************************************
1296          * Function Name: CyXTAL_32KHZ_SetPowerMode
1297          ********************************************************************************
1298          *
1299          * Summary:
1300          *  Sets the power mode for the 32 KHz oscillator used during sleep mode.
1301          *  Allows for lower power during sleep when there are fewer sources of noise.
1302          *  During active mode the oscillator is always run in high power mode.
1303          *
1304          * Parameters:
1305          *  uint8 mode
1306          *       0: High power mode
1307          *       1: Low power mode during sleep
1308          *
1309          * Return:
1310          *  Previous power mode.
1311          *
1312          *******************************************************************************/
1313          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1314          {
1315   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1316   1      
1317   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1318   1      
1319   1          if(1u == mode)
1320   1          {
1321   2              /* Low power mode during Sleep */
1322   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1323   2              CyDelayUs(10u);
1324   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) | CY_CLK_X
             -TAL32_CFG_LP_LOWPOWER;
1325   2              CyDelayUs(20u);
1326   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1327   2          }
1328   1          else
1329   1          {
1330   2              /* High power mode */
1331   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1332   2              CyDelayUs(10u);
1333   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) | CY_CLK_X
             -TAL32_CFG_LP_DEFAULT;
1334   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1335   2          }
1336   1      
1337   1          return(state);
1338   1      }
1339          
1340          
1341          /*******************************************************************************
1342          * Function Name: CyXTAL_Start
1343          ********************************************************************************
1344          *
1345          * Summary:
1346          *  Enables the megahertz crystal.
1347          *
1348          *  PSoC3:
1349          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1350          *  number of milliseconds specified by the wait parameter has expired.
1351          *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 23  

1352          *  PSoC5:
1353          *  Waits for CY_CLK_XMHZ_MIN_TIMEOUT milliseconds (or number of milliseconds
1354          *  specified by parameter if it is greater than CY_CLK_XMHZ_MIN_TIMEOUT. The
1355          *  XERR bit status is not checked.
1356          *
1357          * Parameters:
1358          *   wait: Valid range [0-255].
1359          *   This is the timeout value in milliseconds.
1360          *   The appropriate value is crystal specific.
1361          *
1362          * Return:
1363          *   CYRET_SUCCESS - Completed successfully
1364          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1365          *
1366          * Side Effects and Restrictions:
1367          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1368          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1369          *  of this function and then restored.
1370          *
1371          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1372          *  ILO for the period of this function. No changes to the setup of the ILO,
1373          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1374          *  by interrupt routines during the period of this function.
1375          *
1376          *  The current operation of the ILO, Central Timewheel and Once Per Second
1377          *  interrupt are maintained during the operation of this function provided the
1378          *  reading of the Power Manager Interrupt Status Register is only done using the
1379          *  CyPmReadStatus() function.
1380          *
1381          *******************************************************************************/
1382          cystatus CyXTAL_Start(uint8 wait) 
1383          {
1384   1          cystatus status = CYRET_SUCCESS;
1385   1      
1386   1          #if(CY_PSOC5A)
                      volatile uint8  timeout = (wait < CY_CLK_XMHZ_MIN_TIMEOUT) ? CY_CLK_XMHZ_MIN_TIMEOUT : wait;
                  #else
1389   1              volatile uint8  timeout = wait;
1390   1          #endif  /* (CY_PSOC5A) */
1391   1      
1392   1          volatile uint8 count;
1393   1          uint8 iloEnableState;
1394   1          uint8 pmTwCfg0Tmp;
1395   1          uint8 pmTwCfg2Tmp;
1396   1      
1397   1      
1398   1          /* Enables the MHz crystal oscillator circuit  */
1399   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1400   1      
1401   1      
1402   1          if(wait > 0u)
1403   1          {
1404   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1405   2              iloEnableState = SLOWCLK_ILO_CR0;
1406   2              pmTwCfg0Tmp = CY_PM_TW_CFG0_REG;
1407   2              pmTwCfg2Tmp = CY_PM_TW_CFG2_REG;
1408   2      
1409   2              /* Set 250 us interval */
1410   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1411   2              status = CYRET_TIMEOUT;
1412   2      
1413   2      
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 24  

1414   2              for( ; timeout > 0u; timeout--)
1415   2              {
1416   3                  #if(!CY_PSOC5A)
1417   3      
1418   3                      /* Read XERR bit to clear it */
1419   3                      (void) CY_CLK_XMHZ_CSR_REG;
1420   3      
1421   3                  #endif  /* (!CY_PSOC5A) */
1422   3      
1423   3      
1424   3                  /* Wait for a millisecond - 4 x 250 us */
1425   3                  for(count = 4u; count > 0u; count--)
1426   3                  {
1427   4                      while(!(CY_PM_FTW_INT == CyPmReadStatus(CY_PM_FTW_INT)))
1428   4                      {
1429   5                          /* Wait for the FTW interrupt event */
1430   5                      }
1431   4                  }
1432   3      
1433   3      
1434   3                  #if(!CY_PSOC5A)
1435   3      
1436   3                      /*******************************************************************
1437   3                      * High output indicates oscillator failure.
1438   3                      * Only can be used after start-up interval (1 ms) is completed.
1439   3                      *******************************************************************/
1440   3                      if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1441   3                      {
1442   4                          status = CYRET_SUCCESS;
1443   4                          break;
1444   4                      }
1445   3      
1446   3                  #endif  /* (!CY_PSOC5A) */
1447   3              }
1448   2      
1449   2      
1450   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1451   2              if(0u == (iloEnableState & ILO_CONTROL_100KHZ_ON))
1452   2              {
1453   3                  CyILO_Stop100K();
1454   3              }
1455   2              CY_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1456   2              CY_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1457   2          }
1458   1      
1459   1          return(status);
1460   1      }
1461          
1462          
1463          /*******************************************************************************
1464          * Function Name: CyXTAL_Stop
1465          ********************************************************************************
1466          *
1467          * Summary:
1468          *  Disables the megahertz crystal oscillator.
1469          *
1470          * Parameters:
1471          *  None
1472          *
1473          * Return:
1474          *  None
1475          *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 25  

1476          *******************************************************************************/
1477          void CyXTAL_Stop(void) 
1478          {
1479   1          /* Disable the the oscillator. */
1480   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1481   1      }
1482          
1483          
1484          #if(!CY_PSOC5A)
1485          
1486              /*******************************************************************************
1487              * Function Name: CyXTAL_EnableErrStatus
1488              ********************************************************************************
1489              *
1490              * Summary:
1491              *  Enables the generation of the XERR status bit for the megahertz crystal.
1492              *  This function is not available for PSoC5.
1493              *
1494              * Parameters:
1495              *  None
1496              *
1497              * Return:
1498              *  None
1499              *
1500              *******************************************************************************/
1501              void CyXTAL_EnableErrStatus(void) 
1502              {
1503   1              /* If oscillator has insufficient amplitude, XERR bit will be high. */
1504   1              CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1505   1          }
1506          
1507          
1508              /*******************************************************************************
1509              * Function Name: CyXTAL_DisableErrStatus
1510              ********************************************************************************
1511              *
1512              * Summary:
1513              *  Disables the generation of the XERR status bit for the megahertz crystal.
1514              *  This function is not available for PSoC5.
1515              *
1516              * Parameters:
1517              *  None
1518              *
1519              * Return:
1520              *  None
1521              *
1522              *******************************************************************************/
1523              void CyXTAL_DisableErrStatus(void) 
1524              {
1525   1              /* If oscillator has insufficient amplitude, XERR bit will be high. */
1526   1              CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1527   1          }
1528          
1529          
1530              /*******************************************************************************
1531              * Function Name: CyXTAL_ReadStatus
1532              ********************************************************************************
1533              *
1534              * Summary:
1535              *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1536              *  sticky clear on read value. This function is not available for PSoC5.
1537              *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 26  

1538              * Parameters:
1539              *  None
1540              *
1541              * Return:
1542              *   Status
1543              *    0: No error
1544              *    1: Error
1545              *
1546              *******************************************************************************/
1547              uint8 CyXTAL_ReadStatus(void) 
1548              {
1549   1              /***************************************************************************
1550   1              * High output indicates oscillator failure. Only use this after start-up
1551   1              * interval is completed. This can be used for status and failure recovery.
1552   1              ***************************************************************************/
1553   1              return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1554   1          }
1555          
1556          
1557              /*******************************************************************************
1558              * Function Name: CyXTAL_EnableFaultRecovery
1559              ********************************************************************************
1560              *
1561              * Summary:
1562              *  Enables the fault recovery circuit which will switch to the IMO in the case
1563              *  of a fault in the megahertz crystal circuit. The crystal must be up and
1564              *  running with the XERR bit at 0, before calling this function to prevent
1565              *  immediate fault switchover. This function is not available for PSoC5.
1566              *
1567              * Parameters:
1568              *  None
1569              *
1570              * Return:
1571              *  None
1572              *
1573              *******************************************************************************/
1574              void CyXTAL_EnableFaultRecovery(void) 
1575              {
1576   1              CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1577   1          }
1578          
1579          
1580              /*******************************************************************************
1581              * Function Name: CyXTAL_DisableFaultRecovery
1582              ********************************************************************************
1583              *
1584              * Summary:
1585              *  Disables the fault recovery circuit which will switch to the IMO in the case
1586              *  of a fault in the megahertz crystal circuit. This function is not available
1587              *  for PSoC5.
1588              *
1589              * Parameters:
1590              *  None
1591              *
1592              * Return:
1593              *  None
1594              *
1595              *******************************************************************************/
1596              void CyXTAL_DisableFaultRecovery(void) 
1597              {
1598   1              CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1599   1          }
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 27  

1600          
1601          #endif  /* (!CY_PSOC5A) */
1602          
1603          /*******************************************************************************
1604          * Function Name: CyXTAL_SetStartup
1605          ********************************************************************************
1606          *
1607          * Summary:
1608          *  Sets the startup settings for the crystal. Logic model outputs a frequency
1609          *  (setting + 4) MHz when enabled.
1610          *
1611          *  This is artificial as the actual frequency is determined by an attached
1612          *  external crystal.
1613          *
1614          * Parameters:
1615          *  setting: Valid range [0-31].
1616          *   Value is dependent on the frequency and quality of the crystal being used.
1617          *   Refer to the device TRM and datasheet for more information.
1618          *
1619          * Return:
1620          *  None
1621          *
1622          *******************************************************************************/
1623          void CyXTAL_SetStartup(uint8 setting) 
1624          {
1625   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1626   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1627   1      }
1628          
1629          
1630          #if(CY_PSOC3 || CY_PSOC5LP)
1631              /*******************************************************************************
1632              * Function Name: CyXTAL_SetFbVoltage
1633              ********************************************************************************
1634              *
1635              * Summary:
1636              *  Sets the feedback reference voltage to use for the crystal circuit.
1637              *  This function is only available for PSoC3 and PSoC 5LP.
1638              *
1639              * Parameters:
1640              *  setting: Valid range [0-15].
1641              *  Refer to the device TRM and datasheet for more information.
1642              *
1643              * Return:
1644              *  None
1645              *
1646              *******************************************************************************/
1647              void CyXTAL_SetFbVoltage(uint8 setting) 
1648              {
1649   1              CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1650   1                                      (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1651   1          }
1652          
1653          
1654              /*******************************************************************************
1655              * Function Name: CyXTAL_SetWdVoltage
1656              ********************************************************************************
1657              *
1658              * Summary:
1659              *  Sets the reference voltage used by the watchdog to detect a failure in the
1660              *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1661              *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 28  

1662              * Parameters:
1663              *  setting: Valid range [0-7].
1664              *  Refer to the device TRM and datasheet for more information.
1665              *
1666              * Return:
1667              *  None
1668              *
1669              *******************************************************************************/
1670              void CyXTAL_SetWdVoltage(uint8 setting) 
1671              {
1672   1              CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1673   1                                      (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1674   1          }
1675          
1676          #endif /* (CY_PSOC3 || CY_PSOC5LP) */
1677          
1678          
1679          /*******************************************************************************
1680          * Function Name: CyHalt
1681          ********************************************************************************
1682          *
1683          * Summary:
1684          *  Halts the CPU.
1685          *
1686          * Parameters:
1687          *  uint8 reason: Value to be used during debugging.
1688          *
1689          * Return:
1690          *  None
1691          *
1692          *******************************************************************************/
1693          void CyHalt(uint8 reason) CYREENTRANT
1694          {
1695   1          if(0u != reason)
1696   1          {
1697   2              /* To remove unreferenced local variable warning */
1698   2          }
1699   1      
1700   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1705   1              CYDEV_HALT_CPU;
1706   1          #endif  /* (__ARMCC_VERSION) */
1707   1      }
1708          
1709          
1710          /*******************************************************************************
1711          * Function Name: CySoftwareReset
1712          ********************************************************************************
1713          *
1714          * Summary:
1715          *  Forces a software reset of the device.
1716          *
1717          * Parameters:
1718          *  None
1719          *
1720          * Return:
1721          *  None
1722          *
1723          *******************************************************************************/
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 29  

1724          void CySoftwareReset(void) 
1725          {
1726   1          /* Perform software reset */
1727   1          *RESET_CR2 = 0x1u;
1728   1      }
1729          
1730          
1731          /*******************************************************************************
1732          * Function Name: CyDelay
1733          ********************************************************************************
1734          *
1735          * Summary:
1736          *  Blocks for milliseconds.
1737          *
1738          *  Note:
1739          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1740          *  instruction cache is disabled on PSoC5, CyDelay will be two times larger. For
1741          *  example, with instruction cache disabled CyDelay(100) would result in about
1742          *  200 ms delay instead of 100 ms.
1743          *
1744          * Parameters:
1745          *  milliseconds: number of milliseconds to delay.
1746          *
1747          * Return:
1748          *   None
1749          *
1750          *******************************************************************************/
1751          void CyDelay(uint32 milliseconds) CYREENTRANT
1752          {
1753   1          while (milliseconds > 32768u)
1754   1          {
1755   2              /***********************************************************************
1756   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1757   2              * overflows at about 42 seconds.
1758   2              ***********************************************************************/
1759   2              CyDelayCycles(cydelay_32k_ms);
1760   2              milliseconds = ((uint32)(milliseconds - 32768u));
1761   2          }
1762   1      
1763   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1764   1      }
1765          
1766          
1767          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 30  

                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1806          
1807          
1808          /*******************************************************************************
1809          * Function Name: CyDelayFreq
1810          ********************************************************************************
1811          *
1812          * Summary:
1813          *  Sets clock frequency for CyDelay.
1814          *
1815          * Parameters:
1816          *  freq: Frequency of bus clock in Hertz.
1817          *
1818          * Return:
1819          *  None
1820          *
1821          *******************************************************************************/
1822          void CyDelayFreq(uint32 freq) CYREENTRANT
1823          {
1824   1          if (freq != 0u)
1825   1          {
1826   2              cydelay_freq_hz = freq;
1827   2          }
1828   1          else
1829   1          {
1830   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1831   2          }
1832   1      
1833   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1834   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1835   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1836   1      }
1837          
1838          
1839          /*******************************************************************************
1840          * Function Name: CyWdtStart
1841          ********************************************************************************
1842          *
1843          * Summary:
1844          *  Enables the watchdog timer.
1845          *
1846          *  The timer is configured for the specified count interval, the central
1847          *  timewheel is cleared, the setting for low power mode is configured and the
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 31  

1848          *  watchdog timer is enabled.
1849          *
1850          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1851          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1852          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1853          *  timer occur. The CTW is free running, so this will occur after between 2 and
1854          *  3 timer periods elapse.
1855          *
1856          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1857          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1858          *  set to be greater than the sleep wakeup period, then feed the dog on each
1859          *  wakeup from Sleep.
1860          *
1861          * Parameters:
1862          *  ticks: One of the four available timer periods. Once WDT enabled, the
1863             interval cannot be changed.
1864          *         CYWDT_2_TICKS     -     4 - 6     ms
1865          *         CYWDT_16_TICKS    -    32 - 48    ms
1866          *         CYWDT_128_TICKS   -   256 - 384   ms
1867          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1868          *
1869          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1870          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1871          *
1872          *          CYWDT_LPMODE_NOCHANGE - No Change
1873          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1874          *                                 mode
1875          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1876          *
1877          * Return:
1878          *  None
1879          *
1880          * Side Effects:
1881          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1882          *  ILO 1 kHz could break the active WDT functionality.
1883          *
1884          *******************************************************************************/
1885          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1886          {
1887   1          #if(CY_PSOC5A)
                      CyILO_Start1K();
                  #endif  /* (CY_PSOC5A) */
1890   1      
1891   1          /* Set WDT interval */
1892   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1893   1      
1894   1          /* Reset CTW to ensure that first watchdog period is full */
1895   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1896   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1897   1      
1898   1          #if(!CY_PSOC5A)
1899   1      
1900   1              /* Setting the low power mode */
1901   1              CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1902   1                                (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1903   1          #else
              
                      if(0u != lpMode)
                      {
                          /* To remove unreferenced local variable warning */
                      }
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 32  

              
                  #endif  /* (!CY_PSOC5A) */
1911   1      
1912   1          /* Enables the watchdog reset */
1913   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1914   1      }
1915          
1916          
1917          /*******************************************************************************
1918          * Function Name: CyWdtClear
1919          ********************************************************************************
1920          *
1921          * Summary:
1922          *  Clears (feeds) the watchdog timer.
1923          *
1924          * Parameters:
1925          *  None
1926          *
1927          * Return:
1928          *  None
1929          *
1930          *******************************************************************************/
1931          void CyWdtClear(void) 
1932          {
1933   1          #if(CY_PSOC5A)
              
                      /* PSoC5 ES1 watchdog time clear requires workaround */
                      uint8 wdtCfg = CY_WDT_CFG_REG;
                      CY_WDT_CR_REG  = CY_WDT_CR_FEED;
                      CY_WDT_CFG_REG = CY_WDT_CFG_CLEAR_ALL;
                      CY_WDT_CFG_REG = wdtCfg;
              
                  #else
1942   1      
1943   1              CY_WDT_CR_REG = CY_WDT_CR_FEED;
1944   1      
1945   1          #endif  /* (CY_PSOC5A) */
1946   1      }
1947          
1948          
1949          
1950          /*******************************************************************************
1951          * Function Name: CyVdLvDigitEnable
1952          ********************************************************************************
1953          *
1954          * Summary:
1955          *  Enables the digital low voltage monitors to generate interrupt on Vddd
1956          *   archives specified threshold and optionally resets device.
1957          *
1958          * Parameters:
1959          *  reset: Option to reset device at a specified Vddd threshold:
1960          *           0 - Device is not reset.
1961          *           1 - Device is reset.
1962          *         This option is applicable for PSoC 3/PSoC 5LP devices only.
1963          *
1964          *  threshold: Sets the trip level for the voltage monitor.
1965          *  Values from 1.70 V to 5.45 V(for PSoC 3/PSoC 5LP) and from 2.45 V to 5.45 V
1966          *  (for PSoC 5TM) are accepted with the approximately 250 mV interval.
1967          *
1968          * Return:
1969          *  None
1970          *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 33  

1971          *******************************************************************************/
1972          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1973          {
1974   1          *CY_INT_CLEAR_PTR = 0x01u;
1975   1      
1976   1          #if(!CY_PSOC5A)
1977   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1978   1          #endif /*(!CY_PSOC5A)*/
1979   1      
1980   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1981   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1982   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1983   1      
1984   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
1985   1          CyDelayUs(1u);
1986   1      
1987   1              (void)CY_VD_PERSISTENT_STATUS_REG;
1988   1      
1989   1          #if(!CY_PSOC5A)
1990   1              if(0u != reset)
1991   1              {
1992   2                  CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1993   2              }
1994   1              else
1995   1              {
1996   2                  CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1997   2              }
1998   1          #else
              
                      if(0u != reset)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /*(!CY_PSOC5A)*/
2006   1      
2007   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2008   1          *CY_INT_ENABLE_PTR   = 0x01u;
2009   1      }
2010          
2011          
2012          /*******************************************************************************
2013          * Function Name: CyVdLvAnalogEnable
2014          ********************************************************************************
2015          *
2016          * Summary:
2017          *  Enables the analog low voltage monitors to generate interrupt on Vdda
2018          *   archives specified threshold and optionally resets device.
2019          *
2020          * Parameters:
2021          *  reset: Option to reset device at a specified Vdda threshold:
2022          *           0 - Device is not reset.
2023          *           1 - Device is reset.
2024          *         This option is applicable for PSoC 3/PSoC 5LP devices only.
2025          *
2026          *  threshold: Sets the trip level for the voltage monitor.
2027          *  Values from 1.70 V to 5.45 V(for PSoC 3/PSoC 5LP) and from 2.45 V to 5.45 V
2028          *  (for PSoC 5TM) are accepted with the approximately 250 mV interval.
2029          *
2030          * Return:
2031          *  None
2032          *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 34  

2033          *******************************************************************************/
2034          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
2035          {
2036   1          *CY_INT_CLEAR_PTR = 0x01u;
2037   1      
2038   1          #if(!CY_PSOC5A)
2039   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2040   1          #endif /*(!CY_PSOC5A)*/
2041   1      
2042   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
2043   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
2044   1      
2045   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
2046   1          CyDelayUs(1u);
2047   1      
2048   1              (void)CY_VD_PERSISTENT_STATUS_REG;
2049   1      
2050   1          #if(!CY_PSOC5A)
2051   1              if(0u != reset)
2052   1              {
2053   2                  CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
2054   2              }
2055   1              else
2056   1              {
2057   2                  CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2058   2              }
2059   1          #else
              
                      if(0u != reset)
                      {
                          /* To remove unreferenced local variable warning */
                      }
              
                  #endif /*(!CY_PSOC5A)*/
2067   1      
2068   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2069   1          *CY_INT_ENABLE_PTR   = 0x01u;
2070   1      }
2071          
2072          
2073          /*******************************************************************************
2074          * Function Name: CyVdLvDigitDisable
2075          ********************************************************************************
2076          *
2077          * Summary:
2078          *  Disables the digital low voltage monitor (interrupt and device reset are
2079          *  disabled).
2080          *
2081          * Parameters:
2082          *  None
2083          *
2084          * Return:
2085          *  None
2086          *
2087          *******************************************************************************/
2088          void CyVdLvDigitDisable(void) 
2089          {
2090   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
2091   1      
2092   1          #if(!CY_PSOC5A)
2093   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
2094   1          #endif /*(!CY_PSOC5A)*/
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 35  

2095   1      
2096   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
2097   1          {
2098   2      
2099   2          }
2100   1      }
2101          
2102          
2103          /*******************************************************************************
2104          * Function Name: CyVdLvAnalogDisable
2105          ********************************************************************************
2106          *
2107          * Summary:
2108          *  Disables the analog low voltage monitor
2109          *  (interrupt and device reset are disabled).
2110          *
2111          * Parameters:
2112          *  None
2113          *
2114          * Return:
2115          *  None
2116          *
2117          *******************************************************************************/
2118          void CyVdLvAnalogDisable(void) 
2119          {
2120   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2121   1      
2122   1          #if(!CY_PSOC5A)
2123   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2124   1          #endif /*(!CY_PSOC5A)*/
2125   1      
2126   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
2127   1          {
2128   2      
2129   2          }
2130   1      }
2131          
2132          
2133          /*******************************************************************************
2134          * Function Name: CyVdHvAnalogEnable
2135          ********************************************************************************
2136          *
2137          * Summary:
2138          *  Enables the analog high voltage monitors to generate interrupt on
2139          *  Vdda archives 5.75 V threshold and optionally resets device.
2140          *
2141          * Parameters:
2142          *  None
2143          *
2144          * Return:
2145          *  None
2146          *
2147          *******************************************************************************/
2148          void CyVdHvAnalogEnable(void) 
2149          {
2150   1          *CY_INT_CLEAR_PTR = 0x01u;
2151   1      
2152   1          #if(!CY_PSOC5A)
2153   1              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2154   1          #endif /*(!CY_PSOC5A)*/
2155   1      
2156   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 36  

2157   1      
2158   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
2159   1          CyDelayUs(1u);
2160   1      
2161   1              (void) CY_VD_PERSISTENT_STATUS_REG;
2162   1      
2163   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2164   1          *CY_INT_ENABLE_PTR   = 0x01u;
2165   1      }
2166          
2167          
2168          /*******************************************************************************
2169          * Function Name: CyVdHvAnalogDisable
2170          ********************************************************************************
2171          *
2172          * Summary:
2173          *  Disables the analog low voltage monitor
2174          *  (interrupt and device reset are disabled).
2175          *
2176          * Parameters:
2177          *  None
2178          *
2179          * Return:
2180          *  None
2181          *
2182          *******************************************************************************/
2183          void CyVdHvAnalogDisable(void) 
2184          {
2185   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2186   1      }
2187          
2188          
2189          /*******************************************************************************
2190          * Function Name: CyVdStickyStatus
2191          ********************************************************************************
2192          *
2193          * Summary:
2194          *  Manages the Reset and Voltage Detection Status Register 0.
2195          *  This register has the interrupt status for the HVIA, LVID and LVIA.
2196          *  This hardware register clears on read.
2197          *
2198          * Parameters:
2199          *  mask: Bits in the shadow register to clear.
2200          *       Value        Define                Bit To Clear
2201          *       0x01         CY_VD_LVID            LVID
2202          *       0x02         CY_VD_LVIA            LVIA
2203          *       0x04         CY_VD_HVIA            HVIA
2204          *
2205          * Return:
2206          *  Status.  Same enumerated bit values as used for the mask parameter.
2207          *
2208          *******************************************************************************/
2209          uint8 CyVdStickyStatus(uint8 mask) 
2210          {
2211   1          uint8 status;
2212   1      
2213   1          status = CY_VD_PERSISTENT_STATUS_REG;
2214   1          CY_VD_PERSISTENT_STATUS_REG &= ((uint8)(~mask));
2215   1      
2216   1          return(status);
2217   1      }
2218          
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 37  

2219          
2220          /*******************************************************************************
2221          * Function Name: CyVdRealTimeStatus
2222          ********************************************************************************
2223          *
2224          * Summary:
2225          *  Returns the real time voltage detection status.
2226          *
2227          * Parameters:
2228          *  None
2229          *
2230          * Return:
2231          *  Status. Same enumerated bit values as used for the mask parameter.
2232          *
2233          *******************************************************************************/
2234          uint8 CyVdRealTimeStatus(void) 
2235          {
2236   1          uint8 interruptState;
2237   1          uint8 vdFlagsState;
2238   1      
2239   1          interruptState = CyEnterCriticalSection();
2240   1          vdFlagsState = CY_VD_RT_STATUS_REG;
2241   1          CyExitCriticalSection(interruptState);
2242   1      
2243   1          return(vdFlagsState);
2244   1      }
2245          
2246          
2247          /*******************************************************************************
2248          * Function Name: CyDisableInts
2249          ********************************************************************************
2250          *
2251          * Summary:
2252          *  Disables the interrupt enable for each interrupt.
2253          *
2254          * Parameters:
2255          *  None
2256          *
2257          * Return:
2258          *  32 bit mask of previously enabled interrupts.
2259          *
2260          *******************************************************************************/
2261          uint32 CyDisableInts(void) 
2262          {
2263   1          uint32 intState;
2264   1          uint8 interruptState;
2265   1      
2266   1          interruptState = CyEnterCriticalSection();
2267   1      
2268   1          #if(CY_PSOC3)
2269   1      
2270   1              /* Get the current interrupt state. */
2271   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
2272   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2273   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2274   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2275   1      
2276   1      
2277   1              /* Disable all of the interrupts. */
2278   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2279   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2280   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 38  

2281   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
2282   1      
2283   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2292   1      
2293   1          CyExitCriticalSection(interruptState);
2294   1      
2295   1          return (intState);
2296   1      }
2297          
2298          
2299          /*******************************************************************************
2300          * Function Name: CyEnableInts
2301          ********************************************************************************
2302          *
2303          * Summary:
2304          *  Enables interrupts to a given state.
2305          *
2306          * Parameters:
2307          *  uint32 mask: 32 bit mask of interrupts to enable.
2308          *
2309          * Return:
2310          *  None
2311          *
2312          *******************************************************************************/
2313          void CyEnableInts(uint32 mask) 
2314          {
2315   1      
2316   1          uint8 interruptState;
2317   1      
2318   1          interruptState = CyEnterCriticalSection();
2319   1      
2320   1          #if(CY_PSOC3)
2321   1      
2322   1              /* Set interrupts as enabled. */
2323   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2324   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2325   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2326   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2327   1      
2328   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
2333   1      
2334   1          CyExitCriticalSection(interruptState);
2335   1      
2336   1      }
2337          
2338          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 39  

                  * Summary:
                  *  Flushes the PSoC 5/5LP cache by invalidating all entries.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in the cache are invalidated on the next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
              
                      /***********************************************************************
                      * The prefetch unit could/would be filled with the instructions that
                      * succeed the flush. Since a flush is desired then theoretically those
                      * instructions might be considered stale/invalid.
                      ***********************************************************************/
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* Restore global interrupt enable state */
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 40  

                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
                  * Summary:
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: Interrupt number, valid range [0-15].
                     address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *   number: The interrupt number, valid range [0-15].
                  *
                  * Return:
                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 41  

                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
                  * Return:
                  *  Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 42  

                  * Parameters:
                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
                  *   number: Valid range [0-31].  Interrupt number.
                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 43  

                      /* Get a pointer to the Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get the state of the interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2600          
2601          
2602              /*******************************************************************************
2603              * Function Name: CyIntSetVector
2604              ********************************************************************************
2605              *
2606              * Summary:
2607              *  Sets the interrupt vector of the specified interrupt number.
2608              *
2609              * Parameters:
2610              *  number:  Valid range [0-31].  Interrupt number
2611              *  address: Pointer to an interrupt service routine
2612              *
2613              * Return:
2614              *  Previous interrupt vector value.
2615              *
2616              *******************************************************************************/
2617              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2618              {
2619   1              cyisraddress oldIsr;
2620   1      
2621   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2622   1      
2623   1              /* Save old Interrupt service routine. */
2624   1              oldIsr = (cyisraddress) \
2625   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2626   1      
2627   1              /* Set new Interrupt service routine. */
2628   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2629   1      
2630   1              return (oldIsr);
2631   1          }
2632          
2633          
2634              /*******************************************************************************
2635              * Function Name: CyIntGetVector
2636              ********************************************************************************
2637              *
2638              * Summary:
2639              *  Gets the interrupt vector of the specified interrupt number.
2640              *
2641              * Parameters:
2642              *  number: Valid range [0-31].  Interrupt number
2643              *
2644              * Return:
2645              *  Address of the ISR in the interrupt vector table.
2646              *
2647              *******************************************************************************/
2648              cyisraddress CyIntGetVector(uint8 number) 
2649              {
2650   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2651   1      
2652   1              return ((cyisraddress) \
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 44  

2653   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2654   1          }
2655          
2656          
2657              /*******************************************************************************
2658              * Function Name: CyIntSetPriority
2659              ********************************************************************************
2660              *
2661              * Summary:
2662              *  Sets the Priority of the Interrupt.
2663              *
2664              * Parameters:
2665              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2666              *  number:   The number of the interrupt, 0 - 31.
2667              *
2668              * Return:
2669              *  None
2670              *
2671              *******************************************************************************/
2672              void CyIntSetPriority(uint8 number, uint8 priority) 
2673              {
2674   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2675   1      
2676   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2677   1      
2678   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2679   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2680   1          }
2681          
2682          
2683              /*******************************************************************************
2684              * Function Name: CyIntGetPriority
2685              ********************************************************************************
2686              *
2687              * Summary:
2688              *  Gets the Priority of the Interrupt.
2689              *
2690              * Parameters:
2691              *  number: The number of the interrupt, 0 - 31.
2692              *
2693              * Return:
2694              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2695              *
2696              *******************************************************************************/
2697              uint8 CyIntGetPriority(uint8 number) 
2698              {
2699   1              uint8 priority;
2700   1      
2701   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2702   1      
2703   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2704   1      
2705   1              return (priority);
2706   1          }
2707          
2708          
2709              /*******************************************************************************
2710              * Function Name: CyIntGetState
2711              ********************************************************************************
2712              *
2713              * Summary:
2714              *   Gets the enable state of the specified interrupt number.
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 45  

2715              *
2716              * Parameters:
2717              *   number: Valid range [0-31].  Interrupt number.
2718              *
2719              * Return:
2720              *   Enable status: 1 if enabled, 0 if disabled
2721              *
2722              *******************************************************************************/
2723              uint8 CyIntGetState(uint8 number) 
2724              {
2725   1              reg8 * stateReg;
2726   1      
2727   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2728   1      
2729   1              /* Get a pointer to the Interrupt enable register. */
2730   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2731   1      
2732   1              /* Get the state of the interrupt. */
2733   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2734   1          }
2735          
2736          
2737          #endif  /* (CY_PSOC5) */
2738          
2739          
2740          #if(!CY_PSOC5A)
2741          
2742              #if(CYDEV_VARIABLE_VDDA == 1)
              
              
                      /*******************************************************************************
                      * Function Name: CySetScPumps
                      ********************************************************************************
                      *
                      * Summary:
                      *  If 1 is passed as a parameter:
                      *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                      *     start boost clock.
                      *   - For the each enabled SC block set boost clock index and enable boost clock.
                      *
                      *  If non-1 value is passed as a parameter:
                      *   - If all SC blocks are not used - disable pumps for the SC blocks and
                      *     stop boost clock.
                      *   - For the each enabled SC block clear boost clock index and disable boost
                      *     clock.
                              *
                      *  The global variable CyScPumpEnabled is updated to be equal to passed
                      *  parameter.
                      *
                      * Parameters:
                      *   uint8 enable: Enable/disable SC pumps and boost clock for enabled SC block.
                      *                 1 - Enable
                      *                 0 - Disable
                      *
                      * Return:
                      *   None
                      *
                      *******************************************************************************/
                      void CySetScPumps(uint8 enable) 
                      {
              
                          if(1u == enable)
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 46  

                          {
                              /* The SC pumps should be enabled */
                              CyScPumpEnabled = 1u;
              
              
                              /* Enable pumps if any of SC blocks are used */
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                              {
              
                                  CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
              
                                  CyScBoostClk_Start();
                              }
              
              
                              /* Set positive pump for each enabled SC block: set clock index and enable it */
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                              {
                                  CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
              
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                              {
                                  CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
              
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                              {
                                  CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
              
                              if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                              {
                                  CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostCl
             -k__INDEX;
                                  CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                              }
                          }
                          else
                          {
                              /* The SC pumps should be disabled */
                              CyScPumpEnabled = 0u;
              
                              /* Disable pumps for all SC blocks and stop boost clock */
                              CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                              CyScBoostClk_Stop();
              
                              /* Disable boost clock and clear clock index for each SC block */
                              CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
              
                              CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
              
                              CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 47  

              
                              CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                              CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          }
                      }
              
                  #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2842          
2843          #endif /* (!CY_PSOC5A) */
2844          
2845          
2846          /* [] END OF FILE */
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 48  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _CyPLL_OUT_Start (BEGIN)
                                           ; SOURCE LINE # 90
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 92
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 100
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 4401              ORL     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 102
000C EF                MOV     A,R7
000D 605A              JZ      ?C0001
                                           ; SOURCE LINE # 103
                                           ; SOURCE LINE # 105
000F 904300            MOV     DPTR,#04300H
0012 E0                MOVX    A,@DPTR
0013 900000      R     MOV     DPTR,#iloEnableState
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 106
0017 904380            MOV     DPTR,#04380H
001A E0                MOVX    A,@DPTR
001B 900000      R     MOV     DPTR,#pmTwCfg0State
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 107
001F 904382            MOV     DPTR,#04382H
0022 E0                MOVX    A,@DPTR
0023 900000      R     MOV     DPTR,#pmTwCfg2State
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 109
0027 7F18              MOV     R7,#018H
0029 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 111
002C 900000      R     MOV     DPTR,#status
002F 7410              MOV     A,#010H
0031 F0                MOVX    @DPTR,A
0032         ?C0002:
                                           ; SOURCE LINE # 114
0032 7F01              MOV     R7,#01H
0034 120000      E     LCALL   _CyPmReadStatus
0037 EF                MOV     A,R7
0038 6401              XRL     A,#01H
003A 6012              JZ      ?C0003
                                           ; SOURCE LINE # 115
                                           ; SOURCE LINE # 117
003C 904225            MOV     DPTR,#04225H
003F E0                MOVX    A,@DPTR
0040 5401              ANL     A,#01H
0042 60EE              JZ      ?C0002
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 119
0044 E0                MOVX    A,@DPTR
0045 5401              ANL     A,#01H
0047 60E9              JZ      ?C0002
                                           ; SOURCE LINE # 120
                                           ; SOURCE LINE # 121
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 49  

0049 E4                CLR     A
004A 900000      R     MOV     DPTR,#status
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
                                           ; SOURCE LINE # 123
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
004E         ?C0003:
                                           ; SOURCE LINE # 129
004E 900000      R     MOV     DPTR,#iloEnableState
0051 E0                MOVX    A,@DPTR
0052 5404              ANL     A,#04H
0054 7003              JNZ     ?C0006
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 131
0056 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 132
0059         ?C0006:
                                           ; SOURCE LINE # 133
0059 900000      R     MOV     DPTR,#pmTwCfg0State
005C E0                MOVX    A,@DPTR
005D 904380            MOV     DPTR,#04380H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 134
0061 900000      R     MOV     DPTR,#pmTwCfg2State
0064 E0                MOVX    A,@DPTR
0065 904382            MOV     DPTR,#04382H
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 135
0069         ?C0001:
                                           ; SOURCE LINE # 137
0069 900000      R     MOV     DPTR,#status
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
                                           ; SOURCE LINE # 138
006E         ?C0007:
006E 22                RET     
             ; FUNCTION _CyPLL_OUT_Start (END)

             ; FUNCTION CyPLL_OUT_Stop (BEGIN)
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
0000 904220            MOV     DPTR,#04220H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 158
0007 22                RET     
             ; FUNCTION CyPLL_OUT_Stop (END)

             ; FUNCTION _CyPLL_OUT_SetPQ (BEGIN)
                                           ; SOURCE LINE # 193
;---- Variable 'pDiv' assigned to Register 'R7' ----
;---- Variable 'current' assigned to Register 'R3' ----
;---- Variable 'qDiv' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 194
                                           ; SOURCE LINE # 198
0000 EF                MOV     A,R7
0001 C3                CLR     C
0002 9408              SUBB    A,#08H
0004 402F              JC      ?C0011
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 50  

0006 ED                MOV     A,R5
0007 D3                SETB    C
0008 9410              SUBB    A,#010H
000A 5029              JNC     ?C0011
000C ED                MOV     A,R5
000D C3                CLR     C
000E 9401              SUBB    A,#01H
0010 4023              JC      ?C0011
0012 EB                MOV     A,R3
0013 9401              SUBB    A,#01H
0015 401E              JC      ?C0011
0017 EB                MOV     A,R3
0018 D3                SETB    C
0019 9407              SUBB    A,#07H
001B 5018              JNC     ?C0011
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 203
001D 904222            MOV     DPTR,#04222H
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 204
0022 ED                MOV     A,R5
0023 14                DEC     A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0026 EB                MOV     A,R3
0027 14                DEC     A
0028 FF                MOV     R7,A
0029 C4                SWAP    A
002A 54F0              ANL     A,#0F0H
002C FF                MOV     R7,A
002D 904221            MOV     DPTR,#04221H
0030 E0                MOVX    A,@DPTR
0031 548F              ANL     A,#08FH
0033 4F                ORL     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 217
                                           ; SOURCE LINE # 219
0035         ?C0011:
0035 22                RET     
             ; FUNCTION _CyPLL_OUT_SetPQ (END)

             ; FUNCTION _CyPLL_OUT_SetSource (BEGIN)
                                           ; SOURCE LINE # 248
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 249
                                           ; SOURCE LINE # 253
0000 EF                MOV     A,R7
0001 24FD              ADD     A,#0FDH
0003 5002              JNC     ?C0015
0005 8008              SJMP    ?C0017
                                           ; SOURCE LINE # 254
                                           ; SOURCE LINE # 255
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 257
0007         ?C0015:
                                           ; SOURCE LINE # 258
0007 904000            MOV     DPTR,#04000H
000A E0                MOVX    A,@DPTR
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 51  

000B 54FC              ANL     A,#0FCH
000D 4F                ORL     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 261
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 265
000F         ?C0017:
000F 22                RET     
             ; FUNCTION _CyPLL_OUT_SetSource (END)

             ; FUNCTION _CyIMO_Start (BEGIN)
                                           ; SOURCE LINE # 298
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 305
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
0007 EF                MOV     A,R7
0008 6054              JZ      ?C0023
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 311
000A 904300            MOV     DPTR,#04300H
000D E0                MOVX    A,@DPTR
000E 900000      R     MOV     DPTR,#iloControlReg
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 313
0012 E0                MOVX    A,@DPTR
0013 5404              ANL     A,#04H
0015 7003              JNZ     ?C0019
                                           ; SOURCE LINE # 314
                                           ; SOURCE LINE # 315
0017 120000      R     LCALL   CyILO_Start100K
                                           ; SOURCE LINE # 316
001A         ?C0019:
                                           ; SOURCE LINE # 319
001A 904382            MOV     DPTR,#04382H
001D E0                MOVX    A,@DPTR
001E 900000      R     MOV     DPTR,#pmFtwCfg2Reg
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 320
0022 904380            MOV     DPTR,#04380H
0025 E0                MOVX    A,@DPTR
0026 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 323
002A 904382            MOV     DPTR,#04382H
002D E0                MOVX    A,@DPTR
002E 54FC              ANL     A,#0FCH
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 327
0031 904380            MOV     DPTR,#04380H
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 330
0036 904382            MOV     DPTR,#04382H
0039 04                INC     A
003A F0                MOVX    @DPTR,A
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 52  

003B         ?C0020:
                                           ; SOURCE LINE # 333
003B 7F01              MOV     R7,#01H
003D 120000      E     LCALL   _CyPmReadStatus
0040 EF                MOV     A,R7
0041 60F8              JZ      ?C0020
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 336
0043         ?C0021:
                                           ; SOURCE LINE # 339
0043 900000      R     MOV     DPTR,#iloControlReg
0046 E0                MOVX    A,@DPTR
0047 5404              ANL     A,#04H
0049 7003              JNZ     ?C0022
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
004B 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 342
004E         ?C0022:
                                           ; SOURCE LINE # 345
004E 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0051 E0                MOVX    A,@DPTR
0052 904380            MOV     DPTR,#04380H
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 346
0056 900000      R     MOV     DPTR,#pmFtwCfg2Reg
0059 E0                MOVX    A,@DPTR
005A 904382            MOV     DPTR,#04382H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 347
                                           ; SOURCE LINE # 348
005E         ?C0023:
005E 22                RET     
             ; FUNCTION _CyIMO_Start (END)

             ; FUNCTION CyIMO_Stop (BEGIN)
                                           ; SOURCE LINE # 365
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 368
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 369
0007 22                RET     
             ; FUNCTION CyIMO_Stop (END)

             ; FUNCTION CyUSB_PowerOnCheck (BEGIN)
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
;---- Variable 'poweredOn' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 394
0002 904393            MOV     DPTR,#04393H
0005 E0                MOVX    A,@DPTR
0006 5407              ANL     A,#07H
0008 7008              JNZ     ?C0027
000A 9043A5            MOV     DPTR,#043A5H
000D E0                MOVX    A,@DPTR
000E 5401              ANL     A,#01H
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 53  

0010 7012              JNZ     ?C0026
0012         ?C0027:
0012 904393            MOV     DPTR,#04393H
0015 E0                MOVX    A,@DPTR
0016 5407              ANL     A,#07H
0018 6401              XRL     A,#01H
001A 700A              JNZ     ?C0025
001C 9043B5            MOV     DPTR,#043B5H
001F E0                MOVX    A,@DPTR
0020 5401              ANL     A,#01H
0022 6002              JZ      ?C0025
0024         ?C0026:
                                           ; SOURCE LINE # 395
                                           ; SOURCE LINE # 396
0024 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 397
0026         ?C0025:
                                           ; SOURCE LINE # 399
                                           ; SOURCE LINE # 400
0026         ?C0028:
0026 22                RET     
             ; FUNCTION CyUSB_PowerOnCheck (END)

             ; FUNCTION _CyIMO_SetTrimValue (BEGIN)
                                           ; SOURCE LINE # 417
;---- Variable 'freq' assigned to Register 'R6' ----
0000 AE07              MOV     R6,AR7
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
0002 120000      R     LCALL   CyUSB_PowerOnCheck
0005 900000      R     MOV     DPTR,#usb_power_on
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 422
000A B40107            CJNE    A,#01H,?C0029
                                           ; SOURCE LINE # 423
                                           ; SOURCE LINE # 425
000D 906009            MOV     DPTR,#06009H
0010 E0                MOVX    A,@DPTR
0011 54FD              ANL     A,#0FDH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 426
0014         ?C0029:
                                           ; SOURCE LINE # 427
0014 EE                MOV     A,R6
0015 120000      E     LCALL   ?C?CCASE
0018 0000        R     DW      ?C0031
001A 00                DB      00H
001B 0000        R     DW      ?C0032
001D 01                DB      01H
001E 0000        R     DW      ?C0033
0020 02                DB      02H
0021 0000        R     DW      ?C0034
0023 03                DB      03H
0024 0000        R     DW      ?C0035
0026 04                DB      04H
0027 0000        R     DW      ?C0036
0029 05                DB      05H
002A 0000        R     DW      ?C0037
002C 08                DB      08H
002D 0000              DW      00H
002F 0000        R     DW      ?C0040
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 54  

                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
0031         ?C0031:
                                           ; SOURCE LINE # 430
0031 7B0C              MOV     R3,#0CH
0033 7A01              MOV     R2,#01H
0035 7908              MOV     R1,#08H
0037 120000      E     LCALL   _cyread8
003A 9046A1            MOV     DPTR,#046A1H
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 431
003F 22                RET     
                                           ; SOURCE LINE # 433
0040         ?C0032:
                                           ; SOURCE LINE # 434
0040 7B0C              MOV     R3,#0CH
0042 7A01              MOV     R2,#01H
0044 7909              MOV     R1,#09H
0046 120000      E     LCALL   _cyread8
0049 9046A1            MOV     DPTR,#046A1H
004C EF                MOV     A,R7
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
004E 22                RET     
                                           ; SOURCE LINE # 437
004F         ?C0033:
                                           ; SOURCE LINE # 438
004F 7B0C              MOV     R3,#0CH
0051 7A01              MOV     R2,#01H
0053 790A              MOV     R1,#0AH
0055 120000      E     LCALL   _cyread8
0058 9046A1            MOV     DPTR,#046A1H
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
005D 22                RET     
                                           ; SOURCE LINE # 441
005E         ?C0034:
                                           ; SOURCE LINE # 442
005E 7B0C              MOV     R3,#0CH
0060 7A01              MOV     R2,#01H
0062 790B              MOV     R1,#0BH
0064 120000      E     LCALL   _cyread8
0067 9046A1            MOV     DPTR,#046A1H
006A EF                MOV     A,R7
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 443
006C 22                RET     
                                           ; SOURCE LINE # 445
006D         ?C0035:
                                           ; SOURCE LINE # 446
006D 7B0C              MOV     R3,#0CH
006F 7A01              MOV     R2,#01H
0071 7989              MOV     R1,#089H
0073 120000      E     LCALL   _cyread8
0076 9046A1            MOV     DPTR,#046A1H
0079 EF                MOV     A,R7
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 447
007B 22                RET     
                                           ; SOURCE LINE # 452
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 55  

007C         ?C0036:
                                           ; SOURCE LINE # 453
007C 7B0C              MOV     R3,#0CH
007E 7A01              MOV     R2,#01H
0080 790C              MOV     R1,#0CH
0082 120000      E     LCALL   _cyread8
0085 9046A1            MOV     DPTR,#046A1H
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 454
008A 22                RET     
                                           ; SOURCE LINE # 458
008B         ?C0037:
                                           ; SOURCE LINE # 459
008B 7B0C              MOV     R3,#0CH
008D 7A01              MOV     R2,#01H
008F 790F              MOV     R1,#0FH
0091 120000      E     LCALL   _cyread8
0094 9046A1            MOV     DPTR,#046A1H
0097 EF                MOV     A,R7
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 462
0099 900000      R     MOV     DPTR,#usb_power_on
009C E0                MOVX    A,@DPTR
009D B40107            CJNE    A,#01H,?C0040
                                           ; SOURCE LINE # 463
                                           ; SOURCE LINE # 465
00A0 906009            MOV     DPTR,#06009H
00A3 E0                MOVX    A,@DPTR
00A4 4402              ORL     A,#02H
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 469
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 472
                                           ; SOURCE LINE # 474
00A7         ?C0040:
00A7 22                RET     
             ; FUNCTION _CyIMO_SetTrimValue (END)

             ; FUNCTION _CyIMO_SetFreq (BEGIN)
                                           ; SOURCE LINE # 510
0000 900000      R     MOV     DPTR,#freq
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 511
                                           ; SOURCE LINE # 522
0005 904200            MOV     DPTR,#04200H
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 900000      R     MOV     DPTR,#currentFreq
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 525
000F 900000      R     MOV     DPTR,#freq
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 B40806            CJNE    A,#08H,?C0041
0017 7E03              MOV     R6,#03H
0019 7F03              MOV     R7,#03H
001B 8000              SJMP    ?C0042
001D         ?C0041:
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 56  

001D         ?C0042:
001D 900000      R     MOV     DPTR,#nextFreq
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
0022 900000      R     MOV     DPTR,#currentFreq
0025 E0                MOVX    A,@DPTR
0026 14                DEC     A
0027 6018              JZ      ?C0045
0029 14                DEC     A
002A 601D              JZ      ?C0046
002C 14                DEC     A
002D 6022              JZ      ?C0047
002F 14                DEC     A
0030 6026              JZ      ?C0048
0032 14                DEC     A
0033 602B              JZ      ?C0049
0035 2405              ADD     A,#05H
0037 702D              JNZ     ?C0043
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 529
0039         ?C0044:
                                           ; SOURCE LINE # 530
0039 900000      R     MOV     DPTR,#currentFreq
003C 7402              MOV     A,#02H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 531
003F 8025              SJMP    ?C0043
                                           ; SOURCE LINE # 533
0041         ?C0045:
                                           ; SOURCE LINE # 534
0041 900000      R     MOV     DPTR,#currentFreq
0044 7401              MOV     A,#01H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 535
0047 801D              SJMP    ?C0043
                                           ; SOURCE LINE # 537
0049         ?C0046:
                                           ; SOURCE LINE # 538
0049 900000      R     MOV     DPTR,#currentFreq
004C 7403              MOV     A,#03H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 539
004F 8015              SJMP    ?C0043
                                           ; SOURCE LINE # 541
0051         ?C0047:
                                           ; SOURCE LINE # 542
0051 E4                CLR     A
0052 900000      R     MOV     DPTR,#currentFreq
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 543
0056 800E              SJMP    ?C0043
                                           ; SOURCE LINE # 545
0058         ?C0048:
                                           ; SOURCE LINE # 546
0058 900000      R     MOV     DPTR,#currentFreq
005B 7404              MOV     A,#04H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 547
005E 8006              SJMP    ?C0043
                                           ; SOURCE LINE # 552
0060         ?C0049:
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 57  

                                           ; SOURCE LINE # 553
0060 900000      R     MOV     DPTR,#currentFreq
0063 7405              MOV     A,#05H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 554
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 560
                                           ; SOURCE LINE # 561
0066         ?C0043:
                                           ; SOURCE LINE # 563
0066 900000      R     MOV     DPTR,#currentFreq
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B A3                INC     DPTR
006C E0                MOVX    A,@DPTR
006D C3                CLR     C
006E 9F                SUBB    A,R7
006F 4008              JC      ?C0051
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 566
0071 900000      R     MOV     DPTR,#freq
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 567
0079         ?C0051:
                                           ; SOURCE LINE # 570
0079 900000      R     MOV     DPTR,#freq
007C E0                MOVX    A,@DPTR
007D FF                MOV     R7,A
007E 120000      E     LCALL   ?C?CCASE
0081 0000        R     DW      ?C0053
0083 00                DB      00H
0084 0000        R     DW      ?C0054
0086 01                DB      01H
0087 0000        R     DW      ?C0055
0089 02                DB      02H
008A 0000        R     DW      ?C0056
008C 03                DB      03H
008D 0000        R     DW      ?C0057
008F 04                DB      04H
0090 0000        R     DW      ?C0058
0092 05                DB      05H
0093 0000        R     DW      ?C0059
0095 08                DB      08H
0096 0000              DW      00H
0098 0000        R     DW      ?C0052
                                           ; SOURCE LINE # 571
                                           ; SOURCE LINE # 572
009A         ?C0053:
                                           ; SOURCE LINE # 574
009A 904200            MOV     DPTR,#04200H
009D E0                MOVX    A,@DPTR
009E 54F8              ANL     A,#0F8H
00A0 4403              ORL     A,#03H
00A2 54BF              ANL     A,#0BFH
00A4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 575
00A5 8046              SJMP    ?C0052
                                           ; SOURCE LINE # 577
00A7         ?C0054:
                                           ; SOURCE LINE # 579
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 58  

00A7 904200            MOV     DPTR,#04200H
00AA E0                MOVX    A,@DPTR
00AB 54F8              ANL     A,#0F8H
00AD 4401              ORL     A,#01H
00AF 54BF              ANL     A,#0BFH
00B1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 580
00B2 8039              SJMP    ?C0052
                                           ; SOURCE LINE # 582
00B4         ?C0055:
                                           ; SOURCE LINE # 584
00B4 904200            MOV     DPTR,#04200H
00B7 E0                MOVX    A,@DPTR
00B8 54B8              ANL     A,#0B8H
00BA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 585
00BB 8030              SJMP    ?C0052
                                           ; SOURCE LINE # 587
00BD         ?C0056:
                                           ; SOURCE LINE # 589
00BD 904200            MOV     DPTR,#04200H
00C0 E0                MOVX    A,@DPTR
00C1 54F8              ANL     A,#0F8H
00C3 4402              ORL     A,#02H
00C5 54BF              ANL     A,#0BFH
00C7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 590
00C8 8023              SJMP    ?C0052
                                           ; SOURCE LINE # 592
00CA         ?C0057:
                                           ; SOURCE LINE # 594
00CA 904200            MOV     DPTR,#04200H
00CD E0                MOVX    A,@DPTR
00CE 54F8              ANL     A,#0F8H
00D0 4404              ORL     A,#04H
00D2 54BF              ANL     A,#0BFH
00D4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 595
00D5 8016              SJMP    ?C0052
                                           ; SOURCE LINE # 600
00D7         ?C0058:
                                           ; SOURCE LINE # 602
00D7 904200            MOV     DPTR,#04200H
00DA E0                MOVX    A,@DPTR
00DB 54F8              ANL     A,#0F8H
00DD 4405              ORL     A,#05H
00DF 54BF              ANL     A,#0BFH
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 603
00E2 8009              SJMP    ?C0052
                                           ; SOURCE LINE # 607
00E4         ?C0059:
                                           ; SOURCE LINE # 608
00E4 904200            MOV     DPTR,#04200H
00E7 E0                MOVX    A,@DPTR
00E8 54F8              ANL     A,#0F8H
00EA 4442              ORL     A,#042H
00EC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 612
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 59  

00ED         ?C0052:
                                           ; SOURCE LINE # 618
00ED EF                MOV     A,R7
00EE B40805            CJNE    A,#08H,?C0061
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 620
00F1 120000      R     LCALL   CyIMO_EnableDoubler
                                           ; SOURCE LINE # 621
00F4 8003              SJMP    ?C0062
00F6         ?C0061:
                                           ; SOURCE LINE # 623
                                           ; SOURCE LINE # 624
00F6 120000      R     LCALL   CyIMO_DisableDoubler
                                           ; SOURCE LINE # 625
00F9         ?C0062:
                                           ; SOURCE LINE # 627
00F9 900000      R     MOV     DPTR,#currentFreq
00FC E0                MOVX    A,@DPTR
00FD FF                MOV     R7,A
00FE A3                INC     DPTR
00FF E0                MOVX    A,@DPTR
0100 C3                CLR     C
0101 9F                SUBB    A,R7
0102 5008              JNC     ?C0064
                                           ; SOURCE LINE # 628
                                           ; SOURCE LINE # 630
0104 900000      R     MOV     DPTR,#freq
0107 E0                MOVX    A,@DPTR
0108 FF                MOV     R7,A
0109 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 631
                                           ; SOURCE LINE # 632
010C         ?C0064:
010C 22                RET     
             ; FUNCTION _CyIMO_SetFreq (END)

             ; FUNCTION _CyIMO_SetSource (BEGIN)
                                           ; SOURCE LINE # 662
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 663
                                           ; SOURCE LINE # 664
0000 EF                MOV     A,R7
0001 6024              JZ      ?C0068
0003 14                DEC     A
0004 6012              JZ      ?C0067
0006 14                DEC     A
0007 7025              JNZ     ?C0070
                                           ; SOURCE LINE # 665
                                           ; SOURCE LINE # 666
0009         ?C0066:
                                           ; SOURCE LINE # 667
0009 904000            MOV     DPTR,#04000H
000C E0                MOVX    A,@DPTR
000D 54BF              ANL     A,#0BFH
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 668
0010 904200            MOV     DPTR,#04200H
0013 E0                MOVX    A,@DPTR
0014 4420              ORL     A,#020H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 669
0017 22                RET     
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 60  

                                           ; SOURCE LINE # 671
0018         ?C0067:
                                           ; SOURCE LINE # 672
0018 904000            MOV     DPTR,#04000H
001B E0                MOVX    A,@DPTR
001C 4440              ORL     A,#040H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 673
001F 904200            MOV     DPTR,#04200H
0022 E0                MOVX    A,@DPTR
0023 4420              ORL     A,#020H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 674
0026 22                RET     
                                           ; SOURCE LINE # 676
0027         ?C0068:
                                           ; SOURCE LINE # 677
0027 904200            MOV     DPTR,#04200H
002A E0                MOVX    A,@DPTR
002B 54DF              ANL     A,#0DFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 678
                                           ; SOURCE LINE # 680
                                           ; SOURCE LINE # 683
                                           ; SOURCE LINE # 684
                                           ; SOURCE LINE # 685
002E         ?C0070:
002E 22                RET     
             ; FUNCTION _CyIMO_SetSource (END)

             ; FUNCTION CyIMO_EnableDoubler (BEGIN)
                                           ; SOURCE LINE # 703
                                           ; SOURCE LINE # 704
                                           ; SOURCE LINE # 706
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 707
0007 22                RET     
             ; FUNCTION CyIMO_EnableDoubler (END)

             ; FUNCTION CyIMO_DisableDoubler (BEGIN)
                                           ; SOURCE LINE # 724
                                           ; SOURCE LINE # 725
                                           ; SOURCE LINE # 726
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 727
0007 22                RET     
             ; FUNCTION CyIMO_DisableDoubler (END)

             ; FUNCTION _CyMasterClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 759
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 760
                                           ; SOURCE LINE # 777
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 61  

0004 904005            MOV     DPTR,#04005H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
000C 22                RET     
             ; FUNCTION _CyMasterClk_SetSource (END)

             ; FUNCTION _CyMasterClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 819
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 820
                                           ; SOURCE LINE # 821
0000 904004            MOV     DPTR,#04004H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 822
0005 22                RET     
             ; FUNCTION _CyMasterClk_SetDivider (END)

             ; FUNCTION _CyBusClk_Internal_SetDivider (BEGIN)
                                           ; SOURCE LINE # 841
;---- Variable 'divider' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 842
                                           ; SOURCE LINE # 844
0000 904014            MOV     DPTR,#04014H
0003 E0                MOVX    A,@DPTR
0004 54F0              ANL     A,#0F0H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 845
0007 904010            MOV     DPTR,#04010H
000A E4                CLR     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 848
000C 904008            MOV     DPTR,#04008H
000F E0                MOVX    A,@DPTR
0010 4480              ORL     A,#080H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 851
0013 904002            MOV     DPTR,#04002H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 852
0018 EE                MOV     A,R6
0019 A3                INC     DPTR
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 861
001B 904001            MOV     DPTR,#04001H
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 862
0022 22                RET     
             ; FUNCTION _CyBusClk_Internal_SetDivider (END)

             ; FUNCTION _CyBusClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 888
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 62  

0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 889
                                           ; SOURCE LINE # 894
0008 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R5' ----
000B AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 897
000D 904007            MOV     DPTR,#04007H
0010 E0                MOVX    A,@DPTR
0011 FE                MOV     R6,A
0012 904006            MOV     DPTR,#04006H
0015 E0                MOVX    A,@DPTR
0016 FB                MOV     R3,A
0017 EE                MOV     A,R6
0018 EB                MOV     A,R3
0019 FF                MOV     R7,A
;---- Variable 'busClkDiv' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 899
001A 900000      R     MOV     DPTR,#divider
001D E0                MOVX    A,@DPTR
001E 7002              JNZ     ?C0168
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022         ?C0168:
0022 6004              JZ      ?C0077
0024 EF                MOV     A,R7
0025 4E                ORL     A,R6
0026 7046              JNZ     ?C0076
0028         ?C0077:
                                           ; SOURCE LINE # 900
                                           ; SOURCE LINE # 902
0028 904004            MOV     DPTR,#04004H
002B E0                MOVX    A,@DPTR
;---- Variable 'masterClkDiv' assigned to Register 'R4' ----
002C FC                MOV     R4,A
                                           ; SOURCE LINE # 904
002D C3                CLR     C
002E 9407              SUBB    A,#07H
0030 5005              JNC     ?C0078
                                           ; SOURCE LINE # 905
                                           ; SOURCE LINE # 907
0032 7F07              MOV     R7,#07H
0034 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 908
0037         ?C0078:
                                           ; SOURCE LINE # 910
0037 900000      R     MOV     DPTR,#divider
003A E0                MOVX    A,@DPTR
003B 7002              JNZ     ?C0169
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F         ?C0169:
003F 7014              JNZ     ?C0079
                                           ; SOURCE LINE # 911
                                           ; SOURCE LINE # 913
0041 904008            MOV     DPTR,#04008H
0044 E0                MOVX    A,@DPTR
0045 4440              ORL     A,#040H
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 914
0048 900000      R     MOV     DPTR,#divider
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 63  

004B E0                MOVX    A,@DPTR
004C FE                MOV     R6,A
004D A3                INC     DPTR
004E E0                MOVX    A,@DPTR
004F FF                MOV     R7,A
0050 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 915
0053 8012              SJMP    ?C0080
0055         ?C0079:
                                           ; SOURCE LINE # 917
                                           ; SOURCE LINE # 918
0055 900000      R     MOV     DPTR,#divider
0058 E0                MOVX    A,@DPTR
0059 FE                MOV     R6,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C FF                MOV     R7,A
005D 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 919
0060 904008            MOV     DPTR,#04008H
0063 E0                MOVX    A,@DPTR
0064 54BF              ANL     A,#0BFH
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 920
0067         ?C0080:
                                           ; SOURCE LINE # 923
0067 AF04              MOV     R7,AR4
0069 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 924
006C 800B              SJMP    ?C0081
006E         ?C0076:
                                           ; SOURCE LINE # 926
                                           ; SOURCE LINE # 927
006E 900000      R     MOV     DPTR,#divider
0071 E0                MOVX    A,@DPTR
0072 FE                MOV     R6,A
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 928
0079         ?C0081:
                                           ; SOURCE LINE # 930
0079 AF05              MOV     R7,AR5
007B 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 931
007E 22                RET     
             ; FUNCTION _CyBusClk_SetDivider (END)

             ; FUNCTION _CyCpuClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 960
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 961
                                           ; SOURCE LINE # 963
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 54F0              ANL     A,#0F0H
0004 FF                MOV     R7,A
0005 904005            MOV     DPTR,#04005H
0008 E0                MOVX    A,@DPTR
0009 540F              ANL     A,#0FH
000B 4F                ORL     A,R7
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 64  

000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 964
000D 22                RET     
             ; FUNCTION _CyCpuClk_SetDivider (END)

             ; FUNCTION _CyUsbClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 987
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 988
                                           ; SOURCE LINE # 989
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904009            MOV     DPTR,#04009H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 991
000C 22                RET     
             ; FUNCTION _CyUsbClk_SetSource (END)

             ; FUNCTION CyILO_Start1K (BEGIN)
                                           ; SOURCE LINE # 1012
                                           ; SOURCE LINE # 1013
                                           ; SOURCE LINE # 1015
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4402              ORL     A,#02H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1016
0007 22                RET     
             ; FUNCTION CyILO_Start1K (END)

             ; FUNCTION CyILO_Stop1K (BEGIN)
                                           ; SOURCE LINE # 1040
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1043
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1044
0007 22                RET     
             ; FUNCTION CyILO_Stop1K (END)

             ; FUNCTION CyILO_Start100K (BEGIN)
                                           ; SOURCE LINE # 1061
                                           ; SOURCE LINE # 1062
                                           ; SOURCE LINE # 1064
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1065
0007 22                RET     
             ; FUNCTION CyILO_Start100K (END)

             ; FUNCTION CyILO_Stop100K (BEGIN)
                                           ; SOURCE LINE # 1082
                                           ; SOURCE LINE # 1083
                                           ; SOURCE LINE # 1085
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 65  

0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1086
0007 22                RET     
             ; FUNCTION CyILO_Stop100K (END)

             ; FUNCTION CyILO_Enable33K (BEGIN)
                                           ; SOURCE LINE # 1106
                                           ; SOURCE LINE # 1107
                                           ; SOURCE LINE # 1109
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4420              ORL     A,#020H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1110
0007 22                RET     
             ; FUNCTION CyILO_Enable33K (END)

             ; FUNCTION CyILO_Disable33K (BEGIN)
                                           ; SOURCE LINE # 1130
                                           ; SOURCE LINE # 1131
                                           ; SOURCE LINE # 1133
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54DF              ANL     A,#0DFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1134
0007 22                RET     
             ; FUNCTION CyILO_Disable33K (END)

             ; FUNCTION _CyILO_SetSource (BEGIN)
                                           ; SOURCE LINE # 1155
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1156
                                           ; SOURCE LINE # 1158
0000 EF                MOV     A,R7
0001 25E0              ADD     A,ACC
0003 25E0              ADD     A,ACC
0005 540C              ANL     A,#0CH
0007 FF                MOV     R7,A
0008 904000            MOV     DPTR,#04000H
000B E0                MOVX    A,@DPTR
000C 54F3              ANL     A,#0F3H
000E 4F                ORL     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1159
0010 22                RET     
             ; FUNCTION _CyILO_SetSource (END)

             ; FUNCTION _CyILO_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1179
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1180
                                           ; SOURCE LINE # 1184
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
;---- Variable 'state' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 1187
0005 EF                MOV     A,R7
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 66  

0006 6006              JZ      ?C0092
                                           ; SOURCE LINE # 1188
                                           ; SOURCE LINE # 1189
0008 EE                MOV     A,R6
0009 4410              ORL     A,#010H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1190
000C 8007              SJMP    ?C0093
000E         ?C0092:
                                           ; SOURCE LINE # 1192
                                           ; SOURCE LINE # 1193
000E EE                MOV     A,R6
000F 54EF              ANL     A,#0EFH
0011 904300            MOV     DPTR,#04300H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1194
0015         ?C0093:
                                           ; SOURCE LINE # 1197
0015 AF06              MOV     R7,AR6
0017 EE                MOV     A,R6
0018 5410              ANL     A,#010H
001A FF                MOV     R7,A
001B E4                CLR     A
001C C4                SWAP    A
001D F8                MOV     R0,A
001E 54F0              ANL     A,#0F0H
0020 C8                XCH     A,R0
0021 68                XRL     A,R0
0022 EF                MOV     A,R7
0023 C4                SWAP    A
0024 540F              ANL     A,#0FH
0026 48                ORL     A,R0
0027 FF                MOV     R7,A
                                           ; SOURCE LINE # 1198
0028         ?C0094:
0028 22                RET     
             ; FUNCTION _CyILO_SetPowerMode (END)

             ; FUNCTION CyXTAL_32KHZ_Start (BEGIN)
                                           ; SOURCE LINE # 1215
                                           ; SOURCE LINE # 1216
                                           ; SOURCE LINE # 1219
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1220
0006 904698            MOV     DPTR,#04698H
0009 7403              MOV     A,#03H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1221
000C 904309            MOV     DPTR,#04309H
000F E0                MOVX    A,@DPTR
0010 54F3              ANL     A,#0F3H
0012 4404              ORL     A,#04H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1225
0015 904308            MOV     DPTR,#04308H
0018 E0                MOVX    A,@DPTR
0019 4404              ORL     A,#04H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1229
001C E0                MOVX    A,@DPTR
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 67  

001D 4401              ORL     A,#01H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1231
0020 900000      R     MOV     DPTR,#i
0023 7403              MOV     A,#03H
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74E8              MOV     A,#0E8H
0029 F0                MOVX    @DPTR,A
002A         ?C0095:
002A D3                SETB    C
002B 900000      R     MOV     DPTR,#i+01H
002E E0                MOVX    A,@DPTR
002F 9400              SUBB    A,#00H
0031 900000      R     MOV     DPTR,#i
0034 E0                MOVX    A,@DPTR
0035 9400              SUBB    A,#00H
0037 4020              JC      ?C0099
                                           ; SOURCE LINE # 1232
                                           ; SOURCE LINE # 1233
0039 120000      R     LCALL   CyXTAL_32KHZ_ReadStatus
003C EF                MOV     A,R7
003D 30E506            JNB     ACC.5,?C0098
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1236
0040 E4                CLR     A
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _CyXTAL_32KHZ_SetPowerMode
                                           ; SOURCE LINE # 1238
0045 22                RET     
                                           ; SOURCE LINE # 1239
0046         ?C0098:
                                           ; SOURCE LINE # 1240
0046 7F01              MOV     R7,#01H
0048 7E00              MOV     R6,#00H
004A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1241
004D 900000      R     MOV     DPTR,#i
0050 74FF              MOV     A,#0FFH
0052 F5F0              MOV     B,A
0054 120000      E     LCALL   ?C?IILDX
0057 80D1              SJMP    ?C0095
                                           ; SOURCE LINE # 1242
0059         ?C0099:
0059 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Start (END)

             ; FUNCTION CyXTAL_32KHZ_Stop (BEGIN)
                                           ; SOURCE LINE # 1259
                                           ; SOURCE LINE # 1260
                                           ; SOURCE LINE # 1261
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1262
0006 904698            MOV     DPTR,#04698H
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1263
000B 904309            MOV     DPTR,#04309H
000E E0                MOVX    A,@DPTR
000F 54F3              ANL     A,#0F3H
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 68  

0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1264
0014 904308            MOV     DPTR,#04308H
0017 E0                MOVX    A,@DPTR
0018 54FC              ANL     A,#0FCH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1267
001B E0                MOVX    A,@DPTR
001C 54FB              ANL     A,#0FBH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1269
001F 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Stop (END)

             ; FUNCTION CyXTAL_32KHZ_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1289
                                           ; SOURCE LINE # 1290
                                           ; SOURCE LINE # 1291
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5420              ANL     A,#020H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 1292
0007         ?C0101:
0007 22                RET     
             ; FUNCTION CyXTAL_32KHZ_ReadStatus (END)

             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1313
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1314
                                           ; SOURCE LINE # 1315
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5402              ANL     A,#02H
0006 6004              JZ      ?C0102
0008 7E01              MOV     R6,#01H
000A 8002              SJMP    ?C0103
000C         ?C0102:
000C 7E00              MOV     R6,#00H
000E         ?C0103:
000E 900000      R     MOV     DPTR,#state
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1317
0013 90430A            MOV     DPTR,#0430AH
0016 74F3              MOV     A,#0F3H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1319
0019 EF                MOV     A,R7
001A 6401              XRL     A,#01H
001C 7025              JNZ     ?C0104
                                           ; SOURCE LINE # 1320
                                           ; SOURCE LINE # 1322
001E 904698            MOV     DPTR,#04698H
0021 04                INC     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1323
0023 7F0A              MOV     R7,#0AH
0025 7E00              MOV     R6,#00H
0027 120000      E     LCALL   _CyDelayUs
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 69  

                                           ; SOURCE LINE # 1324
002A 904309            MOV     DPTR,#04309H
002D E0                MOVX    A,@DPTR
002E 54F3              ANL     A,#0F3H
0030 4408              ORL     A,#08H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1325
0033 7F14              MOV     R7,#014H
0035 7E00              MOV     R6,#00H
0037 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1326
003A 904308            MOV     DPTR,#04308H
003D E0                MOVX    A,@DPTR
003E 4402              ORL     A,#02H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1327
0041 801D              SJMP    ?C0105
0043         ?C0104:
                                           ; SOURCE LINE # 1329
                                           ; SOURCE LINE # 1331
0043 904698            MOV     DPTR,#04698H
0046 7406              MOV     A,#06H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1332
0049 7F0A              MOV     R7,#0AH
004B 7E00              MOV     R6,#00H
004D 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1333
0050 904309            MOV     DPTR,#04309H
0053 E0                MOVX    A,@DPTR
0054 54F3              ANL     A,#0F3H
0056 4404              ORL     A,#04H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1334
0059 904308            MOV     DPTR,#04308H
005C E0                MOVX    A,@DPTR
005D 54FD              ANL     A,#0FDH
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1335
0060         ?C0105:
                                           ; SOURCE LINE # 1337
0060 900000      R     MOV     DPTR,#state
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
                                           ; SOURCE LINE # 1338
0065         ?C0106:
0065 22                RET     
             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (END)

             ; FUNCTION _CyXTAL_Start (BEGIN)
                                           ; SOURCE LINE # 1382
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1383
                                           ; SOURCE LINE # 1384
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1389
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1399
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 70  

0008 904210            MOV     DPTR,#04210H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1402
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 5003              JNC     $ + 5H
0015 020000      R     LJMP    ?C0107
                                           ; SOURCE LINE # 1403
                                           ; SOURCE LINE # 1405
0018 904300            MOV     DPTR,#04300H
001B E0                MOVX    A,@DPTR
001C 900000      R     MOV     DPTR,#iloEnableState
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1406
0020 904380            MOV     DPTR,#04380H
0023 E0                MOVX    A,@DPTR
0024 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1407
0028 904382            MOV     DPTR,#04382H
002B E0                MOVX    A,@DPTR
002C 900000      R     MOV     DPTR,#pmTwCfg2Tmp
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1410
0030 7F18              MOV     R7,#018H
0032 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 1411
0035 900000      R     MOV     DPTR,#status
0038 7410              MOV     A,#010H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1414
003B         ?C0108:
003B 900000      R     MOV     DPTR,#timeout
003E E0                MOVX    A,@DPTR
003F D3                SETB    C
0040 9400              SUBB    A,#00H
0042 4041              JC      ?C0109
                                           ; SOURCE LINE # 1415
                                           ; SOURCE LINE # 1419
0044 904210            MOV     DPTR,#04210H
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
                                           ; SOURCE LINE # 1425
0049 900000      R     MOV     DPTR,#count
004C 7404              MOV     A,#04H
004E F0                MOVX    @DPTR,A
004F         ?C0111:
004F 900000      R     MOV     DPTR,#count
0052 E0                MOVX    A,@DPTR
0053 D3                SETB    C
0054 9400              SUBB    A,#00H
0056 4017              JC      ?C0112
                                           ; SOURCE LINE # 1426
0058         ?C0114:
                                           ; SOURCE LINE # 1427
0058 7F01              MOV     R7,#01H
005A 120000      E     LCALL   _CyPmReadStatus
005D EF                MOV     A,R7
005E B40103            CJNE    A,#01H,?C0116
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 71  

0061 D3                SETB    C
0062 8001              SJMP    ?C0117
0064         ?C0116:
0064 C3                CLR     C
0065         ?C0117:
0065 50F1              JNC     ?C0114
                                           ; SOURCE LINE # 1428
                                           ; SOURCE LINE # 1430
0067         ?C0115:
                                           ; SOURCE LINE # 1431
0067         ?C0113:
0067 900000      R     MOV     DPTR,#count
006A E0                MOVX    A,@DPTR
006B 14                DEC     A
006C F0                MOVX    @DPTR,A
006D 80E0              SJMP    ?C0111
006F         ?C0112:
                                           ; SOURCE LINE # 1440
006F 904210            MOV     DPTR,#04210H
0072 E0                MOVX    A,@DPTR
0073 5480              ANL     A,#080H
0075 7006              JNZ     ?C0110
                                           ; SOURCE LINE # 1441
                                           ; SOURCE LINE # 1442
0077 900000      R     MOV     DPTR,#status
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1443
007B 8008              SJMP    ?C0109
                                           ; SOURCE LINE # 1444
                                           ; SOURCE LINE # 1447
007D         ?C0110:
007D 900000      R     MOV     DPTR,#timeout
0080 E0                MOVX    A,@DPTR
0081 14                DEC     A
0082 F0                MOVX    @DPTR,A
0083 80B6              SJMP    ?C0108
0085         ?C0109:
                                           ; SOURCE LINE # 1451
0085 900000      R     MOV     DPTR,#iloEnableState
0088 E0                MOVX    A,@DPTR
0089 5404              ANL     A,#04H
008B 7003              JNZ     ?C0119
                                           ; SOURCE LINE # 1452
                                           ; SOURCE LINE # 1453
008D 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 1454
0090         ?C0119:
                                           ; SOURCE LINE # 1455
0090 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0093 E0                MOVX    A,@DPTR
0094 904380            MOV     DPTR,#04380H
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1456
0098 900000      R     MOV     DPTR,#pmTwCfg2Tmp
009B E0                MOVX    A,@DPTR
009C 904382            MOV     DPTR,#04382H
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1457
00A0         ?C0107:
                                           ; SOURCE LINE # 1459
00A0 900000      R     MOV     DPTR,#status
00A3 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 72  

00A4 FF                MOV     R7,A
                                           ; SOURCE LINE # 1460
00A5         ?C0120:
00A5 22                RET     
             ; FUNCTION _CyXTAL_Start (END)

             ; FUNCTION CyXTAL_Stop (BEGIN)
                                           ; SOURCE LINE # 1477
                                           ; SOURCE LINE # 1478
                                           ; SOURCE LINE # 1480
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1481
0007 22                RET     
             ; FUNCTION CyXTAL_Stop (END)

             ; FUNCTION CyXTAL_EnableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1501
                                           ; SOURCE LINE # 1502
                                           ; SOURCE LINE # 1504
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1505
0007 22                RET     
             ; FUNCTION CyXTAL_EnableErrStatus (END)

             ; FUNCTION CyXTAL_DisableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1523
                                           ; SOURCE LINE # 1524
                                           ; SOURCE LINE # 1526
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1527
0007 22                RET     
             ; FUNCTION CyXTAL_DisableErrStatus (END)

             ; FUNCTION CyXTAL_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1547
                                           ; SOURCE LINE # 1548
                                           ; SOURCE LINE # 1553
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 5480              ANL     A,#080H
0006 6004              JZ      ?C0124
0008 7F01              MOV     R7,#01H
000A 8002              SJMP    ?C0125
000C         ?C0124:
000C 7F00              MOV     R7,#00H
000E         ?C0125:
                                           ; SOURCE LINE # 1554
000E         ?C0126:
000E 22                RET     
             ; FUNCTION CyXTAL_ReadStatus (END)

             ; FUNCTION CyXTAL_EnableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1574
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 73  

                                           ; SOURCE LINE # 1575
                                           ; SOURCE LINE # 1576
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4440              ORL     A,#040H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1577
0007 22                RET     
             ; FUNCTION CyXTAL_EnableFaultRecovery (END)

             ; FUNCTION CyXTAL_DisableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1596
                                           ; SOURCE LINE # 1597
                                           ; SOURCE LINE # 1598
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54BF              ANL     A,#0BFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1599
0007 22                RET     
             ; FUNCTION CyXTAL_DisableFaultRecovery (END)

             ; FUNCTION _CyXTAL_SetStartup (BEGIN)
                                           ; SOURCE LINE # 1623
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1624
                                           ; SOURCE LINE # 1625
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 FF                MOV     R7,A
0004 904212            MOV     DPTR,#04212H
0007 E0                MOVX    A,@DPTR
0008 54E0              ANL     A,#0E0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1627
000C 22                RET     
             ; FUNCTION _CyXTAL_SetStartup (END)

             ; FUNCTION _CyXTAL_SetFbVoltage (BEGIN)
                                           ; SOURCE LINE # 1647
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1648
                                           ; SOURCE LINE # 1649
0000 EF                MOV     A,R7
0001 540F              ANL     A,#0FH
0003 FF                MOV     R7,A
0004 904213            MOV     DPTR,#04213H
0007 E0                MOVX    A,@DPTR
0008 54F0              ANL     A,#0F0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1651
000C 22                RET     
             ; FUNCTION _CyXTAL_SetFbVoltage (END)

             ; FUNCTION _CyXTAL_SetWdVoltage (BEGIN)
                                           ; SOURCE LINE # 1670
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1671
                                           ; SOURCE LINE # 1673
0000 EF                MOV     A,R7
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 74  

0001 C4                SWAP    A
0002 5470              ANL     A,#070H
0004 FF                MOV     R7,A
0005 904213            MOV     DPTR,#04213H
0008 E0                MOVX    A,@DPTR
0009 548F              ANL     A,#08FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1674
000D 22                RET     
             ; FUNCTION _CyXTAL_SetWdVoltage (END)

             ; FUNCTION _?CyHalt (BEGIN)
                                           ; SOURCE LINE # 1693
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1695
                                           ; SOURCE LINE # 1696
                                           ; SOURCE LINE # 1698
0008         ?C0132:
                                           ; SOURCE LINE # 1705
0008 9046EA            MOV     DPTR,#046EAH
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1707
000E 900001            MOV     DPTR,#01H
0011 120000      E     LCALL   ?C?ADDXBP
0014 22                RET     
             ; FUNCTION _?CyHalt (END)

             ; FUNCTION CySoftwareReset (BEGIN)
                                           ; SOURCE LINE # 1724
                                           ; SOURCE LINE # 1725
                                           ; SOURCE LINE # 1727
0000 9046F6            MOV     DPTR,#046F6H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1728
0006 22                RET     
             ; FUNCTION CySoftwareReset (END)

             ; FUNCTION _?CyDelay (BEGIN)
                                           ; SOURCE LINE # 1751
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
0009         ?C0135:
                                           ; SOURCE LINE # 1753
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F 120000      E     LCALL   ?C?LLDXDATA
0012 D3                SETB    C
0013 EF                MOV     A,R7
0014 9400              SUBB    A,#00H
0016 EE                MOV     A,R6
0017 9480              SUBB    A,#080H
0019 402E              JC      ?C0136
                                           ; SOURCE LINE # 1754
                                           ; SOURCE LINE # 1759
001B 900000      R     MOV     DPTR,#cydelay_32k_ms
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 75  

001E 120000      E     LCALL   ?C?LLDXDATA
0021 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1760
0024 850083      E     MOV     DPH,?C_XBP
0027 850082      E     MOV     DPL,?C_XBP+01H
002A C083              PUSH    DPH
002C C082              PUSH    DPL
002E 120000      E     LCALL   ?C?LLDXDATA
0031 E4                CLR     A
0032 2F                ADD     A,R7
0033 FF                MOV     R7,A
0034 EE                MOV     A,R6
0035 3480              ADDC    A,#080H
0037 FE                MOV     R6,A
0038 ED                MOV     A,R5
0039 34FF              ADDC    A,#0FFH
003B FD                MOV     R5,A
003C EC                MOV     A,R4
003D 34FF              ADDC    A,#0FFH
003F FC                MOV     R4,A
0040 D082              POP     DPL
0042 D083              POP     DPH
0044 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1761
0047 80C0              SJMP    ?C0135
0049         ?C0136:
                                           ; SOURCE LINE # 1763
0049 900000      R     MOV     DPTR,#cydelay_freq_khz
004C 120000      E     LCALL   ?C?LLDXDATA
004F 850083      E     MOV     DPH,?C_XBP
0052 850082      E     MOV     DPL,?C_XBP+01H
0055 120000      E     LCALL   ?C?LLDXDATA0
0058 120000      E     LCALL   ?C?LMUL
005B 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1764
005E 900004            MOV     DPTR,#04H
0061 120000      E     LCALL   ?C?ADDXBP
0064 22                RET     
             ; FUNCTION _?CyDelay (END)

             ; FUNCTION _?CyDelayFreq (BEGIN)
                                           ; SOURCE LINE # 1822
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1824
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F 120000      E     LCALL   ?C?LLDXDATA
0012 EF                MOV     A,R7
0013 4E                ORL     A,R6
0014 6011              JZ      ?C0138
                                           ; SOURCE LINE # 1825
                                           ; SOURCE LINE # 1826
0016 850083      E     MOV     DPH,?C_XBP
0019 850082      E     MOV     DPL,?C_XBP+01H
001C 120000      E     LCALL   ?C?LLDXDATA
001F 900000      R     MOV     DPTR,#cydelay_freq_hz
0022 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1827
0025 800E              SJMP    ?C0139
0027         ?C0138:
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 76  

                                           ; SOURCE LINE # 1829
                                           ; SOURCE LINE # 1830
0027 7F00              MOV     R7,#00H
0029 7E6C              MOV     R6,#06CH
002B 7DDC              MOV     R5,#0DCH
002D 7C02              MOV     R4,#02H
002F 900000      R     MOV     DPTR,#cydelay_freq_hz
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1831
0035         ?C0139:
                                           ; SOURCE LINE # 1833
0035 900000      R     MOV     DPTR,#cydelay_freq_hz
0038 120000      E     LCALL   ?C?LLDXDATA
003B EF                MOV     A,R7
003C 243F              ADD     A,#03FH
003E FF                MOV     R7,A
003F EE                MOV     A,R6
0040 3442              ADDC    A,#042H
0042 FE                MOV     R6,A
0043 ED                MOV     A,R5
0044 340F              ADDC    A,#0FH
0046 FD                MOV     R5,A
0047 E4                CLR     A
0048 3C                ADDC    A,R4
0049 FC                MOV     R4,A
004A 7B40              MOV     R3,#040H
004C 7A42              MOV     R2,#042H
004E 790F              MOV     R1,#0FH
0050 7800              MOV     R0,#00H
0052 120000      E     LCALL   ?C?ULDIV
0055 900000      R     MOV     DPTR,#cydelay_freq_mhz
0058 EF                MOV     A,R7
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1834
005A A3                INC     DPTR
005B 120000      E     LCALL   ?C?LLDXDATA
005E EF                MOV     A,R7
005F 24E7              ADD     A,#0E7H
0061 FF                MOV     R7,A
0062 EE                MOV     A,R6
0063 3403              ADDC    A,#03H
0065 FE                MOV     R6,A
0066 E4                CLR     A
0067 3D                ADDC    A,R5
0068 FD                MOV     R5,A
0069 E4                CLR     A
006A 3C                ADDC    A,R4
006B FC                MOV     R4,A
006C E4                CLR     A
006D 7BE8              MOV     R3,#0E8H
006F 7A03              MOV     R2,#03H
0071 F9                MOV     R1,A
0072 F8                MOV     R0,A
0073 120000      E     LCALL   ?C?ULDIV
0076 900000      R     MOV     DPTR,#cydelay_freq_khz
0079 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1835
007C E4                CLR     A
007D FF                MOV     R7,A
007E 7E80              MOV     R6,#080H
0080 FD                MOV     R5,A
0081 FC                MOV     R4,A
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 77  

0082 900000      R     MOV     DPTR,#cydelay_freq_khz
0085 120000      E     LCALL   ?C?LLDXDATA0
0088 120000      E     LCALL   ?C?LMUL
008B 900000      R     MOV     DPTR,#cydelay_32k_ms
008E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1836
0091 900004            MOV     DPTR,#04H
0094 120000      E     LCALL   ?C?ADDXBP
0097 22                RET     
             ; FUNCTION _?CyDelayFreq (END)

             ; FUNCTION _CyWdtStart (BEGIN)
                                           ; SOURCE LINE # 1885
;---- Variable 'lpMode' assigned to Register 'R5' ----
;---- Variable 'ticks' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1886
                                           ; SOURCE LINE # 1892
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904383            MOV     DPTR,#04383H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1895
000C E0                MOVX    A,@DPTR
000D 4480              ORL     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1896
0010 E0                MOVX    A,@DPTR
0011 547F              ANL     A,#07FH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1902
0014 AF05              MOV     R7,AR5
0016 EF                MOV     A,R7
0017 C4                SWAP    A
0018 33                RLC     A
0019 5460              ANL     A,#060H
001B FF                MOV     R7,A
001C E0                MOVX    A,@DPTR
001D 549F              ANL     A,#09FH
001F 4F                ORL     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1913
0021 E0                MOVX    A,@DPTR
0022 4410              ORL     A,#010H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1914
0025 22                RET     
             ; FUNCTION _CyWdtStart (END)

             ; FUNCTION CyWdtClear (BEGIN)
                                           ; SOURCE LINE # 1931
                                           ; SOURCE LINE # 1932
                                           ; SOURCE LINE # 1943
0000 904384            MOV     DPTR,#04384H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1946
0006 22                RET     
             ; FUNCTION CyWdtClear (END)
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 78  


             ; FUNCTION _CyVdLvDigitEnable (BEGIN)
                                           ; SOURCE LINE # 1972
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
;---- Variable 'threshold' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 1973
                                           ; SOURCE LINE # 1974
0005 9044C8            MOV     DPTR,#044C8H
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1977
000B 9046F7            MOV     DPTR,#046F7H
000E E0                MOVX    A,@DPTR
000F 54BF              ANL     A,#0BFH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1981
0012 9046F4            MOV     DPTR,#046F4H
0015 E0                MOVX    A,@DPTR
0016 54F0              ANL     A,#0F0H
0018 FF                MOV     R7,A
0019 ED                MOV     A,R5
001A 540F              ANL     A,#0FH
001C 4F                ORL     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1982
001E A3                INC     DPTR
001F E0                MOVX    A,@DPTR
0020 4401              ORL     A,#01H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1985
0023 7F01              MOV     R7,#01H
0025 7E00              MOV     R6,#00H
0027 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1987
002A 9046FA            MOV     DPTR,#046FAH
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
                                           ; SOURCE LINE # 1990
002F 900000      R     MOV     DPTR,#reset
0032 E0                MOVX    A,@DPTR
0033 6009              JZ      ?C0143
                                           ; SOURCE LINE # 1991
                                           ; SOURCE LINE # 1992
0035 9046F7            MOV     DPTR,#046F7H
0038 E0                MOVX    A,@DPTR
0039 4440              ORL     A,#040H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1993
003C 8007              SJMP    ?C0144
003E         ?C0143:
                                           ; SOURCE LINE # 1995
                                           ; SOURCE LINE # 1996
003E 9046F7            MOV     DPTR,#046F7H
0041 E0                MOVX    A,@DPTR
0042 54BF              ANL     A,#0BFH
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1997
0045         ?C0144:
                                           ; SOURCE LINE # 2007
0045 9044D8            MOV     DPTR,#044D8H
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 79  

0048 7401              MOV     A,#01H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2008
004B 9044C0            MOV     DPTR,#044C0H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2009
004F 22                RET     
             ; FUNCTION _CyVdLvDigitEnable (END)

             ; FUNCTION _CyVdLvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 2034
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
;---- Variable 'threshold' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 2035
                                           ; SOURCE LINE # 2036
0005 9044C8            MOV     DPTR,#044C8H
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2039
000B 9046F7            MOV     DPTR,#046F7H
000E E0                MOVX    A,@DPTR
000F 547F              ANL     A,#07FH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2042
0012 AF05              MOV     R7,AR5
0014 EF                MOV     A,R7
0015 C4                SWAP    A
0016 54F0              ANL     A,#0F0H
0018 FF                MOV     R7,A
0019 9046F4            MOV     DPTR,#046F4H
001C E0                MOVX    A,@DPTR
001D 540F              ANL     A,#0FH
001F 4F                ORL     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2043
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 4402              ORL     A,#02H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2046
0026 7F01              MOV     R7,#01H
0028 7E00              MOV     R6,#00H
002A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2048
002D 9046FA            MOV     DPTR,#046FAH
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
                                           ; SOURCE LINE # 2051
0032 900000      R     MOV     DPTR,#reset
0035 E0                MOVX    A,@DPTR
0036 6009              JZ      ?C0146
                                           ; SOURCE LINE # 2052
                                           ; SOURCE LINE # 2053
0038 9046F7            MOV     DPTR,#046F7H
003B E0                MOVX    A,@DPTR
003C 4480              ORL     A,#080H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2054
003F 8007              SJMP    ?C0147
0041         ?C0146:
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 80  

                                           ; SOURCE LINE # 2056
                                           ; SOURCE LINE # 2057
0041 9046F7            MOV     DPTR,#046F7H
0044 E0                MOVX    A,@DPTR
0045 547F              ANL     A,#07FH
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2058
0048         ?C0147:
                                           ; SOURCE LINE # 2068
0048 9044D8            MOV     DPTR,#044D8H
004B 7401              MOV     A,#01H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2069
004E 9044C0            MOV     DPTR,#044C0H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2070
0052 22                RET     
             ; FUNCTION _CyVdLvAnalogEnable (END)

             ; FUNCTION CyVdLvDigitDisable (BEGIN)
                                           ; SOURCE LINE # 2088
                                           ; SOURCE LINE # 2089
                                           ; SOURCE LINE # 2090
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2093
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 54BF              ANL     A,#0BFH
000D F0                MOVX    @DPTR,A
000E         ?C0149:
                                           ; SOURCE LINE # 2096
000E 9046FA            MOV     DPTR,#046FAH
0011 E0                MOVX    A,@DPTR
0012 5407              ANL     A,#07H
0014 70F8              JNZ     ?C0149
                                           ; SOURCE LINE # 2097
                                           ; SOURCE LINE # 2099
0016         ?C0150:
                                           ; SOURCE LINE # 2100
0016         ?C0151:
0016 22                RET     
             ; FUNCTION CyVdLvDigitDisable (END)

             ; FUNCTION CyVdLvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2118
                                           ; SOURCE LINE # 2119
                                           ; SOURCE LINE # 2120
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2123
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 547F              ANL     A,#07FH
000D F0                MOVX    @DPTR,A
000E         ?C0152:
                                           ; SOURCE LINE # 2126
000E 9046FA            MOV     DPTR,#046FAH
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 81  

0011 E0                MOVX    A,@DPTR
0012 5407              ANL     A,#07H
0014 70F8              JNZ     ?C0152
                                           ; SOURCE LINE # 2127
                                           ; SOURCE LINE # 2129
0016         ?C0153:
                                           ; SOURCE LINE # 2130
0016         ?C0154:
0016 22                RET     
             ; FUNCTION CyVdLvAnalogDisable (END)

             ; FUNCTION CyVdHvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 2148
                                           ; SOURCE LINE # 2149
                                           ; SOURCE LINE # 2150
0000 9044C8            MOV     DPTR,#044C8H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2153
0006 9046F7            MOV     DPTR,#046F7H
0009 E0                MOVX    A,@DPTR
000A 547F              ANL     A,#07FH
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2156
000D 9046F5            MOV     DPTR,#046F5H
0010 E0                MOVX    A,@DPTR
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2159
0014 7F01              MOV     R7,#01H
0016 7E00              MOV     R6,#00H
0018 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2161
001B 9046FA            MOV     DPTR,#046FAH
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
                                           ; SOURCE LINE # 2163
0020 9044D8            MOV     DPTR,#044D8H
0023 7401              MOV     A,#01H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2164
0026 9044C0            MOV     DPTR,#044C0H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2165
002A 22                RET     
             ; FUNCTION CyVdHvAnalogEnable (END)

             ; FUNCTION CyVdHvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2183
                                           ; SOURCE LINE # 2184
                                           ; SOURCE LINE # 2185
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2186
0007 22                RET     
             ; FUNCTION CyVdHvAnalogDisable (END)

             ; FUNCTION _CyVdStickyStatus (BEGIN)
                                           ; SOURCE LINE # 2209
;---- Variable 'mask' assigned to Register 'R7' ----
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 82  

                                           ; SOURCE LINE # 2210
                                           ; SOURCE LINE # 2213
0000 9046FA            MOV     DPTR,#046FAH
0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
;---- Variable 'status' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 2214
0005 E0                MOVX    A,@DPTR
0006 FD                MOV     R5,A
0007 EF                MOV     A,R7
0008 F4                CPL     A
0009 FF                MOV     R7,A
000A ED                MOV     A,R5
000B 5F                ANL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2216
000D AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 2217
000F         ?C0157:
000F 22                RET     
             ; FUNCTION _CyVdStickyStatus (END)

             ; FUNCTION CyVdRealTimeStatus (BEGIN)
                                           ; SOURCE LINE # 2234
                                           ; SOURCE LINE # 2235
                                           ; SOURCE LINE # 2239
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2240
0003 9046FC            MOV     DPTR,#046FCH
0006 E0                MOVX    A,@DPTR
0007 900000      R     MOV     DPTR,#vdFlagsState
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2241
000B 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2243
000E 900000      R     MOV     DPTR,#vdFlagsState
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
                                           ; SOURCE LINE # 2244
0013         ?C0158:
0013 22                RET     
             ; FUNCTION CyVdRealTimeStatus (END)

             ; FUNCTION CyDisableInts (BEGIN)
                                           ; SOURCE LINE # 2261
                                           ; SOURCE LINE # 2262
                                           ; SOURCE LINE # 2266
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2271
0008 9044C8            MOV     DPTR,#044C8H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D E4                CLR     A
000E FC                MOV     R4,A
000F FD                MOV     R5,A
0010 FE                MOV     R6,A
0011 900000      R     MOV     DPTR,#intState
0014 120000      E     LCALL   ?C?LSTXDATA
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 83  

                                           ; SOURCE LINE # 2272
0017 900000      R     MOV     DPTR,#intState
001A 120000      E     LCALL   ?C?LLDXDATA0
001D C000              PUSH    AR0
001F 9044C9            MOV     DPTR,#044C9H
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E4                CLR     A
0025 FC                MOV     R4,A
0026 FD                MOV     R5,A
0027 FE                MOV     R6,A
0028 7808              MOV     R0,#08H
002A 120000      E     LCALL   ?C?LSHL
002D D000              POP     AR0
002F 120000      E     LCALL   ?C?LOR
0032 900000      R     MOV     DPTR,#intState
0035 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2273
0038 900000      R     MOV     DPTR,#intState
003B 120000      E     LCALL   ?C?LLDXDATA0
003E C000              PUSH    AR0
0040 9044CA            MOV     DPTR,#044CAH
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 E4                CLR     A
0046 FC                MOV     R4,A
0047 FD                MOV     R5,A
0048 FE                MOV     R6,A
0049 7810              MOV     R0,#010H
004B 120000      E     LCALL   ?C?LSHL
004E D000              POP     AR0
0050 120000      E     LCALL   ?C?LOR
0053 900000      R     MOV     DPTR,#intState
0056 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2274
0059 900000      R     MOV     DPTR,#intState
005C 120000      E     LCALL   ?C?LLDXDATA0
005F C000              PUSH    AR0
0061 9044CB            MOV     DPTR,#044CBH
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 E4                CLR     A
0067 FC                MOV     R4,A
0068 FD                MOV     R5,A
0069 FE                MOV     R6,A
006A 7818              MOV     R0,#018H
006C 120000      E     LCALL   ?C?LSHL
006F D000              POP     AR0
0071 120000      E     LCALL   ?C?LOR
0074 900000      R     MOV     DPTR,#intState
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2278
007A 9044C8            MOV     DPTR,#044C8H
007D 74FF              MOV     A,#0FFH
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2279
0080 A3                INC     DPTR
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2280
0082 A3                INC     DPTR
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2281
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 84  

0084 A3                INC     DPTR
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2293
0086 900000      R     MOV     DPTR,#interruptState
0089 E0                MOVX    A,@DPTR
008A FF                MOV     R7,A
008B 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2295
008E 900000      R     MOV     DPTR,#intState
0091 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 2296
0094         ?C0159:
0094 22                RET     
             ; FUNCTION CyDisableInts (END)

             ; FUNCTION _CyEnableInts (BEGIN)
                                           ; SOURCE LINE # 2313
0000 900000      R     MOV     DPTR,#mask
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2314
                                           ; SOURCE LINE # 2318
0006 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R3' ----
0009 AB07              MOV     R3,AR7
                                           ; SOURCE LINE # 2323
000B 900000      R     MOV     DPTR,#mask
000E 120000      E     LCALL   ?C?LLDXDATA
0011 7818              MOV     R0,#018H
0013 120000      E     LCALL   ?C?ULSHR
0016 9044C3            MOV     DPTR,#044C3H
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2324
001B 900000      R     MOV     DPTR,#mask
001E 120000      E     LCALL   ?C?LLDXDATA
0021 7810              MOV     R0,#010H
0023 120000      E     LCALL   ?C?ULSHR
0026 9044C2            MOV     DPTR,#044C2H
0029 EF                MOV     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2325
002B 900000      R     MOV     DPTR,#mask
002E 120000      E     LCALL   ?C?LLDXDATA
0031 7808              MOV     R0,#08H
0033 120000      E     LCALL   ?C?ULSHR
0036 9044C1            MOV     DPTR,#044C1H
0039 EF                MOV     A,R7
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2326
003B 900000      R     MOV     DPTR,#mask
003E 120000      E     LCALL   ?C?LLDXDATA
0041 9044C0            MOV     DPTR,#044C0H
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2334
0046 AF03              MOV     R7,AR3
0048 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2336
004B 22                RET     
             ; FUNCTION _CyEnableInts (END)

             ; FUNCTION _CyIntSetVector (BEGIN)
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 85  

                                           ; SOURCE LINE # 2617
0000 900000      R     MOV     DPTR,#address
0003 EC                MOV     A,R4
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#number
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2618
                                           ; SOURCE LINE # 2624
000D 541F              ANL     A,#01FH
000F 25E0              ADD     A,ACC
0011 FF                MOV     R7,A
0012 E4                CLR     A
0013 33                RLC     A
0014 FE                MOV     R6,A
0015 E4                CLR     A
0016 2F                ADD     A,R7
0017 FF                MOV     R7,A
0018 EE                MOV     A,R6
0019 3444              ADDC    A,#044H
001B FA                MOV     R2,A
001C A907              MOV     R1,AR7
001E 7B01              MOV     R3,#01H
0020 120000      E     LCALL   _cyread16_nodpx
0023 900000      R     MOV     DPTR,#oldIsr
0026 EE                MOV     A,R6
0027 F0                MOVX    @DPTR,A
0028 A3                INC     DPTR
0029 EF                MOV     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2628
002B 900000      R     MOV     DPTR,#number
002E E0                MOVX    A,@DPTR
002F 75F002            MOV     B,#02H
0032 A4                MUL     AB
0033 2400              ADD     A,#00H
0035 FF                MOV     R7,A
0036 E5F0              MOV     A,B
0038 3444              ADDC    A,#044H
003A FA                MOV     R2,A
003B A907              MOV     R1,AR7
003D 7B01              MOV     R3,#01H
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 FD                MOV     R5,A
0046 AC06              MOV     R4,AR6
0048 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2630
004B 900000      R     MOV     DPTR,#oldIsr
004E E0                MOVX    A,@DPTR
004F FE                MOV     R6,A
0050 A3                INC     DPTR
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
                                           ; SOURCE LINE # 2631
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 86  

0053         ?C0161:
0053 22                RET     
             ; FUNCTION _CyIntSetVector (END)

             ; FUNCTION _CyIntGetVector (BEGIN)
                                           ; SOURCE LINE # 2648
;---- Variable 'number' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2649
                                           ; SOURCE LINE # 2652
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 25E0              ADD     A,ACC
0005 FF                MOV     R7,A
0006 E4                CLR     A
0007 33                RLC     A
0008 FE                MOV     R6,A
0009 E4                CLR     A
000A 2F                ADD     A,R7
000B FF                MOV     R7,A
000C EE                MOV     A,R6
000D 3444              ADDC    A,#044H
000F FA                MOV     R2,A
0010 A907              MOV     R1,AR7
0012 7B01              MOV     R3,#01H
0014 120000      E     LCALL   _cyread16_nodpx
                                           ; SOURCE LINE # 2654
0017         ?C0162:
0017 22                RET     
             ; FUNCTION _CyIntGetVector (END)

             ; FUNCTION _CyIntSetPriority (BEGIN)
                                           ; SOURCE LINE # 2672
;---- Variable 'priority' assigned to Register 'R5' ----
;---- Variable 'number' assigned to Register 'R4' ----
0000 AC07              MOV     R4,AR7
                                           ; SOURCE LINE # 2673
                                           ; SOURCE LINE # 2678
0002 ED                MOV     A,R5
0003 5407              ANL     A,#07H
0005 75F020            MOV     B,#020H
0008 A4                MUL     AB
0009 FF                MOV     R7,A
000A EC                MOV     A,R4
000B 541F              ANL     A,#01FH
000D 2480              ADD     A,#080H
000F F582              MOV     DPL,A
0011 E4                CLR     A
0012 3444              ADDC    A,#044H
0014 F583              MOV     DPH,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2680
0018 22                RET     
             ; FUNCTION _CyIntSetPriority (END)

             ; FUNCTION _CyIntGetPriority (BEGIN)
                                           ; SOURCE LINE # 2697
;---- Variable 'number' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2698
                                           ; SOURCE LINE # 2703
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 87  

0003 2480              ADD     A,#080H
0005 F582              MOV     DPL,A
0007 E4                CLR     A
0008 3444              ADDC    A,#044H
000A F583              MOV     DPH,A
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E C4                SWAP    A
000F 13                RRC     A
0010 5407              ANL     A,#07H
0012 FF                MOV     R7,A
;---- Variable 'priority' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2705
                                           ; SOURCE LINE # 2706
0013         ?C0164:
0013 22                RET     
             ; FUNCTION _CyIntGetPriority (END)

             ; FUNCTION _CyIntGetState (BEGIN)
                                           ; SOURCE LINE # 2723
;---- Variable 'number' assigned to Register 'R5' ----
0000 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 2724
                                           ; SOURCE LINE # 2730
0002 ED                MOV     A,R5
0003 541F              ANL     A,#01FH
0005 7E00              MOV     R6,#00H
0007 7803              MOV     R0,#03H
0009         ?C0170:
0009 CE                XCH     A,R6
000A C3                CLR     C
000B 13                RRC     A
000C CE                XCH     A,R6
000D 13                RRC     A
000E D8F9              DJNZ    R0,?C0170
0010 24C0              ADD     A,#0C0H
0012 FF                MOV     R7,A
0013 EE                MOV     A,R6
0014 3444              ADDC    A,#044H
0016 FE                MOV     R6,A
;---- Variable 'stateReg' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 2733
0017 ED                MOV     A,R5
0018 5407              ANL     A,#07H
001A FD                MOV     R5,A
001B 7401              MOV     A,#01H
001D A805              MOV     R0,AR5
001F 08                INC     R0
0020 8002              SJMP    ?C0172
0022         ?C0171:
0022 C3                CLR     C
0023 33                RLC     A
0024         ?C0172:
0024 D8FC              DJNZ    R0,?C0171
0026 FD                MOV     R5,A
0027 8F82              MOV     DPL,R7
0029 8E83              MOV     DPH,R6
002B E0                MOVX    A,@DPTR
002C 5D                ANL     A,R5
002D 6004              JZ      ?C0165
002F 7F01              MOV     R7,#01H
0031 8002              SJMP    ?C0166
C51 COMPILER V9.03   CYLIB                                                                 07/27/2013 12:49:48 PAGE 88  

0033         ?C0165:
0033 7F00              MOV     R7,#00H
0035         ?C0166:
                                           ; SOURCE LINE # 2734
0035         ?C0167:
0035 22                RET     
             ; FUNCTION _CyIntGetState (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2692    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
